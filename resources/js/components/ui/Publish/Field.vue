<script setup>
import { computed, useTemplateRef, watch, ref, inject } from 'vue';
import { injectContainerContext } from './Container.vue';
import { injectFieldsContext } from './FieldsProvider.vue';
import { Field, Icon, Tooltip, Label } from '@/components/ui';
import FieldActions from '@/components/field-actions/FieldActions.vue';
import ShowField from '@/components/field-conditions/ShowField.js';

const props = defineProps({
    config: {
        type: Object,
        required: true,
    },
});

const {
    values: containerValues,
    extraValues: containerExtraValues,
    visibleValues: containerVisibleValues,
    revealerValues,
    meta: containerMeta,
    syncField,
    desyncField,
    isTrackingOriginValues,
    originValues: containerOriginValues,
    asConfig,
    errors: containerErrors,
    readOnly: containerReadOnly,
    setFieldPreviewValue,
    localizedFields,
    setFieldValue,
    setFieldMeta,
    hiddenFields,
    setHiddenField,
    container,
} = injectContainerContext();
const { fieldPathPrefix, metaPathPrefix } = injectFieldsContext();
const handle = props.config.handle;

const fieldtypeComponent = computed(() => {
    return `${props.config.component || props.config.type}-fieldtype`;
});

const fieldtypeComponentExists = computed(() => {
    return Statamic.$app.component(fieldtypeComponent.value) !== undefined;
});

const fullPath = computed(() => [fieldPathPrefix.value, handle].filter(Boolean).join('.'));
const metaFullPath = computed(() => [metaPathPrefix.value, handle].filter(Boolean).join('.'));
const value = computed(() => data_get(containerValues.value, fullPath.value));
const meta = computed(() => {
    const key = [metaPathPrefix.value, handle].filter(Boolean).join('.');
    return data_get(containerMeta.value, key);
});

const errors = ref();
watch(
    () => containerErrors.value,
    (newErrors) => errors.value = newErrors[fullPath.value] || [],
    { immediate: true },
);

const fieldId = computed(() => `field_${fullPath.value.replaceAll('.', '_')}`);
const namePrefix = '';
const isRequired = computed(() => props.config.required);
const fieldtype = useTemplateRef('fieldtype');

const fieldActions = computed(() => {
    return fieldtype.value ? fieldtype.value.fieldActions : [];
});

const shouldShowFieldActions = computed(() => {
    return props.config.actions && fieldActions.value?.length > 0;
});

function valueUpdated(value) {
    const existingValue = data_get(containerValues.value, fullPath.value);
    if (value === existingValue) return;
    setFieldValue(fullPath.value, value);
    desync();
}

function metaUpdated(value) {
    setFieldMeta(metaFullPath.value, value);
}

function replicatorPreviewUpdated(value) {
    setFieldPreviewValue(fullPath.value, value);
}

function focused() {
    // todo
}

function blurred() {
    // todo
}

const values = computed(() => {
    return fieldPathPrefix.value ? data_get(containerValues.value, fieldPathPrefix.value) : containerValues.value;
});

const visibleValues = computed(() => {
    return fieldPathPrefix.value ? data_get(containerVisibleValues.value, fieldPathPrefix.value) : containerVisibleValues.value;
});

const extraValues = computed(() => {
    return fieldPathPrefix.value ? data_get(containerExtraValues.value, fieldPathPrefix.value) : containerExtraValues.value;
});

const shouldShowField = computed(() => {
    return new ShowField(
        visibleValues.value,
        extraValues.value,
        containerVisibleValues.value,
        revealerValues.value,
        hiddenFields.value,
        setHiddenField,
        { container },
    ).showField(props.config, fullPath.value);
});

const shouldShowLabelText = computed(() => !props.config.hide_display);

const shouldShowLabel = computed(
    () =>
        shouldShowLabelText.value || // Need to see the text
        isLocked.value || // Need to see the avatar
        isSyncable.value, // Need to see the icon
);

const shouldShowFieldPreviews = computed(() => {
    if (! props.config.replicator_preview) return false;

    return inject('showReplicatorFieldPreviews', false);
});

const isLocalizable = computed(() => props.config.localizable);

const isReadOnly = computed(() => {
    if (containerReadOnly.value) return true;

    if (isTrackingOriginValues.value && isSyncable.value && !isLocalizable.value) return true;

    return isLocked.value || props.config.visibility === 'read_only' || false;
});

const isLocked = computed(() => false); // todo

const isSyncable = computed(() => {
    // Only top-level fields can be synced.
    if (isNested.value) return false;

    // If origin values have been provided but the field is missing, there's nothing to sync.
    return isTrackingOriginValues.value && containerOriginValues.value.hasOwnProperty(fullPath.value)
});

const isSynced = computed(() => isSyncable.value && !localizedFields.value.includes(fullPath.value));
const isNested = computed(() => fullPath.value.includes('.'));
const wrapperComponent = computed(() => {
    // Todo: Find a way to not need to hard code this.
    if (props.config.type === 'dictionary_fields') return 'div';

    return asConfig.value && !isNested.value ? 'card' : 'div';
});

function sync() {
    syncField(fullPath.value);
}

function desync() {
    desyncField(fullPath.value);
}

const fieldtypeComponentProps = computed(() => ({
    id: fieldId.value,
    config: props.config,
    value: value.value,
    meta: meta.value,
    handle: handle,
    namePrefix: namePrefix,
    fieldPathPrefix: fieldPathPrefix.value,
    metaPathPrefix: metaPathPrefix.value,
    readOnly: isReadOnly.value,
    showFieldPreviews: shouldShowFieldPreviews.value,
}));

const fieldtypeComponentEvents = computed(() => ({
    'update:value': valueUpdated,
    'update:meta': metaUpdated,
    focus: focused,
    blur: blurred,
    replicatorPreviewUpdated: replicatorPreviewUpdated
}));
</script>

<template>
    <slot
        :fieldtypeComponent="fieldtypeComponent"
        :fieldtypeComponentProps="fieldtypeComponentProps"
        :fieldtypeComponentEvents="fieldtypeComponentEvents"
    >
        <Field
            v-show="shouldShowField"
            :class="`${config.type}-fieldtype`"
            :id="fieldId"
            :instructions="config.instructions"
            :instructions-below="config.instructions_position === 'below'"
            :required="isRequired"
            :errors="errors"
            :read-only="isReadOnly"
            :as="wrapperComponent"
            :variant="config.variant"
            v-bind="$attrs"
        >
            <template #label v-if="shouldShowLabel">
                <Label :for="fieldId" :required="isRequired">
                    <template v-if="shouldShowLabelText">
                        <Tooltip :text="config.handle" :delay="1000">
                            {{ __(config.display) }}
                        </Tooltip>
                    </template>
                    <ui-button size="xs" inset icon="synced" variant="ghost" v-tooltip="__('messages.field_synced_with_origin')" v-if="!isReadOnly && isSyncable" v-show="isSynced" @click="desync" />
                    <ui-button size="xs" inset icon="unsynced" variant="ghost" v-tooltip="__('messages.field_desynced_from_origin')" v-if="!isReadOnly && isSyncable" v-show="!isSynced" @click="sync" />
                </Label>
            </template>
            <template #actions v-if="shouldShowFieldActions">
                <FieldActions :actions="fieldActions" />
            </template>
            <div class="text-xs text-red-600" v-if="!fieldtypeComponentExists">
                Component <code v-text="fieldtypeComponent"></code> does not exist.
            </div>
            <Component
                ref="fieldtype"
                :is="fieldtypeComponent"
                v-bind="fieldtypeComponentProps"
                v-on="fieldtypeComponentEvents"
            />
        </Field>
    </slot>
</template>
