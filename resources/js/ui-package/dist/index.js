import * as vue$1 from "vue";
import { computed, resolveComponent, createElementBlock, openBlock, createElementVNode, createCommentVNode, renderSlot, createBlock, withCtx, createVNode, toDisplayString, normalizeClass, ref, shallowRef, watch, getCurrentScope, onScopeDispose, shallowReadonly, unref, Fragment, defineComponent, Comment, mergeProps, cloneVNode, h, toValue as toValue$3, readonly, effectScope, customRef, onBeforeUnmount, watchEffect, getCurrentInstance, isRef, reactive, toRefs, nextTick, onMounted, inject, provide, onUnmounted, toHandlerKey, camelize, normalizeStyle, Teleport, toRef, withKeys, withModifiers, createTextVNode, normalizeProps, guardReactiveProps, markRaw, renderList, resolveDynamicComponent, watchPostEffect, mergeDefaults, watchSyncEffect, withMemo, toHandlers, toRaw, useSlots, useId as useId$1, useTemplateRef, useAttrs, defineAsyncComponent, onBeforeMount, onBeforeUpdate, onUpdated, createSlots, resolveDirective, withDirectives, vShow, Transition } from "vue";
const _hoisted_1$17 = { class: "bg-white backdrop-blur-[2px] border border-gray-200 rounded-2xl p-2 shadow-[0_8px_5px_-6px_rgba(0,0,0,0.12),_0_3px_8px_0_rgba(0,0,0,0.02),_0_30px_22px_-22px_rgba(39,39,42,0.35)]" }, _hoisted_2$G = { class: "relative space-y-3 rounded-xl border border-gray-300 bg-white p-4 shadow-[0_1px_16px_-2px_rgba(63,63,71,0.2)]" }, _hoisted_3$k = {
  key: 0,
  class: "flex flex-col justify-center items-center mb-8 py-3"
}, _sfc_main$4x = {
  __name: "AuthCard",
  props: {
    icon: { type: String, default: null },
    title: { type: String, default: null },
    description: { type: String, default: null }
  },
  setup(e) {
    const t = e, n = computed(() => t.icon || t.title || t.description);
    return (a, o) => {
      const s = resolveComponent("ui-icon"), u = resolveComponent("ui-card"), d = resolveComponent("ui-heading"), f = resolveComponent("ui-description");
      return openBlock(), createElementBlock("div", _hoisted_1$17, [
        createElementVNode("div", _hoisted_2$G, [
          n.value ? (openBlock(), createElementBlock("header", _hoisted_3$k, [
            e.icon ? (openBlock(), createBlock(u, {
              key: 0,
              class: "p-2! mb-4 flex items-center justify-center"
            }, {
              default: withCtx(() => [
                createVNode(s, {
                  name: e.icon,
                  class: "size-5"
                }, null, 8, ["name"])
              ]),
              _: 1
            })) : createCommentVNode("", !0),
            e.title ? (openBlock(), createBlock(d, {
              key: 1,
              level: 1,
              size: "xl",
              textContent: toDisplayString(e.title)
            }, null, 8, ["textContent"])) : createCommentVNode("", !0),
            e.description ? (openBlock(), createBlock(f, {
              key: 2,
              text: e.description,
              class: "text-center mt-1.5"
            }, null, 8, ["text"])) : createCommentVNode("", !0)
          ])) : createCommentVNode("", !0),
          renderSlot(a.$slots, "default")
        ])
      ]);
    };
  }
};
function r(e) {
  var t, n, a = "";
  if (typeof e == "string" || typeof e == "number") a += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var o = e.length;
    for (t = 0; t < o; t++) e[t] && (n = r(e[t])) && (a && (a += " "), a += n);
  } else for (n in e) e[n] && (a && (a += " "), a += n);
  return a;
}
function clsx() {
  for (var e, t, n = 0, a = "", o = arguments.length; n < o; n++) (e = arguments[n]) && (t = r(e)) && (a && (a += " "), a += t);
  return a;
}
const falsyToString = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, defineConfig = (e) => {
  const t = function() {
    for (var o = arguments.length, s = new Array(o), u = 0; u < o; u++)
      s[u] = arguments[u];
    return clsx(s);
  };
  return {
    compose: function() {
      for (var o = arguments.length, s = new Array(o), u = 0; u < o; u++)
        s[u] = arguments[u];
      return (d) => {
        const f = Object.fromEntries(Object.entries(d || {}).filter((g) => {
          let [v] = g;
          return ![
            "class",
            "className"
          ].includes(v);
        }));
        return t(s.map((g) => g(f)), d?.class, d?.className);
      };
    },
    cva: (o) => (s) => {
      var u;
      if (o?.variants == null) return t(o?.base, s?.class, s?.className);
      const { variants: d, defaultVariants: f } = o, g = Object.keys(d).map((w) => {
        const C = s?.[w], k = f?.[w], E = falsyToString(C) || falsyToString(k);
        return d[w][E];
      }), v = {
        ...f,
        // remove `undefined` props
        ...s && Object.entries(s).reduce((w, C) => {
          let [k, E] = C;
          return typeof E > "u" ? w : {
            ...w,
            [k]: E
          };
        }, {})
      }, b = o == null || (u = o.compoundVariants) === null || u === void 0 ? void 0 : u.reduce((w, C) => {
        let { class: k, className: E, ...A } = C;
        return Object.entries(A).every((P) => {
          let [M, B] = P;
          const _ = v[M];
          return Array.isArray(B) ? B.includes(_) : _ === B;
        }) ? [
          ...w,
          k,
          E
        ] : w;
      }, []);
      return t(o?.base, g, b, s?.class, s?.className);
    },
    cx: t
  };
}, { cva } = defineConfig(), CLASS_PART_SEPARATOR = "-", createClassGroupUtils = (e) => {
  const t = createClassMap(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: a
  } = e;
  return {
    getClassGroupId: (u) => {
      const d = u.split(CLASS_PART_SEPARATOR);
      return d[0] === "" && d.length !== 1 && d.shift(), getGroupRecursive(d, t) || getGroupIdForArbitraryProperty(u);
    },
    getConflictingClassGroupIds: (u, d) => {
      const f = n[u] || [];
      return d && a[u] ? [...f, ...a[u]] : f;
    }
  };
}, getGroupRecursive = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], a = t.nextPart.get(n), o = a ? getGroupRecursive(e.slice(1), a) : void 0;
  if (o)
    return o;
  if (t.validators.length === 0)
    return;
  const s = e.join(CLASS_PART_SEPARATOR);
  return t.validators.find(({
    validator: u
  }) => u(s))?.classGroupId;
}, arbitraryPropertyRegex = /^\[(.+)\]$/, getGroupIdForArbitraryProperty = (e) => {
  if (arbitraryPropertyRegex.test(e)) {
    const t = arbitraryPropertyRegex.exec(e)[1], n = t?.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, createClassMap = (e) => {
  const {
    theme: t,
    classGroups: n
  } = e, a = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  for (const o in n)
    processClassesRecursively(n[o], a, o, t);
  return a;
}, processClassesRecursively = (e, t, n, a) => {
  e.forEach((o) => {
    if (typeof o == "string") {
      const s = o === "" ? t : getPart(t, o);
      s.classGroupId = n;
      return;
    }
    if (typeof o == "function") {
      if (isThemeGetter(o)) {
        processClassesRecursively(o(a), t, n, a);
        return;
      }
      t.validators.push({
        validator: o,
        classGroupId: n
      });
      return;
    }
    Object.entries(o).forEach(([s, u]) => {
      processClassesRecursively(u, getPart(t, s), n, a);
    });
  });
}, getPart = (e, t) => {
  let n = e;
  return t.split(CLASS_PART_SEPARATOR).forEach((a) => {
    n.nextPart.has(a) || n.nextPart.set(a, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(a);
  }), n;
}, isThemeGetter = (e) => e.isThemeGetter, createLruCache = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  const o = (s, u) => {
    n.set(s, u), t++, t > e && (t = 0, a = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(s) {
      let u = n.get(s);
      if (u !== void 0)
        return u;
      if ((u = a.get(s)) !== void 0)
        return o(s, u), u;
    },
    set(s, u) {
      n.has(s) ? n.set(s, u) : o(s, u);
    }
  };
}, IMPORTANT_MODIFIER = "!", MODIFIER_SEPARATOR = ":", MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length, createParseClassName = (e) => {
  const {
    prefix: t,
    experimentalParseClassName: n
  } = e;
  let a = (o) => {
    const s = [];
    let u = 0, d = 0, f = 0, g;
    for (let k = 0; k < o.length; k++) {
      let E = o[k];
      if (u === 0 && d === 0) {
        if (E === MODIFIER_SEPARATOR) {
          s.push(o.slice(f, k)), f = k + MODIFIER_SEPARATOR_LENGTH;
          continue;
        }
        if (E === "/") {
          g = k;
          continue;
        }
      }
      E === "[" ? u++ : E === "]" ? u-- : E === "(" ? d++ : E === ")" && d--;
    }
    const v = s.length === 0 ? o : o.substring(f), b = stripImportantModifier(v), w = b !== v, C = g && g > f ? g - f : void 0;
    return {
      modifiers: s,
      hasImportantModifier: w,
      baseClassName: b,
      maybePostfixModifierPosition: C
    };
  };
  if (t) {
    const o = t + MODIFIER_SEPARATOR, s = a;
    a = (u) => u.startsWith(o) ? s(u.substring(o.length)) : {
      isExternal: !0,
      modifiers: [],
      hasImportantModifier: !1,
      baseClassName: u,
      maybePostfixModifierPosition: void 0
    };
  }
  if (n) {
    const o = a;
    a = (s) => n({
      className: s,
      parseClassName: o
    });
  }
  return a;
}, stripImportantModifier = (e) => e.endsWith(IMPORTANT_MODIFIER) ? e.substring(0, e.length - 1) : e.startsWith(IMPORTANT_MODIFIER) ? e.substring(1) : e, createSortModifiers = (e) => {
  const t = Object.fromEntries(e.orderSensitiveModifiers.map((a) => [a, !0]));
  return (a) => {
    if (a.length <= 1)
      return a;
    const o = [];
    let s = [];
    return a.forEach((u) => {
      u[0] === "[" || t[u] ? (o.push(...s.sort(), u), s = []) : s.push(u);
    }), o.push(...s.sort()), o;
  };
}, createConfigUtils = (e) => ({
  cache: createLruCache(e.cacheSize),
  parseClassName: createParseClassName(e),
  sortModifiers: createSortModifiers(e),
  ...createClassGroupUtils(e)
}), SPLIT_CLASSES_REGEX = /\s+/, mergeClassList = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: a,
    getConflictingClassGroupIds: o,
    sortModifiers: s
  } = t, u = [], d = e.trim().split(SPLIT_CLASSES_REGEX);
  let f = "";
  for (let g = d.length - 1; g >= 0; g -= 1) {
    const v = d[g], {
      isExternal: b,
      modifiers: w,
      hasImportantModifier: C,
      baseClassName: k,
      maybePostfixModifierPosition: E
    } = n(v);
    if (b) {
      f = v + (f.length > 0 ? " " + f : f);
      continue;
    }
    let A = !!E, P = a(A ? k.substring(0, E) : k);
    if (!P) {
      if (!A) {
        f = v + (f.length > 0 ? " " + f : f);
        continue;
      }
      if (P = a(k), !P) {
        f = v + (f.length > 0 ? " " + f : f);
        continue;
      }
      A = !1;
    }
    const M = s(w).join(":"), B = C ? M + IMPORTANT_MODIFIER : M, _ = B + P;
    if (u.includes(_))
      continue;
    u.push(_);
    const T = o(P, A);
    for (let O = 0; O < T.length; ++O) {
      const I = T[O];
      u.push(B + I);
    }
    f = v + (f.length > 0 ? " " + f : f);
  }
  return f;
};
function twJoin() {
  let e = 0, t, n, a = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = toValue$2(t)) && (a && (a += " "), a += n);
  return a;
}
const toValue$2 = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let a = 0; a < e.length; a++)
    e[a] && (t = toValue$2(e[a])) && (n && (n += " "), n += t);
  return n;
};
function createTailwindMerge(e, ...t) {
  let n, a, o, s = u;
  function u(f) {
    const g = t.reduce((v, b) => b(v), e());
    return n = createConfigUtils(g), a = n.cache.get, o = n.cache.set, s = d, d(f);
  }
  function d(f) {
    const g = a(f);
    if (g)
      return g;
    const v = mergeClassList(f, n);
    return o(f, v), v;
  }
  return function() {
    return s(twJoin.apply(null, arguments));
  };
}
const fromTheme = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i, fractionRegex = /^\d+\/\d+$/, tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, isFraction = (e) => fractionRegex.test(e), isNumber$3 = (e) => !!e && !Number.isNaN(Number(e)), isInteger = (e) => !!e && Number.isInteger(Number(e)), isPercent = (e) => e.endsWith("%") && isNumber$3(e.slice(0, -1)), isTshirtSize = (e) => tshirtUnitRegex.test(e), isAny = () => !0, isLengthOnly = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(e) && !colorFunctionRegex.test(e)
), isNever = () => !1, isShadow = (e) => shadowRegex.test(e), isImage = (e) => imageRegex.test(e), isAnyNonArbitrary = (e) => !isArbitraryValue(e) && !isArbitraryVariable(e), isArbitrarySize = (e) => getIsArbitraryValue(e, isLabelSize, isNever), isArbitraryValue = (e) => arbitraryValueRegex.test(e), isArbitraryLength = (e) => getIsArbitraryValue(e, isLabelLength, isLengthOnly), isArbitraryNumber = (e) => getIsArbitraryValue(e, isLabelNumber, isNumber$3), isArbitraryPosition = (e) => getIsArbitraryValue(e, isLabelPosition, isNever), isArbitraryImage = (e) => getIsArbitraryValue(e, isLabelImage, isImage), isArbitraryShadow = (e) => getIsArbitraryValue(e, isLabelShadow, isShadow), isArbitraryVariable = (e) => arbitraryVariableRegex.test(e), isArbitraryVariableLength = (e) => getIsArbitraryVariable(e, isLabelLength), isArbitraryVariableFamilyName = (e) => getIsArbitraryVariable(e, isLabelFamilyName), isArbitraryVariablePosition = (e) => getIsArbitraryVariable(e, isLabelPosition), isArbitraryVariableSize = (e) => getIsArbitraryVariable(e, isLabelSize), isArbitraryVariableImage = (e) => getIsArbitraryVariable(e, isLabelImage), isArbitraryVariableShadow = (e) => getIsArbitraryVariable(e, isLabelShadow, !0), getIsArbitraryValue = (e, t, n) => {
  const a = arbitraryValueRegex.exec(e);
  return a ? a[1] ? t(a[1]) : n(a[2]) : !1;
}, getIsArbitraryVariable = (e, t, n = !1) => {
  const a = arbitraryVariableRegex.exec(e);
  return a ? a[1] ? t(a[1]) : n : !1;
}, isLabelPosition = (e) => e === "position" || e === "percentage", isLabelImage = (e) => e === "image" || e === "url", isLabelSize = (e) => e === "length" || e === "size" || e === "bg-size", isLabelLength = (e) => e === "length", isLabelNumber = (e) => e === "number", isLabelFamilyName = (e) => e === "family-name", isLabelShadow = (e) => e === "shadow", getDefaultConfig = () => {
  const e = fromTheme("color"), t = fromTheme("font"), n = fromTheme("text"), a = fromTheme("font-weight"), o = fromTheme("tracking"), s = fromTheme("leading"), u = fromTheme("breakpoint"), d = fromTheme("container"), f = fromTheme("spacing"), g = fromTheme("radius"), v = fromTheme("shadow"), b = fromTheme("inset-shadow"), w = fromTheme("text-shadow"), C = fromTheme("drop-shadow"), k = fromTheme("blur"), E = fromTheme("perspective"), A = fromTheme("aspect"), P = fromTheme("ease"), M = fromTheme("animate"), B = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], _ = () => [
    "center",
    "top",
    "bottom",
    "left",
    "right",
    "top-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-top",
    "top-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-top",
    "bottom-right",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "right-bottom",
    "bottom-left",
    // Deprecated since Tailwind CSS v4.1.0, see https://github.com/tailwindlabs/tailwindcss/pull/17378
    "left-bottom"
  ], T = () => [..._(), isArbitraryVariable, isArbitraryValue], O = () => ["auto", "hidden", "clip", "visible", "scroll"], I = () => ["auto", "contain", "none"], q = () => [isArbitraryVariable, isArbitraryValue, f], F = () => [isFraction, "full", "auto", ...q()], W = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue], K = () => ["auto", {
    span: ["full", isInteger, isArbitraryVariable, isArbitraryValue]
  }, isInteger, isArbitraryVariable, isArbitraryValue], Z = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue], J = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue], re = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], V = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], ne = () => ["auto", ...q()], Q = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...q()], z = () => [e, isArbitraryVariable, isArbitraryValue], X = () => [..._(), isArbitraryVariablePosition, isArbitraryPosition, {
    position: [isArbitraryVariable, isArbitraryValue]
  }], ue = () => ["no-repeat", {
    repeat: ["", "x", "y", "space", "round"]
  }], Be = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, {
    size: [isArbitraryVariable, isArbitraryValue]
  }], te = () => [isPercent, isArbitraryVariableLength, isArbitraryLength], G = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    "full",
    g,
    isArbitraryVariable,
    isArbitraryValue
  ], ie = () => ["", isNumber$3, isArbitraryVariableLength, isArbitraryLength], oe = () => ["solid", "dashed", "dotted", "double"], ye = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ve = () => [isNumber$3, isPercent, isArbitraryVariablePosition, isArbitraryPosition], ke = () => [
    // Deprecated since Tailwind CSS v4.0.0
    "",
    "none",
    k,
    isArbitraryVariable,
    isArbitraryValue
  ], Ae = () => ["none", isNumber$3, isArbitraryVariable, isArbitraryValue], be = () => ["none", isNumber$3, isArbitraryVariable, isArbitraryValue], Ie = () => [isNumber$3, isArbitraryVariable, isArbitraryValue], Se = () => [isFraction, "full", ...q()];
  return {
    cacheSize: 500,
    theme: {
      animate: ["spin", "ping", "pulse", "bounce"],
      aspect: ["video"],
      blur: [isTshirtSize],
      breakpoint: [isTshirtSize],
      color: [isAny],
      container: [isTshirtSize],
      "drop-shadow": [isTshirtSize],
      ease: ["in", "out", "in-out"],
      font: [isAnyNonArbitrary],
      "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"],
      "inset-shadow": [isTshirtSize],
      leading: ["none", "tight", "snug", "normal", "relaxed", "loose"],
      perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"],
      radius: [isTshirtSize],
      shadow: [isTshirtSize],
      spacing: ["px", isNumber$3],
      text: [isTshirtSize],
      "text-shadow": [isTshirtSize],
      tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"]
    },
    classGroups: {
      // --------------
      // --- Layout ---
      // --------------
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, A]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       * @deprecated since Tailwind CSS v4.0.0
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isNumber$3, isArbitraryValue, isArbitraryVariable, d]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": B()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": B()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Screen Reader Only
       * @see https://tailwindcss.com/docs/display#screen-reader-only
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: T()
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: O()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": O()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": O()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: I()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": I()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": I()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: F()
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": F()
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": F()
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: F()
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: F()
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: F()
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: F()
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: F()
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: F()
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------------
      // --- Flexbox and Grid ---
      // ------------------------
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: [isFraction, "full", "auto", d, ...q()]
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["nowrap", "wrap", "wrap-reverse"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: [isNumber$3, isFraction, "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": W()
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: K()
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Z()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Z()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": W()
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: K()
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Z()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Z()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": J()
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": J()
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: q()
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": q()
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": q()
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: [...re(), "normal"]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": [...V(), "normal"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", ...V()]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...re()]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: [...V(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", ...V(), {
          baseline: ["", "last"]
        }]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": re()
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": [...V(), "baseline"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", ...V()]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: q()
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: q()
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: q()
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: q()
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: q()
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: q()
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: q()
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: q()
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: q()
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: ne()
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: ne()
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: ne()
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: ne()
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: ne()
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: ne()
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: ne()
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: ne()
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: ne()
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x": [{
        "space-x": q()
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y": [{
        "space-y": q()
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/margin#adding-space-between-children
       */
      "space-y-reverse": ["space-y-reverse"],
      // --------------
      // --- Sizing ---
      // --------------
      /**
       * Size
       * @see https://tailwindcss.com/docs/width#setting-both-width-and-height
       */
      size: [{
        size: Q()
      }],
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: [d, "screen", ...Q()]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [
          d,
          "screen",
          /** Deprecated. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "none",
          ...Q()
        ]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [
          d,
          "screen",
          "none",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          "prose",
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          {
            screen: [u]
          },
          ...Q()
        ]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: ["screen", "lh", ...Q()]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["screen", "lh", "none", ...Q()]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": ["screen", "lh", ...Q()]
      }],
      // ------------------
      // --- Typography ---
      // ------------------
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", n, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: [a, isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Font Stretch
       * @see https://tailwindcss.com/docs/font-stretch
       */
      "font-stretch": [{
        "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isArbitraryVariableFamilyName, isArbitraryValue, t]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: [o, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": [isNumber$3, "none", isArbitraryVariable, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: [
          /** Deprecated since Tailwind CSS v4.0.0. @see https://github.com/tailwindlabs/tailwindcss.com/issues/2027#issuecomment-2620152757 */
          s,
          ...q()
        ]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://v3.tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: z()
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: z()
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...oe(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: [isNumber$3, "from-font", "auto", isArbitraryVariable, isArbitraryLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: z()
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": [isNumber$3, "auto", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: q()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Overflow Wrap
       * @see https://tailwindcss.com/docs/overflow-wrap
       */
      wrap: [{
        wrap: ["break-word", "anywhere", "normal"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // -------------------
      // --- Backgrounds ---
      // -------------------
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: X()
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ue()
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: Be()
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          linear: [{
            to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
          }, isInteger, isArbitraryVariable, isArbitraryValue],
          radial: ["", isArbitraryVariable, isArbitraryValue],
          conic: [isInteger, isArbitraryVariable, isArbitraryValue]
        }, isArbitraryVariableImage, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: z()
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: te()
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: te()
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: te()
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: z()
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: z()
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: z()
      }],
      // ---------------
      // --- Borders ---
      // ---------------
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: G()
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": G()
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": G()
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": G()
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": G()
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": G()
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": G()
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": G()
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": G()
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": G()
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": G()
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": G()
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": G()
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": G()
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": G()
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: ie()
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": ie()
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": ie()
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": ie()
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": ie()
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": ie()
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": ie()
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": ie()
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": ie()
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x": [{
        "divide-x": ie()
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y": [{
        "divide-y": ie()
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/border-width#between-children
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...oe(), "hidden", "none"]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/border-style#setting-the-divider-style
       */
      "divide-style": [{
        divide: [...oe(), "hidden", "none"]
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: z()
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": z()
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": z()
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": z()
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": z()
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": z()
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": z()
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": z()
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": z()
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: z()
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [...oe(), "none", "hidden"]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: ["", isNumber$3, isArbitraryVariableLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: z()
      }],
      // ---------------
      // --- Effects ---
      // ---------------
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          v,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-shadow-color
       */
      "shadow-color": [{
        shadow: z()
      }],
      /**
       * Inset Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-shadow
       */
      "inset-shadow": [{
        "inset-shadow": ["none", b, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Inset Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-shadow-color
       */
      "inset-shadow-color": [{
        "inset-shadow": z()
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-a-ring
       */
      "ring-w": [{
        ring: ie()
      }],
      /**
       * Ring Width Inset
       * @see https://v3.tailwindcss.com/docs/ring-width#inset-rings
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-ring-color
       */
      "ring-color": [{
        ring: z()
      }],
      /**
       * Ring Offset Width
       * @see https://v3.tailwindcss.com/docs/ring-offset-width
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-w": [{
        "ring-offset": [isNumber$3, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://v3.tailwindcss.com/docs/ring-offset-color
       * @deprecated since Tailwind CSS v4.0.0
       * @see https://github.com/tailwindlabs/tailwindcss/blob/v4.0.0/packages/tailwindcss/src/utilities.ts#L4158
       */
      "ring-offset-color": [{
        "ring-offset": z()
      }],
      /**
       * Inset Ring Width
       * @see https://tailwindcss.com/docs/box-shadow#adding-an-inset-ring
       */
      "inset-ring-w": [{
        "inset-ring": ie()
      }],
      /**
       * Inset Ring Color
       * @see https://tailwindcss.com/docs/box-shadow#setting-the-inset-ring-color
       */
      "inset-ring-color": [{
        "inset-ring": z()
      }],
      /**
       * Text Shadow
       * @see https://tailwindcss.com/docs/text-shadow
       */
      "text-shadow": [{
        "text-shadow": ["none", w, isArbitraryVariableShadow, isArbitraryShadow]
      }],
      /**
       * Text Shadow Color
       * @see https://tailwindcss.com/docs/text-shadow#setting-the-shadow-color
       */
      "text-shadow-color": [{
        "text-shadow": z()
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...ye(), "plus-darker", "plus-lighter"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": ye()
      }],
      /**
       * Mask Clip
       * @see https://tailwindcss.com/docs/mask-clip
       */
      "mask-clip": [{
        "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"]
      }, "mask-no-clip"],
      /**
       * Mask Composite
       * @see https://tailwindcss.com/docs/mask-composite
       */
      "mask-composite": [{
        mask: ["add", "subtract", "intersect", "exclude"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image-linear-pos": [{
        "mask-linear": [isNumber$3]
      }],
      "mask-image-linear-from-pos": [{
        "mask-linear-from": ve()
      }],
      "mask-image-linear-to-pos": [{
        "mask-linear-to": ve()
      }],
      "mask-image-linear-from-color": [{
        "mask-linear-from": z()
      }],
      "mask-image-linear-to-color": [{
        "mask-linear-to": z()
      }],
      "mask-image-t-from-pos": [{
        "mask-t-from": ve()
      }],
      "mask-image-t-to-pos": [{
        "mask-t-to": ve()
      }],
      "mask-image-t-from-color": [{
        "mask-t-from": z()
      }],
      "mask-image-t-to-color": [{
        "mask-t-to": z()
      }],
      "mask-image-r-from-pos": [{
        "mask-r-from": ve()
      }],
      "mask-image-r-to-pos": [{
        "mask-r-to": ve()
      }],
      "mask-image-r-from-color": [{
        "mask-r-from": z()
      }],
      "mask-image-r-to-color": [{
        "mask-r-to": z()
      }],
      "mask-image-b-from-pos": [{
        "mask-b-from": ve()
      }],
      "mask-image-b-to-pos": [{
        "mask-b-to": ve()
      }],
      "mask-image-b-from-color": [{
        "mask-b-from": z()
      }],
      "mask-image-b-to-color": [{
        "mask-b-to": z()
      }],
      "mask-image-l-from-pos": [{
        "mask-l-from": ve()
      }],
      "mask-image-l-to-pos": [{
        "mask-l-to": ve()
      }],
      "mask-image-l-from-color": [{
        "mask-l-from": z()
      }],
      "mask-image-l-to-color": [{
        "mask-l-to": z()
      }],
      "mask-image-x-from-pos": [{
        "mask-x-from": ve()
      }],
      "mask-image-x-to-pos": [{
        "mask-x-to": ve()
      }],
      "mask-image-x-from-color": [{
        "mask-x-from": z()
      }],
      "mask-image-x-to-color": [{
        "mask-x-to": z()
      }],
      "mask-image-y-from-pos": [{
        "mask-y-from": ve()
      }],
      "mask-image-y-to-pos": [{
        "mask-y-to": ve()
      }],
      "mask-image-y-from-color": [{
        "mask-y-from": z()
      }],
      "mask-image-y-to-color": [{
        "mask-y-to": z()
      }],
      "mask-image-radial": [{
        "mask-radial": [isArbitraryVariable, isArbitraryValue]
      }],
      "mask-image-radial-from-pos": [{
        "mask-radial-from": ve()
      }],
      "mask-image-radial-to-pos": [{
        "mask-radial-to": ve()
      }],
      "mask-image-radial-from-color": [{
        "mask-radial-from": z()
      }],
      "mask-image-radial-to-color": [{
        "mask-radial-to": z()
      }],
      "mask-image-radial-shape": [{
        "mask-radial": ["circle", "ellipse"]
      }],
      "mask-image-radial-size": [{
        "mask-radial": [{
          closest: ["side", "corner"],
          farthest: ["side", "corner"]
        }]
      }],
      "mask-image-radial-pos": [{
        "mask-radial-at": _()
      }],
      "mask-image-conic-pos": [{
        "mask-conic": [isNumber$3]
      }],
      "mask-image-conic-from-pos": [{
        "mask-conic-from": ve()
      }],
      "mask-image-conic-to-pos": [{
        "mask-conic-to": ve()
      }],
      "mask-image-conic-from-color": [{
        "mask-conic-from": z()
      }],
      "mask-image-conic-to-color": [{
        "mask-conic-to": z()
      }],
      /**
       * Mask Mode
       * @see https://tailwindcss.com/docs/mask-mode
       */
      "mask-mode": [{
        mask: ["alpha", "luminance", "match"]
      }],
      /**
       * Mask Origin
       * @see https://tailwindcss.com/docs/mask-origin
       */
      "mask-origin": [{
        "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"]
      }],
      /**
       * Mask Position
       * @see https://tailwindcss.com/docs/mask-position
       */
      "mask-position": [{
        mask: X()
      }],
      /**
       * Mask Repeat
       * @see https://tailwindcss.com/docs/mask-repeat
       */
      "mask-repeat": [{
        mask: ue()
      }],
      /**
       * Mask Size
       * @see https://tailwindcss.com/docs/mask-size
       */
      "mask-size": [{
        mask: Be()
      }],
      /**
       * Mask Type
       * @see https://tailwindcss.com/docs/mask-type
       */
      "mask-type": [{
        "mask-type": ["alpha", "luminance"]
      }],
      /**
       * Mask Image
       * @see https://tailwindcss.com/docs/mask-image
       */
      "mask-image": [{
        mask: ["none", isArbitraryVariable, isArbitraryValue]
      }],
      // ---------------
      // --- Filters ---
      // ---------------
      /**
       * Filter
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: ke()
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": [
          // Deprecated since Tailwind CSS v4.0.0
          "",
          "none",
          C,
          isArbitraryVariableShadow,
          isArbitraryShadow
        ]
      }],
      /**
       * Drop Shadow Color
       * @see https://tailwindcss.com/docs/filter-drop-shadow#setting-the-shadow-color
       */
      "drop-shadow-color": [{
        "drop-shadow": z()
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Filter
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": [
          // Deprecated since Tailwind CSS v3.0.0
          "",
          "none",
          isArbitraryVariable,
          isArbitraryValue
        ]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": ke()
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": ["", isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      // --------------
      // --- Tables ---
      // --------------
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": q()
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": q()
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": q()
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // ---------------------------------
      // --- Transitions and Animation ---
      // ---------------------------------
      /**
       * Transition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Behavior
       * @see https://tailwindcss.com/docs/transition-behavior
       */
      "transition-behavior": [{
        transition: ["normal", "discrete"]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: [isNumber$3, "initial", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "initial", P, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: [isNumber$3, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", M, isArbitraryVariable, isArbitraryValue]
      }],
      // ------------------
      // --- Transforms ---
      // ------------------
      /**
       * Backface Visibility
       * @see https://tailwindcss.com/docs/backface-visibility
       */
      backface: [{
        backface: ["hidden", "visible"]
      }],
      /**
       * Perspective
       * @see https://tailwindcss.com/docs/perspective
       */
      perspective: [{
        perspective: [E, isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Perspective Origin
       * @see https://tailwindcss.com/docs/perspective-origin
       */
      "perspective-origin": [{
        "perspective-origin": T()
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: Ae()
      }],
      /**
       * Rotate X
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-x": [{
        "rotate-x": Ae()
      }],
      /**
       * Rotate Y
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-y": [{
        "rotate-y": Ae()
      }],
      /**
       * Rotate Z
       * @see https://tailwindcss.com/docs/rotate
       */
      "rotate-z": [{
        "rotate-z": Ae()
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: be()
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": be()
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": be()
      }],
      /**
       * Scale Z
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-z": [{
        "scale-z": be()
      }],
      /**
       * Scale 3D
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-3d": ["scale-3d"],
      /**
       * Skew
       * @see https://tailwindcss.com/docs/skew
       */
      skew: [{
        skew: Ie()
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": Ie()
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": Ie()
      }],
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: T()
      }],
      /**
       * Transform Style
       * @see https://tailwindcss.com/docs/transform-style
       */
      "transform-style": [{
        transform: ["3d", "flat"]
      }],
      /**
       * Translate
       * @see https://tailwindcss.com/docs/translate
       */
      translate: [{
        translate: Se()
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": Se()
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": Se()
      }],
      /**
       * Translate Z
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-z": [{
        "translate-z": Se()
      }],
      /**
       * Translate None
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-none": ["translate-none"],
      // ---------------------
      // --- Interactivity ---
      // ---------------------
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: z()
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: z()
      }],
      /**
       * Color Scheme
       * @see https://tailwindcss.com/docs/color-scheme
       */
      "color-scheme": [{
        scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue]
      }],
      /**
       * Field Sizing
       * @see https://tailwindcss.com/docs/field-sizing
       */
      "field-sizing": [{
        "field-sizing": ["fixed", "content"]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["auto", "none"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "", "y", "x"]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": q()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": q()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": q()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": q()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": q()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": q()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": q()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": q()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": q()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": q()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": q()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": q()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": q()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": q()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": q()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": q()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": q()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": q()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue]
      }],
      // -----------
      // --- SVG ---
      // -----------
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: ["none", ...z()]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isNumber$3, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: ["none", ...z()]
      }],
      // ---------------------
      // --- Accessibility ---
      // ---------------------
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      translate: ["translate-x", "translate-y", "translate-none"],
      "translate-none": ["translate", "translate-x", "translate-y", "translate-z"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    },
    orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"]
  };
}, twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig), _export_sfc = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [a, o] of t)
    n[a] = o;
  return n;
}, _sfc_main$4w = {}, _hoisted_1$16 = { class: "imabutton" };
function _sfc_render$f(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$16, "im a button");
}
const Button = /* @__PURE__ */ _export_sfc(_sfc_main$4w, [["render", _sfc_render$f]]), _sfc_main$4v = {}, _hoisted_1$15 = {
  class: /* @__PURE__ */ normalizeClass([
    "group/button flex",
    "[&>[data-ui-group-target]:not(:first-child):not(:last-child)]:rounded-none",
    "[&>[data-ui-group-target]:first-child:not(:last-child)]:rounded-e-none",
    "[&>[data-ui-group-target]:last-child:not(:first-child)]:rounded-s-none",
    "[&>*:not(:first-child):not(:last-child):not(:only-child)_[data-ui-group-target]]:rounded-none",
    "[&>*:first-child:not(:last-child)_[data-ui-group-target]]:rounded-e-none",
    "[&>*:last-child:not(:first-child)_[data-ui-group-target]]:rounded-s-none",
    "dark:[&_button]:ring-0"
  ]),
  "data-ui-button-group": ""
};
function _sfc_render$e(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$15, [
    renderSlot(e.$slots, "default")
  ]);
}
const ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$4v, [["render", _sfc_render$e]]), sides = ["top", "right", "bottom", "left"], min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (e) => ({
  x: e,
  y: e
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$2(e, t, n) {
  return max(e, min(t, n));
}
function evaluate(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function getSide(e) {
  return e.split("-")[0];
}
function getAlignment(e) {
  return e.split("-")[1];
}
function getOppositeAxis(e) {
  return e === "x" ? "y" : "x";
}
function getAxisLength(e) {
  return e === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(e) {
  return yAxisSides.has(getSide(e)) ? "y" : "x";
}
function getAlignmentAxis(e) {
  return getOppositeAxis(getSideAxis(e));
}
function getAlignmentSides(e, t, n) {
  n === void 0 && (n = !1);
  const a = getAlignment(e), o = getAlignmentAxis(e), s = getAxisLength(o);
  let u = o === "x" ? a === (n ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (u = getOppositePlacement(u)), [u, getOppositePlacement(u)];
}
function getExpandedPlacements(e) {
  const t = getOppositePlacement(e);
  return [getOppositeAlignmentPlacement(e), t, getOppositeAlignmentPlacement(t)];
}
function getOppositeAlignmentPlacement(e) {
  return e.replace(/start|end/g, (t) => oppositeAlignmentMap[t]);
}
const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"];
function getSideList(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? rlPlacement : lrPlacement : t ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return t ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(e, t, n, a) {
  const o = getAlignment(e);
  let s = getSideList(getSide(e), n === "start", a);
  return o && (s = s.map((u) => u + "-" + o), t && (s = s.concat(s.map(getOppositeAlignmentPlacement)))), s;
}
function getOppositePlacement(e) {
  return e.replace(/left|right|bottom|top/g, (t) => oppositeSideMap[t]);
}
function expandPaddingObject(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function getPaddingObject(e) {
  return typeof e != "number" ? expandPaddingObject(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function rectToClientRect(e) {
  const {
    x: t,
    y: n,
    width: a,
    height: o
  } = e;
  return {
    width: a,
    height: o,
    top: n,
    left: t,
    right: t + a,
    bottom: n + o,
    x: t,
    y: n
  };
}
function computeCoordsFromPlacement(e, t, n) {
  let {
    reference: a,
    floating: o
  } = e;
  const s = getSideAxis(t), u = getAlignmentAxis(t), d = getAxisLength(u), f = getSide(t), g = s === "y", v = a.x + a.width / 2 - o.width / 2, b = a.y + a.height / 2 - o.height / 2, w = a[d] / 2 - o[d] / 2;
  let C;
  switch (f) {
    case "top":
      C = {
        x: v,
        y: a.y - o.height
      };
      break;
    case "bottom":
      C = {
        x: v,
        y: a.y + a.height
      };
      break;
    case "right":
      C = {
        x: a.x + a.width,
        y: b
      };
      break;
    case "left":
      C = {
        x: a.x - o.width,
        y: b
      };
      break;
    default:
      C = {
        x: a.x,
        y: a.y
      };
  }
  switch (getAlignment(t)) {
    case "start":
      C[u] -= w * (n && g ? -1 : 1);
      break;
    case "end":
      C[u] += w * (n && g ? -1 : 1);
      break;
  }
  return C;
}
const computePosition$1 = async (e, t, n) => {
  const {
    placement: a = "bottom",
    strategy: o = "absolute",
    middleware: s = [],
    platform: u
  } = n, d = s.filter(Boolean), f = await (u.isRTL == null ? void 0 : u.isRTL(t));
  let g = await u.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: v,
    y: b
  } = computeCoordsFromPlacement(g, a, f), w = a, C = {}, k = 0;
  for (let E = 0; E < d.length; E++) {
    const {
      name: A,
      fn: P
    } = d[E], {
      x: M,
      y: B,
      data: _,
      reset: T
    } = await P({
      x: v,
      y: b,
      initialPlacement: a,
      placement: w,
      strategy: o,
      middlewareData: C,
      rects: g,
      platform: u,
      elements: {
        reference: e,
        floating: t
      }
    });
    v = M ?? v, b = B ?? b, C = {
      ...C,
      [A]: {
        ...C[A],
        ..._
      }
    }, T && k <= 50 && (k++, typeof T == "object" && (T.placement && (w = T.placement), T.rects && (g = T.rects === !0 ? await u.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : T.rects), {
      x: v,
      y: b
    } = computeCoordsFromPlacement(g, w, f)), E = -1);
  }
  return {
    x: v,
    y: b,
    placement: w,
    strategy: o,
    middlewareData: C
  };
};
async function detectOverflow(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: a,
    y: o,
    platform: s,
    rects: u,
    elements: d,
    strategy: f
  } = e, {
    boundary: g = "clippingAncestors",
    rootBoundary: v = "viewport",
    elementContext: b = "floating",
    altBoundary: w = !1,
    padding: C = 0
  } = evaluate(t, e), k = getPaddingObject(C), A = d[w ? b === "floating" ? "reference" : "floating" : b], P = rectToClientRect(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(A))) == null || n ? A : A.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(d.floating)),
    boundary: g,
    rootBoundary: v,
    strategy: f
  })), M = b === "floating" ? {
    x: a,
    y: o,
    width: u.floating.width,
    height: u.floating.height
  } : u.reference, B = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(d.floating)), _ = await (s.isElement == null ? void 0 : s.isElement(B)) ? await (s.getScale == null ? void 0 : s.getScale(B)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, T = rectToClientRect(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: d,
    rect: M,
    offsetParent: B,
    strategy: f
  }) : M);
  return {
    top: (P.top - T.top + k.top) / _.y,
    bottom: (T.bottom - P.bottom + k.bottom) / _.y,
    left: (P.left - T.left + k.left) / _.x,
    right: (T.right - P.right + k.right) / _.x
  };
}
const arrow$2 = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: a,
      placement: o,
      rects: s,
      platform: u,
      elements: d,
      middlewareData: f
    } = t, {
      element: g,
      padding: v = 0
    } = evaluate(e, t) || {};
    if (g == null)
      return {};
    const b = getPaddingObject(v), w = {
      x: n,
      y: a
    }, C = getAlignmentAxis(o), k = getAxisLength(C), E = await u.getDimensions(g), A = C === "y", P = A ? "top" : "left", M = A ? "bottom" : "right", B = A ? "clientHeight" : "clientWidth", _ = s.reference[k] + s.reference[C] - w[C] - s.floating[k], T = w[C] - s.reference[C], O = await (u.getOffsetParent == null ? void 0 : u.getOffsetParent(g));
    let I = O ? O[B] : 0;
    (!I || !await (u.isElement == null ? void 0 : u.isElement(O))) && (I = d.floating[B] || s.floating[k]);
    const q = _ / 2 - T / 2, F = I / 2 - E[k] / 2 - 1, W = min(b[P], F), K = min(b[M], F), Z = W, J = I - E[k] - K, re = I / 2 - E[k] / 2 + q, V = clamp$2(Z, re, J), ne = !f.arrow && getAlignment(o) != null && re !== V && s.reference[k] / 2 - (re < Z ? W : K) - E[k] / 2 < 0, Q = ne ? re < Z ? re - Z : re - J : 0;
    return {
      [C]: w[C] + Q,
      data: {
        [C]: V,
        centerOffset: re - V - Q,
        ...ne && {
          alignmentOffset: Q
        }
      },
      reset: ne
    };
  }
}), flip$1 = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: o,
        middlewareData: s,
        rects: u,
        initialPlacement: d,
        platform: f,
        elements: g
      } = t, {
        mainAxis: v = !0,
        crossAxis: b = !0,
        fallbackPlacements: w,
        fallbackStrategy: C = "bestFit",
        fallbackAxisSideDirection: k = "none",
        flipAlignment: E = !0,
        ...A
      } = evaluate(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const P = getSide(o), M = getSideAxis(d), B = getSide(d) === d, _ = await (f.isRTL == null ? void 0 : f.isRTL(g.floating)), T = w || (B || !E ? [getOppositePlacement(d)] : getExpandedPlacements(d)), O = k !== "none";
      !w && O && T.push(...getOppositeAxisPlacements(d, E, k, _));
      const I = [d, ...T], q = await detectOverflow(t, A), F = [];
      let W = ((a = s.flip) == null ? void 0 : a.overflows) || [];
      if (v && F.push(q[P]), b) {
        const re = getAlignmentSides(o, u, _);
        F.push(q[re[0]], q[re[1]]);
      }
      if (W = [...W, {
        placement: o,
        overflows: F
      }], !F.every((re) => re <= 0)) {
        var K, Z;
        const re = (((K = s.flip) == null ? void 0 : K.index) || 0) + 1, V = I[re];
        if (V && (!(b === "alignment" ? M !== getSideAxis(V) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        W.every((z) => z.overflows[0] > 0 && getSideAxis(z.placement) === M)))
          return {
            data: {
              index: re,
              overflows: W
            },
            reset: {
              placement: V
            }
          };
        let ne = (Z = W.filter((Q) => Q.overflows[0] <= 0).sort((Q, z) => Q.overflows[1] - z.overflows[1])[0]) == null ? void 0 : Z.placement;
        if (!ne)
          switch (C) {
            case "bestFit": {
              var J;
              const Q = (J = W.filter((z) => {
                if (O) {
                  const X = getSideAxis(z.placement);
                  return X === M || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  X === "y";
                }
                return !0;
              }).map((z) => [z.placement, z.overflows.filter((X) => X > 0).reduce((X, ue) => X + ue, 0)]).sort((z, X) => z[1] - X[1])[0]) == null ? void 0 : J[0];
              Q && (ne = Q);
              break;
            }
            case "initialPlacement":
              ne = d;
              break;
          }
        if (o !== ne)
          return {
            reset: {
              placement: ne
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function isAnySideFullyClipped(e) {
  return sides.some((t) => e[t] >= 0);
}
const hide$1 = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: a = "referenceHidden",
        ...o
      } = evaluate(e, t);
      switch (a) {
        case "referenceHidden": {
          const s = await detectOverflow(t, {
            ...o,
            elementContext: "reference"
          }), u = getSideOffsets(s, n.reference);
          return {
            data: {
              referenceHiddenOffsets: u,
              referenceHidden: isAnySideFullyClipped(u)
            }
          };
        }
        case "escaped": {
          const s = await detectOverflow(t, {
            ...o,
            altBoundary: !0
          }), u = getSideOffsets(s, n.floating);
          return {
            data: {
              escapedOffsets: u,
              escaped: isAnySideFullyClipped(u)
            }
          };
        }
        default:
          return {};
      }
    }
  };
}, originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(e, t) {
  const {
    placement: n,
    platform: a,
    elements: o
  } = e, s = await (a.isRTL == null ? void 0 : a.isRTL(o.floating)), u = getSide(n), d = getAlignment(n), f = getSideAxis(n) === "y", g = originSides.has(u) ? -1 : 1, v = s && f ? -1 : 1, b = evaluate(t, e);
  let {
    mainAxis: w,
    crossAxis: C,
    alignmentAxis: k
  } = typeof b == "number" ? {
    mainAxis: b,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: b.mainAxis || 0,
    crossAxis: b.crossAxis || 0,
    alignmentAxis: b.alignmentAxis
  };
  return d && typeof k == "number" && (C = d === "end" ? k * -1 : k), f ? {
    x: C * v,
    y: w * g
  } : {
    x: w * g,
    y: C * v
  };
}
const offset$1 = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, a;
      const {
        x: o,
        y: s,
        placement: u,
        middlewareData: d
      } = t, f = await convertValueToCoords(t, e);
      return u === ((n = d.offset) == null ? void 0 : n.placement) && (a = d.arrow) != null && a.alignmentOffset ? {} : {
        x: o + f.x,
        y: s + f.y,
        data: {
          ...f,
          placement: u
        }
      };
    }
  };
}, shift$1 = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: a,
        placement: o
      } = t, {
        mainAxis: s = !0,
        crossAxis: u = !1,
        limiter: d = {
          fn: (A) => {
            let {
              x: P,
              y: M
            } = A;
            return {
              x: P,
              y: M
            };
          }
        },
        ...f
      } = evaluate(e, t), g = {
        x: n,
        y: a
      }, v = await detectOverflow(t, f), b = getSideAxis(getSide(o)), w = getOppositeAxis(b);
      let C = g[w], k = g[b];
      if (s) {
        const A = w === "y" ? "top" : "left", P = w === "y" ? "bottom" : "right", M = C + v[A], B = C - v[P];
        C = clamp$2(M, C, B);
      }
      if (u) {
        const A = b === "y" ? "top" : "left", P = b === "y" ? "bottom" : "right", M = k + v[A], B = k - v[P];
        k = clamp$2(M, k, B);
      }
      const E = d.fn({
        ...t,
        [w]: C,
        [b]: k
      });
      return {
        ...E,
        data: {
          x: E.x - n,
          y: E.y - a,
          enabled: {
            [w]: s,
            [b]: u
          }
        }
      };
    }
  };
}, limitShift$1 = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: a,
        placement: o,
        rects: s,
        middlewareData: u
      } = t, {
        offset: d = 0,
        mainAxis: f = !0,
        crossAxis: g = !0
      } = evaluate(e, t), v = {
        x: n,
        y: a
      }, b = getSideAxis(o), w = getOppositeAxis(b);
      let C = v[w], k = v[b];
      const E = evaluate(d, t), A = typeof E == "number" ? {
        mainAxis: E,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...E
      };
      if (f) {
        const B = w === "y" ? "height" : "width", _ = s.reference[w] - s.floating[B] + A.mainAxis, T = s.reference[w] + s.reference[B] - A.mainAxis;
        C < _ ? C = _ : C > T && (C = T);
      }
      if (g) {
        var P, M;
        const B = w === "y" ? "width" : "height", _ = originSides.has(getSide(o)), T = s.reference[b] - s.floating[B] + (_ && ((P = u.offset) == null ? void 0 : P[b]) || 0) + (_ ? 0 : A.crossAxis), O = s.reference[b] + s.reference[B] + (_ ? 0 : ((M = u.offset) == null ? void 0 : M[b]) || 0) - (_ ? A.crossAxis : 0);
        k < T ? k = T : k > O && (k = O);
      }
      return {
        [w]: C,
        [b]: k
      };
    }
  };
}, size$1 = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, a;
      const {
        placement: o,
        rects: s,
        platform: u,
        elements: d
      } = t, {
        apply: f = () => {
        },
        ...g
      } = evaluate(e, t), v = await detectOverflow(t, g), b = getSide(o), w = getAlignment(o), C = getSideAxis(o) === "y", {
        width: k,
        height: E
      } = s.floating;
      let A, P;
      b === "top" || b === "bottom" ? (A = b, P = w === (await (u.isRTL == null ? void 0 : u.isRTL(d.floating)) ? "start" : "end") ? "left" : "right") : (P = b, A = w === "end" ? "top" : "bottom");
      const M = E - v.top - v.bottom, B = k - v.left - v.right, _ = min(E - v[A], M), T = min(k - v[P], B), O = !t.middlewareData.shift;
      let I = _, q = T;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (q = B), (a = t.middlewareData.shift) != null && a.enabled.y && (I = M), O && !w) {
        const W = max(v.left, 0), K = max(v.right, 0), Z = max(v.top, 0), J = max(v.bottom, 0);
        C ? q = k - 2 * (W !== 0 || K !== 0 ? W + K : max(v.left, v.right)) : I = E - 2 * (Z !== 0 || J !== 0 ? Z + J : max(v.top, v.bottom));
      }
      await f({
        ...t,
        availableWidth: q,
        availableHeight: I
      });
      const F = await u.getDimensions(d.floating);
      return k !== F.width || E !== F.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function hasWindow() {
  return typeof window < "u";
}
function getNodeName(e) {
  return isNode(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function getWindow(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function getDocumentElement(e) {
  var t;
  return (t = (isNode(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function isNode(e) {
  return hasWindow() ? e instanceof Node || e instanceof getWindow(e).Node : !1;
}
function isElement$1(e) {
  return hasWindow() ? e instanceof Element || e instanceof getWindow(e).Element : !1;
}
function isHTMLElement$3(e) {
  return hasWindow() ? e instanceof HTMLElement || e instanceof getWindow(e).HTMLElement : !1;
}
function isShadowRoot(e) {
  return !hasWindow() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof getWindow(e).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: a,
    display: o
  } = getComputedStyle$2(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + n) && !invalidOverflowDisplayValues.has(o);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(e) {
  return tableElements.has(getNodeName(e));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(e) {
  return topLayerSelectors.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(e) {
  const t = isWebKit(), n = isElement$1(e) ? getComputedStyle$2(e) : e;
  return transformProperties.some((a) => n[a] ? n[a] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || willChangeValues.some((a) => (n.willChange || "").includes(a)) || containValues.some((a) => (n.contain || "").includes(a));
}
function getContainingBlock(e) {
  let t = getParentNode(e);
  for (; isHTMLElement$3(t) && !isLastTraversableNode(t); ) {
    if (isContainingBlock(t))
      return t;
    if (isTopLayer(t))
      return null;
    t = getParentNode(t);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(e) {
  return lastTraversableNodeNames.has(getNodeName(e));
}
function getComputedStyle$2(e) {
  return getWindow(e).getComputedStyle(e);
}
function getNodeScroll(e) {
  return isElement$1(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function getParentNode(e) {
  if (getNodeName(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    isShadowRoot(e) && e.host || // Fallback.
    getDocumentElement(e)
  );
  return isShadowRoot(t) ? t.host : t;
}
function getNearestOverflowAncestor(e) {
  const t = getParentNode(e);
  return isLastTraversableNode(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : isHTMLElement$3(t) && isOverflowElement(t) ? t : getNearestOverflowAncestor(t);
}
function getOverflowAncestors(e, t, n) {
  var a;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = getNearestOverflowAncestor(e), s = o === ((a = e.ownerDocument) == null ? void 0 : a.body), u = getWindow(o);
  if (s) {
    const d = getFrameElement(u);
    return t.concat(u, u.visualViewport || [], isOverflowElement(o) ? o : [], d && n ? getOverflowAncestors(d) : []);
  }
  return t.concat(o, getOverflowAncestors(o, [], n));
}
function getFrameElement(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function getCssDimensions(e) {
  const t = getComputedStyle$2(e);
  let n = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const o = isHTMLElement$3(e), s = o ? e.offsetWidth : n, u = o ? e.offsetHeight : a, d = round(n) !== s || round(a) !== u;
  return d && (n = s, a = u), {
    width: n,
    height: a,
    $: d
  };
}
function unwrapElement$1(e) {
  return isElement$1(e) ? e : e.contextElement;
}
function getScale(e) {
  const t = unwrapElement$1(e);
  if (!isHTMLElement$3(t))
    return createCoords(1);
  const n = t.getBoundingClientRect(), {
    width: a,
    height: o,
    $: s
  } = getCssDimensions(t);
  let u = (s ? round(n.width) : n.width) / a, d = (s ? round(n.height) : n.height) / o;
  return (!u || !Number.isFinite(u)) && (u = 1), (!d || !Number.isFinite(d)) && (d = 1), {
    x: u,
    y: d
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(e) {
  const t = getWindow(e);
  return !isWebKit() || !t.visualViewport ? noOffsets : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== getWindow(e) ? !1 : t;
}
function getBoundingClientRect(e, t, n, a) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), s = unwrapElement$1(e);
  let u = createCoords(1);
  t && (a ? isElement$1(a) && (u = getScale(a)) : u = getScale(e));
  const d = shouldAddVisualOffsets(s, n, a) ? getVisualOffsets(s) : createCoords(0);
  let f = (o.left + d.x) / u.x, g = (o.top + d.y) / u.y, v = o.width / u.x, b = o.height / u.y;
  if (s) {
    const w = getWindow(s), C = a && isElement$1(a) ? getWindow(a) : a;
    let k = w, E = getFrameElement(k);
    for (; E && a && C !== k; ) {
      const A = getScale(E), P = E.getBoundingClientRect(), M = getComputedStyle$2(E), B = P.left + (E.clientLeft + parseFloat(M.paddingLeft)) * A.x, _ = P.top + (E.clientTop + parseFloat(M.paddingTop)) * A.y;
      f *= A.x, g *= A.y, v *= A.x, b *= A.y, f += B, g += _, k = getWindow(E), E = getFrameElement(k);
    }
  }
  return rectToClientRect({
    width: v,
    height: b,
    x: f,
    y: g
  });
}
function getWindowScrollBarX(e, t) {
  const n = getNodeScroll(e).scrollLeft;
  return t ? t.left + n : getBoundingClientRect(getDocumentElement(e)).left + n;
}
function getHTMLOffset(e, t, n) {
  n === void 0 && (n = !1);
  const a = e.getBoundingClientRect(), o = a.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(e, a)
  )), s = a.top + t.scrollTop;
  return {
    x: o,
    y: s
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: a,
    strategy: o
  } = e;
  const s = o === "fixed", u = getDocumentElement(a), d = t ? isTopLayer(t.floating) : !1;
  if (a === u || d && s)
    return n;
  let f = {
    scrollLeft: 0,
    scrollTop: 0
  }, g = createCoords(1);
  const v = createCoords(0), b = isHTMLElement$3(a);
  if ((b || !b && !s) && ((getNodeName(a) !== "body" || isOverflowElement(u)) && (f = getNodeScroll(a)), isHTMLElement$3(a))) {
    const C = getBoundingClientRect(a);
    g = getScale(a), v.x = C.x + a.clientLeft, v.y = C.y + a.clientTop;
  }
  const w = u && !b && !s ? getHTMLOffset(u, f, !0) : createCoords(0);
  return {
    width: n.width * g.x,
    height: n.height * g.y,
    x: n.x * g.x - f.scrollLeft * g.x + v.x + w.x,
    y: n.y * g.y - f.scrollTop * g.y + v.y + w.y
  };
}
function getClientRects(e) {
  return Array.from(e.getClientRects());
}
function getDocumentRect(e) {
  const t = getDocumentElement(e), n = getNodeScroll(e), a = e.ownerDocument.body, o = max(t.scrollWidth, t.clientWidth, a.scrollWidth, a.clientWidth), s = max(t.scrollHeight, t.clientHeight, a.scrollHeight, a.clientHeight);
  let u = -n.scrollLeft + getWindowScrollBarX(e);
  const d = -n.scrollTop;
  return getComputedStyle$2(a).direction === "rtl" && (u += max(t.clientWidth, a.clientWidth) - o), {
    width: o,
    height: s,
    x: u,
    y: d
  };
}
function getViewportRect(e, t) {
  const n = getWindow(e), a = getDocumentElement(e), o = n.visualViewport;
  let s = a.clientWidth, u = a.clientHeight, d = 0, f = 0;
  if (o) {
    s = o.width, u = o.height;
    const g = isWebKit();
    (!g || g && t === "fixed") && (d = o.offsetLeft, f = o.offsetTop);
  }
  return {
    width: s,
    height: u,
    x: d,
    y: f
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(e, t) {
  const n = getBoundingClientRect(e, !0, t === "fixed"), a = n.top + e.clientTop, o = n.left + e.clientLeft, s = isHTMLElement$3(e) ? getScale(e) : createCoords(1), u = e.clientWidth * s.x, d = e.clientHeight * s.y, f = o * s.x, g = a * s.y;
  return {
    width: u,
    height: d,
    x: f,
    y: g
  };
}
function getClientRectFromClippingAncestor(e, t, n) {
  let a;
  if (t === "viewport")
    a = getViewportRect(e, n);
  else if (t === "document")
    a = getDocumentRect(getDocumentElement(e));
  else if (isElement$1(t))
    a = getInnerBoundingClientRect(t, n);
  else {
    const o = getVisualOffsets(e);
    a = {
      x: t.x - o.x,
      y: t.y - o.y,
      width: t.width,
      height: t.height
    };
  }
  return rectToClientRect(a);
}
function hasFixedPositionAncestor(e, t) {
  const n = getParentNode(e);
  return n === t || !isElement$1(n) || isLastTraversableNode(n) ? !1 : getComputedStyle$2(n).position === "fixed" || hasFixedPositionAncestor(n, t);
}
function getClippingElementAncestors(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let a = getOverflowAncestors(e, [], !1).filter((d) => isElement$1(d) && getNodeName(d) !== "body"), o = null;
  const s = getComputedStyle$2(e).position === "fixed";
  let u = s ? getParentNode(e) : e;
  for (; isElement$1(u) && !isLastTraversableNode(u); ) {
    const d = getComputedStyle$2(u), f = isContainingBlock(u);
    !f && d.position === "fixed" && (o = null), (s ? !f && !o : !f && d.position === "static" && !!o && absoluteOrFixed.has(o.position) || isOverflowElement(u) && !f && hasFixedPositionAncestor(e, u)) ? a = a.filter((v) => v !== u) : o = d, u = getParentNode(u);
  }
  return t.set(e, a), a;
}
function getClippingRect(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: a,
    strategy: o
  } = e;
  const u = [...n === "clippingAncestors" ? isTopLayer(t) ? [] : getClippingElementAncestors(t, this._c) : [].concat(n), a], d = u[0], f = u.reduce((g, v) => {
    const b = getClientRectFromClippingAncestor(t, v, o);
    return g.top = max(b.top, g.top), g.right = min(b.right, g.right), g.bottom = min(b.bottom, g.bottom), g.left = max(b.left, g.left), g;
  }, getClientRectFromClippingAncestor(t, d, o));
  return {
    width: f.right - f.left,
    height: f.bottom - f.top,
    x: f.left,
    y: f.top
  };
}
function getDimensions(e) {
  const {
    width: t,
    height: n
  } = getCssDimensions(e);
  return {
    width: t,
    height: n
  };
}
function getRectRelativeToOffsetParent(e, t, n) {
  const a = isHTMLElement$3(t), o = getDocumentElement(t), s = n === "fixed", u = getBoundingClientRect(e, !0, s, t);
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const f = createCoords(0);
  function g() {
    f.x = getWindowScrollBarX(o);
  }
  if (a || !a && !s)
    if ((getNodeName(t) !== "body" || isOverflowElement(o)) && (d = getNodeScroll(t)), a) {
      const C = getBoundingClientRect(t, !0, s, t);
      f.x = C.x + t.clientLeft, f.y = C.y + t.clientTop;
    } else o && g();
  s && !a && o && g();
  const v = o && !a && !s ? getHTMLOffset(o, d) : createCoords(0), b = u.left + d.scrollLeft - f.x - v.x, w = u.top + d.scrollTop - f.y - v.y;
  return {
    x: b,
    y: w,
    width: u.width,
    height: u.height
  };
}
function isStaticPositioned(e) {
  return getComputedStyle$2(e).position === "static";
}
function getTrueOffsetParent(e, t) {
  if (!isHTMLElement$3(e) || getComputedStyle$2(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return getDocumentElement(e) === n && (n = n.ownerDocument.body), n;
}
function getOffsetParent(e, t) {
  const n = getWindow(e);
  if (isTopLayer(e))
    return n;
  if (!isHTMLElement$3(e)) {
    let o = getParentNode(e);
    for (; o && !isLastTraversableNode(o); ) {
      if (isElement$1(o) && !isStaticPositioned(o))
        return o;
      o = getParentNode(o);
    }
    return n;
  }
  let a = getTrueOffsetParent(e, t);
  for (; a && isTableElement(a) && isStaticPositioned(a); )
    a = getTrueOffsetParent(a, t);
  return a && isLastTraversableNode(a) && isStaticPositioned(a) && !isContainingBlock(a) ? n : a || getContainingBlock(e) || n;
}
const getElementRects = async function(e) {
  const t = this.getOffsetParent || getOffsetParent, n = this.getDimensions, a = await n(e.floating);
  return {
    reference: getRectRelativeToOffsetParent(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: a.width,
      height: a.height
    }
  };
};
function isRTL(e) {
  return getComputedStyle$2(e).direction === "rtl";
}
const platform$2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function rectsAreEqual(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function observeMove(e, t) {
  let n = null, a;
  const o = getDocumentElement(e);
  function s() {
    var d;
    clearTimeout(a), (d = n) == null || d.disconnect(), n = null;
  }
  function u(d, f) {
    d === void 0 && (d = !1), f === void 0 && (f = 1), s();
    const g = e.getBoundingClientRect(), {
      left: v,
      top: b,
      width: w,
      height: C
    } = g;
    if (d || t(), !w || !C)
      return;
    const k = floor(b), E = floor(o.clientWidth - (v + w)), A = floor(o.clientHeight - (b + C)), P = floor(v), B = {
      rootMargin: -k + "px " + -E + "px " + -A + "px " + -P + "px",
      threshold: max(0, min(1, f)) || 1
    };
    let _ = !0;
    function T(O) {
      const I = O[0].intersectionRatio;
      if (I !== f) {
        if (!_)
          return u();
        I ? u(!1, I) : a = setTimeout(() => {
          u(!1, 1e-7);
        }, 1e3);
      }
      I === 1 && !rectsAreEqual(g, e.getBoundingClientRect()) && u(), _ = !1;
    }
    try {
      n = new IntersectionObserver(T, {
        ...B,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(T, B);
    }
    n.observe(e);
  }
  return u(!0), s;
}
function autoUpdate(e, t, n, a) {
  a === void 0 && (a = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: s = !0,
    elementResize: u = typeof ResizeObserver == "function",
    layoutShift: d = typeof IntersectionObserver == "function",
    animationFrame: f = !1
  } = a, g = unwrapElement$1(e), v = o || s ? [...g ? getOverflowAncestors(g) : [], ...getOverflowAncestors(t)] : [];
  v.forEach((P) => {
    o && P.addEventListener("scroll", n, {
      passive: !0
    }), s && P.addEventListener("resize", n);
  });
  const b = g && d ? observeMove(g, n) : null;
  let w = -1, C = null;
  u && (C = new ResizeObserver((P) => {
    let [M] = P;
    M && M.target === g && C && (C.unobserve(t), cancelAnimationFrame(w), w = requestAnimationFrame(() => {
      var B;
      (B = C) == null || B.observe(t);
    })), n();
  }), g && !f && C.observe(g), C.observe(t));
  let k, E = f ? getBoundingClientRect(e) : null;
  f && A();
  function A() {
    const P = getBoundingClientRect(e);
    E && !rectsAreEqual(E, P) && n(), E = P, k = requestAnimationFrame(A);
  }
  return n(), () => {
    var P;
    v.forEach((M) => {
      o && M.removeEventListener("scroll", n), s && M.removeEventListener("resize", n);
    }), b?.(), (P = C) == null || P.disconnect(), C = null, f && cancelAnimationFrame(k);
  };
}
const offset = offset$1, shift = shift$1, flip = flip$1, size = size$1, hide = hide$1, arrow$1 = arrow$2, limitShift = limitShift$1, computePosition = (e, t, n) => {
  const a = /* @__PURE__ */ new Map(), o = {
    platform: platform$2,
    ...n
  }, s = {
    ...o.platform,
    _c: a
  };
  return computePosition$1(e, t, {
    ...o,
    platform: s
  });
};
function isComponentPublicInstance(e) {
  return e != null && typeof e == "object" && "$el" in e;
}
function unwrapElement(e) {
  if (isComponentPublicInstance(e)) {
    const t = e.$el;
    return isNode(t) && getNodeName(t) === "#comment" ? null : t;
  }
  return e;
}
function toValue$1(e) {
  return typeof e == "function" ? e() : unref(e);
}
function arrow(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const n = unwrapElement(toValue$1(e.element));
      return n == null ? {} : arrow$1({
        element: n,
        padding: e.padding
      }).fn(t);
    }
  };
}
function getDPR(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(e, t) {
  const n = getDPR(e);
  return Math.round(t * n) / n;
}
function useFloating(e, t, n) {
  n === void 0 && (n = {});
  const a = n.whileElementsMounted, o = computed(() => {
    var I;
    return (I = toValue$1(n.open)) != null ? I : !0;
  }), s = computed(() => toValue$1(n.middleware)), u = computed(() => {
    var I;
    return (I = toValue$1(n.placement)) != null ? I : "bottom";
  }), d = computed(() => {
    var I;
    return (I = toValue$1(n.strategy)) != null ? I : "absolute";
  }), f = computed(() => {
    var I;
    return (I = toValue$1(n.transform)) != null ? I : !0;
  }), g = computed(() => unwrapElement(e.value)), v = computed(() => unwrapElement(t.value)), b = ref(0), w = ref(0), C = ref(d.value), k = ref(u.value), E = shallowRef({}), A = ref(!1), P = computed(() => {
    const I = {
      position: C.value,
      left: "0",
      top: "0"
    };
    if (!v.value)
      return I;
    const q = roundByDPR(v.value, b.value), F = roundByDPR(v.value, w.value);
    return f.value ? {
      ...I,
      transform: "translate(" + q + "px, " + F + "px)",
      ...getDPR(v.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: C.value,
      left: q + "px",
      top: F + "px"
    };
  });
  let M;
  function B() {
    if (g.value == null || v.value == null)
      return;
    const I = o.value;
    computePosition(g.value, v.value, {
      middleware: s.value,
      placement: u.value,
      strategy: d.value
    }).then((q) => {
      b.value = q.x, w.value = q.y, C.value = q.strategy, k.value = q.placement, E.value = q.middlewareData, A.value = I !== !1;
    });
  }
  function _() {
    typeof M == "function" && (M(), M = void 0);
  }
  function T() {
    if (_(), a === void 0) {
      B();
      return;
    }
    if (g.value != null && v.value != null) {
      M = a(g.value, v.value, B);
      return;
    }
  }
  function O() {
    o.value || (A.value = !1);
  }
  return watch([s, u, d, o], B, {
    flush: "sync"
  }), watch([g, v], T, {
    flush: "sync"
  }), watch(o, O, {
    flush: "sync"
  }), getCurrentScope() && onScopeDispose(_), {
    x: shallowReadonly(b),
    y: shallowReadonly(w),
    strategy: shallowReadonly(C),
    placement: shallowReadonly(k),
    middlewareData: shallowReadonly(E),
    isPositioned: shallowReadonly(A),
    floatingStyles: P,
    update: B
  };
}
function renderSlotFragments$1(e) {
  return e ? e.flatMap((t) => t.type === Fragment ? renderSlotFragments$1(t.children) : [t]) : [];
}
const Slot = defineComponent({
  name: "PrimitiveSlot",
  inheritAttrs: !1,
  setup(e, { attrs: t, slots: n }) {
    return () => {
      if (!n.default)
        return null;
      const a = renderSlotFragments$1(n.default()), o = a.findIndex((f) => f.type !== Comment);
      if (o === -1)
        return a;
      const s = a[o];
      delete s.props?.ref;
      const u = s.props ? mergeProps(t, s.props) : t, d = cloneVNode({ ...s, props: {} }, u);
      return a.length === 1 ? d : (a[o] = d, a);
    };
  }
}), SELF_CLOSING_TAGS$1 = ["area", "img", "input"], Primitive = defineComponent({
  name: "Primitive",
  inheritAttrs: !1,
  props: {
    asChild: {
      type: Boolean,
      default: !1
    },
    as: {
      type: [String, Object],
      default: "div"
    }
  },
  setup(e, { attrs: t, slots: n }) {
    const a = e.asChild ? "template" : e.as;
    return typeof a == "string" && SELF_CLOSING_TAGS$1.includes(a) ? () => h(a, t) : a !== "template" ? () => h(e.as, t, { default: n.default }) : () => h(Slot, t, { default: n.default });
  }
}), _sfc_main$4u = /* @__PURE__ */ defineComponent({
  __name: "VisuallyHidden",
  props: {
    feature: { default: "focusable" },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(Primitive), {
      as: t.as,
      "as-child": t.asChild,
      "aria-hidden": t.feature === "focusable" ? "true" : void 0,
      "data-hidden": t.feature === "fully-hidden" ? "" : void 0,
      tabindex: t.feature === "fully-hidden" ? "-1" : void 0,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: "1px",
        height: "1px",
        padding: 0,
        margin: "-1px",
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        clipPath: "inset(50%)",
        whiteSpace: "nowrap",
        wordWrap: "normal"
      }
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"]));
  }
});
function computedEager(e, t) {
  var n;
  const a = shallowRef();
  return watchEffect(() => {
    a.value = e();
  }, {
    ...t,
    flush: (n = void 0) != null ? n : "sync"
  }), readonly(a);
}
function tryOnScopeDispose(e) {
  return getCurrentScope() ? (onScopeDispose(e), !0) : !1;
}
function createEventHook() {
  const e = /* @__PURE__ */ new Set(), t = (s) => {
    e.delete(s);
  };
  return {
    on: (s) => {
      e.add(s);
      const u = () => t(s);
      return tryOnScopeDispose(u), {
        off: u
      };
    },
    off: t,
    trigger: (...s) => Promise.all(Array.from(e).map((u) => u(...s))),
    clear: () => {
      e.clear();
    }
  };
}
function createGlobalState(e) {
  let t = !1, n;
  const a = effectScope(!0);
  return (...o) => (t || (n = a.run(() => e(...o)), t = !0), n);
}
function createSharedComposable(e) {
  let t = 0, n, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), n = void 0, a = void 0);
  };
  return (...s) => (t += 1, a || (a = effectScope(!0), n = a.run(() => e(...s))), tryOnScopeDispose(o), n);
}
function toReactive(e) {
  if (!isRef(e))
    return reactive(e);
  const t = new Proxy({}, {
    get(n, a, o) {
      return unref(Reflect.get(e.value, a, o));
    },
    set(n, a, o) {
      return isRef(e.value[a]) && !isRef(o) ? e.value[a].value = o : e.value[a] = o, !0;
    },
    deleteProperty(n, a) {
      return Reflect.deleteProperty(e.value, a);
    },
    has(n, a) {
      return Reflect.has(e.value, a);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return reactive(t);
}
function reactiveComputed(e) {
  return toReactive(computed(e));
}
function reactiveOmit(e, ...t) {
  const n = t.flat(), a = n[0];
  return reactiveComputed(() => Object.fromEntries(typeof a == "function" ? Object.entries(toRefs(e)).filter(([o, s]) => !a(toValue$3(s), o)) : Object.entries(toRefs(e)).filter((o) => !n.includes(o[0]))));
}
const isClient = typeof window < "u" && typeof document < "u";
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const isDef$1 = (e) => typeof e < "u", toString$2 = Object.prototype.toString, isObject$3 = (e) => toString$2.call(e) === "[object Object]", isIOS = /* @__PURE__ */ getIsIOS();
function getIsIOS() {
  var e, t;
  return isClient && ((e = window?.navigator) == null ? void 0 : e.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((t = window?.navigator) == null ? void 0 : t.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window?.navigator.userAgent));
}
function getLifeCycleTarget(e) {
  return getCurrentInstance();
}
function toArray$1(e) {
  return Array.isArray(e) ? e : [e];
}
function refAutoReset(e, t = 1e4) {
  return customRef((n, a) => {
    let o = toValue$3(e), s;
    const u = () => setTimeout(() => {
      o = toValue$3(e), a();
    }, toValue$3(t));
    return tryOnScopeDispose(() => {
      clearTimeout(s);
    }), {
      get() {
        return n(), o;
      },
      set(d) {
        o = d, a(), clearTimeout(s), s = u();
      }
    };
  });
}
const toValue = toValue$3;
function tryOnBeforeUnmount(e, t) {
  getLifeCycleTarget() && onBeforeUnmount(e, t);
}
function useTimeoutFn(e, t, n = {}) {
  const {
    immediate: a = !0,
    immediateCallback: o = !1
  } = n, s = shallowRef(!1);
  let u = null;
  function d() {
    u && (clearTimeout(u), u = null);
  }
  function f() {
    s.value = !1, d();
  }
  function g(...v) {
    o && e(), d(), s.value = !0, u = setTimeout(() => {
      s.value = !1, u = null, e(...v);
    }, toValue$3(t));
  }
  return a && (s.value = !0, isClient && g()), tryOnScopeDispose(f), {
    isPending: readonly(s),
    start: g,
    stop: f
  };
}
function watchImmediate(e, t, n) {
  return watch(
    e,
    t,
    {
      ...n,
      immediate: !0
    }
  );
}
const defaultWindow = isClient ? window : void 0;
function unrefElement(e) {
  var t;
  const n = toValue$3(e);
  return (t = n?.$el) != null ? t : n;
}
function useEventListener(...e) {
  const t = [], n = () => {
    t.forEach((d) => d()), t.length = 0;
  }, a = (d, f, g, v) => (d.addEventListener(f, g, v), () => d.removeEventListener(f, g, v)), o = computed(() => {
    const d = toArray$1(toValue$3(e[0])).filter((f) => f != null);
    return d.every((f) => typeof f != "string") ? d : void 0;
  }), s = watchImmediate(
    () => {
      var d, f;
      return [
        (f = (d = o.value) == null ? void 0 : d.map((g) => unrefElement(g))) != null ? f : [defaultWindow].filter((g) => g != null),
        toArray$1(toValue$3(o.value ? e[1] : e[0])),
        toArray$1(unref(o.value ? e[2] : e[1])),
        // @ts-expect-error - TypeScript gets the correct types, but somehow still complains
        toValue$3(o.value ? e[3] : e[2])
      ];
    },
    ([d, f, g, v]) => {
      if (n(), !d?.length || !f?.length || !g?.length)
        return;
      const b = isObject$3(v) ? { ...v } : v;
      t.push(
        ...d.flatMap(
          (w) => f.flatMap(
            (C) => g.map((k) => a(w, C, k, b))
          )
        )
      );
    },
    { flush: "post" }
  ), u = () => {
    s(), n();
  };
  return tryOnScopeDispose(n), u;
}
function useMounted() {
  const e = shallowRef(!1), t = getCurrentInstance();
  return t && onMounted(() => {
    e.value = !0;
  }, t), e;
}
function useSupported(e) {
  const t = useMounted();
  return computed(() => (t.value, !!e()));
}
function createKeyPredicate(e) {
  return typeof e == "function" ? e : typeof e == "string" ? (t) => t.key === e : Array.isArray(e) ? (t) => e.includes(t.key) : () => !0;
}
function onKeyStroke(...e) {
  let t, n, a = {};
  e.length === 3 ? (t = e[0], n = e[1], a = e[2]) : e.length === 2 ? typeof e[1] == "object" ? (t = !0, n = e[0], a = e[1]) : (t = e[0], n = e[1]) : (t = !0, n = e[0]);
  const {
    target: o = defaultWindow,
    eventName: s = "keydown",
    passive: u = !1,
    dedupe: d = !1
  } = a, f = createKeyPredicate(t);
  return useEventListener(o, s, (v) => {
    v.repeat && toValue$3(d) || f(v) && n(v);
  }, u);
}
function cloneFnJSON(e) {
  return JSON.parse(JSON.stringify(e));
}
function useResizeObserver(e, t, n = {}) {
  const { window: a = defaultWindow, ...o } = n;
  let s;
  const u = useSupported(() => a && "ResizeObserver" in a), d = () => {
    s && (s.disconnect(), s = void 0);
  }, f = computed(() => {
    const b = toValue$3(e);
    return Array.isArray(b) ? b.map((w) => unrefElement(w)) : [unrefElement(b)];
  }), g = watch(
    f,
    (b) => {
      if (d(), u.value && a) {
        s = new ResizeObserver(t);
        for (const w of b)
          w && s.observe(w, o);
      }
    },
    { immediate: !0, flush: "post" }
  ), v = () => {
    d(), g();
  };
  return tryOnScopeDispose(v), {
    isSupported: u,
    stop: v
  };
}
function useVModel(e, t, n, a = {}) {
  var o, s, u;
  const {
    clone: d = !1,
    passive: f = !1,
    eventName: g,
    deep: v = !1,
    defaultValue: b,
    shouldEmit: w
  } = a, C = getCurrentInstance(), k = n || C?.emit || ((o = C?.$emit) == null ? void 0 : o.bind(C)) || ((u = (s = C?.proxy) == null ? void 0 : s.$emit) == null ? void 0 : u.bind(C?.proxy));
  let E = g;
  t || (t = "modelValue"), E = E || `update:${t.toString()}`;
  const A = (B) => d ? typeof d == "function" ? d(B) : cloneFnJSON(B) : B, P = () => isDef$1(e[t]) ? A(e[t]) : b, M = (B) => {
    w ? w(B) && k(E, B) : k(E, B);
  };
  if (f) {
    const B = P(), _ = ref(B);
    let T = !1;
    return watch(
      () => e[t],
      (O) => {
        T || (T = !0, _.value = A(O), nextTick(() => T = !1));
      }
    ), watch(
      _,
      (O) => {
        !T && (O !== e[t] || v) && M(O);
      },
      { deep: v }
    ), _;
  } else
    return computed({
      get() {
        return P();
      },
      set(B) {
        M(B);
      }
    });
}
function createContext$2(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(u) => {
    const d = inject(a, u);
    if (d || d === null)
      return d;
    throw new Error(
      `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(
        ", "
      )}` : `\`${e}\``}`
    );
  }, (u) => (provide(a, u), u)];
}
function serialize(e) {
  return typeof e == "string" ? `'${e}'` : new c().serialize(e);
}
const c = /* @__PURE__ */ (function() {
  class e {
    #e = /* @__PURE__ */ new Map();
    compare(n, a) {
      const o = typeof n, s = typeof a;
      return o === "string" && s === "string" ? n.localeCompare(a) : o === "number" && s === "number" ? n - a : String.prototype.localeCompare.call(this.serialize(n, !0), this.serialize(a, !0));
    }
    serialize(n, a) {
      if (n === null) return "null";
      switch (typeof n) {
        case "string":
          return a ? n : `'${n}'`;
        case "bigint":
          return `${n}n`;
        case "object":
          return this.$object(n);
        case "function":
          return this.$function(n);
      }
      return String(n);
    }
    serializeObject(n) {
      const a = Object.prototype.toString.call(n);
      if (a !== "[object Object]") return this.serializeBuiltInType(a.length < 10 ? `unknown:${a}` : a.slice(8, -1), n);
      const o = n.constructor, s = o === Object || o === void 0 ? "" : o.name;
      if (s !== "" && globalThis[s] === o) return this.serializeBuiltInType(s, n);
      if (typeof n.toJSON == "function") {
        const u = n.toJSON();
        return s + (u !== null && typeof u == "object" ? this.$object(u) : `(${this.serialize(u)})`);
      }
      return this.serializeObjectEntries(s, Object.entries(n));
    }
    serializeBuiltInType(n, a) {
      const o = this["$" + n];
      if (o) return o.call(this, a);
      if (typeof a?.entries == "function") return this.serializeObjectEntries(n, a.entries());
      throw new Error(`Cannot serialize ${n}`);
    }
    serializeObjectEntries(n, a) {
      const o = Array.from(a).sort((u, d) => this.compare(u[0], d[0]));
      let s = `${n}{`;
      for (let u = 0; u < o.length; u++) {
        const [d, f] = o[u];
        s += `${this.serialize(d, !0)}:${this.serialize(f)}`, u < o.length - 1 && (s += ",");
      }
      return s + "}";
    }
    $object(n) {
      let a = this.#e.get(n);
      return a === void 0 && (this.#e.set(n, `#${this.#e.size}`), a = this.serializeObject(n), this.#e.set(n, a)), a;
    }
    $function(n) {
      const a = Function.prototype.toString.call(n);
      return a.slice(-15) === "[native code] }" ? `${n.name || ""}()[native]` : `${n.name}(${n.length})${a.replace(/\s*\n\s*/g, "")}`;
    }
    $Array(n) {
      let a = "[";
      for (let o = 0; o < n.length; o++) a += this.serialize(n[o]), o < n.length - 1 && (a += ",");
      return a + "]";
    }
    $Date(n) {
      try {
        return `Date(${n.toISOString()})`;
      } catch {
        return "Date(null)";
      }
    }
    $ArrayBuffer(n) {
      return `ArrayBuffer[${new Uint8Array(n).join(",")}]`;
    }
    $Set(n) {
      return `Set${this.$Array(Array.from(n).sort((a, o) => this.compare(a, o)))}`;
    }
    $Map(n) {
      return this.serializeObjectEntries("Map", n.entries());
    }
  }
  for (const t of ["Error", "RegExp", "URL"]) e.prototype["$" + t] = function(n) {
    return `${t}(${n})`;
  };
  for (const t of ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join(",")}]`;
  };
  for (const t of ["BigInt64Array", "BigUint64Array"]) e.prototype["$" + t] = function(n) {
    return `${t}[${n.join("n,")}${n.length > 0 ? "n" : ""}]`;
  };
  return e;
})();
function isEqual(e, t) {
  return e === t || serialize(e) === serialize(t);
}
function isNullish$1(e) {
  return e == null;
}
function isValueEqualOrExist(e, t) {
  return isNullish$1(e) ? !1 : Array.isArray(e) ? e.some((n) => isEqual(n, t)) : isEqual(e, t);
}
function validateProps({ type: e, defaultValue: t, modelValue: n }) {
  const a = n || t;
  return n !== void 0 || t !== void 0 ? Array.isArray(a) ? "multiple" : "single" : e ?? "single";
}
function getDefaultType({ type: e, defaultValue: t, modelValue: n }) {
  return e || validateProps({ type: e, defaultValue: t, modelValue: n });
}
function getDefaultValue({ type: e, defaultValue: t }) {
  return t !== void 0 ? t : e === "single" ? void 0 : [];
}
function useSingleOrMultipleValue(e, t) {
  const n = computed(() => getDefaultType(e)), a = useVModel(e, "modelValue", t, {
    defaultValue: getDefaultValue(e),
    passive: e.modelValue === void 0,
    deep: !0
  });
  function o(u) {
    if (n.value === "single")
      a.value = isEqual(u, a.value) ? void 0 : u;
    else {
      const d = Array.isArray(a.value) ? [...a.value || []] : [a.value].filter(Boolean);
      if (isValueEqualOrExist(d, u)) {
        const f = d.findIndex((g) => isEqual(g, u));
        d.splice(f, 1);
      } else
        d.push(u);
      a.value = d;
    }
  }
  const s = computed(() => n.value === "single");
  return {
    modelValue: a,
    changeModelValue: o,
    isSingle: s
  };
}
const [injectConfigProviderContext, provideConfigProviderContext] = createContext$2("ConfigProvider");
function useDirection(e) {
  const t = injectConfigProviderContext({
    dir: ref("ltr")
  });
  return computed(() => e?.value || t.dir?.value || "ltr");
}
function useForwardExpose() {
  const e = getCurrentInstance(), t = ref(), n = computed(() => ["#text", "#comment"].includes(t.value?.$el.nodeName) ? t.value?.$el.nextElementSibling : unrefElement(t)), a = Object.assign({}, e.exposed), o = {};
  for (const u in e.props)
    Object.defineProperty(o, u, {
      enumerable: !0,
      configurable: !0,
      get: () => e.props[u]
    });
  if (Object.keys(a).length > 0)
    for (const u in a)
      Object.defineProperty(o, u, {
        enumerable: !0,
        configurable: !0,
        get: () => a[u]
      });
  Object.defineProperty(o, "$el", {
    enumerable: !0,
    configurable: !0,
    get: () => e.vnode.el
  }), e.exposed = o;
  function s(u) {
    t.value = u, u && (Object.defineProperty(o, "$el", {
      enumerable: !0,
      configurable: !0,
      get: () => u instanceof Element ? u : u.$el
    }), e.exposed = o);
  }
  return { forwardRef: s, currentRef: t, currentElement: n };
}
const ignoredElement = ["INPUT", "TEXTAREA"];
function useArrowNavigation(e, t, n, a = {}) {
  if (!t || a.enableIgnoredElement && ignoredElement.includes(t.nodeName))
    return null;
  const {
    arrowKeyOptions: o = "both",
    attributeName: s = "[data-reka-collection-item]",
    itemsArray: u = [],
    loop: d = !0,
    dir: f = "ltr",
    preventScroll: g = !0,
    focus: v = !1
  } = a, [b, w, C, k, E, A] = [
    e.key === "ArrowRight",
    e.key === "ArrowLeft",
    e.key === "ArrowUp",
    e.key === "ArrowDown",
    e.key === "Home",
    e.key === "End"
  ], P = C || k, M = b || w;
  if (!E && !A && (!P && !M || o === "vertical" && M || o === "horizontal" && P))
    return null;
  const B = n ? Array.from(n.querySelectorAll(s)) : u;
  if (!B.length)
    return null;
  g && e.preventDefault();
  let _ = null;
  return M || P ? _ = findNextFocusableElement(B, t, {
    goForward: P ? k : f === "ltr" ? b : w,
    loop: d
  }) : E ? _ = B.at(0) || null : A && (_ = B.at(-1) || null), v && _?.focus(), _;
}
function findNextFocusableElement(e, t, n, a = e.length) {
  if (--a === 0)
    return null;
  const o = e.indexOf(t), s = n.goForward ? o + 1 : o - 1;
  if (!n.loop && (s < 0 || s >= e.length))
    return null;
  const u = (s + e.length) % e.length, d = e[u];
  return d ? d.hasAttribute("disabled") && d.getAttribute("disabled") !== "false" ? findNextFocusableElement(
    e,
    d,
    n,
    a
  ) : d : null;
}
let count$1 = 0;
function useId(e, t = "reka") {
  if (e)
    return e;
  const n = injectConfigProviderContext({ useId: void 0 });
  return Object.hasOwn(vue$1, "useId") ? `${t}-${vue$1.useId?.()}` : n.useId ? `${t}-${n.useId()}` : `${t}-${++count$1}`;
}
function useStateMachine(e, t) {
  const n = ref(e);
  function a(s) {
    return t[n.value][s] ?? n.value;
  }
  return {
    state: n,
    dispatch: (s) => {
      n.value = a(s);
    }
  };
}
function usePresence(e, t) {
  const n = ref({}), a = ref("none"), o = ref(e), s = e.value ? "mounted" : "unmounted";
  let u;
  const d = t.value?.ownerDocument.defaultView ?? defaultWindow, { state: f, dispatch: g } = useStateMachine(s, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  }), v = (A) => {
    if (isClient) {
      const P = new CustomEvent(A, { bubbles: !1, cancelable: !1 });
      t.value?.dispatchEvent(P);
    }
  };
  watch(
    e,
    async (A, P) => {
      const M = P !== A;
      if (await nextTick(), M) {
        const B = a.value, _ = getAnimationName(t.value);
        A ? (g("MOUNT"), v("enter"), _ === "none" && v("after-enter")) : _ === "none" || _ === "undefined" || n.value?.display === "none" ? (g("UNMOUNT"), v("leave"), v("after-leave")) : P && B !== _ ? (g("ANIMATION_OUT"), v("leave")) : (g("UNMOUNT"), v("after-leave"));
      }
    },
    { immediate: !0 }
  );
  const b = (A) => {
    const P = getAnimationName(t.value), M = P.includes(
      A.animationName
    ), B = f.value === "mounted" ? "enter" : "leave";
    if (A.target === t.value && M && (v(`after-${B}`), g("ANIMATION_END"), !o.value)) {
      const _ = t.value.style.animationFillMode;
      t.value.style.animationFillMode = "forwards", u = d?.setTimeout(() => {
        t.value?.style.animationFillMode === "forwards" && (t.value.style.animationFillMode = _);
      });
    }
    A.target === t.value && P === "none" && g("ANIMATION_END");
  }, w = (A) => {
    A.target === t.value && (a.value = getAnimationName(t.value));
  }, C = watch(
    t,
    (A, P) => {
      A ? (n.value = getComputedStyle(A), A.addEventListener("animationstart", w), A.addEventListener("animationcancel", b), A.addEventListener("animationend", b)) : (g("ANIMATION_END"), u !== void 0 && d?.clearTimeout(u), P?.removeEventListener("animationstart", w), P?.removeEventListener("animationcancel", b), P?.removeEventListener("animationend", b));
    },
    { immediate: !0 }
  ), k = watch(f, () => {
    const A = getAnimationName(t.value);
    a.value = f.value === "mounted" ? A : "none";
  });
  return onUnmounted(() => {
    C(), k();
  }), {
    isPresent: computed(
      () => ["mounted", "unmountSuspended"].includes(f.value)
    )
  };
}
function getAnimationName(e) {
  return e && getComputedStyle(e).animationName || "none";
}
const Presence = defineComponent({
  name: "Presence",
  props: {
    present: {
      type: Boolean,
      required: !0
    },
    forceMount: {
      type: Boolean
    }
  },
  slots: {},
  setup(e, { slots: t, expose: n }) {
    const { present: a, forceMount: o } = toRefs(e), s = ref(), { isPresent: u } = usePresence(a, s);
    n({ present: u });
    let d = t.default({ present: u.value });
    d = renderSlotFragments$1(d || []);
    const f = getCurrentInstance();
    if (d && d?.length > 1) {
      const g = f?.parent?.type.name ? `<${f.parent.type.name} />` : "component";
      throw new Error(
        [
          `Detected an invalid children for \`${g}\` for  \`Presence\` component.`,
          "",
          "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.",
          "You can apply a few solutions:",
          [
            "Provide a single child element so that `presence` directive attach correctly.",
            "Ensure the first child is an actual element instead of a raw text node or comment node."
          ].map((v) => `  - ${v}`).join(`
`)
        ].join(`
`)
      );
    }
    return () => o.value || a.value || u.value ? h(t.default({ present: u.value })[0], {
      ref: (g) => {
        const v = unrefElement(g);
        return typeof v?.hasAttribute > "u" || (v?.hasAttribute("data-reka-popper-content-wrapper") ? s.value = v.firstElementChild : s.value = v), v;
      }
    }) : null;
  }
}), [injectDialogRootContext, provideDialogRootContext] = createContext$2("DialogRoot"), _sfc_main$4t = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "DialogRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean, default: !1 },
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, o = useVModel(n, "open", t, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = ref(), u = ref(), { modal: d } = toRefs(n);
    return provideDialogRootContext({
      open: o,
      modal: d,
      openModal: () => {
        o.value = !0;
      },
      onOpenChange: (f) => {
        o.value = f;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      contentId: "",
      titleId: "",
      descriptionId: "",
      triggerElement: s,
      contentElement: u
    }), (f, g) => renderSlot(f.$slots, "default", {
      open: unref(o),
      close: () => o.value = !1
    });
  }
}), _sfc_main$4s = /* @__PURE__ */ defineComponent({
  __name: "DialogClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    useForwardExpose();
    const n = injectDialogRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      type: a.as === "button" ? "button" : void 0,
      onClick: o[0] || (o[0] = (s) => unref(n).onOpenChange(!1))
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["type"]));
  }
});
function useEmitAsProps(e) {
  const t = getCurrentInstance(), n = t?.type.emits, a = {};
  return n?.length || console.warn(
    `No emitted event found. Please check component: ${t?.type.__name}`
  ), n?.forEach((o) => {
    a[toHandlerKey(camelize(o))] = (...s) => e(o, ...s);
  }), a;
}
function getActiveElement() {
  let e = document.activeElement;
  if (e == null)
    return null;
  for (; e != null && e.shadowRoot != null && e.shadowRoot.activeElement != null; )
    e = e.shadowRoot.activeElement;
  return e;
}
const ITEM_SELECT = "menu.itemSelect", SELECTION_KEYS = ["Enter", " "], FIRST_KEYS = ["ArrowDown", "PageUp", "Home"], LAST_KEYS = ["ArrowUp", "PageDown", "End"], FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
[...SELECTION_KEYS], [...SELECTION_KEYS];
function getOpenState(e) {
  return e ? "open" : "closed";
}
function focusFirst$2(e) {
  const t = getActiveElement();
  for (const n of e)
    if (n === t || (n.focus(), getActiveElement() !== t))
      return;
}
function isPointInPolygon$1(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let s = 0, u = t.length - 1; s < t.length; u = s++) {
    const d = t[s].x, f = t[s].y, g = t[u].x, v = t[u].y;
    f > a != v > a && n < (g - d) * (a - f) / (v - f) + d && (o = !o);
  }
  return o;
}
function isPointerInGraceArea(e, t) {
  if (!t)
    return !1;
  const n = { x: e.clientX, y: e.clientY };
  return isPointInPolygon$1(n, t);
}
function isMouseEvent$1(e) {
  return e.pointerType === "mouse";
}
const DEFAULT_TITLE_NAME = "DialogTitle", DEFAULT_CONTENT_NAME = "DialogContent";
function useWarning({
  titleName: e = DEFAULT_TITLE_NAME,
  contentName: t = DEFAULT_CONTENT_NAME,
  componentLink: n = "dialog.html#title",
  titleId: a,
  descriptionId: o,
  contentElement: s
}) {
  const u = `Warning: \`${t}\` requires a \`${e}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://www.reka-ui.com/docs/components/${n}`, d = `Warning: Missing \`Description\` or \`aria-describedby="undefined"\` for ${t}.`;
  onMounted(() => {
    document.getElementById(a) || console.warn(u);
    const g = s.value?.getAttribute("aria-describedby");
    o && g && (document.getElementById(o) || console.warn(d));
  });
}
const useFocusStackState = createGlobalState(() => ref([]));
function createFocusScopesStack() {
  const e = useFocusStackState();
  return {
    add(t) {
      const n = e.value[0];
      t !== n && n?.pause(), e.value = arrayRemove(e.value, t), e.value.unshift(t);
    },
    remove(t) {
      e.value = arrayRemove(e.value, t), e.value[0]?.resume();
    }
  };
}
function arrayRemove(e, t) {
  const n = [...e], a = n.indexOf(t);
  return a !== -1 && n.splice(a, 1), n;
}
function removeLinks(e) {
  return e.filter((t) => t.tagName !== "A");
}
const AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", EVENT_OPTIONS$1 = { bubbles: !1, cancelable: !0 };
function focusFirst$1(e, { select: t = !1 } = {}) {
  const n = getActiveElement();
  for (const a of e)
    if (focus(a, { select: t }), getActiveElement() !== n)
      return !0;
}
function getTabbableEdges(e) {
  const t = getTabbableCandidates(e), n = findVisible(t, e), a = findVisible(t.reverse(), e);
  return [n, a];
}
function getTabbableCandidates(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (a) => {
      const o = a.tagName === "INPUT" && a.type === "hidden";
      return a.disabled || a.hidden || o ? NodeFilter.FILTER_SKIP : a.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function findVisible(e, t) {
  for (const n of e)
    if (!isHidden(n, { upTo: t }))
      return n;
}
function isHidden(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden")
    return !0;
  for (; e; ) {
    if (t !== void 0 && e === t)
      return !1;
    if (getComputedStyle(e).display === "none")
      return !0;
    e = e.parentElement;
  }
  return !1;
}
function isSelectableInput(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function focus(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = getActiveElement();
    e.focus({ preventScroll: !0 }), e !== n && isSelectableInput(e) && t && e.select();
  }
}
const _sfc_main$4r = /* @__PURE__ */ defineComponent({
  __name: "FocusScope",
  props: {
    loop: { type: Boolean, default: !1 },
    trapped: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["mountAutoFocus", "unmountAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, { currentRef: o, currentElement: s } = useForwardExpose(), u = ref(null), d = createFocusScopesStack(), f = reactive({
      paused: !1,
      pause() {
        this.paused = !0;
      },
      resume() {
        this.paused = !1;
      }
    });
    watchEffect((v) => {
      if (!isClient)
        return;
      const b = s.value;
      if (!n.trapped)
        return;
      function w(A) {
        if (f.paused || !b)
          return;
        const P = A.target;
        b.contains(P) ? u.value = P : focus(u.value, { select: !0 });
      }
      function C(A) {
        if (f.paused || !b)
          return;
        const P = A.relatedTarget;
        P !== null && (b.contains(P) || focus(u.value, { select: !0 }));
      }
      function k(A) {
        b.contains(u.value) || focus(b);
      }
      document.addEventListener("focusin", w), document.addEventListener("focusout", C);
      const E = new MutationObserver(k);
      b && E.observe(b, { childList: !0, subtree: !0 }), v(() => {
        document.removeEventListener("focusin", w), document.removeEventListener("focusout", C), E.disconnect();
      });
    }), watchEffect(async (v) => {
      const b = s.value;
      if (await nextTick(), !b)
        return;
      d.add(f);
      const w = getActiveElement();
      if (!b.contains(w)) {
        const k = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        b.addEventListener(AUTOFOCUS_ON_MOUNT, (E) => a("mountAutoFocus", E)), b.dispatchEvent(k), k.defaultPrevented || (focusFirst$1(removeLinks(getTabbableCandidates(b)), {
          select: !0
        }), getActiveElement() === w && focus(b));
      }
      v(() => {
        b.removeEventListener(AUTOFOCUS_ON_MOUNT, (A) => a("mountAutoFocus", A));
        const k = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1), E = (A) => {
          a("unmountAutoFocus", A);
        };
        b.addEventListener(AUTOFOCUS_ON_UNMOUNT, E), b.dispatchEvent(k), setTimeout(() => {
          k.defaultPrevented || focus(w ?? document.body, { select: !0 }), b.removeEventListener(AUTOFOCUS_ON_UNMOUNT, E), d.remove(f);
        }, 0);
      });
    });
    function g(v) {
      if (!n.loop && !n.trapped || f.paused)
        return;
      const b = v.key === "Tab" && !v.altKey && !v.ctrlKey && !v.metaKey, w = getActiveElement();
      if (b && w) {
        const C = v.currentTarget, [k, E] = getTabbableEdges(C);
        k && E ? !v.shiftKey && w === E ? (v.preventDefault(), n.loop && focus(k, { select: !0 })) : v.shiftKey && w === k && (v.preventDefault(), n.loop && focus(E, { select: !0 })) : w === C && v.preventDefault();
      }
    }
    return (v, b) => (openBlock(), createBlock(unref(Primitive), {
      ref_key: "currentRef",
      ref: o,
      tabindex: "-1",
      "as-child": v.asChild,
      as: v.as,
      onKeydown: g
    }, {
      default: withCtx(() => [
        renderSlot(v.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as"]));
  }
});
function handleAndDispatchCustomEvent(e, t, n) {
  const a = n.originalEvent.target, o = new CustomEvent(e, {
    bubbles: !1,
    cancelable: !0,
    detail: n
  });
  t && a.addEventListener(e, t, { once: !0 }), a.dispatchEvent(o);
}
const POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
function isLayerExist(e, t) {
  const n = t.closest(
    "[data-dismissable-layer]"
  ), a = e.dataset.dismissableLayer === "" ? e : e.querySelector(
    "[data-dismissable-layer]"
  ), o = Array.from(
    e.ownerDocument.querySelectorAll("[data-dismissable-layer]")
  );
  return !!(n && (a === n || o.indexOf(a) < o.indexOf(n)));
}
function usePointerDownOutside(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, o = ref(!1), s = ref(() => {
  });
  return watchEffect((u) => {
    if (!isClient || !toValue$3(n))
      return;
    const d = async (g) => {
      const v = g.target;
      if (!(!t?.value || !v)) {
        if (isLayerExist(t.value, v)) {
          o.value = !1;
          return;
        }
        if (g.target && !o.value) {
          let b = function() {
            handleAndDispatchCustomEvent(
              POINTER_DOWN_OUTSIDE,
              e,
              w
            );
          };
          const w = { originalEvent: g };
          g.pointerType === "touch" ? (a.removeEventListener("click", s.value), s.value = b, a.addEventListener("click", s.value, {
            once: !0
          })) : b();
        } else
          a.removeEventListener("click", s.value);
        o.value = !1;
      }
    }, f = window.setTimeout(() => {
      a.addEventListener("pointerdown", d);
    }, 0);
    u(() => {
      window.clearTimeout(f), a.removeEventListener("pointerdown", d), a.removeEventListener("click", s.value);
    });
  }), {
    onPointerDownCapture: () => {
      toValue$3(n) && (o.value = !0);
    }
  };
}
function useFocusOutside(e, t, n = !0) {
  const a = t?.value?.ownerDocument ?? globalThis?.document, o = ref(!1);
  return watchEffect((s) => {
    if (!isClient || !toValue$3(n))
      return;
    const u = async (d) => {
      if (!t?.value)
        return;
      await nextTick(), await nextTick();
      const f = d.target;
      !t.value || !f || isLayerExist(t.value, f) || d.target && !o.value && handleAndDispatchCustomEvent(
        FOCUS_OUTSIDE,
        e,
        { originalEvent: d }
      );
    };
    a.addEventListener("focusin", u), s(() => a.removeEventListener("focusin", u));
  }), {
    onFocusCapture: () => {
      toValue$3(n) && (o.value = !0);
    },
    onBlurCapture: () => {
      toValue$3(n) && (o.value = !1);
    }
  };
}
const context = reactive({
  layersRoot: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), _sfc_main$4q = /* @__PURE__ */ defineComponent({
  __name: "DismissableLayer",
  props: {
    disableOutsidePointerEvents: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = computed(
      () => s.value?.ownerDocument ?? globalThis.document
    ), d = computed(() => context.layersRoot), f = computed(() => s.value ? Array.from(d.value).indexOf(s.value) : -1), g = computed(() => context.layersWithOutsidePointerEventsDisabled.size > 0), v = computed(() => {
      const k = Array.from(d.value), [E] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1), A = k.indexOf(E);
      return f.value >= A;
    }), b = usePointerDownOutside(async (k) => {
      const E = [...context.branches].some(
        (A) => A?.contains(k.target)
      );
      !v.value || E || (a("pointerDownOutside", k), a("interactOutside", k), await nextTick(), k.defaultPrevented || a("dismiss"));
    }, s), w = useFocusOutside((k) => {
      [...context.branches].some(
        (A) => A?.contains(k.target)
      ) || (a("focusOutside", k), a("interactOutside", k), k.defaultPrevented || a("dismiss"));
    }, s);
    onKeyStroke("Escape", (k) => {
      f.value === d.value.size - 1 && (a("escapeKeyDown", k), k.defaultPrevented || a("dismiss"));
    });
    let C;
    return watchEffect((k) => {
      s.value && (n.disableOutsidePointerEvents && (context.layersWithOutsidePointerEventsDisabled.size === 0 && (C = u.value.body.style.pointerEvents, u.value.body.style.pointerEvents = "none"), context.layersWithOutsidePointerEventsDisabled.add(s.value)), d.value.add(s.value), k(() => {
        n.disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1 && (u.value.body.style.pointerEvents = C);
      }));
    }), watchEffect((k) => {
      k(() => {
        s.value && (d.value.delete(s.value), context.layersWithOutsidePointerEventsDisabled.delete(s.value));
      });
    }), (k, E) => (openBlock(), createBlock(unref(Primitive), {
      ref: unref(o),
      "as-child": k.asChild,
      as: k.as,
      "data-dismissable-layer": "",
      style: normalizeStyle({
        pointerEvents: g.value ? v.value ? "auto" : "none" : void 0
      }),
      onFocusCapture: unref(w).onFocusCapture,
      onBlurCapture: unref(w).onBlurCapture,
      onPointerdownCapture: unref(b).onPointerDownCapture
    }, {
      default: withCtx(() => [
        renderSlot(k.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), _sfc_main$4p = /* @__PURE__ */ defineComponent({
  __name: "DialogContentImpl",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectDialogRootContext(), { forwardRef: s, currentElement: u } = useForwardExpose();
    return o.titleId ||= useId(void 0, "reka-dialog-title"), o.descriptionId ||= useId(void 0, "reka-dialog-description"), onMounted(() => {
      o.contentElement = u, getActiveElement() !== document.body && (o.triggerElement.value = getActiveElement());
    }), process.env.NODE_ENV !== "production" && useWarning({
      titleName: "DialogTitle",
      contentName: "DialogContent",
      componentLink: "dialog.html#title",
      titleId: o.titleId,
      descriptionId: o.descriptionId,
      contentElement: u
    }), (d, f) => (openBlock(), createBlock(unref(_sfc_main$4r), {
      "as-child": "",
      loop: "",
      trapped: n.trapFocus,
      onMountAutoFocus: f[5] || (f[5] = (g) => a("openAutoFocus", g)),
      onUnmountAutoFocus: f[6] || (f[6] = (g) => a("closeAutoFocus", g))
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$4q), mergeProps({
          id: unref(o).contentId,
          ref: unref(s),
          as: d.as,
          "as-child": d.asChild,
          "disable-outside-pointer-events": d.disableOutsidePointerEvents,
          role: "dialog",
          "aria-describedby": unref(o).descriptionId,
          "aria-labelledby": unref(o).titleId,
          "data-state": unref(getOpenState)(unref(o).open.value)
        }, d.$attrs, {
          onDismiss: f[0] || (f[0] = (g) => unref(o).onOpenChange(!1)),
          onEscapeKeyDown: f[1] || (f[1] = (g) => a("escapeKeyDown", g)),
          onFocusOutside: f[2] || (f[2] = (g) => a("focusOutside", g)),
          onInteractOutside: f[3] || (f[3] = (g) => a("interactOutside", g)),
          onPointerDownOutside: f[4] || (f[4] = (g) => a("pointerDownOutside", g))
        }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "as", "as-child", "disable-outside-pointer-events", "aria-describedby", "aria-labelledby", "data-state"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
});
var getDefaultParent = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {}, lockCount = 0, unwrapHost = function(e) {
  return e && (e.host || unwrapHost(e.parentNode));
}, correctTargets = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var a = unwrapHost(n);
    return a && e.contains(a) ? a : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, applyAttributeToOthers = function(e, t, n, a) {
  var o = correctTargets(t, Array.isArray(e) ? e : [e]);
  markerMap[n] || (markerMap[n] = /* @__PURE__ */ new WeakMap());
  var s = markerMap[n], u = [], d = /* @__PURE__ */ new Set(), f = new Set(o), g = function(b) {
    !b || d.has(b) || (d.add(b), g(b.parentNode));
  };
  o.forEach(g);
  var v = function(b) {
    !b || f.has(b) || Array.prototype.forEach.call(b.children, function(w) {
      if (d.has(w))
        v(w);
      else
        try {
          var C = w.getAttribute(a), k = C !== null && C !== "false", E = (counterMap.get(w) || 0) + 1, A = (s.get(w) || 0) + 1;
          counterMap.set(w, E), s.set(w, A), u.push(w), E === 1 && k && uncontrolledNodes.set(w, !0), A === 1 && w.setAttribute(n, "true"), k || w.setAttribute(a, "true");
        } catch (P) {
          console.error("aria-hidden: cannot operate on ", w, P);
        }
    });
  };
  return v(t), d.clear(), lockCount++, function() {
    u.forEach(function(b) {
      var w = counterMap.get(b) - 1, C = s.get(b) - 1;
      counterMap.set(b, w), s.set(b, C), w || (uncontrolledNodes.has(b) || b.removeAttribute(a), uncontrolledNodes.delete(b)), C || b.removeAttribute(n);
    }), lockCount--, lockCount || (counterMap = /* @__PURE__ */ new WeakMap(), counterMap = /* @__PURE__ */ new WeakMap(), uncontrolledNodes = /* @__PURE__ */ new WeakMap(), markerMap = {});
  };
}, hideOthers = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var a = Array.from(Array.isArray(e) ? e : [e]), o = getDefaultParent(e);
  return o ? (a.push.apply(a, Array.from(o.querySelectorAll("[aria-live], script"))), applyAttributeToOthers(a, o, n, "aria-hidden")) : function() {
    return null;
  };
};
function useHideOthers(e) {
  let t;
  watch(() => unrefElement(e), (n) => {
    n ? t = hideOthers(n) : t && t();
  }), onUnmounted(() => {
    t && t();
  });
}
const _sfc_main$4o = /* @__PURE__ */ defineComponent({
  __name: "DialogContentModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectDialogRootContext(), s = useEmitAsProps(a), { forwardRef: u, currentElement: d } = useForwardExpose();
    return useHideOthers(d), (f, g) => (openBlock(), createBlock(_sfc_main$4p, mergeProps({ ...n, ...unref(s) }, {
      ref: unref(u),
      "trap-focus": unref(o).open.value,
      "disable-outside-pointer-events": !0,
      onCloseAutoFocus: g[0] || (g[0] = (v) => {
        v.defaultPrevented || (v.preventDefault(), unref(o).triggerElement.value?.focus());
      }),
      onPointerDownOutside: g[1] || (g[1] = (v) => {
        const b = v.detail.originalEvent, w = b.button === 0 && b.ctrlKey === !0;
        (b.button === 2 || w) && v.preventDefault();
      }),
      onFocusOutside: g[2] || (g[2] = (v) => {
        v.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), _sfc_main$4n = /* @__PURE__ */ defineComponent({
  __name: "DialogContentNonModal",
  props: {
    forceMount: { type: Boolean },
    trapFocus: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, o = useEmitAsProps(t);
    useForwardExpose();
    const s = injectDialogRootContext(), u = ref(!1), d = ref(!1);
    return (f, g) => (openBlock(), createBlock(_sfc_main$4p, mergeProps({ ...n, ...unref(o) }, {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: g[0] || (g[0] = (v) => {
        v.defaultPrevented || (u.value || unref(s).triggerElement.value?.focus(), v.preventDefault()), u.value = !1, d.value = !1;
      }),
      onInteractOutside: g[1] || (g[1] = (v) => {
        v.defaultPrevented || (u.value = !0, v.detail.originalEvent.type === "pointerdown" && (d.value = !0));
        const b = v.target;
        unref(s).triggerElement.value?.contains(b) && v.preventDefault(), v.detail.originalEvent.type === "focusin" && d.value && v.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$4m = /* @__PURE__ */ defineComponent({
  __name: "DialogContent",
  props: {
    forceMount: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectDialogRootContext(), s = useEmitAsProps(a), { forwardRef: u } = useForwardExpose();
    return (d, f) => (openBlock(), createBlock(unref(Presence), {
      present: d.forceMount || unref(o).open.value
    }, {
      default: withCtx(() => [
        unref(o).modal.value ? (openBlock(), createBlock(_sfc_main$4o, mergeProps({
          key: 0,
          ref: unref(u)
        }, { ...n, ...unref(s), ...d.$attrs }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(_sfc_main$4n, mergeProps({
          key: 1,
          ref: unref(u)
        }, { ...n, ...unref(s), ...d.$attrs }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
function isPlainObject$1(e) {
  if (e === null || typeof e != "object")
    return !1;
  const t = Object.getPrototypeOf(e);
  return t !== null && t !== Object.prototype && Object.getPrototypeOf(t) !== null || Symbol.iterator in e ? !1 : Symbol.toStringTag in e ? Object.prototype.toString.call(e) === "[object Module]" : !0;
}
function _defu(e, t, n = ".", a) {
  if (!isPlainObject$1(t))
    return _defu(e, {}, n, a);
  const o = Object.assign({}, t);
  for (const s in e) {
    if (s === "__proto__" || s === "constructor")
      continue;
    const u = e[s];
    u != null && (a && a(o, s, u, n) || (Array.isArray(u) && Array.isArray(o[s]) ? o[s] = [...u, ...o[s]] : isPlainObject$1(u) && isPlainObject$1(o[s]) ? o[s] = _defu(
      u,
      o[s],
      (n ? `${n}.` : "") + s.toString(),
      a
    ) : o[s] = u));
  }
  return o;
}
function createDefu(e) {
  return (...t) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    t.reduce((n, a) => _defu(n, a, "", e), {})
  );
}
const defu = createDefu(), useBodyLockStackCount = createSharedComposable(() => {
  const e = ref(/* @__PURE__ */ new Map()), t = ref(), n = computed(() => {
    for (const u of e.value.values())
      if (u)
        return !0;
    return !1;
  }), a = injectConfigProviderContext({
    scrollBody: ref(!0)
  });
  let o = null;
  const s = () => {
    document.body.style.paddingRight = "", document.body.style.marginRight = "", document.body.style.pointerEvents = "", document.documentElement.style.removeProperty("--scrollbar-width"), document.body.style.overflow = t.value ?? "", isIOS && o?.(), t.value = void 0;
  };
  return watch(n, (u, d) => {
    if (!isClient)
      return;
    if (!u) {
      d && s();
      return;
    }
    t.value === void 0 && (t.value = document.body.style.overflow);
    const f = window.innerWidth - document.documentElement.clientWidth, g = { padding: f, margin: 0 }, v = a.scrollBody?.value ? typeof a.scrollBody.value == "object" ? defu({
      padding: a.scrollBody.value.padding === !0 ? f : a.scrollBody.value.padding,
      margin: a.scrollBody.value.margin === !0 ? f : a.scrollBody.value.margin
    }, g) : g : { padding: 0, margin: 0 };
    f > 0 && (document.body.style.paddingRight = typeof v.padding == "number" ? `${v.padding}px` : String(v.padding), document.body.style.marginRight = typeof v.margin == "number" ? `${v.margin}px` : String(v.margin), document.documentElement.style.setProperty("--scrollbar-width", `${f}px`), document.body.style.overflow = "hidden"), isIOS && (o = useEventListener(
      document,
      "touchmove",
      (b) => preventDefault(b),
      { passive: !1 }
    )), nextTick(() => {
      document.body.style.pointerEvents = "none", document.body.style.overflow = "hidden";
    });
  }, { immediate: !0, flush: "sync" }), e;
});
function useBodyScrollLock(e) {
  const t = Math.random().toString(36).substring(2, 7), n = useBodyLockStackCount();
  n.value.set(t, e ?? !1);
  const a = computed({
    get: () => n.value.get(t) ?? !1,
    set: (o) => n.value.set(t, o)
  });
  return tryOnBeforeUnmount(() => {
    n.value.delete(t);
  }), a;
}
function checkOverflowScroll(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const n = e.parentNode;
    return !(n instanceof Element) || n.tagName === "BODY" ? !1 : checkOverflowScroll(n);
  }
}
function preventDefault(e) {
  const t = e || window.event, n = t.target;
  return n instanceof Element && checkOverflowScroll(n) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.cancelable && t.preventDefault(), !1);
}
const _sfc_main$4l = /* @__PURE__ */ defineComponent({
  __name: "DialogOverlayImpl",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = injectDialogRootContext();
    return useBodyScrollLock(!0), useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(Primitive), {
      as: n.as,
      "as-child": n.asChild,
      "data-state": unref(t).open.value ? "open" : "closed",
      style: { "pointer-events": "auto" }
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "data-state"]));
  }
}), _sfc_main$4k = /* @__PURE__ */ defineComponent({
  __name: "DialogOverlay",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = injectDialogRootContext(), { forwardRef: n } = useForwardExpose();
    return (a, o) => unref(t)?.modal.value ? (openBlock(), createBlock(unref(Presence), {
      key: 0,
      present: a.forceMount || unref(t).open.value
    }, {
      default: withCtx(() => [
        createVNode(_sfc_main$4l, mergeProps(a.$attrs, {
          ref: unref(n),
          as: a.as,
          "as-child": a.asChild
        }), {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child"])
      ]),
      _: 3
    }, 8, ["present"])) : createCommentVNode("", !0);
  }
}), _sfc_main$4j = /* @__PURE__ */ defineComponent({
  __name: "Teleport",
  props: {
    to: { default: "body" },
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = useMounted();
    return (n, a) => unref(t) || n.forceMount ? (openBlock(), createBlock(Teleport, {
      key: 0,
      to: n.to,
      disabled: n.disabled,
      defer: n.defer
    }, [
      renderSlot(n.$slots, "default")
    ], 8, ["to", "disabled", "defer"])) : createCommentVNode("", !0);
  }
});
function useForwardProps(e) {
  const t = getCurrentInstance(), n = Object.keys(t?.type.props ?? {}).reduce((o, s) => {
    const u = (t?.type.props[s]).default;
    return u !== void 0 && (o[s] = u), o;
  }, {}), a = toRef(e);
  return computed(() => {
    const o = {}, s = t?.vnode.props ?? {};
    return Object.keys(s).forEach((u) => {
      o[camelize(u)] = s[u];
    }), Object.keys({ ...n, ...o }).reduce((u, d) => (a.value[d] !== void 0 && (u[d] = a.value[d]), u), {});
  });
}
function useForwardPropsEmits(e, t) {
  const n = useForwardProps(e), a = t ? useEmitAsProps(t) : {};
  return computed(() => ({
    ...n.value,
    ...a
  }));
}
const _sfc_main$4i = /* @__PURE__ */ defineComponent({
  __name: "DialogTitle",
  props: {
    asChild: { type: Boolean },
    as: { default: "h2" }
  },
  setup(e) {
    const t = e, n = injectDialogRootContext();
    return useForwardExpose(), (a, o) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      id: unref(n).titleId
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["id"]));
  }
}), _sfc_main$4h = /* @__PURE__ */ defineComponent({
  __name: "DialogTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = injectDialogRootContext(), { forwardRef: a, currentElement: o } = useForwardExpose();
    return n.contentId ||= useId(void 0, "reka-dialog-content"), onMounted(() => {
      n.triggerElement.value = o.value;
    }), (s, u) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      ref: unref(a),
      type: s.as === "button" ? "button" : void 0,
      "aria-haspopup": "dialog",
      "aria-expanded": unref(n).open.value || !1,
      "aria-controls": unref(n).open.value ? unref(n).contentId : void 0,
      "data-state": unref(n).open.value ? "open" : "closed",
      onClick: unref(n).onOpenToggle
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "onClick"]));
  }
});
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(e, t) {
  return e - t * Math.floor(e / t);
}
const $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(e, t, n, a) {
  t = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(e, t);
  let o = t - 1, s = -2;
  return n <= 2 ? s = 0 : $3b62074eb05584b2$export$553d7fa8e3805fc0(t) && (s = -1), $3b62074eb05584b2$var$EPOCH - 1 + 365 * o + Math.floor(o / 4) - Math.floor(o / 100) + Math.floor(o / 400) + Math.floor((367 * n - 362) / 12 + s + a);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(e, t) {
  return e === "BC" ? 1 - t : t;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(e) {
  let t = "AD";
  return e <= 0 && (t = "BC", e = 1 - e), [
    t,
    e
  ];
}
const $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
class $3b62074eb05584b2$export$80ee6245ec4f29ec {
  fromJulianDay(t) {
    let n = t, a = n - $3b62074eb05584b2$var$EPOCH, o = Math.floor(a / 146097), s = $2b4dce13dd5a17fa$export$842a2cf37af977e1(a, 146097), u = Math.floor(s / 36524), d = $2b4dce13dd5a17fa$export$842a2cf37af977e1(s, 36524), f = Math.floor(d / 1461), g = $2b4dce13dd5a17fa$export$842a2cf37af977e1(d, 1461), v = Math.floor(g / 365), b = o * 400 + u * 100 + f * 4 + v + (u !== 4 && v !== 4 ? 1 : 0), [w, C] = $3b62074eb05584b2$export$4475b7e617eb123c(b), k = n - $3b62074eb05584b2$export$f297eb839006d339(w, C, 1, 1), E = 2;
    n < $3b62074eb05584b2$export$f297eb839006d339(w, C, 3, 1) ? E = 0 : $3b62074eb05584b2$export$553d7fa8e3805fc0(C) && (E = 1);
    let A = Math.floor(((k + E) * 12 + 373) / 367), P = n - $3b62074eb05584b2$export$f297eb839006d339(w, C, A, 1) + 1;
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(w, C, A, P);
  }
  toJulianDay(t) {
    return $3b62074eb05584b2$export$f297eb839006d339(t.era, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(t.year) ? "leapyear" : "standard"][t.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(t) {
    return 12;
  }
  getDaysInYear(t) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(t.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(t) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(t) {
    return t.era === "BC";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BC" ? "AD" : "BC", t.year = 1 - t.year);
  }
  constructor() {
    this.identifier = "gregory";
  }
}
const $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(e, t) {
  return t = $11d87f3f76e88657$export$b4a036af3fc0b032(t, e.calendar), e.era === t.era && e.year === t.year && e.month === t.month && e.day === t.day;
}
function $14e0f24ef4ac5c92$export$a18c89cbd24170ff(e, t) {
  return t = $11d87f3f76e88657$export$b4a036af3fc0b032(t, e.calendar), e = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(e), t = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(t), e.era === t.era && e.year === t.year && e.month === t.month;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(e, t) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(e.calendar, t.calendar) && $14e0f24ef4ac5c92$export$ea39ec197993aef0(e, t);
}
function $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(e, t) {
  return $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(e.calendar, t.calendar) && $14e0f24ef4ac5c92$export$a18c89cbd24170ff(e, t);
}
function $14e0f24ef4ac5c92$export$dbc69fd56b53d5e(e, t) {
  var n, a, o, s;
  return (s = (o = (n = e.isEqual) === null || n === void 0 ? void 0 : n.call(e, t)) !== null && o !== void 0 ? o : (a = t.isEqual) === null || a === void 0 ? void 0 : a.call(t, e)) !== null && s !== void 0 ? s : e.identifier === t.identifier;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(e, t) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(e, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(t));
}
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(e, t, n) {
  let a = e.calendar.toJulianDay(e), o = $14e0f24ef4ac5c92$var$getWeekStart(t), s = Math.ceil(a + 1 - o) % 7;
  return s < 0 && (s += 7), s;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(e) {
  return $11d87f3f76e88657$export$1b96692a1ba042ac(Date.now(), e);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(e) {
  return $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$461939dd4422153(e));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(e, t) {
  return e.calendar.toJulianDay(e) - t.calendar.toJulianDay(t);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(e, t) {
  return $14e0f24ef4ac5c92$var$timeToMs(e) - $14e0f24ef4ac5c92$var$timeToMs(t);
}
function $14e0f24ef4ac5c92$var$timeToMs(e) {
  return e.hour * 36e5 + e.minute * 6e4 + e.second * 1e3 + e.millisecond;
}
let $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  return $14e0f24ef4ac5c92$var$localTimeZone == null && ($14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone), $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(e) {
  return e.subtract({
    days: e.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(e) {
  return e.add({
    days: e.calendar.getDaysInMonth(e) - e.day
  });
}
const $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(e) {
  if (Intl.Locale) {
    let n = $14e0f24ef4ac5c92$var$cachedRegions.get(e);
    return n || (n = new Intl.Locale(e).maximize().region, n && $14e0f24ef4ac5c92$var$cachedRegions.set(e, n)), n;
  }
  let t = e.split("-")[1];
  return t === "u" ? void 0 : t;
}
function $14e0f24ef4ac5c92$var$getWeekStart(e) {
  let t = $14e0f24ef4ac5c92$var$getRegion(e);
  return t && $2fe286d2fb449abb$export$7a5acbd77d414bd9[t] || 0;
}
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(e) {
  e = $11d87f3f76e88657$export$b4a036af3fc0b032(e, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
  let t = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(e.era, e.year);
  return $11d87f3f76e88657$var$epochFromParts(t, e.month, e.day, e.hour, e.minute, e.second, e.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(e, t, n, a, o, s, u) {
  let d = /* @__PURE__ */ new Date();
  return d.setUTCHours(a, o, s, u), d.setUTCFullYear(e, t - 1, n), d.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(e, t) {
  if (t === "UTC") return 0;
  if (e > 0 && t === $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) return new Date(e).getTimezoneOffset() * -6e4;
  let { year: n, month: a, day: o, hour: s, minute: u, second: d } = $11d87f3f76e88657$var$getTimeZoneParts(e, t);
  return $11d87f3f76e88657$var$epochFromParts(n, a, o, s, u, d, 0) - Math.floor(e / 1e3) * 1e3;
}
const $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(e, t) {
  let n = $11d87f3f76e88657$var$formattersByTimeZone.get(t);
  n || (n = new Intl.DateTimeFormat("en-US", {
    timeZone: t,
    hour12: !1,
    era: "short",
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  }), $11d87f3f76e88657$var$formattersByTimeZone.set(t, n));
  let a = n.formatToParts(new Date(e)), o = {};
  for (let s of a) s.type !== "literal" && (o[s.type] = s.value);
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: o.era === "BC" || o.era === "B" ? -o.year + 1 : +o.year,
    month: +o.month,
    day: +o.day,
    hour: o.hour === "24" ? 0 : +o.hour,
    minute: +o.minute,
    second: +o.second
  };
}
const $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(e, t, n, a) {
  return (n === a ? [
    n
  ] : [
    n,
    a
  ]).filter((s) => $11d87f3f76e88657$var$isValidWallTime(e, t, s));
}
function $11d87f3f76e88657$var$isValidWallTime(e, t, n) {
  let a = $11d87f3f76e88657$var$getTimeZoneParts(n, t);
  return e.year === a.year && e.month === a.month && e.day === a.day && e.hour === a.hour && e.minute === a.minute && e.second === a.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(e, t, n = "compatible") {
  let a = $11d87f3f76e88657$export$b21e0b124e224484(e);
  if (t === "UTC") return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(a);
  if (t === $14e0f24ef4ac5c92$export$aa8b41735afcabd2() && n === "compatible") {
    a = $11d87f3f76e88657$export$b4a036af3fc0b032(a, new $3b62074eb05584b2$export$80ee6245ec4f29ec());
    let f = /* @__PURE__ */ new Date(), g = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(a.era, a.year);
    return f.setFullYear(g, a.month - 1, a.day), f.setHours(a.hour, a.minute, a.second, a.millisecond), f.getTime();
  }
  let o = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(a), s = $11d87f3f76e88657$export$59c99f3515d3493f(o - $11d87f3f76e88657$var$DAYMILLIS, t), u = $11d87f3f76e88657$export$59c99f3515d3493f(o + $11d87f3f76e88657$var$DAYMILLIS, t), d = $11d87f3f76e88657$var$getValidWallTimes(a, t, o - s, o - u);
  if (d.length === 1) return d[0];
  if (d.length > 1) switch (n) {
    // 'compatible' means 'earlier' for "fall back" transitions
    case "compatible":
    case "earlier":
      return d[0];
    case "later":
      return d[d.length - 1];
    case "reject":
      throw new RangeError("Multiple possible absolute times found");
  }
  switch (n) {
    case "earlier":
      return Math.min(o - s, o - u);
    // 'compatible' means 'later' for "spring forward" transitions
    case "compatible":
    case "later":
      return Math.max(o - s, o - u);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(e, t, n = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(e, t, n));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(e, t) {
  let n = $11d87f3f76e88657$export$59c99f3515d3493f(e, t), a = new Date(e + n), o = a.getUTCFullYear(), s = a.getUTCMonth() + 1, u = a.getUTCDate(), d = a.getUTCHours(), f = a.getUTCMinutes(), g = a.getUTCSeconds(), v = a.getUTCMilliseconds();
  return new $35ea8db9cb2ccb90$export$d3b7288e7994edea(o < 1 ? "BC" : "AD", o < 1 ? -o + 1 : o, s, u, t, n, d, f, g, v);
}
function $11d87f3f76e88657$export$93522d1a439f3617(e) {
  return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(e.calendar, e.era, e.year, e.month, e.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(e, t) {
  let n = 0, a = 0, o = 0, s = 0;
  if ("timeZone" in e) ({ hour: n, minute: a, second: o, millisecond: s } = e);
  else if ("hour" in e && !t) return e;
  return t && ({ hour: n, minute: a, second: o, millisecond: s } = t), new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(e.calendar, e.era, e.year, e.month, e.day, n, a, o, s);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(e, t) {
  if ($14e0f24ef4ac5c92$export$dbc69fd56b53d5e(e.calendar, t)) return e;
  let n = t.fromJulianDay(e.calendar.toJulianDay(e)), a = e.copy();
  return a.calendar = t, a.era = n.era, a.year = n.year, a.month = n.month, a.day = n.day, $735220c2d4774dd3$export$c4e2ecac49351ef2(a), a;
}
function $11d87f3f76e88657$export$84c95a83c799e074(e, t, n) {
  if (e instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea)
    return e.timeZone === t ? e : $11d87f3f76e88657$export$538b00033cc11c75(e, t);
  let a = $11d87f3f76e88657$export$5107c82f94518f5c(e, t, n);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(a, t);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(e) {
  let t = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(e) - e.offset;
  return new Date(t);
}
function $11d87f3f76e88657$export$538b00033cc11c75(e, t) {
  let n = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(e) - e.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(n, t), e.calendar);
}
const $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(e, t) {
  let n = e.copy(), a = "hour" in n ? $735220c2d4774dd3$var$addTimeFields(n, t) : 0;
  $735220c2d4774dd3$var$addYears(n, t.years || 0), n.calendar.balanceYearMonth && n.calendar.balanceYearMonth(n, e), n.month += t.months || 0, $735220c2d4774dd3$var$balanceYearMonth(n), $735220c2d4774dd3$var$constrainMonthDay(n), n.day += (t.weeks || 0) * 7, n.day += t.days || 0, n.day += a, $735220c2d4774dd3$var$balanceDay(n), n.calendar.balanceDate && n.calendar.balanceDate(n), n.year < 1 && (n.year = 1, n.month = 1, n.day = 1);
  let o = n.calendar.getYearsInEra(n);
  if (n.year > o) {
    var s, u;
    let f = (s = (u = n.calendar).isInverseEra) === null || s === void 0 ? void 0 : s.call(u, n);
    n.year = o, n.month = f ? 1 : n.calendar.getMonthsInYear(n), n.day = f ? 1 : n.calendar.getDaysInMonth(n);
  }
  n.month < 1 && (n.month = 1, n.day = 1);
  let d = n.calendar.getMonthsInYear(n);
  return n.month > d && (n.month = d, n.day = n.calendar.getDaysInMonth(n)), n.day = Math.max(1, Math.min(n.calendar.getDaysInMonth(n), n.day)), n;
}
function $735220c2d4774dd3$var$addYears(e, t) {
  var n, a;
  !((n = (a = e.calendar).isInverseEra) === null || n === void 0) && n.call(a, e) && (t = -t), e.year += t;
}
function $735220c2d4774dd3$var$balanceYearMonth(e) {
  for (; e.month < 1; )
    $735220c2d4774dd3$var$addYears(e, -1), e.month += e.calendar.getMonthsInYear(e);
  let t = 0;
  for (; e.month > (t = e.calendar.getMonthsInYear(e)); )
    e.month -= t, $735220c2d4774dd3$var$addYears(e, 1);
}
function $735220c2d4774dd3$var$balanceDay(e) {
  for (; e.day < 1; )
    e.month--, $735220c2d4774dd3$var$balanceYearMonth(e), e.day += e.calendar.getDaysInMonth(e);
  for (; e.day > e.calendar.getDaysInMonth(e); )
    e.day -= e.calendar.getDaysInMonth(e), e.month++, $735220c2d4774dd3$var$balanceYearMonth(e);
}
function $735220c2d4774dd3$var$constrainMonthDay(e) {
  e.month = Math.max(1, Math.min(e.calendar.getMonthsInYear(e), e.month)), e.day = Math.max(1, Math.min(e.calendar.getDaysInMonth(e), e.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(e) {
  e.calendar.constrainDate && e.calendar.constrainDate(e), e.year = Math.max(1, Math.min(e.calendar.getYearsInEra(e), e.year)), $735220c2d4774dd3$var$constrainMonthDay(e);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(e) {
  let t = {};
  for (let n in e) typeof e[n] == "number" && (t[n] = -e[n]);
  return t;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(e, t) {
  return $735220c2d4774dd3$export$e16d8520af44a096(e, $735220c2d4774dd3$export$3e2544e88a25bff8(t));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(e, t) {
  let n = e.copy();
  return t.era != null && (n.era = t.era), t.year != null && (n.year = t.year), t.month != null && (n.month = t.month), t.day != null && (n.day = t.day), $735220c2d4774dd3$export$c4e2ecac49351ef2(n), n;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(e, t) {
  let n = e.copy();
  return t.hour != null && (n.hour = t.hour), t.minute != null && (n.minute = t.minute), t.second != null && (n.second = t.second), t.millisecond != null && (n.millisecond = t.millisecond), $735220c2d4774dd3$export$7555de1e070510cb(n), n;
}
function $735220c2d4774dd3$var$balanceTime(e) {
  e.second += Math.floor(e.millisecond / 1e3), e.millisecond = $735220c2d4774dd3$var$nonNegativeMod(e.millisecond, 1e3), e.minute += Math.floor(e.second / 60), e.second = $735220c2d4774dd3$var$nonNegativeMod(e.second, 60), e.hour += Math.floor(e.minute / 60), e.minute = $735220c2d4774dd3$var$nonNegativeMod(e.minute, 60);
  let t = Math.floor(e.hour / 24);
  return e.hour = $735220c2d4774dd3$var$nonNegativeMod(e.hour, 24), t;
}
function $735220c2d4774dd3$export$7555de1e070510cb(e) {
  e.millisecond = Math.max(0, Math.min(e.millisecond, 1e3)), e.second = Math.max(0, Math.min(e.second, 59)), e.minute = Math.max(0, Math.min(e.minute, 59)), e.hour = Math.max(0, Math.min(e.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(e, t) {
  let n = e % t;
  return n < 0 && (n += t), n;
}
function $735220c2d4774dd3$var$addTimeFields(e, t) {
  return e.hour += t.hours || 0, e.minute += t.minutes || 0, e.second += t.seconds || 0, e.millisecond += t.milliseconds || 0, $735220c2d4774dd3$var$balanceTime(e);
}
function $735220c2d4774dd3$export$7ed87b6bc2506470(e, t) {
  let n = e.copy();
  return $735220c2d4774dd3$var$addTimeFields(n, t), n;
}
function $735220c2d4774dd3$export$fe34d3a381cd7501(e, t) {
  return $735220c2d4774dd3$export$7ed87b6bc2506470(e, $735220c2d4774dd3$export$3e2544e88a25bff8(t));
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(e, t, n, a) {
  let o = e.copy();
  switch (t) {
    case "era": {
      let d = e.calendar.getEras(), f = d.indexOf(e.era);
      if (f < 0) throw new Error("Invalid era: " + e.era);
      f = $735220c2d4774dd3$var$cycleValue(f, n, 0, d.length - 1, a?.round), o.era = d[f], $735220c2d4774dd3$export$c4e2ecac49351ef2(o);
      break;
    }
    case "year":
      var s, u;
      !((s = (u = o.calendar).isInverseEra) === null || s === void 0) && s.call(u, o) && (n = -n), o.year = $735220c2d4774dd3$var$cycleValue(e.year, n, -1 / 0, 9999, a?.round), o.year === -1 / 0 && (o.year = 1), o.calendar.balanceYearMonth && o.calendar.balanceYearMonth(o, e);
      break;
    case "month":
      o.month = $735220c2d4774dd3$var$cycleValue(e.month, n, 1, e.calendar.getMonthsInYear(e), a?.round);
      break;
    case "day":
      o.day = $735220c2d4774dd3$var$cycleValue(e.day, n, 1, e.calendar.getDaysInMonth(e), a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return e.calendar.balanceDate && e.calendar.balanceDate(o), $735220c2d4774dd3$export$c4e2ecac49351ef2(o), o;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(e, t, n, a) {
  let o = e.copy();
  switch (t) {
    case "hour": {
      let s = e.hour, u = 0, d = 23;
      if (a?.hourCycle === 12) {
        let f = s >= 12;
        u = f ? 12 : 0, d = f ? 23 : 11;
      }
      o.hour = $735220c2d4774dd3$var$cycleValue(s, n, u, d, a?.round);
      break;
    }
    case "minute":
      o.minute = $735220c2d4774dd3$var$cycleValue(e.minute, n, 0, 59, a?.round);
      break;
    case "second":
      o.second = $735220c2d4774dd3$var$cycleValue(e.second, n, 0, 59, a?.round);
      break;
    case "millisecond":
      o.millisecond = $735220c2d4774dd3$var$cycleValue(e.millisecond, n, 0, 999, a?.round);
      break;
    default:
      throw new Error("Unsupported field " + t);
  }
  return o;
}
function $735220c2d4774dd3$var$cycleValue(e, t, n, a, o = !1) {
  if (o) {
    e += Math.sign(t), e < n && (e = a);
    let s = Math.abs(t);
    t > 0 ? e = Math.ceil(e / s) * s : e = Math.floor(e / s) * s, e > a && (e = n);
  } else
    e += t, e < n ? e = a - (n - e - 1) : e > a && (e = n + (e - a - 1));
  return e;
}
function $735220c2d4774dd3$export$96b1d28349274637(e, t) {
  let n;
  if (t.years != null && t.years !== 0 || t.months != null && t.months !== 0 || t.weeks != null && t.weeks !== 0 || t.days != null && t.days !== 0) {
    let o = $735220c2d4774dd3$export$e16d8520af44a096($11d87f3f76e88657$export$b21e0b124e224484(e), {
      years: t.years,
      months: t.months,
      weeks: t.weeks,
      days: t.days
    });
    n = $11d87f3f76e88657$export$5107c82f94518f5c(o, e.timeZone);
  } else
    n = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(e) - e.offset;
  n += t.milliseconds || 0, n += (t.seconds || 0) * 1e3, n += (t.minutes || 0) * 6e4, n += (t.hours || 0) * 36e5;
  let a = $11d87f3f76e88657$export$1b96692a1ba042ac(n, e.timeZone);
  return $11d87f3f76e88657$export$b4a036af3fc0b032(a, e.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(e, t) {
  return $735220c2d4774dd3$export$96b1d28349274637(e, $735220c2d4774dd3$export$3e2544e88a25bff8(t));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(e, t, n, a) {
  switch (t) {
    case "hour": {
      let o = 0, s = 23;
      if (a?.hourCycle === 12) {
        let k = e.hour >= 12;
        o = k ? 12 : 0, s = k ? 23 : 11;
      }
      let u = $11d87f3f76e88657$export$b21e0b124e224484(e), d = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(u, {
        hour: o
      }), new $3b62074eb05584b2$export$80ee6245ec4f29ec()), f = [
        $11d87f3f76e88657$export$5107c82f94518f5c(d, e.timeZone, "earlier"),
        $11d87f3f76e88657$export$5107c82f94518f5c(d, e.timeZone, "later")
      ].filter((k) => $11d87f3f76e88657$export$1b96692a1ba042ac(k, e.timeZone).day === d.day)[0], g = $11d87f3f76e88657$export$b4a036af3fc0b032($735220c2d4774dd3$export$e5d5e1c1822b6e56(u, {
        hour: s
      }), new $3b62074eb05584b2$export$80ee6245ec4f29ec()), v = [
        $11d87f3f76e88657$export$5107c82f94518f5c(g, e.timeZone, "earlier"),
        $11d87f3f76e88657$export$5107c82f94518f5c(g, e.timeZone, "later")
      ].filter((k) => $11d87f3f76e88657$export$1b96692a1ba042ac(k, e.timeZone).day === g.day).pop(), b = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(e) - e.offset, w = Math.floor(b / $735220c2d4774dd3$var$ONE_HOUR), C = b % $735220c2d4774dd3$var$ONE_HOUR;
      return b = $735220c2d4774dd3$var$cycleValue(w, n, Math.floor(f / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(v / $735220c2d4774dd3$var$ONE_HOUR), a?.round) * $735220c2d4774dd3$var$ONE_HOUR + C, $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(b, e.timeZone), e.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(e, t, n, a);
    case "era":
    case "year":
    case "month":
    case "day": {
      let o = $735220c2d4774dd3$export$d52ced6badfb9a4c($11d87f3f76e88657$export$b21e0b124e224484(e), t, n, a), s = $11d87f3f76e88657$export$5107c82f94518f5c(o, e.timeZone);
      return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(s, e.timeZone), e.calendar);
    }
    default:
      throw new Error("Unsupported field " + t);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(e, t, n) {
  let a = $11d87f3f76e88657$export$b21e0b124e224484(e), o = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(a, t), t);
  if (o.compare(a) === 0) return e;
  let s = $11d87f3f76e88657$export$5107c82f94518f5c(o, e.timeZone, n);
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(s, e.timeZone), e.calendar);
}
const $fae977aafc393c5c$var$ABSOLUTE_RE = /^([+-]\d{6}|\d{4})-(\d{2})-(\d{2})(?:T(\d{2}))?(?::(\d{2}))?(?::(\d{2}))?(\.\d+)?(?:(?:([+-]\d{2})(?::?(\d{2}))?)|Z)$/;
function $fae977aafc393c5c$export$5adfdab05168c219(e, t) {
  let n = e.match($fae977aafc393c5c$var$ABSOLUTE_RE);
  if (!n) throw new Error("Invalid ISO 8601 date time string: " + e);
  let a = $fae977aafc393c5c$var$parseNumber(n[1], -9999, 9999), o = a < 1 ? "BC" : "AD", s = new $35ea8db9cb2ccb90$export$d3b7288e7994edea(o, a < 1 ? -a + 1 : a, $fae977aafc393c5c$var$parseNumber(n[2], 1, 12), 1, t, 0, n[4] ? $fae977aafc393c5c$var$parseNumber(n[4], 0, 23) : 0, n[5] ? $fae977aafc393c5c$var$parseNumber(n[5], 0, 59) : 0, n[6] ? $fae977aafc393c5c$var$parseNumber(n[6], 0, 59) : 0, n[7] ? $fae977aafc393c5c$var$parseNumber(n[7], 0, 1 / 0) * 1e3 : 0);
  s.day = $fae977aafc393c5c$var$parseNumber(n[3], 0, s.calendar.getDaysInMonth(s));
  var u;
  return n[8] && (s.offset = $fae977aafc393c5c$var$parseNumber(n[8], -23, 23) * 36e5 + $fae977aafc393c5c$var$parseNumber((u = n[9]) !== null && u !== void 0 ? u : "0", 0, 59) * 6e4), $11d87f3f76e88657$export$538b00033cc11c75(s, t);
}
function $fae977aafc393c5c$export$8e384432362ed0f0(e) {
  return $fae977aafc393c5c$export$5adfdab05168c219(e, $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function $fae977aafc393c5c$var$parseNumber(e, t, n) {
  let a = Number(e);
  if (a < t || a > n) throw new RangeError(`Value out of range: ${t} <= ${a} <= ${n}`);
  return a;
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(e) {
  return `${String(e.hour).padStart(2, "0")}:${String(e.minute).padStart(2, "0")}:${String(e.second).padStart(2, "0")}${e.millisecond ? String(e.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(e) {
  let t = $11d87f3f76e88657$export$b4a036af3fc0b032(e, new $3b62074eb05584b2$export$80ee6245ec4f29ec()), n;
  return t.era === "BC" ? n = t.year === 1 ? "0000" : "-" + String(Math.abs(1 - t.year)).padStart(6, "00") : n = String(t.year).padStart(4, "0"), `${n}-${String(t.month).padStart(2, "0")}-${String(t.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(e) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(e)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(e)}`;
}
function $fae977aafc393c5c$var$offsetToString(e) {
  let t = Math.sign(e) < 0 ? "-" : "+";
  e = Math.abs(e);
  let n = Math.floor(e / 36e5), a = e % 36e5 / 6e4;
  return `${t}${String(n).padStart(2, "0")}:${String(a).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(e) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(e)}${$fae977aafc393c5c$var$offsetToString(e.offset)}[${e.timeZone}]`;
}
function _check_private_redeclaration(e, t) {
  if (t.has(e))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _class_private_field_init(e, t, n) {
  _check_private_redeclaration(e, t), t.set(e, n);
}
function $35ea8db9cb2ccb90$var$shiftArgs(e) {
  let t = typeof e[0] == "object" ? e.shift() : new $3b62074eb05584b2$export$80ee6245ec4f29ec(), n;
  if (typeof e[0] == "string") n = e.shift();
  else {
    let u = t.getEras();
    n = u[u.length - 1];
  }
  let a = e.shift(), o = e.shift(), s = e.shift();
  return [
    t,
    n,
    a,
    o,
    s
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
class $35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day) : new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(t) {
    return $735220c2d4774dd3$export$e16d8520af44a096(this, t);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(t) {
    return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, t);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return $735220c2d4774dd3$export$adaa4cf7ef1b65be(this, t);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(t) {
    return $11d87f3f76e88657$export$e67a095c620b86fe(this, t);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return $fae977aafc393c5c$export$60dfd74aa96791bd(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, t);
  }
  constructor(...t) {
    _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, s, u] = $35ea8db9cb2ccb90$var$shiftArgs(t);
    this.calendar = n, this.era = a, this.year = o, this.month = s, this.day = u, $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
  }
}
var $35ea8db9cb2ccb90$var$_type1 = /* @__PURE__ */ new WeakMap();
class $35ea8db9cb2ccb90$export$680ea196effce5f {
  /** Returns a copy of this time. */
  copy() {
    return new $35ea8db9cb2ccb90$export$680ea196effce5f(this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `Time` with the given duration added to it. */
  add(t) {
    return $735220c2d4774dd3$export$7ed87b6bc2506470(this, t);
  }
  /** Returns a new `Time` with the given duration subtracted from it. */
  subtract(t) {
    return $735220c2d4774dd3$export$fe34d3a381cd7501(this, t);
  }
  /** Returns a new `Time` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return $735220c2d4774dd3$export$e5d5e1c1822b6e56(this, t);
  }
  /**
  * Returns a new `Time` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, t, n, a);
  }
  /** Converts the time to an ISO 8601 formatted string. */
  toString() {
    return $fae977aafc393c5c$export$f59dee82248f5ad4(this);
  }
  /** Compares this time with another. A negative result indicates that this time is before the given one, and a positive time indicates that it is after. */
  compare(t) {
    return $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, t);
  }
  constructor(t = 0, n = 0, a = 0, o = 0) {
    _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type1, {
      writable: !0,
      value: void 0
    }), this.hour = t, this.minute = n, this.second = a, this.millisecond = o, $735220c2d4774dd3$export$7555de1e070510cb(this);
  }
}
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
class $35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond) : new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(t) {
    return $735220c2d4774dd3$export$e16d8520af44a096(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return $735220c2d4774dd3$export$4e2d2ead65e5f7e3(this, t);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t) {
    return $735220c2d4774dd3$export$adaa4cf7ef1b65be($735220c2d4774dd3$export$e5d5e1c1822b6e56(this, t), t);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    switch (t) {
      case "era":
      case "year":
      case "month":
      case "day":
        return $735220c2d4774dd3$export$d52ced6badfb9a4c(this, t, n, a);
      default:
        return $735220c2d4774dd3$export$dd02b3e0007dfe28(this, t, n, a);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(t, n) {
    return $11d87f3f76e88657$export$e67a095c620b86fe(this, t, n);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return $fae977aafc393c5c$export$4223de14708adc63(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    let n = $14e0f24ef4ac5c92$export$68781ddf31c0090f(this, t);
    return n === 0 ? $14e0f24ef4ac5c92$export$c19a80a9721b80f6(this, $11d87f3f76e88657$export$b21e0b124e224484(t)) : n;
  }
  constructor(...t) {
    _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, s, u] = $35ea8db9cb2ccb90$var$shiftArgs(t);
    this.calendar = n, this.era = a, this.year = o, this.month = s, this.day = u, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
  }
}
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
class $35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    return this.era ? new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond) : new $35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(t) {
    return $735220c2d4774dd3$export$96b1d28349274637(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(t) {
    return $735220c2d4774dd3$export$6814caac34ca03c7(this, t);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(t, n) {
    return $735220c2d4774dd3$export$31b5430eb18be4f8(this, t, n);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(t, n, a) {
    return $735220c2d4774dd3$export$9a297d111fc86b79(this, t, n, a);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return $11d87f3f76e88657$export$83aac07b4c37b25(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return $fae977aafc393c5c$export$bf79f1ebf4b18792(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(t) {
    return this.toDate().getTime() - $11d87f3f76e88657$export$84c95a83c799e074(t, this.timeZone).toDate().getTime();
  }
  constructor(...t) {
    _class_private_field_init(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: !0,
      value: void 0
    });
    let [n, a, o, s, u] = $35ea8db9cb2ccb90$var$shiftArgs(t), d = t.shift(), f = t.shift();
    this.calendar = n, this.era = a, this.year = o, this.month = s, this.day = u, this.timeZone = d, this.offset = f, this.hour = t.shift() || 0, this.minute = t.shift() || 0, this.second = t.shift() || 0, this.millisecond = t.shift() || 0, $735220c2d4774dd3$export$c4e2ecac49351ef2(this);
  }
}
const $62225008020f0a13$var$ERA_START_DATES = [
  [
    1868,
    9,
    8
  ],
  [
    1912,
    7,
    30
  ],
  [
    1926,
    12,
    25
  ],
  [
    1989,
    1,
    8
  ],
  [
    2019,
    5,
    1
  ]
], $62225008020f0a13$var$ERA_END_DATES = [
  [
    1912,
    7,
    29
  ],
  [
    1926,
    12,
    24
  ],
  [
    1989,
    1,
    7
  ],
  [
    2019,
    4,
    30
  ]
], $62225008020f0a13$var$ERA_ADDENDS = [
  1867,
  1911,
  1925,
  1988,
  2018
], $62225008020f0a13$var$ERA_NAMES = [
  "meiji",
  "taisho",
  "showa",
  "heisei",
  "reiwa"
];
function $62225008020f0a13$var$findEraFromGregorianDate(e) {
  const t = $62225008020f0a13$var$ERA_START_DATES.findIndex(([n, a, o]) => e.year < n || e.year === n && e.month < a || e.year === n && e.month === a && e.day < o);
  return t === -1 ? $62225008020f0a13$var$ERA_START_DATES.length - 1 : t === 0 ? 0 : t - 1;
}
function $62225008020f0a13$var$toGregorian(e) {
  let t = $62225008020f0a13$var$ERA_ADDENDS[$62225008020f0a13$var$ERA_NAMES.indexOf(e.era)];
  if (!t) throw new Error("Unknown era: " + e.era);
  return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(e.year + t, e.month, e.day);
}
class $62225008020f0a13$export$b746ab2b60cdffbf extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = $62225008020f0a13$var$findEraFromGregorianDate(n);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, $62225008020f0a13$var$ERA_NAMES[a], n.year - $62225008020f0a13$var$ERA_ADDENDS[a], n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay($62225008020f0a13$var$toGregorian(t));
  }
  balanceDate(t) {
    let n = $62225008020f0a13$var$toGregorian(t), a = $62225008020f0a13$var$findEraFromGregorianDate(n);
    $62225008020f0a13$var$ERA_NAMES[a] !== t.era && (t.era = $62225008020f0a13$var$ERA_NAMES[a], t.year = n.year - $62225008020f0a13$var$ERA_ADDENDS[a]), this.constrainDate(t);
  }
  constrainDate(t) {
    let n = $62225008020f0a13$var$ERA_NAMES.indexOf(t.era), a = $62225008020f0a13$var$ERA_END_DATES[n];
    if (a != null) {
      let [o, s, u] = a, d = o - $62225008020f0a13$var$ERA_ADDENDS[n];
      t.year = Math.max(1, Math.min(d, t.year)), t.year === d && (t.month = Math.min(s, t.month), t.month === s && (t.day = Math.min(u, t.day)));
    }
    if (t.year === 1 && n >= 0) {
      let [, o, s] = $62225008020f0a13$var$ERA_START_DATES[n];
      t.month = Math.max(o, t.month), t.month === o && (t.day = Math.max(s, t.day));
    }
  }
  getEras() {
    return $62225008020f0a13$var$ERA_NAMES;
  }
  getYearsInEra(t) {
    let n = $62225008020f0a13$var$ERA_NAMES.indexOf(t.era), a = $62225008020f0a13$var$ERA_START_DATES[n], o = $62225008020f0a13$var$ERA_START_DATES[n + 1];
    if (o == null)
      return 9999 - a[0] + 1;
    let s = o[0] - a[0];
    return (t.month < o[1] || t.month === o[1] && t.day < o[2]) && s++, s;
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth($62225008020f0a13$var$toGregorian(t));
  }
  getMinimumMonthInYear(t) {
    let n = $62225008020f0a13$var$getMinimums(t);
    return n ? n[1] : 1;
  }
  getMinimumDayInMonth(t) {
    let n = $62225008020f0a13$var$getMinimums(t);
    return n && t.month === n[1] ? n[2] : 1;
  }
  constructor(...t) {
    super(...t), this.identifier = "japanese";
  }
}
function $62225008020f0a13$var$getMinimums(e) {
  if (e.year === 1) {
    let t = $62225008020f0a13$var$ERA_NAMES.indexOf(e.era);
    return $62225008020f0a13$var$ERA_START_DATES[t];
  }
}
const $8d73d47422ca7302$var$BUDDHIST_ERA_START = -543;
class $8d73d47422ca7302$export$42d20a78301dee44 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(n.era, n.year);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, a - $8d73d47422ca7302$var$BUDDHIST_ERA_START, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay($8d73d47422ca7302$var$toGregorian(t));
  }
  getEras() {
    return [
      "BE"
    ];
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth($8d73d47422ca7302$var$toGregorian(t));
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "buddhist";
  }
}
function $8d73d47422ca7302$var$toGregorian(e) {
  let [t, n] = $3b62074eb05584b2$export$4475b7e617eb123c(e.year + $8d73d47422ca7302$var$BUDDHIST_ERA_START);
  return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(t, n, e.month, e.day);
}
const $5f31bd6f0c8940b2$var$TAIWAN_ERA_START = 1911;
function $5f31bd6f0c8940b2$var$gregorianYear(e) {
  return e.era === "minguo" ? e.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START : 1 - e.year + $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
}
function $5f31bd6f0c8940b2$var$gregorianToTaiwan(e) {
  let t = e - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  return t > 0 ? [
    "minguo",
    t
  ] : [
    "before_minguo",
    1 - t
  ];
}
class $5f31bd6f0c8940b2$export$65e01080afcb0799 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(n.era, n.year), [o, s] = $5f31bd6f0c8940b2$var$gregorianToTaiwan(a);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, o, s, n.month, n.day);
  }
  toJulianDay(t) {
    return super.toJulianDay($5f31bd6f0c8940b2$var$toGregorian(t));
  }
  getEras() {
    return [
      "before_minguo",
      "minguo"
    ];
  }
  balanceDate(t) {
    let [n, a] = $5f31bd6f0c8940b2$var$gregorianToTaiwan($5f31bd6f0c8940b2$var$gregorianYear(t));
    t.era = n, t.year = a;
  }
  isInverseEra(t) {
    return t.era === "before_minguo";
  }
  getDaysInMonth(t) {
    return super.getDaysInMonth($5f31bd6f0c8940b2$var$toGregorian(t));
  }
  getYearsInEra(t) {
    return t.era === "before_minguo" ? 9999 : 9999 - $5f31bd6f0c8940b2$var$TAIWAN_ERA_START;
  }
  constructor(...t) {
    super(...t), this.identifier = "roc";
  }
}
function $5f31bd6f0c8940b2$var$toGregorian(e) {
  let [t, n] = $3b62074eb05584b2$export$4475b7e617eb123c($5f31bd6f0c8940b2$var$gregorianYear(e));
  return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(t, n, e.month, e.day);
}
const $f3ed2e4472ae7e25$var$PERSIAN_EPOCH = 1948320, $f3ed2e4472ae7e25$var$MONTH_START = [
  0,
  31,
  62,
  93,
  124,
  155,
  186,
  216,
  246,
  276,
  306,
  336
  // Esfand
];
class $f3ed2e4472ae7e25$export$37fccdbfd14c5939 {
  fromJulianDay(t) {
    let n = t - $f3ed2e4472ae7e25$var$PERSIAN_EPOCH, a = 1 + Math.floor((33 * n + 3) / 12053), o = 365 * (a - 1) + Math.floor((8 * a + 21) / 33), s = n - o, u = s < 216 ? Math.floor(s / 31) : Math.floor((s - 6) / 30), d = s - $f3ed2e4472ae7e25$var$MONTH_START[u] + 1;
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, a, u + 1, d);
  }
  toJulianDay(t) {
    let n = $f3ed2e4472ae7e25$var$PERSIAN_EPOCH - 1 + 365 * (t.year - 1) + Math.floor((8 * t.year + 21) / 33);
    return n += $f3ed2e4472ae7e25$var$MONTH_START[t.month - 1], n += t.day, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInMonth(t) {
    return t.month <= 6 ? 31 : t.month <= 11 || $2b4dce13dd5a17fa$export$842a2cf37af977e1(25 * t.year + 11, 33) < 8 ? 30 : 29;
  }
  getEras() {
    return [
      "AP"
    ];
  }
  getYearsInEra() {
    return 9377;
  }
  constructor() {
    this.identifier = "persian";
  }
}
const $82c358003bdda0a8$var$INDIAN_ERA_START = 78, $82c358003bdda0a8$var$INDIAN_YEAR_START = 80;
class $82c358003bdda0a8$export$39f31c639fa15726 extends $3b62074eb05584b2$export$80ee6245ec4f29ec {
  fromJulianDay(t) {
    let n = super.fromJulianDay(t), a = n.year - $82c358003bdda0a8$var$INDIAN_ERA_START, o = t - $3b62074eb05584b2$export$f297eb839006d339(n.era, n.year, 1, 1), s;
    o < $82c358003bdda0a8$var$INDIAN_YEAR_START ? (a--, s = $3b62074eb05584b2$export$553d7fa8e3805fc0(n.year - 1) ? 31 : 30, o += s + 155 + 90 + 10) : (s = $3b62074eb05584b2$export$553d7fa8e3805fc0(n.year) ? 31 : 30, o -= $82c358003bdda0a8$var$INDIAN_YEAR_START);
    let u, d;
    if (o < s)
      u = 1, d = o + 1;
    else {
      let f = o - s;
      f < 155 ? (u = Math.floor(f / 31) + 2, d = f % 31 + 1) : (f -= 155, u = Math.floor(f / 30) + 7, d = f % 30 + 1);
    }
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, a, u, d);
  }
  toJulianDay(t) {
    let n = t.year + $82c358003bdda0a8$var$INDIAN_ERA_START, [a, o] = $3b62074eb05584b2$export$4475b7e617eb123c(n), s, u;
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(o) ? (s = 31, u = $3b62074eb05584b2$export$f297eb839006d339(a, o, 3, 21)) : (s = 30, u = $3b62074eb05584b2$export$f297eb839006d339(a, o, 3, 22)), t.month === 1 ? u + t.day - 1 : (u += s + Math.min(t.month - 2, 5) * 31, t.month >= 8 && (u += (t.month - 7) * 30), u += t.day - 1, u);
  }
  getDaysInMonth(t) {
    return t.month === 1 && $3b62074eb05584b2$export$553d7fa8e3805fc0(t.year + $82c358003bdda0a8$var$INDIAN_ERA_START) || t.month >= 2 && t.month <= 6 ? 31 : 30;
  }
  getYearsInEra() {
    return 9919;
  }
  getEras() {
    return [
      "saka"
    ];
  }
  balanceDate() {
  }
  constructor(...t) {
    super(...t), this.identifier = "indian";
  }
}
const $f2f3e0e3a817edbd$var$CIVIL_EPOC = 1948440, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC = 1948439, $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START = 1300, $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END = 1600, $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS = 460322;
function $f2f3e0e3a817edbd$var$islamicToJulianDay(e, t, n, a) {
  return a + Math.ceil(29.5 * (n - 1)) + (t - 1) * 354 + Math.floor((3 + 11 * t) / 30) + e - 1;
}
function $f2f3e0e3a817edbd$var$julianDayToIslamic(e, t, n) {
  let a = Math.floor((30 * (n - t) + 10646) / 10631), o = Math.min(12, Math.ceil((n - (29 + $f2f3e0e3a817edbd$var$islamicToJulianDay(t, a, 1, 1))) / 29.5) + 1), s = n - $f2f3e0e3a817edbd$var$islamicToJulianDay(t, a, o, 1) + 1;
  return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(e, a, o, s);
}
function $f2f3e0e3a817edbd$var$isLeapYear(e) {
  return (14 + 11 * e) % 30 < 11;
}
class $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(t) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$CIVIL_EPOC, t);
  }
  toJulianDay(t) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$CIVIL_EPOC, t.year, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = 29 + t.month % 2;
    return t.month === 12 && $f2f3e0e3a817edbd$var$isLeapYear(t.year) && n++, n;
  }
  getMonthsInYear() {
    return 12;
  }
  getDaysInYear(t) {
    return $f2f3e0e3a817edbd$var$isLeapYear(t.year) ? 355 : 354;
  }
  getYearsInEra() {
    return 9665;
  }
  getEras() {
    return [
      "AH"
    ];
  }
  constructor() {
    this.identifier = "islamic-civil";
  }
}
class $f2f3e0e3a817edbd$export$37f0887f2f9d22f7 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(t) {
    return $f2f3e0e3a817edbd$var$julianDayToIslamic(this, $f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, t);
  }
  toJulianDay(t) {
    return $f2f3e0e3a817edbd$var$islamicToJulianDay($f2f3e0e3a817edbd$var$ASTRONOMICAL_EPOC, t.year, t.month, t.day);
  }
  constructor(...t) {
    super(...t), this.identifier = "islamic-tbla";
  }
}
const $f2f3e0e3a817edbd$var$UMALQURA_DATA = "qgpUDckO1AbqBmwDrQpVBakGkgepC9QF2gpcBS0NlQZKB1QLagutBa4ETwoXBYsGpQbVCtYCWwmdBE0KJg2VDawFtgm6AlsKKwWVCsoG6Qr0AnYJtgJWCcoKpAvSC9kF3AJtCU0FpQpSC6ULtAW2CVcFlwJLBaMGUgdlC2oFqworBZUMSg2lDcoF1gpXCasESwmlClILagt1BXYCtwhbBFUFqQW0BdoJ3QRuAjYJqgpUDbIN1QXaAlsJqwRVCkkLZAtxC7QFtQpVCiUNkg7JDtQG6QprCasEkwpJDaQNsg25CroEWworBZUKKgtVC1wFvQQ9Ah0JlQpKC1oLbQW2AjsJmwRVBqkGVAdqC2wFrQpVBSkLkgupC9QF2gpaBasKlQVJB2QHqgu1BbYCVgpNDiULUgtqC60FrgIvCZcESwalBqwG1gpdBZ0ETQoWDZUNqgW1BdoCWwmtBJUFygbkBuoK9QS2AlYJqgpUC9IL2QXqAm0JrQSVCkoLpQuyBbUJ1gSXCkcFkwZJB1ULagVrCisFiwpGDaMNygXWCtsEawJLCaUKUgtpC3UFdgG3CFsCKwVlBbQF2gntBG0BtgimClINqQ3UBdoKWwmrBFMGKQdiB6kLsgW1ClUFJQuSDckO0gbpCmsFqwRVCikNVA2qDbUJugQ7CpsETQqqCtUK2gJdCV4ELgqaDFUNsga5BroEXQotBZUKUguoC7QLuQXaAloJSgukDdEO6AZqC20FNQWVBkoNqA3UDdoGWwWdAisGFQtKC5ULqgWuCi4JjwwnBZUGqgbWCl0FnQI=";
let $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH, $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE;
function $f2f3e0e3a817edbd$var$umalquraYearStart(e) {
  return $f2f3e0e3a817edbd$var$UMALQURA_START_DAYS + $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[e - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
function $f2f3e0e3a817edbd$var$umalquraMonthLength(e, t) {
  let n = e - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START, a = 1 << 11 - (t - 1);
  return ($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH[n] & a) === 0 ? 29 : 30;
}
function $f2f3e0e3a817edbd$var$umalquraMonthStart(e, t) {
  let n = $f2f3e0e3a817edbd$var$umalquraYearStart(e);
  for (let a = 1; a < t; a++) n += $f2f3e0e3a817edbd$var$umalquraMonthLength(e, a);
  return n;
}
function $f2f3e0e3a817edbd$var$umalquraYearLength(e) {
  return $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[e + 1 - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[e - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START];
}
class $f2f3e0e3a817edbd$export$5baab4758c231076 extends $f2f3e0e3a817edbd$export$2066795aadd37bfc {
  fromJulianDay(t) {
    let n = t - $f2f3e0e3a817edbd$var$CIVIL_EPOC, a = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_START), o = $f2f3e0e3a817edbd$var$umalquraYearStart($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END);
    if (n < a || n > o) return super.fromJulianDay(t);
    {
      let s = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START - 1, u = 1, d = 1;
      for (; d > 0; ) {
        s++, d = n - $f2f3e0e3a817edbd$var$umalquraYearStart(s) + 1;
        let f = $f2f3e0e3a817edbd$var$umalquraYearLength(s);
        if (d === f) {
          u = 12;
          break;
        } else if (d < f) {
          let g = $f2f3e0e3a817edbd$var$umalquraMonthLength(s, u);
          for (u = 1; d > g; )
            d -= g, u++, g = $f2f3e0e3a817edbd$var$umalquraMonthLength(s, u);
          break;
        }
      }
      return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, s, u, n - $f2f3e0e3a817edbd$var$umalquraMonthStart(s, u) + 1);
    }
  }
  toJulianDay(t) {
    return t.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || t.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END ? super.toJulianDay(t) : $f2f3e0e3a817edbd$var$CIVIL_EPOC + $f2f3e0e3a817edbd$var$umalquraMonthStart(t.year, t.month) + (t.day - 1);
  }
  getDaysInMonth(t) {
    return t.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || t.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END ? super.getDaysInMonth(t) : $f2f3e0e3a817edbd$var$umalquraMonthLength(t.year, t.month);
  }
  getDaysInYear(t) {
    return t.year < $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START || t.year > $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END ? super.getDaysInYear(t) : $f2f3e0e3a817edbd$var$umalquraYearLength(t.year);
  }
  constructor() {
    if (super(), this.identifier = "islamic-umalqura", $f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH || ($f2f3e0e3a817edbd$var$UMALQURA_MONTHLENGTH = new Uint16Array(Uint8Array.from(atob($f2f3e0e3a817edbd$var$UMALQURA_DATA), (t) => t.charCodeAt(0)).buffer)), !$f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE) {
      $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE = new Uint32Array($f2f3e0e3a817edbd$var$UMALQURA_YEAR_END - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START + 1);
      let t = 0;
      for (let n = $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START; n <= $f2f3e0e3a817edbd$var$UMALQURA_YEAR_END; n++) {
        $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START_TABLE[n - $f2f3e0e3a817edbd$var$UMALQURA_YEAR_START] = t;
        for (let a = 1; a <= 12; a++) t += $f2f3e0e3a817edbd$var$umalquraMonthLength(n, a);
      }
    }
  }
}
const $7c5f6fbf42389787$var$HEBREW_EPOCH = 347997, $7c5f6fbf42389787$var$HOUR_PARTS = 1080, $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS, $7c5f6fbf42389787$var$MONTH_DAYS = 29, $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793, $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;
function $7c5f6fbf42389787$var$isLeapYear(e) {
  return $2b4dce13dd5a17fa$export$842a2cf37af977e1(e * 7 + 1, 19) < 7;
}
function $7c5f6fbf42389787$var$hebrewDelay1(e) {
  let t = Math.floor((235 * e - 234) / 19), n = 12084 + 13753 * t, a = t * 29 + Math.floor(n / 25920);
  return $2b4dce13dd5a17fa$export$842a2cf37af977e1(3 * (a + 1), 7) < 3 && (a += 1), a;
}
function $7c5f6fbf42389787$var$hebrewDelay2(e) {
  let t = $7c5f6fbf42389787$var$hebrewDelay1(e - 1), n = $7c5f6fbf42389787$var$hebrewDelay1(e);
  return $7c5f6fbf42389787$var$hebrewDelay1(e + 1) - n === 356 ? 2 : n - t === 382 ? 1 : 0;
}
function $7c5f6fbf42389787$var$startOfYear(e) {
  return $7c5f6fbf42389787$var$hebrewDelay1(e) + $7c5f6fbf42389787$var$hebrewDelay2(e);
}
function $7c5f6fbf42389787$var$getDaysInYear(e) {
  return $7c5f6fbf42389787$var$startOfYear(e + 1) - $7c5f6fbf42389787$var$startOfYear(e);
}
function $7c5f6fbf42389787$var$getYearType(e) {
  let t = $7c5f6fbf42389787$var$getDaysInYear(e);
  switch (t > 380 && (t -= 30), t) {
    case 353:
      return 0;
    // deficient
    case 354:
      return 1;
    // normal
    case 355:
      return 2;
  }
}
function $7c5f6fbf42389787$var$getDaysInMonth(e, t) {
  if (t >= 6 && !$7c5f6fbf42389787$var$isLeapYear(e) && t++, t === 4 || t === 7 || t === 9 || t === 11 || t === 13) return 29;
  let n = $7c5f6fbf42389787$var$getYearType(e);
  return t === 2 ? n === 2 ? 30 : 29 : t === 3 ? n === 0 ? 29 : 30 : t === 6 ? $7c5f6fbf42389787$var$isLeapYear(e) ? 30 : 0 : 30;
}
class $7c5f6fbf42389787$export$ca405048b8fb5af {
  fromJulianDay(t) {
    let n = t - $7c5f6fbf42389787$var$HEBREW_EPOCH, a = n * $7c5f6fbf42389787$var$DAY_PARTS / $7c5f6fbf42389787$var$MONTH_PARTS, o = Math.floor((19 * a + 234) / 235) + 1, s = $7c5f6fbf42389787$var$startOfYear(o), u = Math.floor(n - s);
    for (; u < 1; )
      o--, s = $7c5f6fbf42389787$var$startOfYear(o), u = Math.floor(n - s);
    let d = 1, f = 0;
    for (; f < u; )
      f += $7c5f6fbf42389787$var$getDaysInMonth(o, d), d++;
    d--, f -= $7c5f6fbf42389787$var$getDaysInMonth(o, d);
    let g = u - f;
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, o, d, g);
  }
  toJulianDay(t) {
    let n = $7c5f6fbf42389787$var$startOfYear(t.year);
    for (let a = 1; a < t.month; a++) n += $7c5f6fbf42389787$var$getDaysInMonth(t.year, a);
    return n + t.day + $7c5f6fbf42389787$var$HEBREW_EPOCH;
  }
  getDaysInMonth(t) {
    return $7c5f6fbf42389787$var$getDaysInMonth(t.year, t.month);
  }
  getMonthsInYear(t) {
    return $7c5f6fbf42389787$var$isLeapYear(t.year) ? 13 : 12;
  }
  getDaysInYear(t) {
    return $7c5f6fbf42389787$var$getDaysInYear(t.year);
  }
  getYearsInEra() {
    return 9999;
  }
  getEras() {
    return [
      "AM"
    ];
  }
  balanceYearMonth(t, n) {
    n.year !== t.year && ($7c5f6fbf42389787$var$isLeapYear(n.year) && !$7c5f6fbf42389787$var$isLeapYear(t.year) && n.month > 6 ? t.month-- : !$7c5f6fbf42389787$var$isLeapYear(n.year) && $7c5f6fbf42389787$var$isLeapYear(t.year) && n.month > 6 && t.month++);
  }
  constructor() {
    this.identifier = "hebrew";
  }
}
const $b956b2d7a6cf451f$var$ETHIOPIC_EPOCH = 1723856, $b956b2d7a6cf451f$var$COPTIC_EPOCH = 1824665, $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA = 5500;
function $b956b2d7a6cf451f$var$ceToJulianDay(e, t, n, a) {
  return e + 365 * t + Math.floor(t / 4) + 30 * (n - 1) + a - 1;
}
function $b956b2d7a6cf451f$var$julianDayToCE(e, t) {
  let n = Math.floor(4 * (t - e) / 1461), a = 1 + Math.floor((t - $b956b2d7a6cf451f$var$ceToJulianDay(e, n, 1, 1)) / 30), o = t + 1 - $b956b2d7a6cf451f$var$ceToJulianDay(e, n, a, 1);
  return [
    n,
    a,
    o
  ];
}
function $b956b2d7a6cf451f$var$getLeapDay(e) {
  return Math.floor(e % 4 / 3);
}
function $b956b2d7a6cf451f$var$getDaysInMonth(e, t) {
  return t % 13 !== 0 ? 30 : $b956b2d7a6cf451f$var$getLeapDay(e) + 5;
}
class $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(t) {
    let [n, a, o] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, t), s = "AM";
    return n <= 0 && (s = "AA", n += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA), new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, s, n, a, o);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "AA" && (n -= $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA), $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    return $b956b2d7a6cf451f$var$getDaysInMonth(t.year, t.month);
  }
  getMonthsInYear() {
    return 13;
  }
  getDaysInYear(t) {
    return 365 + $b956b2d7a6cf451f$var$getLeapDay(t.year);
  }
  getYearsInEra(t) {
    return t.era === "AA" ? 9999 : 9991;
  }
  getEras() {
    return [
      "AA",
      "AM"
    ];
  }
  constructor() {
    this.identifier = "ethiopic";
  }
}
class $b956b2d7a6cf451f$export$d72e0c37005a4914 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(t) {
    let [n, a, o] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$ETHIOPIC_EPOCH, t);
    return n += $b956b2d7a6cf451f$var$AMETE_MIHRET_DELTA, new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, "AA", n, a, o);
  }
  getEras() {
    return [
      "AA"
    ];
  }
  getYearsInEra() {
    return 9999;
  }
  constructor(...t) {
    super(...t), this.identifier = "ethioaa";
  }
}
class $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1 extends $b956b2d7a6cf451f$export$26ba6eab5e20cd7d {
  fromJulianDay(t) {
    let [n, a, o] = $b956b2d7a6cf451f$var$julianDayToCE($b956b2d7a6cf451f$var$COPTIC_EPOCH, t), s = "CE";
    return n <= 0 && (s = "BCE", n = 1 - n), new $35ea8db9cb2ccb90$export$99faa760c7908e4f(this, s, n, a, o);
  }
  toJulianDay(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), $b956b2d7a6cf451f$var$ceToJulianDay($b956b2d7a6cf451f$var$COPTIC_EPOCH, n, t.month, t.day);
  }
  getDaysInMonth(t) {
    let n = t.year;
    return t.era === "BCE" && (n = 1 - n), $b956b2d7a6cf451f$var$getDaysInMonth(n, t.month);
  }
  isInverseEra(t) {
    return t.era === "BCE";
  }
  balanceDate(t) {
    t.year <= 0 && (t.era = t.era === "BCE" ? "CE" : "BCE", t.year = 1 - t.year);
  }
  getEras() {
    return [
      "BCE",
      "CE"
    ];
  }
  getYearsInEra(t) {
    return t.era === "BCE" ? 9999 : 9715;
  }
  constructor(...t) {
    super(...t), this.identifier = "coptic";
  }
}
function $64244302c3013299$export$dd0bbc9b26defe37(e) {
  switch (e) {
    case "buddhist":
      return new $8d73d47422ca7302$export$42d20a78301dee44();
    case "ethiopic":
      return new $b956b2d7a6cf451f$export$26ba6eab5e20cd7d();
    case "ethioaa":
      return new $b956b2d7a6cf451f$export$d72e0c37005a4914();
    case "coptic":
      return new $b956b2d7a6cf451f$export$fe6243cbe1a4b7c1();
    case "hebrew":
      return new $7c5f6fbf42389787$export$ca405048b8fb5af();
    case "indian":
      return new $82c358003bdda0a8$export$39f31c639fa15726();
    case "islamic-civil":
      return new $f2f3e0e3a817edbd$export$2066795aadd37bfc();
    case "islamic-tbla":
      return new $f2f3e0e3a817edbd$export$37f0887f2f9d22f7();
    case "islamic-umalqura":
      return new $f2f3e0e3a817edbd$export$5baab4758c231076();
    case "japanese":
      return new $62225008020f0a13$export$b746ab2b60cdffbf();
    case "persian":
      return new $f3ed2e4472ae7e25$export$37fccdbfd14c5939();
    case "roc":
      return new $5f31bd6f0c8940b2$export$65e01080afcb0799();
    case "gregory":
    default:
      return new $3b62074eb05584b2$export$80ee6245ec4f29ec();
  }
}
let $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
class $fb18d541ea1ad717$export$ad991b66133851cf {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(t) {
    return this.formatter.format(t);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(t) {
    return this.formatter.formatToParts(t);
  }
  /** Formats a date range as a string. */
  formatRange(t, n) {
    if (typeof this.formatter.formatRange == "function")
      return this.formatter.formatRange(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(t)}  ${this.formatter.format(n)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(t, n) {
    if (typeof this.formatter.formatRangeToParts == "function")
      return this.formatter.formatRangeToParts(t, n);
    if (n < t) throw new RangeError("End date must be >= start date");
    let a = this.formatter.formatToParts(t), o = this.formatter.formatToParts(n);
    return [
      ...a.map((s) => ({
        ...s,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...o.map((s) => ({
        ...s,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let t = this.formatter.resolvedOptions();
    return $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() && (this.resolvedHourCycle || (this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(t.locale, this.options)), t.hourCycle = this.resolvedHourCycle, t.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12"), t.calendar === "ethiopic-amete-alem" && (t.calendar = "ethioaa"), t;
  }
  constructor(t, n = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(t, n), this.options = n;
  }
}
const $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(e, t = {}) {
  if (typeof t.hour12 == "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    t = {
      ...t
    };
    let o = $fb18d541ea1ad717$var$hour12Preferences[String(t.hour12)][e.split("-")[0]], s = t.hour12 ? "h12" : "h23";
    t.hourCycle = o ?? s, delete t.hour12;
  }
  let n = e + (t ? Object.entries(t).sort((o, s) => o[0] < s[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(n)) return $fb18d541ea1ad717$var$formatterCache.get(n);
  let a = new Intl.DateTimeFormat(e, t);
  return $fb18d541ea1ad717$var$formatterCache.set(n, a), a;
}
let $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null && ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
    hour: "numeric",
    hour12: !1
  }).format(new Date(2020, 2, 3, 0)) === "24"), $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
let $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null && ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
    hour: "numeric",
    hour12: !1
  }).resolvedOptions().hourCycle === "h12"), $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(e, t) {
  if (!t.timeStyle && !t.hour) return;
  e = e.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, ""), e += (e.includes("-u-") ? "" : "-u") + "-nu-latn";
  let n = $fb18d541ea1ad717$var$getCachedDateFormatter(e, {
    ...t,
    timeZone: void 0
    // use local timezone
  }), a = parseInt(n.formatToParts(new Date(2020, 2, 3, 0)).find((s) => s.type === "hour").value, 10), o = parseInt(n.formatToParts(new Date(2020, 2, 3, 23)).find((s) => s.type === "hour").value, 10);
  if (a === 0 && o === 23) return "h23";
  if (a === 24 && o === 23) return "h24";
  if (a === 0 && o === 11) return "h11";
  if (a === 12 && o === 11) return "h12";
  throw new Error("Unexpected hour cycle result");
}
function getDefaultDate(e) {
  const { defaultValue: t, defaultPlaceholder: n, granularity: a = "day", locale: o = "en" } = e;
  if (Array.isArray(t) && t.length)
    return t.at(-1).copy();
  if (t && !Array.isArray(t))
    return t.copy();
  if (n)
    return n.copy();
  const s = /* @__PURE__ */ new Date(), u = s.getFullYear(), d = s.getMonth() + 1, f = s.getDate(), g = ["hour", "minute", "second"], v = new $fb18d541ea1ad717$export$ad991b66133851cf(o), b = $64244302c3013299$export$dd0bbc9b26defe37(v.resolvedOptions().calendar);
  return g.includes(a ?? "day") ? $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$ca871e8dbb80966f(u, d, f, 0, 0, 0), b) : $11d87f3f76e88657$export$b4a036af3fc0b032(new $35ea8db9cb2ccb90$export$99faa760c7908e4f(u, d, f), b);
}
function getDefaultTime(e) {
  const { defaultValue: t, defaultPlaceholder: n } = e;
  return t ? t.copy() : n ? n.copy() : new $35ea8db9cb2ccb90$export$680ea196effce5f(0, 0, 0);
}
function toDate(e, t = $14e0f24ef4ac5c92$export$aa8b41735afcabd2()) {
  return isZonedDateTime(e) ? e.toDate() : e.toDate(t);
}
function isCalendarDateTime(e) {
  return e instanceof $35ea8db9cb2ccb90$export$ca871e8dbb80966f;
}
function isZonedDateTime(e) {
  return e instanceof $35ea8db9cb2ccb90$export$d3b7288e7994edea;
}
function hasTime(e) {
  return isCalendarDateTime(e) || isZonedDateTime(e);
}
function getDaysInMonth(e) {
  if (e instanceof Date) {
    const t = e.getFullYear(), n = e.getMonth() + 1;
    return new Date(t, n, 0).getDate();
  } else
    return e.set({ day: 100 }).day;
}
function isBefore(e, t) {
  return e.compare(t) < 0;
}
function isAfter(e, t) {
  return e.compare(t) > 0;
}
function isBeforeOrSame(e, t) {
  return e.compare(t) <= 0;
}
function isAfterOrSame(e, t) {
  return e.compare(t) >= 0;
}
function isBetweenInclusive(e, t, n) {
  return isAfterOrSame(e, t) && isBeforeOrSame(e, n);
}
function isBetween(e, t, n) {
  return isAfter(e, t) && isBefore(e, n);
}
function getLastFirstDayOfWeek(e, t, n) {
  const a = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(e, n);
  return t > a ? e.subtract({ days: a + 7 - t }) : t === a ? e : e.subtract({ days: a - t });
}
function getNextLastDayOfWeek(e, t, n) {
  const a = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(e, n), o = t === 0 ? 6 : t - 1;
  return a === o ? e : a > o ? e.add({ days: 7 - a + o }) : e.add({ days: o - a });
}
function areAllDaysBetweenValid(e, t, n, a, o) {
  if (n === void 0 && a === void 0 && o === void 0)
    return !0;
  let s = e.add({ days: 1 });
  if ((a?.(s) || n?.(s)) && !o?.(s))
    return !1;
  const u = t;
  for (; s.compare(u) < 0; )
    if (s = s.add({ days: 1 }), (a?.(s) || n?.(s)) && !o?.(s))
      return !1;
  return !0;
}
function chunk(e, t) {
  const n = [];
  for (let a = 0; a < e.length; a += t)
    n.push(e.slice(a, a + t));
  return n;
}
function getOptsByGranularity(e, t, n = !1) {
  const a = {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    timeZoneName: "short",
    hourCycle: normalizeHourCycle(t),
    hour12: normalizeHour12(t)
  };
  return n && (delete a.year, delete a.month, delete a.day), e === "day" && (delete a.second, delete a.hour, delete a.minute, delete a.timeZoneName), e === "hour" && (delete a.minute, delete a.second), e === "minute" && delete a.second, a;
}
function normalizeDateStep(e) {
  return defu(e?.step, {
    year: 1,
    month: 1,
    day: 1,
    hour: 1,
    minute: 1,
    second: 1,
    millisecond: 1
  });
}
function handleCalendarInitialFocus(e) {
  const t = e.querySelector("[data-selected]");
  if (t)
    return t.focus();
  const n = e.querySelector("[data-today]");
  if (n)
    return n.focus();
  const a = e.querySelector("[data-reka-calendar-day]");
  if (a)
    return a.focus();
}
function normalizeHourCycle(e) {
  if (e === 24)
    return "h23";
  if (e === 12)
    return "h11";
}
function normalizeHour12(e) {
  if (e === 24)
    return !1;
  if (e === 12)
    return !0;
}
function getDaysBetween(e, t) {
  const n = [];
  let a = e.add({ days: 1 });
  const o = t;
  for (; a.compare(o) < 0; )
    n.push(a), a = a.add({ days: 1 });
  return n;
}
function createMonth(e) {
  const { dateObj: t, weekStartsOn: n, fixedWeeks: a, locale: o } = e, s = getDaysInMonth(t), u = Array.from({ length: s }, (A, P) => t.set({ day: P + 1 })), d = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(t), f = $14e0f24ef4ac5c92$export$a2258d9c4118825c(t), g = getLastFirstDayOfWeek(d, n, o), v = getNextLastDayOfWeek(f, n, o), b = getDaysBetween(g.subtract({ days: 1 }), d), w = getDaysBetween(f, v.add({ days: 1 })), C = b.length + u.length + w.length;
  if (a && C < 42) {
    const A = 42 - C;
    let P = w[w.length - 1];
    P || (P = $14e0f24ef4ac5c92$export$a2258d9c4118825c(t));
    const M = Array.from({ length: A }, (B, _) => {
      const T = _ + 1;
      return P.add({ days: T });
    });
    w.push(...M);
  }
  const k = b.concat(u, w), E = chunk(k, 7);
  return {
    value: t,
    cells: k,
    rows: E
  };
}
function createMonths(e) {
  const { numberOfMonths: t, dateObj: n, ...a } = e, o = [];
  if (!t || t === 1)
    return o.push(
      createMonth({
        ...a,
        dateObj: n
      })
    ), o;
  o.push(
    createMonth({
      ...a,
      dateObj: n
    })
  );
  for (let s = 1; s < t; s++) {
    const u = n.add({ months: s });
    o.push(
      createMonth({
        ...a,
        dateObj: u
      })
    );
  }
  return o;
}
function useDateFormatter(e, t = {}) {
  const n = ref(e);
  function a() {
    return n.value;
  }
  function o(A) {
    n.value = A;
  }
  function s(A, P) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, ...P }).format(A);
  }
  function u(A, P = !0) {
    return hasTime(A) && P ? s(toDate(A), {
      dateStyle: "long",
      timeStyle: "long"
    }) : s(toDate(A), {
      dateStyle: "long"
    });
  }
  function d(A, P = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, month: "long", year: "numeric", ...P }).format(A);
  }
  function f(A, P = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, month: "long", ...P }).format(A);
  }
  function g() {
    const A = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2());
    return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((M) => ({ label: f(toDate(A.set({ month: M }))), value: M }));
  }
  function v(A, P = {}) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, year: "numeric", ...P }).format(A);
  }
  function b(A, P) {
    return isZonedDateTime(A) ? new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, {
      ...t,
      ...P,
      timeZone: A.timeZone
    }).formatToParts(toDate(A)) : new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, ...P }).formatToParts(toDate(A));
  }
  function w(A, P = "narrow") {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, { ...t, weekday: P }).format(A);
  }
  function C(A) {
    return new $fb18d541ea1ad717$export$ad991b66133851cf(n.value, {
      ...t,
      hour: "numeric",
      minute: "numeric"
    }).formatToParts(A).find((B) => B.type === "dayPeriod")?.value === "PM" ? "PM" : "AM";
  }
  const k = {
    year: "numeric",
    month: "numeric",
    day: "numeric",
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  };
  function E(A, P, M = {}) {
    const B = { ...k, ...M }, T = b(A, B).find((O) => O.type === P);
    return T ? T.value : "";
  }
  return {
    setLocale: o,
    getLocale: a,
    fullMonth: f,
    fullYear: v,
    fullMonthAndYear: d,
    toParts: b,
    custom: s,
    part: E,
    dayPeriod: C,
    selectedDate: u,
    dayOfWeek: w,
    getMonths: g
  };
}
function useCalendarState(e) {
  function t(a) {
    return Array.isArray(e.date.value) ? e.date.value.some((o) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(o, a)) : e.date.value ? $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.date.value, a) : !1;
  }
  const n = computed(
    () => {
      if (Array.isArray(e.date.value)) {
        if (!e.date.value.length)
          return !1;
        for (const a of e.date.value)
          if (e.isDateDisabled?.(a) || e.isDateUnavailable?.(a))
            return !0;
      } else {
        if (!e.date.value)
          return !1;
        if (e.isDateDisabled?.(e.date.value) || e.isDateUnavailable?.(e.date.value))
          return !0;
      }
      return !1;
    }
  );
  return {
    isDateSelected: t,
    isInvalid: n
  };
}
function handleNextDisabled(e, t) {
  const n = t(e), a = n.compare(e), o = {};
  return a >= 7 && (o.day = 1), a >= getDaysInMonth(e) && (o.month = 1), n.set({ ...o });
}
function handlePrevDisabled(e, t) {
  const n = t(e), a = e.compare(n), o = {};
  return a >= 7 && (o.day = 35), a >= getDaysInMonth(e) && (o.month = 13), n.set({ ...o });
}
function handleNextPage(e, t) {
  return t(e);
}
function handlePrevPage(e, t) {
  return t(e);
}
function useCalendar(e) {
  const t = useDateFormatter(e.locale.value), n = computed(() => {
    const E = {
      calendar: e.placeholder.value.calendar.identifier
    };
    return e.placeholder.value.calendar.identifier === "gregory" && e.placeholder.value.era === "BC" && (E.era = "short"), E;
  }), a = ref(createMonths({
    dateObj: e.placeholder.value,
    weekStartsOn: e.weekStartsOn.value,
    locale: e.locale.value,
    fixedWeeks: e.fixedWeeks.value,
    numberOfMonths: e.numberOfMonths.value
  })), o = computed(() => a.value.map((E) => E.value));
  function s(E) {
    return !o.value.some((A) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(E, A));
  }
  const u = (E) => {
    if (!e.maxValue.value || !a.value.length)
      return !1;
    if (e.disabled.value)
      return !0;
    const A = a.value[a.value.length - 1].value;
    if (!E && !e.nextPage.value) {
      const M = A.add({ months: 1 }).set({ day: 1 });
      return isAfter(M, e.maxValue.value);
    }
    const P = handleNextDisabled(A, E || e.nextPage.value);
    return isAfter(P, e.maxValue.value);
  }, d = (E) => {
    if (!e.minValue.value || !a.value.length)
      return !1;
    if (e.disabled.value)
      return !0;
    const A = a.value[0].value;
    if (!E && !e.prevPage.value) {
      const M = A.subtract({ months: 1 }).set({ day: 35 });
      return isBefore(M, e.minValue.value);
    }
    const P = handlePrevDisabled(A, E || e.prevPage.value);
    return isBefore(P, e.minValue.value);
  };
  function f(E) {
    return !!(e.isDateDisabled?.(E) || e.disabled.value || e.maxValue.value && isAfter(E, e.maxValue.value) || e.minValue.value && isBefore(E, e.minValue.value));
  }
  const g = (E) => !!e.isDateUnavailable?.(E), v = computed(() => a.value.length ? a.value[0].rows[0].map((E) => t.dayOfWeek(toDate(E), e.weekdayFormat.value)) : []), b = (E) => {
    const A = a.value[0].value;
    if (!E && !e.nextPage.value) {
      const _ = A.add({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), T = createMonths({
        dateObj: _,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = T, e.placeholder.value = T[0].value.set({ day: 1 });
      return;
    }
    const P = handleNextPage(A, E || e.nextPage.value), M = createMonths({
      dateObj: P,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = M;
    const B = {};
    if (!E) {
      const _ = M[0].value.compare(A);
      _ >= getDaysInMonth(A) && (B.day = 1), _ >= 365 && (B.month = 1);
    }
    e.placeholder.value = M[0].value.set({ ...B });
  }, w = (E) => {
    const A = a.value[0].value;
    if (!E && !e.prevPage.value) {
      const _ = A.subtract({ months: e.pagedNavigation.value ? e.numberOfMonths.value : 1 }), T = createMonths({
        dateObj: _,
        weekStartsOn: e.weekStartsOn.value,
        locale: e.locale.value,
        fixedWeeks: e.fixedWeeks.value,
        numberOfMonths: e.numberOfMonths.value
      });
      a.value = T, e.placeholder.value = T[0].value.set({ day: 1 });
      return;
    }
    const P = handlePrevPage(A, E || e.prevPage.value), M = createMonths({
      dateObj: P,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
    a.value = M;
    const B = {};
    if (!E) {
      const _ = A.compare(M[0].value);
      _ >= getDaysInMonth(A) && (B.day = 1), _ >= 365 && (B.month = 1);
    }
    e.placeholder.value = M[0].value.set({ ...B });
  };
  watch(e.placeholder, (E) => {
    o.value.some((A) => $14e0f24ef4ac5c92$export$5a8da0c44a3afdf2(A, E)) || (a.value = createMonths({
      dateObj: E,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    }));
  }), watch([e.locale, e.weekStartsOn, e.fixedWeeks, e.numberOfMonths], () => {
    a.value = createMonths({
      dateObj: e.placeholder.value,
      weekStartsOn: e.weekStartsOn.value,
      locale: e.locale.value,
      fixedWeeks: e.fixedWeeks.value,
      numberOfMonths: e.numberOfMonths.value
    });
  });
  const C = computed(() => {
    if (!a.value.length)
      return "";
    if (e.locale.value !== t.getLocale() && t.setLocale(e.locale.value), a.value.length === 1) {
      const O = a.value[0].value;
      return `${t.fullMonthAndYear(toDate(O), n.value)}`;
    }
    const E = toDate(a.value[0].value), A = toDate(a.value[a.value.length - 1].value), P = t.fullMonth(E, n.value), M = t.fullMonth(A, n.value), B = t.fullYear(E, n.value), _ = t.fullYear(A, n.value);
    return B === _ ? `${P} - ${M} ${_}` : `${P} ${B} - ${M} ${_}`;
  }), k = computed(() => `${e.calendarLabel.value ?? "Event Date"}, ${C.value}`);
  return {
    isDateDisabled: f,
    isDateUnavailable: g,
    isNextButtonDisabled: u,
    isPrevButtonDisabled: d,
    grid: a,
    weekdays: v,
    visibleView: o,
    isOutsideVisibleView: s,
    formatter: t,
    nextPage: b,
    prevPage: w,
    headingValue: C,
    fullCalendarLabel: k
  };
}
function usePrimitiveElement() {
  const e = ref(), t = computed(() => ["#text", "#comment"].includes(e.value?.$el.nodeName) ? e.value?.$el.nextElementSibling : unrefElement(e));
  return {
    primitiveElement: e,
    currentElement: t
  };
}
function useLocale(e) {
  const t = injectConfigProviderContext({
    locale: ref("en")
  });
  return computed(() => e?.value || t.locale?.value || "en");
}
const _hoisted_1$14 = { style: { border: "0px", clip: "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0px", position: "absolute", "white-space": "nowrap", width: "1px" } }, _hoisted_2$F = {
  role: "heading",
  "aria-level": "2"
}, [injectCalendarRootContext, provideCalendarRootContext] = createContext$2("CalendarRoot"), _sfc_main$4g = /* @__PURE__ */ defineComponent({
  __name: "CalendarRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    preventDeselect: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: !1 },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    initialFocus: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    dir: {},
    nextPage: {},
    prevPage: {},
    modelValue: {},
    multiple: { type: Boolean, default: !1 },
    disableDaysOutsideCurrentView: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { emit: t }) {
    const n = e, a = t, {
      disabled: o,
      readonly: s,
      initialFocus: u,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      multiple: b,
      minValue: w,
      maxValue: C,
      numberOfMonths: k,
      preventDeselect: E,
      isDateDisabled: A,
      isDateUnavailable: P,
      calendarLabel: M,
      defaultValue: B,
      nextPage: _,
      prevPage: T,
      dir: O,
      locale: I,
      disableDaysOutsideCurrentView: q
    } = toRefs(n), { primitiveElement: F, currentElement: W } = usePrimitiveElement(), K = useLocale(I), Z = useDirection(O), J = useVModel(n, "modelValue", a, {
      defaultValue: B.value,
      passive: n.modelValue === void 0
    }), re = getDefaultDate({
      defaultPlaceholder: n.placeholder,
      defaultValue: J.value,
      locale: n.locale
    }), V = useVModel(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? re.copy(),
      passive: n.placeholder === void 0
    });
    function ne(Se) {
      V.value = Se.copy();
    }
    const {
      fullCalendarLabel: Q,
      headingValue: z,
      isDateDisabled: X,
      isDateUnavailable: ue,
      isNextButtonDisabled: Be,
      isPrevButtonDisabled: te,
      weekdays: G,
      isOutsideVisibleView: ie,
      nextPage: oe,
      prevPage: ye,
      formatter: ve,
      grid: ke
    } = useCalendar({
      locale: K,
      placeholder: V,
      weekStartsOn: f,
      fixedWeeks: v,
      numberOfMonths: k,
      minValue: w,
      maxValue: C,
      disabled: o,
      weekdayFormat: g,
      pagedNavigation: d,
      isDateDisabled: A.value,
      isDateUnavailable: P.value,
      calendarLabel: M,
      nextPage: _,
      prevPage: T
    }), {
      isInvalid: Ae,
      isDateSelected: be
    } = useCalendarState({
      date: J,
      isDateDisabled: X,
      isDateUnavailable: ue
    });
    watch(J, (Se) => {
      if (Array.isArray(Se) && Se.length) {
        const ze = Se[Se.length - 1];
        ze && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(V.value, ze) && ne(ze);
      } else !Array.isArray(Se) && Se && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(V.value, Se) && ne(Se);
    });
    function Ie(Se) {
      if (b.value) {
        if (!J.value)
          J.value = [Se.copy()];
        else if (Array.isArray(J.value)) {
          if (J.value.findIndex((Ne) => $14e0f24ef4ac5c92$export$ea39ec197993aef0(Ne, Se)) === -1)
            J.value = [...J.value, Se];
          else if (!E.value) {
            const Ne = J.value.filter((tt) => !$14e0f24ef4ac5c92$export$ea39ec197993aef0(tt, Se));
            if (!Ne.length) {
              V.value = Se.copy(), J.value = void 0;
              return;
            }
            J.value = Ne.map((tt) => tt.copy());
          }
        }
      } else {
        if (!J.value) {
          J.value = Se.copy();
          return;
        }
        !E.value && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(J.value, Se) ? (V.value = Se.copy(), J.value = void 0) : J.value = Se.copy();
      }
    }
    return onMounted(() => {
      u.value && handleCalendarInitialFocus(W.value);
    }), provideCalendarRootContext({
      isDateUnavailable: ue,
      dir: Z,
      isDateDisabled: X,
      locale: K,
      formatter: ve,
      modelValue: J,
      placeholder: V,
      disabled: o,
      initialFocus: u,
      pagedNavigation: d,
      grid: ke,
      weekDays: G,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      multiple: b,
      numberOfMonths: k,
      readonly: s,
      preventDeselect: E,
      fullCalendarLabel: Q,
      headingValue: z,
      isInvalid: Ae,
      isDateSelected: be,
      isNextButtonDisabled: Be,
      isPrevButtonDisabled: te,
      isOutsideVisibleView: ie,
      nextPage: oe,
      prevPage: ye,
      parentElement: W,
      onPlaceholderChange: ne,
      onDateChange: Ie,
      disableDaysOutsideCurrentView: q
    }), (Se, ze) => (openBlock(), createBlock(unref(Primitive), {
      ref_key: "primitiveElement",
      ref: F,
      as: Se.as,
      "as-child": Se.asChild,
      role: "application",
      "aria-label": unref(Q),
      "data-readonly": unref(s) ? "" : void 0,
      "data-disabled": unref(o) ? "" : void 0,
      "data-invalid": unref(Ae) ? "" : void 0,
      dir: unref(Z)
    }, {
      default: withCtx(() => [
        renderSlot(Se.$slots, "default", {
          date: unref(V),
          grid: unref(ke),
          weekDays: unref(G),
          weekStartsOn: unref(f),
          locale: unref(K),
          fixedWeeks: unref(v),
          modelValue: unref(J)
        }),
        createElementVNode("div", _hoisted_1$14, [
          createElementVNode("div", _hoisted_2$F, toDisplayString(unref(Q)), 1)
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid", "dir"]));
  }
}), _sfc_main$4f = /* @__PURE__ */ defineComponent({
  __name: "CalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(e) {
    const t = injectCalendarRootContext();
    return (n, a) => (openBlock(), createBlock(unref(Primitive), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": unref(t).isDateSelected(n.date) ? !0 : void 0,
      "aria-disabled": unref(t).isDateDisabled(n.date) || unref(t).isDateUnavailable?.(n.date) || unref(t).disableDaysOutsideCurrentView.value,
      "data-disabled": unref(t).isDateDisabled(n.date) || unref(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]));
  }
}), SELECTOR = "[data-reka-calendar-cell-trigger]:not([data-outside-view]):not([data-outside-visible-view])";
function getSelectableCells(e) {
  return Array.from(e.querySelectorAll(SELECTOR)) ?? [];
}
function useKbd() {
  return {
    ALT: "Alt",
    ARROW_DOWN: "ArrowDown",
    ARROW_LEFT: "ArrowLeft",
    ARROW_RIGHT: "ArrowRight",
    ARROW_UP: "ArrowUp",
    BACKSPACE: "Backspace",
    CAPS_LOCK: "CapsLock",
    CONTROL: "Control",
    DELETE: "Delete",
    END: "End",
    ENTER: "Enter",
    ESCAPE: "Escape",
    F1: "F1",
    F10: "F10",
    F11: "F11",
    F12: "F12",
    F2: "F2",
    F3: "F3",
    F4: "F4",
    F5: "F5",
    F6: "F6",
    F7: "F7",
    F8: "F8",
    F9: "F9",
    HOME: "Home",
    META: "Meta",
    PAGE_DOWN: "PageDown",
    PAGE_UP: "PageUp",
    SHIFT: "Shift",
    SPACE: " ",
    TAB: "Tab",
    CTRL: "Control",
    ASTERISK: "*",
    SPACE_CODE: "Space"
  };
}
const _sfc_main$4e = /* @__PURE__ */ defineComponent({
  __name: "CalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = useKbd(), a = injectCalendarRootContext(), { primitiveElement: o, currentElement: s } = usePrimitiveElement(), u = computed(() => t.day.day.toLocaleString(a.locale.value)), d = computed(() => a.formatter.custom(toDate(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), f = computed(
      () => a.isDateUnavailable?.(t.day) ?? !1
    ), g = computed(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(t.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), v = computed(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(t.day, t.month)), b = computed(
      () => a.isOutsideVisibleView(t.day)
    ), w = computed(() => a.isDateDisabled(t.day) || a.disableDaysOutsideCurrentView.value && v.value), C = computed(() => !a.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(t.day, a.placeholder.value)), k = computed(() => a.isDateSelected(t.day));
    function E(M) {
      a.readonly.value || a.isDateDisabled(M) || a.isDateUnavailable?.(M) || a.onDateChange(M);
    }
    function A() {
      w.value || E(t.day);
    }
    function P(M) {
      if (w.value)
        return;
      M.preventDefault(), M.stopPropagation();
      const B = a.parentElement.value, _ = 7, T = a.dir.value === "rtl" ? -1 : 1;
      switch (M.code) {
        case n.ARROW_RIGHT:
          O(s.value, T);
          break;
        case n.ARROW_LEFT:
          O(s.value, -T);
          break;
        case n.ARROW_UP:
          O(s.value, -7);
          break;
        case n.ARROW_DOWN:
          O(s.value, _);
          break;
        case n.ENTER:
        case n.SPACE_CODE:
          E(t.day);
      }
      function O(I, q) {
        const F = getSelectableCells(B);
        if (!F.length)
          return;
        const K = F.indexOf(I) + q;
        if (K >= 0 && K < F.length) {
          F[K].hasAttribute("data-disabled") && O(F[K], q), F[K].focus();
          return;
        }
        if (K < 0) {
          if (a.isPrevButtonDisabled())
            return;
          a.prevPage(), nextTick(() => {
            const Z = getSelectableCells(B);
            if (!Z.length)
              return;
            if (!a.pagedNavigation.value && a.numberOfMonths.value > 1) {
              const V = getDaysInMonth(a.placeholder.value) - Math.abs(K);
              Z[V].hasAttribute("data-disabled") && O(Z[V], q), Z[V].focus();
              return;
            }
            const J = Z.length - Math.abs(K);
            Z[J].hasAttribute("data-disabled") && O(Z[J], q), Z[J].focus();
          });
          return;
        }
        if (K >= F.length) {
          if (a.isNextButtonDisabled())
            return;
          a.nextPage(), nextTick(() => {
            const Z = getSelectableCells(B);
            if (!Z.length)
              return;
            if (!a.pagedNavigation.value && a.numberOfMonths.value > 1) {
              const re = getDaysInMonth(
                a.placeholder.value.add({ months: a.numberOfMonths.value - 1 })
              ), V = K - F.length + (Z.length - re);
              Z[V].hasAttribute("data-disabled") && O(Z[V], q), Z[V].focus();
              return;
            }
            const J = K - F.length;
            Z[J].hasAttribute("data-disabled") && O(Z[J], q), Z[J].focus();
          });
        }
      }
    }
    return (M, B) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      ref_key: "primitiveElement",
      ref: o
    }, t, {
      role: "button",
      "aria-label": d.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-disabled": w.value || f.value ? !0 : void 0,
      "data-selected": k.value ? !0 : void 0,
      "data-value": M.day.toString(),
      "data-disabled": w.value ? "" : void 0,
      "data-unavailable": f.value ? "" : void 0,
      "data-today": g.value ? "" : void 0,
      "data-outside-view": v.value ? "" : void 0,
      "data-outside-visible-view": b.value ? "" : void 0,
      "data-focused": C.value ? "" : void 0,
      tabindex: C.value ? 0 : v.value || w.value ? void 0 : -1,
      onClick: A,
      onKeydown: [
        withKeys(P, ["up", "down", "left", "right", "space", "enter"]),
        B[0] || (B[0] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["enter"]))
      ]
    }), {
      default: withCtx(() => [
        renderSlot(M.$slots, "default", {
          dayValue: u.value,
          disabled: w.value,
          today: g.value,
          selected: k.value,
          outsideView: v.value,
          outsideVisibleView: b.value,
          unavailable: f.value
        }, () => [
          createTextVNode(toDisplayString(u.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-disabled", "data-selected", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-view", "data-outside-visible-view", "data-focused", "tabindex"]));
  }
}), _sfc_main$4d = /* @__PURE__ */ defineComponent({
  __name: "CalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(e) {
    const t = e, n = injectCalendarRootContext(), a = computed(() => n.disabled.value ? !0 : void 0), o = computed(() => n.readonly.value ? !0 : void 0);
    return (s, u) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o.value,
      "aria-disabled": a.value,
      "data-readonly": o.value && "",
      "data-disabled": a.value && ""
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]));
  }
}), _sfc_main$4c = /* @__PURE__ */ defineComponent({
  __name: "CalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$4b = /* @__PURE__ */ defineComponent({
  __name: "CalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, { "aria-hidden": "true" }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$4a = /* @__PURE__ */ defineComponent({
  __name: "CalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$49 = /* @__PURE__ */ defineComponent({
  __name: "CalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$48 = /* @__PURE__ */ defineComponent({
  __name: "CalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$47 = /* @__PURE__ */ defineComponent({
  __name: "CalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = injectCalendarRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      "data-disabled": unref(n).disabled.value ? "" : void 0
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {
          headingValue: unref(n).headingValue.value
        }, () => [
          createTextVNode(toDisplayString(unref(n).headingValue.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), _sfc_main$46 = /* @__PURE__ */ defineComponent({
  __name: "CalendarNext",
  props: {
    nextPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = computed(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = injectCalendarRootContext();
    return (o, s) => (openBlock(), createBlock(unref(Primitive), {
      as: t.as,
      "as-child": t.asChild,
      "aria-label": "Next page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: s[0] || (s[0] = (u) => unref(a).nextPage(t.nextPage))
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", { disabled: n.value }, () => [
          s[1] || (s[1] = createTextVNode(" Next page "))
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child", "type", "aria-disabled", "data-disabled", "disabled"]));
  }
}), _sfc_main$45 = /* @__PURE__ */ defineComponent({
  __name: "CalendarPrev",
  props: {
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = computed(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = injectCalendarRootContext();
    return (o, s) => (openBlock(), createBlock(unref(Primitive), {
      "aria-label": "Previous page",
      as: t.as,
      "as-child": t.asChild,
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: s[0] || (s[0] = (u) => unref(a).prevPage(t.prevPage))
    }, {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", { disabled: n.value }, () => [
          s[1] || (s[1] = createTextVNode(" Prev page "))
        ])
      ]),
      _: 3
    }, 8, ["as", "as-child", "type", "aria-disabled", "data-disabled", "disabled"]));
  }
});
function useFormControl(e) {
  return computed(() => toValue(e) ? !!unrefElement(e)?.closest("form") : !0);
}
const ITEM_DATA_ATTR = "data-reka-collection-item";
function useCollection(e = {}) {
  const { key: t = "", isProvider: n = !1 } = e, a = `${t}CollectionProvider`;
  let o;
  if (n) {
    const v = ref(/* @__PURE__ */ new Map());
    o = {
      collectionRef: ref(),
      itemMap: v
    }, provide(a, o);
  } else
    o = inject(a);
  const s = (v = !1) => {
    const b = o.collectionRef.value;
    if (!b)
      return [];
    const w = Array.from(b.querySelectorAll(`[${ITEM_DATA_ATTR}]`)), k = Array.from(o.itemMap.value.values()).sort(
      (E, A) => w.indexOf(E.ref) - w.indexOf(A.ref)
    );
    return v ? k : k.filter((E) => E.ref.dataset.disabled !== "");
  }, u = defineComponent({
    name: "CollectionSlot",
    setup(v, { slots: b }) {
      const { primitiveElement: w, currentElement: C } = usePrimitiveElement();
      return watch(C, () => {
        o.collectionRef.value = C.value;
      }), () => h(Slot, { ref: w }, b);
    }
  }), d = defineComponent({
    name: "CollectionItem",
    inheritAttrs: !1,
    props: {
      value: {
        // It accepts any value
        validator: () => !0
      }
    },
    setup(v, { slots: b, attrs: w }) {
      const { primitiveElement: C, currentElement: k } = usePrimitiveElement();
      return watchEffect((E) => {
        if (k.value) {
          const A = markRaw(k.value);
          o.itemMap.value.set(A, { ref: k.value, value: v.value }), E(() => o.itemMap.value.delete(A));
        }
      }), () => h(Slot, { ...w, [ITEM_DATA_ATTR]: "", ref: C }, b);
    }
  }), f = computed(() => Array.from(o.itemMap.value.values())), g = computed(() => o.itemMap.value.size);
  return { getItems: s, reactiveItems: f, itemMapSize: g, CollectionSlot: u, CollectionItem: d };
}
const ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus", EVENT_OPTIONS = { bubbles: !1, cancelable: !0 }, MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function getFocusIntent(e, t, n) {
  const a = getDirectionAwareKey(e.key, n);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(a)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(a)))
    return MAP_KEY_TO_FOCUS_INTENT[a];
}
function focusFirst(e, t = !1) {
  const n = getActiveElement();
  for (const a of e)
    if (a === n || (a.focus({ preventScroll: t }), getActiveElement() !== n))
      return;
}
function wrapArray$1(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
const [injectRovingFocusGroupContext, provideRovingFocusGroupContext] = createContext$2("RovingFocusGroup"), _sfc_main$44 = /* @__PURE__ */ defineComponent({
  __name: "RovingFocusGroup",
  props: {
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !1 },
    currentTabStopId: {},
    defaultCurrentTabStopId: {},
    preventScrollOnEntryFocus: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["entryFocus", "update:currentTabStopId"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { loop: s, orientation: u, dir: d } = toRefs(a), f = useDirection(d), g = useVModel(a, "currentTabStopId", o, {
      defaultValue: a.defaultCurrentTabStopId,
      passive: a.currentTabStopId === void 0
    }), v = ref(!1), b = ref(!1), w = ref(0), { getItems: C, CollectionSlot: k } = useCollection({ isProvider: !0 });
    function E(P) {
      const M = !b.value;
      if (P.currentTarget && P.target === P.currentTarget && M && !v.value) {
        const B = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
        if (P.currentTarget.dispatchEvent(B), o("entryFocus", B), !B.defaultPrevented) {
          const _ = C().map((q) => q.ref).filter((q) => q.dataset.disabled !== ""), T = _.find((q) => q.getAttribute("data-active") === ""), O = _.find(
            (q) => q.id === g.value
          ), I = [T, O, ..._].filter(
            Boolean
          );
          focusFirst(I, a.preventScrollOnEntryFocus);
        }
      }
      b.value = !1;
    }
    function A() {
      setTimeout(() => {
        b.value = !1;
      }, 1);
    }
    return t({
      getItems: C
    }), provideRovingFocusGroupContext({
      loop: s,
      dir: f,
      orientation: u,
      currentTabStopId: g,
      onItemFocus: (P) => {
        g.value = P;
      },
      onItemShiftTab: () => {
        v.value = !0;
      },
      onFocusableItemAdd: () => {
        w.value++;
      },
      onFocusableItemRemove: () => {
        w.value--;
      }
    }), (P, M) => (openBlock(), createBlock(unref(k), null, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          tabindex: v.value || w.value === 0 ? -1 : 0,
          "data-orientation": unref(u),
          as: P.as,
          "as-child": P.asChild,
          dir: unref(f),
          style: { outline: "none" },
          onMousedown: M[0] || (M[0] = (B) => b.value = !0),
          onMouseup: A,
          onFocus: E,
          onBlur: M[1] || (M[1] = (B) => v.value = !1)
        }, {
          default: withCtx(() => [
            renderSlot(P.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "as", "as-child", "dir"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$43 = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInputBubble",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(e) {
    const t = e, { primitiveElement: n, currentElement: a } = usePrimitiveElement(), o = computed(() => t.checked ?? t.value);
    return watch(o, (s, u) => {
      if (!a.value)
        return;
      const d = a.value, f = window.HTMLInputElement.prototype, v = Object.getOwnPropertyDescriptor(f, "value").set;
      if (v && s !== u) {
        const b = new Event("input", { bubbles: !0 }), w = new Event("change", { bubbles: !0 });
        v.call(d, s), d.dispatchEvent(b), d.dispatchEvent(w);
      }
    }), (s, u) => (openBlock(), createBlock(_sfc_main$4u, mergeProps({
      ref_key: "primitiveElement",
      ref: n
    }, { ...t, ...s.$attrs }, { as: "input" }), null, 16));
  }
}), _sfc_main$42 = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "VisuallyHiddenInput",
  props: {
    name: {},
    value: {},
    checked: { type: Boolean, default: void 0 },
    required: { type: Boolean },
    disabled: { type: Boolean },
    feature: { default: "fully-hidden" }
  },
  setup(e) {
    const t = e, n = computed(
      () => typeof t.value == "object" && Array.isArray(t.value) && t.value.length === 0 && t.required
    ), a = computed(() => typeof t.value == "string" || typeof t.value == "number" || typeof t.value == "boolean" ? [{ name: t.name, value: t.value }] : typeof t.value == "object" && Array.isArray(t.value) ? t.value.flatMap((o, s) => typeof o == "object" ? Object.entries(o).map(([u, d]) => ({ name: `[${t.name}][${s}][${u}]`, value: d })) : { name: `[${t.name}][${s}]`, value: o }) : t.value !== null && typeof t.value == "object" && !Array.isArray(t.value) ? Object.entries(t.value).map(([o, s]) => ({ name: `[${t.name}][${o}]`, value: s })) : []);
    return (o, s) => n.value ? (openBlock(), createBlock(_sfc_main$43, mergeProps({ key: o.name }, { ...t, ...o.$attrs }, {
      name: o.name,
      value: o.value
    }), null, 16, ["name", "value"])) : (openBlock(!0), createElementBlock(Fragment, { key: 1 }, renderList(a.value, (u) => (openBlock(), createBlock(_sfc_main$43, mergeProps({
      key: u.name,
      ref_for: !0
    }, { ...t, ...o.$attrs }, {
      name: u.name,
      value: u.value
    }), null, 16, ["name", "value"]))), 128));
  }
}), [injectCheckboxGroupRootContext, provideCheckboxGroupRootContext] = createContext$2("CheckboxGroupRoot"), _sfc_main$41 = /* @__PURE__ */ defineComponent({
  __name: "CheckboxGroupRoot",
  props: {
    defaultValue: {},
    modelValue: {},
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean },
    as: {},
    asChild: { type: Boolean },
    dir: {},
    orientation: {},
    loop: { type: Boolean },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o, rovingFocus: s, dir: u } = toRefs(n), d = useDirection(u), { primitiveElement: f, currentElement: g } = usePrimitiveElement(), v = useFormControl(g), b = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? [],
      passive: n.modelValue === void 0
    }), w = computed(() => s.value ? { loop: n.loop, dir: d.value, orientation: n.orientation } : {});
    return provideCheckboxGroupRootContext({
      modelValue: b,
      rovingFocus: s,
      disabled: o
    }), (C, k) => (openBlock(), createBlock(resolveDynamicComponent(unref(s) ? unref(_sfc_main$44) : unref(Primitive)), mergeProps({
      ref_key: "primitiveElement",
      ref: f,
      as: C.as,
      "as-child": C.asChild
    }, w.value), {
      default: withCtx(() => [
        renderSlot(C.$slots, "default"),
        unref(v) && C.name ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          name: C.name,
          value: unref(b),
          required: C.required
        }, null, 8, ["name", "value", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 16, ["as", "as-child"]));
  }
});
function isIndeterminate(e) {
  return e === "indeterminate";
}
function getState(e) {
  return isIndeterminate(e) ? "indeterminate" : e ? "checked" : "unchecked";
}
const _sfc_main$40 = /* @__PURE__ */ defineComponent({
  __name: "RovingFocusItem",
  props: {
    tabStopId: {},
    focusable: { type: Boolean, default: !0 },
    active: { type: Boolean },
    allowShiftKey: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = injectRovingFocusGroupContext(), a = useId(), o = computed(() => t.tabStopId || a), s = computed(
      () => n.currentTabStopId.value === o.value
    ), { getItems: u, CollectionItem: d } = useCollection();
    onMounted(() => {
      t.focusable && n.onFocusableItemAdd();
    }), onUnmounted(() => {
      t.focusable && n.onFocusableItemRemove();
    });
    function f(g) {
      if (g.key === "Tab" && g.shiftKey) {
        n.onItemShiftTab();
        return;
      }
      if (g.target !== g.currentTarget)
        return;
      const v = getFocusIntent(
        g,
        n.orientation.value,
        n.dir.value
      );
      if (v !== void 0) {
        if (g.metaKey || g.ctrlKey || g.altKey || !t.allowShiftKey && g.shiftKey)
          return;
        g.preventDefault();
        let b = [...u().map((w) => w.ref).filter((w) => w.dataset.disabled !== "")];
        if (v === "last")
          b.reverse();
        else if (v === "prev" || v === "next") {
          v === "prev" && b.reverse();
          const w = b.indexOf(
            g.currentTarget
          );
          b = n.loop.value ? wrapArray$1(b, w + 1) : b.slice(w + 1);
        }
        nextTick(() => focusFirst(b));
      }
    }
    return (g, v) => (openBlock(), createBlock(unref(d), null, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          tabindex: s.value ? 0 : -1,
          "data-orientation": unref(n).orientation.value,
          "data-active": g.active ? "" : void 0,
          "data-disabled": g.focusable ? void 0 : "",
          as: g.as,
          "as-child": g.asChild,
          onMousedown: v[0] || (v[0] = (b) => {
            g.focusable ? unref(n).onItemFocus(o.value) : b.preventDefault();
          }),
          onFocus: v[1] || (v[1] = (b) => unref(n).onItemFocus(o.value)),
          onKeydown: f
        }, {
          default: withCtx(() => [
            renderSlot(g.$slots, "default")
          ]),
          _: 3
        }, 8, ["tabindex", "data-orientation", "data-active", "data-disabled", "as", "as-child"])
      ]),
      _: 3
    }));
  }
}), [injectCheckboxRootContext, provideCheckboxRootContext] = createContext$2("CheckboxRoot"), _sfc_main$3$ = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "CheckboxRoot",
  props: {
    defaultValue: { type: [Boolean, String] },
    modelValue: { type: [Boolean, String, null], default: void 0 },
    disabled: { type: Boolean },
    value: { default: "on" },
    id: {},
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = injectCheckboxGroupRootContext(null), d = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), f = computed(() => u?.disabled.value || n.disabled), g = computed(() => isNullish$1(u?.modelValue.value) ? d.value === "indeterminate" ? "indeterminate" : d.value : isValueEqualOrExist(u.modelValue.value, n.value));
    function v() {
      if (isNullish$1(u?.modelValue.value))
        d.value = isIndeterminate(d.value) ? !0 : !d.value;
      else {
        const C = [...u.modelValue.value || []];
        if (isValueEqualOrExist(C, n.value)) {
          const k = C.findIndex((E) => isEqual(E, n.value));
          C.splice(k, 1);
        } else
          C.push(n.value);
        u.modelValue.value = C;
      }
    }
    const b = useFormControl(s), w = computed(() => n.id && s.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return provideCheckboxRootContext({
      disabled: f,
      state: g
    }), (C, k) => (openBlock(), createBlock(resolveDynamicComponent(unref(u)?.rovingFocus.value ? unref(_sfc_main$40) : unref(Primitive)), mergeProps(C.$attrs, {
      id: C.id,
      ref: unref(o),
      role: "checkbox",
      "as-child": C.asChild,
      as: C.as,
      type: C.as === "button" ? "button" : void 0,
      "aria-checked": unref(isIndeterminate)(g.value) ? "mixed" : g.value,
      "aria-required": C.required,
      "aria-label": C.$attrs["aria-label"] || w.value,
      "data-state": unref(getState)(g.value),
      "data-disabled": f.value ? "" : void 0,
      disabled: f.value,
      focusable: unref(u)?.rovingFocus.value ? !f.value : void 0,
      onKeydown: withKeys(withModifiers(() => {
      }, ["prevent"]), ["enter"]),
      onClick: v
    }), {
      default: withCtx(() => [
        renderSlot(C.$slots, "default", {
          modelValue: unref(d),
          state: g.value
        }),
        unref(b) && C.name && !unref(u) ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          type: "checkbox",
          checked: !!g.value,
          name: C.name,
          value: C.value,
          disabled: f.value,
          required: C.required
        }, null, 8, ["checked", "name", "value", "disabled", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 16, ["id", "as-child", "as", "type", "aria-checked", "aria-required", "aria-label", "data-state", "data-disabled", "disabled", "focusable", "onKeydown"]));
  }
}), _sfc_main$3_ = /* @__PURE__ */ defineComponent({
  __name: "CheckboxIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const { forwardRef: t } = useForwardExpose(), n = injectCheckboxRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Presence), {
      present: a.forceMount || unref(isIndeterminate)(unref(n).state.value) || unref(n).state.value === !0
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps({
          ref: unref(t),
          "data-state": unref(getState)(unref(n).state.value),
          "data-disabled": unref(n).disabled.value ? "" : void 0,
          style: { pointerEvents: "none" },
          "as-child": a.asChild,
          as: a.as
        }, a.$attrs), {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [injectPopperRootContext, providePopperRootContext] = createContext$2("PopperRoot"), _sfc_main$3Z = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "PopperRoot",
  setup(e) {
    const t = ref();
    return providePopperRootContext({
      anchor: t,
      onAnchorChange: (n) => t.value = n
    }), (n, a) => renderSlot(n.$slots, "default");
  }
}), _sfc_main$3Y = /* @__PURE__ */ defineComponent({
  __name: "PopperAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = useForwardExpose(), o = injectPopperRootContext();
    return watchPostEffect(() => {
      o.onAnchorChange(t.reference ?? a.value);
    }), (s, u) => (openBlock(), createBlock(unref(Primitive), {
      ref: unref(n),
      as: s.as,
      "as-child": s.asChild
    }, {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child"]));
  }
}), _sfc_main$3X = /* @__PURE__ */ defineComponent({
  __name: "ComboboxAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const { forwardRef: t } = useForwardExpose();
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3Y), {
      "as-child": "",
      reference: n.reference
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps({
          ref: unref(t),
          "as-child": n.asChild,
          as: n.as
        }, n.$attrs), {
          default: withCtx(() => [
            renderSlot(n.$slots, "default")
          ]),
          _: 3
        }, 16, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["reference"]));
  }
}), _hoisted_1$13 = {
  key: 0,
  d: "M0 0L6 6L12 0"
}, _hoisted_2$E = {
  key: 1,
  d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0"
}, _sfc_main$3W = /* @__PURE__ */ defineComponent({
  __name: "Arrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      width: n.width,
      height: n.height,
      viewBox: n.asChild ? void 0 : "0 0 12 6",
      preserveAspectRatio: n.asChild ? void 0 : "none"
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default", {}, () => [
          n.rounded ? (openBlock(), createElementBlock("path", _hoisted_2$E)) : (openBlock(), createElementBlock("path", _hoisted_1$13))
        ])
      ]),
      _: 3
    }, 16, ["width", "height", "viewBox", "preserveAspectRatio"]));
  }
});
function isNotNull$2(e) {
  return e !== null;
}
function transformOrigin(e) {
  return {
    name: "transformOrigin",
    options: e,
    fn(t) {
      const { placement: n, rects: a, middlewareData: o } = t, u = o.arrow?.centerOffset !== 0, d = u ? 0 : e.arrowWidth, f = u ? 0 : e.arrowHeight, [g, v] = getSideAndAlignFromPlacement(n), b = { start: "0%", center: "50%", end: "100%" }[v], w = (o.arrow?.x ?? 0) + d / 2, C = (o.arrow?.y ?? 0) + f / 2;
      let k = "", E = "";
      return g === "bottom" ? (k = u ? b : `${w}px`, E = `${-f}px`) : g === "top" ? (k = u ? b : `${w}px`, E = `${a.floating.height + f}px`) : g === "right" ? (k = `${-f}px`, E = u ? b : `${C}px`) : g === "left" && (k = `${a.floating.width + f}px`, E = u ? b : `${C}px`), { data: { x: k, y: E } };
    }
  };
}
function getSideAndAlignFromPlacement(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
function useSize(e) {
  const t = ref(), n = computed(() => t.value?.width ?? 0), a = computed(() => t.value?.height ?? 0);
  return onMounted(() => {
    const o = unrefElement(e);
    if (o) {
      t.value = { width: o.offsetWidth, height: o.offsetHeight };
      const s = new ResizeObserver((u) => {
        if (!Array.isArray(u) || !u.length)
          return;
        const d = u[0];
        let f, g;
        if ("borderBoxSize" in d) {
          const v = d.borderBoxSize, b = Array.isArray(v) ? v[0] : v;
          f = b.inlineSize, g = b.blockSize;
        } else
          f = o.offsetWidth, g = o.offsetHeight;
        t.value = { width: f, height: g };
      });
      return s.observe(o, { box: "border-box" }), () => s.unobserve(o);
    } else
      t.value = void 0;
  }), {
    width: n,
    height: a
  };
}
const PopperContentPropsDefaultValue = {
  side: "bottom",
  sideOffset: 0,
  align: "center",
  alignOffset: 0,
  arrowPadding: 0,
  avoidCollisions: !0,
  collisionBoundary: () => [],
  collisionPadding: 0,
  sticky: "partial",
  hideWhenDetached: !1,
  positionStrategy: "fixed",
  updatePositionStrategy: "optimized",
  prioritizePosition: !1
}, [injectPopperContentContext, providePopperContentContext] = createContext$2("PopperContent"), _sfc_main$3V = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "PopperContent",
  props: /* @__PURE__ */ mergeDefaults({
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["placed"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectPopperRootContext(), { forwardRef: s, currentElement: u } = useForwardExpose(), d = ref(), f = ref(), { width: g, height: v } = useSize(f), b = computed(
      () => n.side + (n.align !== "center" ? `-${n.align}` : "")
    ), w = computed(() => typeof n.collisionPadding == "number" ? n.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...n.collisionPadding }), C = computed(() => Array.isArray(n.collisionBoundary) ? n.collisionBoundary : [n.collisionBoundary]), k = computed(() => ({
      padding: w.value,
      boundary: C.value.filter(isNotNull$2),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: C.value.length > 0
    })), E = computedEager(() => [
      offset({
        mainAxis: n.sideOffset + v.value,
        alignmentAxis: n.alignOffset
      }),
      n.prioritizePosition && n.avoidCollisions && flip({
        ...k.value
      }),
      n.avoidCollisions && shift({
        mainAxis: !0,
        crossAxis: !!n.prioritizePosition,
        limiter: n.sticky === "partial" ? limitShift() : void 0,
        ...k.value
      }),
      !n.prioritizePosition && n.avoidCollisions && flip({
        ...k.value
      }),
      size({
        ...k.value,
        apply: ({ elements: K, rects: Z, availableWidth: J, availableHeight: re }) => {
          const { width: V, height: ne } = Z.reference, Q = K.floating.style;
          Q.setProperty(
            "--reka-popper-available-width",
            `${J}px`
          ), Q.setProperty(
            "--reka-popper-available-height",
            `${re}px`
          ), Q.setProperty(
            "--reka-popper-anchor-width",
            `${V}px`
          ), Q.setProperty(
            "--reka-popper-anchor-height",
            `${ne}px`
          );
        }
      }),
      f.value && arrow({ element: f.value, padding: n.arrowPadding }),
      transformOrigin({
        arrowWidth: g.value,
        arrowHeight: v.value
      }),
      n.hideWhenDetached && hide({ strategy: "referenceHidden", ...k.value })
    ]), A = computed(() => n.reference ?? o.anchor.value), { floatingStyles: P, placement: M, isPositioned: B, middlewareData: _ } = useFloating(
      A,
      d,
      {
        strategy: n.positionStrategy,
        placement: b,
        whileElementsMounted: (...K) => autoUpdate(...K, {
          layoutShift: !n.disableUpdateOnLayoutShift,
          animationFrame: n.updatePositionStrategy === "always"
        }),
        middleware: E
      }
    ), T = computed(
      () => getSideAndAlignFromPlacement(M.value)[0]
    ), O = computed(
      () => getSideAndAlignFromPlacement(M.value)[1]
    );
    watchPostEffect(() => {
      B.value && a("placed");
    });
    const I = computed(
      () => _.value.arrow?.centerOffset !== 0
    ), q = ref("");
    watchEffect(() => {
      u.value && (q.value = window.getComputedStyle(u.value).zIndex);
    });
    const F = computed(() => _.value.arrow?.x ?? 0), W = computed(() => _.value.arrow?.y ?? 0);
    return providePopperContentContext({
      placedSide: T,
      onArrowChange: (K) => f.value = K,
      arrowX: F,
      arrowY: W,
      shouldHideArrow: I
    }), (K, Z) => (openBlock(), createElementBlock("div", {
      ref_key: "floatingRef",
      ref: d,
      "data-reka-popper-content-wrapper": "",
      style: normalizeStyle({
        ...unref(P),
        transform: unref(B) ? unref(P).transform : "translate(0, -200%)",
        // keep off the page when measuring
        minWidth: "max-content",
        zIndex: q.value,
        "--reka-popper-transform-origin": [
          unref(_).transformOrigin?.x,
          unref(_).transformOrigin?.y
        ].join(" "),
        // hide the content if using the hide middleware and should be hidden
        // set visibility to hidden and disable pointer events so the UI behaves
        // as if the PopperContent isn't there at all
        ...unref(_).hide?.referenceHidden && {
          visibility: "hidden",
          pointerEvents: "none"
        }
      })
    }, [
      createVNode(unref(Primitive), mergeProps({ ref: unref(s) }, K.$attrs, {
        "as-child": n.asChild,
        as: K.as,
        "data-side": T.value,
        "data-align": O.value,
        style: {
          // if the PopperContent hasn't been placed yet (not all measurements done)
          // we prevent animations so that users's animation don't kick in too early referring wrong sides
          animation: unref(B) ? void 0 : "none"
        }
      }), {
        default: withCtx(() => [
          renderSlot(K.$slots, "default")
        ]),
        _: 3
      }, 16, ["as-child", "as", "data-side", "data-align", "style"])
    ], 4));
  }
}), OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, _sfc_main$3U = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "PopperArrow",
  props: {
    width: {},
    height: {},
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(e) {
    const { forwardRef: t } = useForwardExpose(), n = injectPopperContentContext(), a = computed(() => OPPOSITE_SIDE[n.placedSide.value]);
    return (o, s) => (openBlock(), createElementBlock("span", {
      ref: (u) => {
        unref(n).onArrowChange(u);
      },
      style: normalizeStyle({
        position: "absolute",
        left: unref(n).arrowX?.value ? `${unref(n).arrowX?.value}px` : void 0,
        top: unref(n).arrowY?.value ? `${unref(n).arrowY?.value}px` : void 0,
        [a.value]: 0,
        transformOrigin: {
          top: "",
          right: "0 0",
          bottom: "center 0",
          left: "100% 0"
        }[unref(n).placedSide.value],
        transform: {
          top: "translateY(100%)",
          right: "translateY(50%) rotate(90deg) translateX(-50%)",
          bottom: "rotate(180deg)",
          left: "translateY(50%) rotate(-90deg) translateX(50%)"
        }[unref(n).placedSide.value],
        visibility: unref(n).shouldHideArrow.value ? "hidden" : void 0
      })
    }, [
      createVNode(_sfc_main$3W, mergeProps(o.$attrs, {
        ref: unref(t),
        style: {
          display: "block"
        },
        as: o.as,
        "as-child": o.asChild,
        rounded: o.rounded,
        width: o.width,
        height: o.height
      }), {
        default: withCtx(() => [
          renderSlot(o.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "rounded", "width", "height"])
    ], 4));
  }
});
function useFilter(e) {
  const t = computed(() => unref(e)), n = computed(() => new Intl.Collator("en", { usage: "search", ...t.value }));
  return {
    startsWith: (u, d) => d.length === 0 ? !0 : (u = u.normalize("NFC"), d = d.normalize("NFC"), n.value.compare(u.slice(0, d.length), d) === 0),
    endsWith: (u, d) => d.length === 0 ? !0 : (u = u.normalize("NFC"), d = d.normalize("NFC"), n.value.compare(u.slice(-d.length), d) === 0),
    contains: (u, d) => {
      if (d.length === 0)
        return !0;
      u = u.normalize("NFC"), d = d.normalize("NFC");
      let f = 0;
      const g = d.length;
      for (; f + g <= u.length; f++) {
        const v = u.slice(f, f + g);
        if (n.value.compare(d, v) === 0)
          return !0;
      }
      return !1;
    }
  };
}
function valueComparator(e, t, n) {
  return e === void 0 ? !1 : Array.isArray(e) ? e.some((a) => compare$1(a, t, n)) : compare$1(e, t, n);
}
function compare$1(e, t, n) {
  return e === void 0 || t === void 0 ? !1 : typeof e == "string" ? e === t : typeof n == "function" ? n(e, t) : typeof n == "string" ? e?.[n] === t?.[n] : isEqual(e, t);
}
function useTypeahead(e) {
  const t = refAutoReset("", 1e3);
  return {
    search: t,
    handleTypeaheadSearch: (o, s) => {
      t.value = t.value + o;
      {
        const u = getActiveElement(), d = s.map((w) => ({
          ...w,
          textValue: w.value?.textValue ?? w.ref.textContent?.trim() ?? ""
        })), f = d.find((w) => w.ref === u), g = d.map((w) => w.textValue), v = getNextMatch(g, t.value, f?.textValue), b = d.find((w) => w.textValue === v);
        return b && b.ref.focus(), b?.ref;
      }
    },
    resetTypeahead: () => {
      t.value = "";
    }
  };
}
function wrapArray(e, t) {
  return e.map((n, a) => e[(t + a) % e.length]);
}
function getNextMatch(e, t, n) {
  const o = t.length > 1 && Array.from(t).every((g) => g === t[0]) ? t[0] : t, s = n ? e.indexOf(n) : -1;
  let u = wrapArray(e, Math.max(s, 0));
  o.length === 1 && (u = u.filter((g) => g !== n));
  const f = u.find(
    (g) => g.toLowerCase().startsWith(o.toLowerCase())
  );
  return f !== n ? f : void 0;
}
function areEqual(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function findValuesBetween(e, t, n) {
  const a = e.findIndex((d) => isEqual(d, t)), o = e.findIndex((d) => isEqual(d, n));
  if (a === -1 || o === -1)
    return [];
  const [s, u] = [a, o].sort((d, f) => d - f);
  return e.slice(s, u + 1);
}
const [injectListboxRootContext, provideListboxRootContext] = createContext$2("ListboxRoot"), _sfc_main$3T = /* @__PURE__ */ defineComponent({
  __name: "ListboxRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    orientation: { default: "vertical" },
    dir: {},
    disabled: { type: Boolean },
    selectionBehavior: { default: "toggle" },
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "entryFocus", "leave"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { multiple: s, highlightOnHover: u, orientation: d, disabled: f, selectionBehavior: g, dir: v } = toRefs(a), { getItems: b } = useCollection({ isProvider: !0 }), { handleTypeaheadSearch: w } = useTypeahead(), { primitiveElement: C, currentElement: k } = usePrimitiveElement(), E = useKbd(), A = useDirection(v), P = useFormControl(k), M = ref(), B = ref(!1), _ = ref(!0), T = useVModel(a, "modelValue", o, {
      defaultValue: a.defaultValue ?? (s.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    });
    function O(ve) {
      if (B.value = !0, a.multiple) {
        const ke = Array.isArray(T.value) ? [...T.value] : [], Ae = ke.findIndex((be) => compare$1(be, ve, a.by));
        a.selectionBehavior === "toggle" ? (Ae === -1 ? ke.push(ve) : ke.splice(Ae, 1), T.value = ke) : (T.value = [ve], M.value = ve);
      } else
        a.selectionBehavior === "toggle" && compare$1(T.value, ve, a.by) ? T.value = void 0 : T.value = ve;
      setTimeout(() => {
        B.value = !1;
      }, 1);
    }
    const I = ref(null), q = ref(null), F = ref(!1), W = ref(!1), K = createEventHook(), Z = createEventHook(), J = createEventHook();
    function re() {
      return b().map((ve) => ve.ref).filter((ve) => ve.dataset.disabled !== "");
    }
    function V(ve, ke = !0) {
      if (!ve)
        return;
      I.value = ve, _.value && I.value.focus(), ke && I.value.scrollIntoView({ block: "nearest" });
      const Ae = b().find((be) => be.ref === ve);
      o("highlight", Ae);
    }
    function ne(ve) {
      if (F.value)
        J.trigger(ve);
      else {
        const ke = b().find((Ae) => compare$1(Ae.value, ve, a.by));
        ke && (I.value = ke.ref, V(ke.ref));
      }
    }
    function Q(ve) {
      I.value && I.value.isConnected && (ve.preventDefault(), ve.stopPropagation(), W.value || I.value.click());
    }
    function z(ve) {
      if (_.value) {
        if (B.value = !0, F.value)
          Z.trigger(ve);
        else {
          const ke = ve.altKey || ve.ctrlKey || ve.metaKey;
          if (ke && ve.key === "a" && s.value) {
            const Ae = b(), be = Ae.map((Ie) => Ie.value);
            T.value = [...be], ve.preventDefault(), V(Ae[Ae.length - 1].ref);
          } else if (!ke) {
            const Ae = w(ve.key, b());
            Ae && V(Ae);
          }
        }
        setTimeout(() => {
          B.value = !1;
        }, 1);
      }
    }
    function X() {
      W.value = !0;
    }
    function ue() {
      requestAnimationFrame(() => {
        W.value = !1;
      });
    }
    function Be() {
      nextTick(() => {
        const ve = new KeyboardEvent("keydown", { key: "PageUp" });
        ie(ve);
      });
    }
    function te(ve) {
      const ke = I.value;
      ke?.isConnected && (q.value = ke), I.value = null, o("leave", ve);
    }
    function G(ve) {
      const ke = new CustomEvent("listbox.entryFocus", { bubbles: !1, cancelable: !0 });
      if (ve.currentTarget?.dispatchEvent(ke), o("entryFocus", ke), !ke.defaultPrevented)
        if (q.value)
          V(q.value);
        else {
          const Ae = re()?.[0];
          V(Ae);
        }
    }
    function ie(ve) {
      const ke = getFocusIntent(ve, d.value, A.value);
      if (!ke)
        return;
      let Ae = re();
      if (I.value) {
        if (ke === "last")
          Ae.reverse();
        else if (ke === "prev" || ke === "next") {
          ke === "prev" && Ae.reverse();
          const be = Ae.indexOf(I.value);
          Ae = Ae.slice(be + 1);
        }
        oe(ve, Ae[0]);
      }
      if (Ae.length) {
        const be = !I.value && ke === "prev" ? Ae.length - 1 : 0;
        V(Ae[be]);
      }
      if (F.value)
        return Z.trigger(ve);
    }
    function oe(ve, ke) {
      if (!(F.value || a.selectionBehavior !== "replace" || !s.value || !Array.isArray(T.value) || (ve.altKey || ve.ctrlKey || ve.metaKey) && !ve.shiftKey) && ve.shiftKey) {
        const be = b().filter((ze) => ze.ref.dataset.disabled !== "");
        let Ie = be.find((ze) => ze.ref === ke)?.value;
        if (ve.key === E.END ? Ie = be[be.length - 1].value : ve.key === E.HOME && (Ie = be[0].value), !Ie || !M.value)
          return;
        const Se = findValuesBetween(be.map((ze) => ze.value), M.value, Ie);
        T.value = Se;
      }
    }
    async function ye(ve) {
      if (await nextTick(), F.value)
        K.trigger(ve);
      else {
        const ke = re(), Ae = ke.find((be) => be.dataset.state === "checked");
        Ae ? V(Ae) : ke.length && V(ke[0]);
      }
    }
    return watch(T, () => {
      B.value || nextTick(() => {
        ye();
      });
    }, { immediate: !0, deep: !0 }), t({
      highlightedElement: I,
      highlightItem: ne,
      highlightFirstItem: Be,
      highlightSelected: ye,
      getItems: b
    }), provideListboxRootContext({
      modelValue: T,
      // @ts-expect-error ignoring
      onValueChange: O,
      multiple: s,
      orientation: d,
      dir: A,
      disabled: f,
      highlightOnHover: u,
      highlightedElement: I,
      isVirtual: F,
      virtualFocusHook: K,
      virtualKeydownHook: Z,
      virtualHighlightHook: J,
      by: a.by,
      firstValue: M,
      selectionBehavior: g,
      focusable: _,
      onLeave: te,
      onEnter: G,
      changeHighlight: V,
      onKeydownEnter: Q,
      onKeydownNavigation: ie,
      onKeydownTypeAhead: z,
      onCompositionStart: X,
      onCompositionEnd: ue,
      highlightFirstItem: Be
    }), (ve, ke) => (openBlock(), createBlock(unref(Primitive), {
      ref_key: "primitiveElement",
      ref: C,
      as: ve.as,
      "as-child": ve.asChild,
      dir: unref(A),
      "data-disabled": unref(f) ? "" : void 0,
      onPointerleave: te,
      onFocusout: ke[0] || (ke[0] = async (Ae) => {
        const be = Ae.relatedTarget || Ae.target;
        await nextTick(), I.value && unref(k) && !unref(k).contains(be) && te(Ae);
      })
    }, {
      default: withCtx(() => [
        renderSlot(ve.$slots, "default", { modelValue: unref(T) }),
        unref(P) && ve.name ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          name: ve.name,
          value: unref(T),
          disabled: unref(f),
          required: ve.required
        }, null, 8, ["name", "value", "disabled", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["as", "as-child", "dir", "data-disabled"]));
  }
}), [injectComboboxRootContext, provideComboboxRootContext] = createContext$2("ComboboxRoot"), _sfc_main$3S = /* @__PURE__ */ defineComponent({
  __name: "ComboboxRoot",
  props: {
    open: { type: Boolean, default: void 0 },
    defaultOpen: { type: Boolean },
    resetSearchTermOnBlur: { type: Boolean, default: !0 },
    resetSearchTermOnSelect: { type: Boolean, default: !0 },
    ignoreFilter: { type: Boolean },
    modelValue: {},
    defaultValue: {},
    multiple: { type: Boolean },
    dir: {},
    disabled: { type: Boolean },
    highlightOnHover: { type: Boolean },
    by: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "highlight", "update:open"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { primitiveElement: s, currentElement: u } = usePrimitiveElement(), { multiple: d, disabled: f, ignoreFilter: g, resetSearchTermOnSelect: v, dir: b } = toRefs(a), w = useDirection(b), C = useVModel(a, "modelValue", o, {
      defaultValue: a.defaultValue ?? (d.value ? [] : void 0),
      passive: a.modelValue === void 0,
      deep: !0
    }), k = useVModel(a, "open", o, {
      defaultValue: a.defaultOpen,
      passive: a.open === void 0
    });
    async function E(Z) {
      k.value = Z, F.value = "", Z ? (await nextTick(), s.value?.highlightSelected(), P.value = !0) : P.value = !1, B.value?.focus(), setTimeout(() => {
        !Z && a.resetSearchTermOnBlur && A.trigger();
      }, 1);
    }
    const A = createEventHook(), P = ref(!1), M = ref(!1), B = ref(), _ = ref(), T = computed(() => s.value?.highlightedElement ?? void 0), O = ref(/* @__PURE__ */ new Map()), I = ref(/* @__PURE__ */ new Map()), { contains: q } = useFilter({ sensitivity: "base" }), F = ref(""), W = computed((Z) => {
      if (!F.value || a.ignoreFilter || M.value)
        return {
          count: O.value.size,
          items: Z?.items ?? /* @__PURE__ */ new Map(),
          groups: Z?.groups ?? new Set(I.value.keys())
        };
      let J = 0;
      const re = /* @__PURE__ */ new Map(), V = /* @__PURE__ */ new Set();
      for (const [ne, Q] of O.value) {
        const z = q(Q, F.value);
        re.set(ne, z ? 1 : 0), z && J++;
      }
      for (const [ne, Q] of I.value)
        for (const z of Q)
          if (re.get(z) > 0) {
            V.add(ne);
            break;
          }
      return {
        count: J,
        items: re,
        groups: V
      };
    }), K = getCurrentInstance();
    return onMounted(() => {
      K?.exposed && (K.exposed.highlightItem = s.value?.highlightItem, K.exposed.highlightFirstItem = s.value?.highlightFirstItem, K.exposed.highlightSelected = s.value?.highlightSelected);
    }), t({
      filtered: W,
      highlightedElement: T,
      highlightItem: s.value?.highlightItem,
      highlightFirstItem: s.value?.highlightFirstItem,
      highlightSelected: s.value?.highlightSelected
    }), provideComboboxRootContext({
      modelValue: C,
      multiple: d,
      disabled: f,
      open: k,
      onOpenChange: E,
      contentId: "",
      isUserInputted: P,
      isVirtual: M,
      inputElement: B,
      highlightedElement: T,
      onInputElementChange: (Z) => B.value = Z,
      triggerElement: _,
      onTriggerElementChange: (Z) => _.value = Z,
      parentElement: u,
      resetSearchTermOnSelect: v,
      onResetSearchTerm: A.on,
      allItems: O,
      allGroups: I,
      filterSearch: F,
      filterState: W,
      ignoreFilter: g
    }), (Z, J) => (openBlock(), createBlock(unref(_sfc_main$3Z), null, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$3T), mergeProps({
          ref_key: "primitiveElement",
          ref: s
        }, Z.$attrs, {
          modelValue: unref(C),
          "onUpdate:modelValue": J[0] || (J[0] = (re) => isRef(C) ? C.value = re : null),
          style: {
            pointerEvents: unref(k) ? "auto" : void 0
          },
          as: Z.as,
          "as-child": Z.asChild,
          dir: unref(w),
          multiple: unref(d),
          name: Z.name,
          required: Z.required,
          disabled: unref(f),
          "highlight-on-hover": !0,
          by: a.by,
          onHighlight: J[1] || (J[1] = (re) => o("highlight", re))
        }), {
          default: withCtx(() => [
            renderSlot(Z.$slots, "default", {
              open: unref(k),
              modelValue: unref(C)
            })
          ]),
          _: 3
        }, 16, ["modelValue", "style", "as", "as-child", "dir", "multiple", "name", "required", "disabled", "by"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$3R = /* @__PURE__ */ defineComponent({
  __name: "ListboxContent",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const { CollectionSlot: t } = useCollection(), n = injectListboxRootContext(), a = refAutoReset(!1, 10);
    return (o, s) => (openBlock(), createBlock(unref(t), null, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          role: "listbox",
          as: o.as,
          "as-child": o.asChild,
          tabindex: unref(n).focusable.value ? unref(n).highlightedElement.value ? "-1" : "0" : void 0,
          "aria-orientation": unref(n).orientation.value,
          "aria-multiselectable": !!unref(n).multiple.value,
          "data-orientation": unref(n).orientation.value,
          onMousedown: s[0] || (s[0] = withModifiers((u) => a.value = !0, ["left"])),
          onFocus: s[1] || (s[1] = (u) => {
            unref(a) || unref(n).onEnter(u);
          }),
          onKeydown: [
            s[2] || (s[2] = withKeys(withModifiers((u) => {
              unref(n).focusable.value && unref(n).onKeydownNavigation(u);
            }, ["prevent"]), ["down", "up", "left", "right", "home", "end"])),
            withKeys(unref(n).onKeydownEnter, ["enter"]),
            unref(n).onKeydownTypeAhead
          ]
        }, {
          default: withCtx(() => [
            renderSlot(o.$slots, "default")
          ]),
          _: 3
        }, 8, ["as", "as-child", "tabindex", "aria-orientation", "aria-multiselectable", "data-orientation", "onKeydown"])
      ]),
      _: 3
    }));
  }
}), [injectComboboxContentContext, provideComboboxContentContext] = createContext$2("ComboboxContent"), _sfc_main$3Q = /* @__PURE__ */ defineComponent({
  __name: "ComboboxContentImpl",
  props: {
    position: { default: "inline" },
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, { position: o } = toRefs(n), s = injectComboboxRootContext(), { forwardRef: u, currentElement: d } = useForwardExpose();
    useBodyScrollLock(n.bodyLock), useHideOthers(s.parentElement);
    const f = computed(() => n.position === "popper" ? n : {}), g = useForwardProps(f.value), v = {
      // Ensure border-box for floating-ui calculations
      boxSizing: "border-box",
      "--reka-combobox-content-transform-origin": "var(--reka-popper-transform-origin)",
      "--reka-combobox-content-available-width": "var(--reka-popper-available-width)",
      "--reka-combobox-content-available-height": "var(--reka-popper-available-height)",
      "--reka-combobox-trigger-width": "var(--reka-popper-anchor-width)",
      "--reka-combobox-trigger-height": "var(--reka-popper-anchor-height)"
    };
    provideComboboxContentContext({ position: o });
    const b = ref(!1);
    return onMounted(() => {
      s.inputElement.value && (b.value = d.value.contains(s.inputElement.value), b.value && s.inputElement.value.focus());
    }), onUnmounted(() => {
      b.value && s.triggerElement.value?.focus();
    }), (w, C) => (openBlock(), createBlock(unref(_sfc_main$3R), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$4q), {
          "as-child": "",
          "disable-outside-pointer-events": w.disableOutsidePointerEvents,
          onDismiss: C[0] || (C[0] = (k) => unref(s).onOpenChange(!1)),
          onFocusOutside: C[1] || (C[1] = (k) => {
            unref(s).parentElement.value?.contains(k.target) && k.preventDefault(), a("focusOutside", k);
          }),
          onInteractOutside: C[2] || (C[2] = (k) => a("interactOutside", k)),
          onEscapeKeyDown: C[3] || (C[3] = (k) => a("escapeKeyDown", k)),
          onPointerDownOutside: C[4] || (C[4] = (k) => {
            unref(s).parentElement.value?.contains(k.target) && k.preventDefault(), a("pointerDownOutside", k);
          })
        }, {
          default: withCtx(() => [
            (openBlock(), createBlock(resolveDynamicComponent(unref(o) === "popper" ? unref(_sfc_main$3V) : unref(Primitive)), mergeProps({ ...w.$attrs, ...unref(g) }, {
              id: unref(s).contentId,
              ref: unref(u),
              "data-state": unref(s).open.value ? "open" : "closed",
              style: {
                // flex layout so we can place the scroll buttons properly
                display: "flex",
                flexDirection: "column",
                // reset the outline by default as the content MAY get focused
                outline: "none",
                ...unref(o) === "popper" ? v : {}
              }
            }), {
              default: withCtx(() => [
                renderSlot(w.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "style"]))
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$3P = /* @__PURE__ */ defineComponent({
  __name: "ComboboxContent",
  props: {
    forceMount: { type: Boolean },
    position: {},
    bodyLock: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside"],
  setup(e, { emit: t }) {
    const o = useForwardPropsEmits(e, t), { forwardRef: s } = useForwardExpose(), u = injectComboboxRootContext();
    return u.contentId ||= useId(void 0, "reka-combobox-content"), (d, f) => (openBlock(), createBlock(unref(Presence), {
      present: d.forceMount || unref(u).open.value
    }, {
      default: withCtx(() => [
        createVNode(_sfc_main$3Q, mergeProps({ ...unref(o), ...d.$attrs }, { ref: unref(s) }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), _sfc_main$3O = /* @__PURE__ */ defineComponent({
  __name: "ComboboxEmpty",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectComboboxRootContext(), a = computed(
      () => n.ignoreFilter.value ? n.allItems.value.size === 0 : n.filterState.value.count === 0
    );
    return (o, s) => a.value ? (openBlock(), createBlock(unref(Primitive), normalizeProps(mergeProps({ key: 0 }, t)), {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", {}, () => [
          s[0] || (s[0] = createTextVNode("No options"))
        ])
      ]),
      _: 3
    }, 16)) : createCommentVNode("", !0);
  }
}), [injectComboboxGroupContext, provideComboboxGroupContext] = createContext$2("ComboboxGroup"), _sfc_main$3N = /* @__PURE__ */ defineComponent({
  __name: "ListboxFilter",
  props: {
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, o = useVModel(n, "modelValue", t, {
      defaultValue: "",
      passive: n.modelValue === void 0
    }), s = injectListboxRootContext(), { primitiveElement: u, currentElement: d } = usePrimitiveElement(), f = computed(() => n.disabled || s.disabled.value || !1), g = ref();
    return watchSyncEffect(() => g.value = s.highlightedElement.value?.id), onMounted(() => {
      s.focusable.value = !1, setTimeout(() => {
        n.autoFocus && d.value?.focus();
      }, 1);
    }), onUnmounted(() => {
      s.focusable.value = !0;
    }), (v, b) => (openBlock(), createBlock(unref(Primitive), {
      ref_key: "primitiveElement",
      ref: u,
      as: v.as,
      "as-child": v.asChild,
      value: unref(o),
      disabled: f.value ? "" : void 0,
      "data-disabled": f.value ? "" : void 0,
      "aria-disabled": f.value ?? void 0,
      "aria-activedescendant": g.value,
      type: "text",
      onKeydown: [
        withKeys(withModifiers(unref(s).onKeydownNavigation, ["prevent"]), ["down", "up", "home", "end"]),
        withKeys(unref(s).onKeydownEnter, ["enter"])
      ],
      onInput: b[0] || (b[0] = (w) => {
        o.value = w.target.value, unref(s).highlightFirstItem();
      }),
      onCompositionstart: unref(s).onCompositionStart,
      onCompositionend: unref(s).onCompositionEnd
    }, {
      default: withCtx(() => [
        renderSlot(v.$slots, "default", { modelValue: unref(o) })
      ]),
      _: 3
    }, 8, ["as", "as-child", "value", "disabled", "data-disabled", "aria-disabled", "aria-activedescendant", "onKeydown", "onCompositionstart", "onCompositionend"]));
  }
}), _sfc_main$3M = /* @__PURE__ */ defineComponent({
  __name: "ComboboxInput",
  props: {
    displayValue: {},
    modelValue: {},
    autoFocus: { type: Boolean },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectComboboxRootContext(), s = injectListboxRootContext(), { primitiveElement: u, currentElement: d } = usePrimitiveElement(), f = useVModel(n, "modelValue", a, {
      passive: n.modelValue === void 0
    });
    onMounted(() => {
      d.value && o.onInputElementChange(d.value);
    });
    function g(w) {
      o.open.value || o.onOpenChange(!0);
    }
    function v(w) {
      const C = w.target;
      o.open.value ? o.filterSearch.value = C.value : (o.onOpenChange(!0), nextTick(() => {
        C.value && (o.filterSearch.value = C.value, s.highlightFirstItem());
      }));
    }
    function b() {
      const w = o.modelValue.value;
      n.displayValue ? f.value = n.displayValue(w) : !o.multiple.value && w && !Array.isArray(w) && typeof w != "object" ? f.value = w.toString() : f.value = "", nextTick(() => {
        f.value = f.value;
      });
    }
    return o.onResetSearchTerm(() => {
      b();
    }), watch(o.modelValue, async () => {
      !o.isUserInputted.value && o.resetSearchTermOnSelect.value && b();
    }, { immediate: !0, deep: !0 }), watch(o.filterState, () => {
      o.isVirtual.value || s.highlightFirstItem();
    }), (w, C) => (openBlock(), createBlock(unref(_sfc_main$3N), {
      ref_key: "primitiveElement",
      ref: u,
      modelValue: unref(f),
      "onUpdate:modelValue": C[0] || (C[0] = (k) => isRef(f) ? f.value = k : null),
      as: w.as,
      "as-child": w.asChild,
      "auto-focus": w.autoFocus,
      "aria-expanded": unref(o).open.value,
      "aria-controls": unref(o).contentId,
      "aria-autocomplete": "list",
      role: "combobox",
      autocomplete: "false",
      onInput: v,
      onKeydown: withKeys(withModifiers(g, ["prevent"]), ["down", "up"])
    }, {
      default: withCtx(() => [
        renderSlot(w.$slots, "default")
      ]),
      _: 3
    }, 8, ["modelValue", "as", "as-child", "auto-focus", "aria-expanded", "aria-controls", "onKeydown"]));
  }
}), LISTBOX_SELECT = "listbox.select", [injectListboxItemContext, provideListboxItemContext] = createContext$2("ListboxItem"), _sfc_main$3L = /* @__PURE__ */ defineComponent({
  __name: "ListboxItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useId(void 0, "reka-listbox-item"), { CollectionItem: s } = useCollection(), { forwardRef: u, currentElement: d } = useForwardExpose(), f = injectListboxRootContext(), g = computed(() => d.value === f.highlightedElement.value), v = computed(() => valueComparator(f.modelValue.value, n.value, f.by)), b = computed(() => f.disabled.value || n.disabled);
    async function w(k) {
      a("select", k), !k?.defaultPrevented && !b.value && k && (f.onValueChange(n.value), f.changeHighlight(d.value));
    }
    function C(k) {
      const E = { originalEvent: k, value: n.value };
      handleAndDispatchCustomEvent(LISTBOX_SELECT, w, E);
    }
    return provideListboxItemContext({
      isSelected: v
    }), (k, E) => (openBlock(), createBlock(unref(s), { value: k.value }, {
      default: withCtx(() => [
        withMemo([g.value, v.value], () => createVNode(unref(Primitive), mergeProps({ id: unref(o) }, k.$attrs, {
          ref: unref(u),
          role: "option",
          tabindex: unref(f).focusable.value ? g.value ? "0" : "-1" : -1,
          "aria-selected": v.value,
          as: k.as,
          "as-child": k.asChild,
          disabled: b.value ? "" : void 0,
          "data-disabled": b.value ? "" : void 0,
          "data-highlighted": g.value ? "" : void 0,
          "data-state": v.value ? "checked" : "unchecked",
          onClick: C,
          onKeydown: withKeys(withModifiers(C, ["prevent"]), ["space"]),
          onPointermove: E[0] || (E[0] = (A) => {
            unref(f).highlightedElement.value !== unref(d) && (unref(f).highlightOnHover.value ? unref(f).changeHighlight(unref(d), !1) : unref(f).focusable.value || unref(f).changeHighlight(unref(d), !1));
          })
        }), {
          default: withCtx(() => [
            renderSlot(k.$slots, "default")
          ]),
          _: 3
        }, 16, ["id", "tabindex", "aria-selected", "as", "as-child", "disabled", "data-disabled", "data-highlighted", "data-state", "onKeydown"]), E, 1)
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), _sfc_main$3K = /* @__PURE__ */ defineComponent({
  __name: "ComboboxItem",
  props: {
    textValue: {},
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useId(void 0, "reka-combobox-item"), s = injectComboboxRootContext(), u = injectComboboxGroupContext(null), { primitiveElement: d, currentElement: f } = usePrimitiveElement();
    if (n.value === "")
      throw new Error(
        "A <ComboboxItem /> must have a value prop that is not an empty string. This is because the Combobox value can be set to an empty string to clear the selection and show the placeholder."
      );
    const g = computed(() => {
      if (s.isVirtual.value || s.ignoreFilter.value || !s.filterSearch.value)
        return !0;
      {
        const v = s.filterState.value.items.get(o);
        return v === void 0 ? !0 : v > 0;
      }
    });
    return onMounted(() => {
      s.allItems.value.set(o, n.textValue || f.value.textContent || f.value.innerText);
      const v = u?.id;
      v && (s.allGroups.value.has(v) ? s.allGroups.value.get(v)?.add(o) : s.allGroups.value.set(v, /* @__PURE__ */ new Set([o])));
    }), onUnmounted(() => {
      s.allItems.value.delete(o);
    }), (v, b) => g.value ? (openBlock(), createBlock(unref(_sfc_main$3L), mergeProps({ key: 0 }, n, {
      id: unref(o),
      ref_key: "primitiveElement",
      ref: d,
      disabled: unref(s).disabled.value || v.disabled,
      onSelect: b[0] || (b[0] = (w) => {
        a("select", w), !w.defaultPrevented && !unref(s).multiple.value && !v.disabled && !unref(s).disabled.value && (w.preventDefault(), unref(s).onOpenChange(!1), unref(s).modelValue.value = n.value);
      })
    }), {
      default: withCtx(() => [
        renderSlot(v.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(v.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["id", "disabled"])) : createCommentVNode("", !0);
  }
}), _sfc_main$3J = /* @__PURE__ */ defineComponent({
  __name: "ComboboxPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4j), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3I = /* @__PURE__ */ defineComponent({
  __name: "ComboboxTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, { forwardRef: n, currentElement: a } = useForwardExpose(), o = injectComboboxRootContext(), s = computed(() => t.disabled || o.disabled.value || !1);
    return onMounted(() => {
      a.value && o.onTriggerElementChange(a.value);
    }), (u, d) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      ref: unref(n),
      type: u.as === "button" ? "button" : void 0,
      tabindex: "-1",
      "aria-label": "Show popup",
      "aria-haspopup": "listbox",
      "aria-expanded": unref(o).open.value,
      "aria-controls": unref(o).contentId,
      "data-state": unref(o).open.value ? "open" : "closed",
      disabled: s.value,
      "data-disabled": s.value ? "" : void 0,
      "aria-disabled": s.value ?? void 0,
      onClick: d[0] || (d[0] = (f) => unref(o).onOpenChange(!unref(o).open.value))
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["type", "aria-expanded", "aria-controls", "data-state", "disabled", "data-disabled", "aria-disabled"]));
  }
});
function useNonce(e) {
  const t = injectConfigProviderContext({
    nonce: ref()
  });
  return computed(() => e?.value || t.nonce?.value);
}
const _sfc_main$3H = /* @__PURE__ */ defineComponent({
  __name: "ComboboxViewport",
  props: {
    nonce: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n } = useForwardExpose(), { nonce: a } = toRefs(t), o = useNonce(a), s = injectComboboxRootContext();
    return (u, d) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(Primitive), mergeProps({ ...u.$attrs, ...t }, {
        ref: unref(n),
        "data-reka-combobox-viewport": "",
        role: "presentation",
        style: {
          // we use position: 'relative' here on the `viewport` so that when we call
          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
          // (independent of the scrollUpButton).
          position: "relative",
          flex: unref(s).isVirtual.value ? void 0 : 1,
          overflow: "auto"
        }
      }), {
        default: withCtx(() => [
          renderSlot(u.$slots, "default")
        ]),
        _: 3
      }, 16, ["style"]),
      createVNode(unref(Primitive), {
        as: "style",
        nonce: unref(o)
      }, {
        default: withCtx(() => d[0] || (d[0] = [
          createTextVNode(" /* Hide scrollbars cross-browser and enable momentum scroll for touch devices */ [data-reka-combobox-viewport] { scrollbar-width:none; -ms-overflow-style: none; -webkit-overflow-scrolling: touch; } [data-reka-combobox-viewport]::-webkit-scrollbar { display: none; } ")
        ])),
        _: 1
      }, 8, ["nonce"])
    ], 64));
  }
});
function useIsUsingKeyboardImpl() {
  const e = ref(!1);
  return onMounted(() => {
    useEventListener("keydown", () => {
      e.value = !0;
    }, { capture: !0, passive: !0 }), useEventListener(["pointerdown", "pointermove"], () => {
      e.value = !1;
    }, { capture: !0, passive: !0 });
  }), e;
}
const useIsUsingKeyboard = createSharedComposable(useIsUsingKeyboardImpl), [injectMenuContext, provideMenuContext] = createContext$2(["MenuRoot", "MenuSub"], "MenuContext"), [injectMenuRootContext, provideMenuRootContext] = createContext$2("MenuRoot"), _sfc_main$3G = /* @__PURE__ */ defineComponent({
  __name: "MenuRoot",
  props: {
    open: { type: Boolean, default: !1 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: o, dir: s } = toRefs(n), u = useDirection(s), d = useVModel(n, "open", a), f = ref(), g = useIsUsingKeyboard();
    return provideMenuContext({
      open: d,
      onOpenChange: (v) => {
        d.value = v;
      },
      content: f,
      onContentChange: (v) => {
        f.value = v;
      }
    }), provideMenuRootContext({
      onClose: () => {
        d.value = !1;
      },
      isUsingKeyboardRef: g,
      dir: u,
      modal: o
    }), (v, b) => (openBlock(), createBlock(unref(_sfc_main$3Z), null, {
      default: withCtx(() => [
        renderSlot(v.$slots, "default")
      ]),
      _: 3
    }));
  }
});
let count = 0;
function useFocusGuards() {
  watchEffect((e) => {
    if (!isClient)
      return;
    const t = document.querySelectorAll("[data-reka-focus-guard]");
    document.body.insertAdjacentElement(
      "afterbegin",
      t[0] ?? createFocusGuard()
    ), document.body.insertAdjacentElement(
      "beforeend",
      t[1] ?? createFocusGuard()
    ), count++, e(() => {
      count === 1 && document.querySelectorAll("[data-reka-focus-guard]").forEach((n) => n.remove()), count--;
    });
  });
}
function createFocusGuard() {
  const e = document.createElement("span");
  return e.setAttribute("data-reka-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
const [injectMenuContentContext, provideMenuContentContext] = createContext$2("MenuContent"), _sfc_main$3F = /* @__PURE__ */ defineComponent({
  __name: "MenuContentImpl",
  props: /* @__PURE__ */ mergeDefaults({
    loop: { type: Boolean },
    disableOutsidePointerEvents: { type: Boolean },
    disableOutsideScroll: { type: Boolean },
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  }, {
    ...PopperContentPropsDefaultValue
  }),
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus", "dismiss"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectMenuContext(), s = injectMenuRootContext(), { trapFocus: u, disableOutsidePointerEvents: d, loop: f } = toRefs(n);
    useFocusGuards(), useBodyScrollLock(d.value);
    const g = ref(""), v = ref(0), b = ref(0), w = ref(null), C = ref("right"), k = ref(0), E = ref(null), A = ref(), { forwardRef: P, currentElement: M } = useForwardExpose(), { handleTypeaheadSearch: B } = useTypeahead();
    watch(M, (F) => {
      o.onContentChange(F);
    }), onUnmounted(() => {
      window.clearTimeout(v.value);
    });
    function _(F) {
      return C.value === w.value?.side && isPointerInGraceArea(F, w.value?.area);
    }
    async function T(F) {
      a("openAutoFocus", F), !F.defaultPrevented && (F.preventDefault(), M.value?.focus({
        preventScroll: !0
      }));
    }
    function O(F) {
      if (F.defaultPrevented)
        return;
      const K = F.target.closest("[data-reka-menu-content]") === F.currentTarget, Z = F.ctrlKey || F.altKey || F.metaKey, J = F.key.length === 1, re = useArrowNavigation(
        F,
        getActiveElement(),
        M.value,
        {
          loop: f.value,
          arrowKeyOptions: "vertical",
          dir: s?.dir.value,
          focus: !0,
          attributeName: "[data-reka-collection-item]:not([data-disabled])"
        }
      );
      if (re)
        return re?.focus();
      if (F.code === "Space")
        return;
      const V = A.value?.getItems() ?? [];
      if (K && (F.key === "Tab" && F.preventDefault(), !Z && J && B(F.key, V)), F.target !== M.value || !FIRST_LAST_KEYS.includes(F.key))
        return;
      F.preventDefault();
      const ne = [...V.map((Q) => Q.ref)];
      LAST_KEYS.includes(F.key) && ne.reverse(), focusFirst$2(ne);
    }
    function I(F) {
      F?.currentTarget?.contains?.(F.target) || (window.clearTimeout(v.value), g.value = "");
    }
    function q(F) {
      if (!isMouseEvent$1(F))
        return;
      const W = F.target, K = k.value !== F.clientX;
      if (F?.currentTarget?.contains(W) && K) {
        const Z = F.clientX > k.value ? "right" : "left";
        C.value = Z, k.value = F.clientX;
      }
    }
    return provideMenuContentContext({
      onItemEnter: (F) => !!_(F),
      onItemLeave: (F) => {
        _(F) || (M.value?.focus(), E.value = null);
      },
      onTriggerLeave: (F) => !!_(F),
      searchRef: g,
      pointerGraceTimerRef: b,
      onPointerGraceIntentChange: (F) => {
        w.value = F;
      }
    }), (F, W) => (openBlock(), createBlock(unref(_sfc_main$4r), {
      "as-child": "",
      trapped: unref(u),
      onMountAutoFocus: T,
      onUnmountAutoFocus: W[7] || (W[7] = (K) => a("closeAutoFocus", K))
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$4q), {
          "as-child": "",
          "disable-outside-pointer-events": unref(d),
          onEscapeKeyDown: W[2] || (W[2] = (K) => a("escapeKeyDown", K)),
          onPointerDownOutside: W[3] || (W[3] = (K) => a("pointerDownOutside", K)),
          onFocusOutside: W[4] || (W[4] = (K) => a("focusOutside", K)),
          onInteractOutside: W[5] || (W[5] = (K) => a("interactOutside", K)),
          onDismiss: W[6] || (W[6] = (K) => a("dismiss"))
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$44), {
              ref_key: "rovingFocusGroupRef",
              ref: A,
              "current-tab-stop-id": E.value,
              "onUpdate:currentTabStopId": W[0] || (W[0] = (K) => E.value = K),
              "as-child": "",
              orientation: "vertical",
              dir: unref(s).dir.value,
              loop: unref(f),
              onEntryFocus: W[1] || (W[1] = (K) => {
                a("entryFocus", K), unref(s).isUsingKeyboardRef.value || K.preventDefault();
              })
            }, {
              default: withCtx(() => [
                createVNode(unref(_sfc_main$3V), {
                  ref: unref(P),
                  role: "menu",
                  as: F.as,
                  "as-child": F.asChild,
                  "aria-orientation": "vertical",
                  "data-reka-menu-content": "",
                  "data-state": unref(getOpenState)(unref(o).open.value),
                  dir: unref(s).dir.value,
                  side: F.side,
                  "side-offset": F.sideOffset,
                  align: F.align,
                  "align-offset": F.alignOffset,
                  "avoid-collisions": F.avoidCollisions,
                  "collision-boundary": F.collisionBoundary,
                  "collision-padding": F.collisionPadding,
                  "arrow-padding": F.arrowPadding,
                  "prioritize-position": F.prioritizePosition,
                  "position-strategy": F.positionStrategy,
                  "update-position-strategy": F.updatePositionStrategy,
                  sticky: F.sticky,
                  "hide-when-detached": F.hideWhenDetached,
                  reference: F.reference,
                  onKeydown: O,
                  onBlur: I,
                  onPointermove: q
                }, {
                  default: withCtx(() => [
                    renderSlot(F.$slots, "default")
                  ]),
                  _: 3
                }, 8, ["as", "as-child", "data-state", "dir", "side", "side-offset", "align", "align-offset", "avoid-collisions", "collision-boundary", "collision-padding", "arrow-padding", "prioritize-position", "position-strategy", "update-position-strategy", "sticky", "hide-when-detached", "reference"])
              ]),
              _: 3
            }, 8, ["current-tab-stop-id", "dir", "loop"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), _sfc_main$3E = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "MenuItemImpl",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectMenuContentContext(), { forwardRef: a } = useForwardExpose(), { CollectionItem: o } = useCollection(), s = ref(!1);
    async function u(f) {
      f.defaultPrevented || isMouseEvent$1(f) && (t.disabled ? n.onItemLeave(f) : n.onItemEnter(f) || f.currentTarget?.focus({ preventScroll: !0 }));
    }
    async function d(f) {
      await nextTick(), !f.defaultPrevented && isMouseEvent$1(f) && n.onItemLeave(f);
    }
    return (f, g) => (openBlock(), createBlock(unref(o), {
      value: { textValue: f.textValue }
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps({
          ref: unref(a),
          role: "menuitem",
          tabindex: "-1"
        }, f.$attrs, {
          as: f.as,
          "as-child": f.asChild,
          "aria-disabled": f.disabled || void 0,
          "data-disabled": f.disabled ? "" : void 0,
          "data-highlighted": s.value ? "" : void 0,
          onPointermove: u,
          onPointerleave: d,
          onFocus: g[0] || (g[0] = async (v) => {
            await nextTick(), !(v.defaultPrevented || f.disabled) && (s.value = !0);
          }),
          onBlur: g[1] || (g[1] = async (v) => {
            await nextTick(), !v.defaultPrevented && (s.value = !1);
          })
        }), {
          default: withCtx(() => [
            renderSlot(f.$slots, "default")
          ]),
          _: 3
        }, 16, ["as", "as-child", "aria-disabled", "data-disabled", "data-highlighted"])
      ]),
      _: 3
    }, 8, ["value"]));
  }
}), _sfc_main$3D = /* @__PURE__ */ defineComponent({
  __name: "MenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = injectMenuRootContext(), d = injectMenuContentContext(), f = ref(!1);
    async function g() {
      const v = s.value;
      if (!n.disabled && v) {
        const b = new CustomEvent(ITEM_SELECT, {
          bubbles: !0,
          cancelable: !0
        });
        a("select", b), await nextTick(), b.defaultPrevented ? f.value = !1 : u.onClose();
      }
    }
    return (v, b) => (openBlock(), createBlock(_sfc_main$3E, mergeProps(n, {
      ref: unref(o),
      onClick: g,
      onPointerdown: b[0] || (b[0] = () => {
        f.value = !0;
      }),
      onPointerup: b[1] || (b[1] = async (w) => {
        await nextTick(), !w.defaultPrevented && (f.value || w.currentTarget?.click());
      }),
      onKeydown: b[2] || (b[2] = async (w) => {
        const C = unref(d).searchRef.value !== "";
        v.disabled || C && w.key === " " || unref(SELECTION_KEYS).includes(w.key) && (w.currentTarget.click(), w.preventDefault());
      })
    }), {
      default: withCtx(() => [
        renderSlot(v.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3C = /* @__PURE__ */ defineComponent({
  __name: "MenuRootContentModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useForwardPropsEmits(n, a), s = injectMenuContext(), { forwardRef: u, currentElement: d } = useForwardExpose();
    return useHideOthers(d), (f, g) => (openBlock(), createBlock(_sfc_main$3F, mergeProps(unref(o), {
      ref: unref(u),
      "trap-focus": unref(s).open.value,
      "disable-outside-pointer-events": unref(s).open.value,
      "disable-outside-scroll": !0,
      onDismiss: g[0] || (g[0] = (v) => unref(s).onOpenChange(!1)),
      onFocusOutside: g[1] || (g[1] = withModifiers((v) => a("focusOutside", v), ["prevent"]))
    }), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus", "disable-outside-pointer-events"]));
  }
}), _sfc_main$3B = /* @__PURE__ */ defineComponent({
  __name: "MenuRootContentNonModal",
  props: {
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const o = useForwardPropsEmits(e, t), s = injectMenuContext();
    return (u, d) => (openBlock(), createBlock(_sfc_main$3F, mergeProps(unref(o), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      "disable-outside-scroll": !1,
      onDismiss: d[0] || (d[0] = (f) => unref(s).onOpenChange(!1))
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3A = /* @__PURE__ */ defineComponent({
  __name: "MenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "entryFocus", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const o = useForwardPropsEmits(e, t), s = injectMenuContext(), u = injectMenuRootContext();
    return (d, f) => (openBlock(), createBlock(unref(Presence), {
      present: d.forceMount || unref(s).open.value
    }, {
      default: withCtx(() => [
        unref(u).modal.value ? (openBlock(), createBlock(_sfc_main$3C, normalizeProps(mergeProps({ key: 0 }, { ...d.$attrs, ...unref(o) })), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(_sfc_main$3B, normalizeProps(mergeProps({ key: 1 }, { ...d.$attrs, ...unref(o) })), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), [injectContextMenuRootContext, provideContextMenuRootContext] = createContext$2("ContextMenuRoot"), _sfc_main$3z = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "ContextMenuRoot",
  props: {
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { dir: o, modal: s } = toRefs(n);
    useForwardExpose();
    const u = useDirection(o), d = ref(!1), f = ref();
    return provideContextMenuRootContext({
      open: d,
      onOpenChange: (g) => {
        d.value = g;
      },
      dir: u,
      modal: s,
      triggerElement: f
    }), watch(d, (g) => {
      a("update:open", g);
    }), (g, v) => (openBlock(), createBlock(unref(_sfc_main$3G), {
      open: d.value,
      "onUpdate:open": v[0] || (v[0] = (b) => d.value = b),
      dir: unref(u),
      modal: unref(s)
    }, {
      default: withCtx(() => [
        renderSlot(g.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), _sfc_main$3y = /* @__PURE__ */ defineComponent({
  __name: "ContextMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    alignOffset: { default: 0 },
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    positionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const o = useForwardPropsEmits(e, t);
    useForwardExpose();
    const s = injectContextMenuRootContext(), u = ref(!1);
    return (d, f) => (openBlock(), createBlock(unref(_sfc_main$3A), mergeProps(unref(o), {
      side: "right",
      "side-offset": 2,
      align: "start",
      "update-position-strategy": "always",
      style: {
        "--reka-context-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-context-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-context-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-context-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-context-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: f[0] || (f[0] = (g) => {
        !g.defaultPrevented && u.value && g.preventDefault(), u.value = !1;
      }),
      onInteractOutside: f[1] || (f[1] = (g) => {
        g.detail.originalEvent.button === 2 && g.target === unref(s).triggerElement.value && g.preventDefault(), !g.defaultPrevented && !unref(s).modal.value && (u.value = !0);
      })
    }), {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3x = /* @__PURE__ */ defineComponent({
  __name: "ContextMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, o = useEmitAsProps(t);
    return useForwardExpose(), (s, u) => (openBlock(), createBlock(unref(_sfc_main$3D), normalizeProps(guardReactiveProps({ ...n, ...unref(o) })), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3w = /* @__PURE__ */ defineComponent({
  __name: "MenuLabel",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3v = /* @__PURE__ */ defineComponent({
  __name: "ContextMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3w), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3u = /* @__PURE__ */ defineComponent({
  __name: "MenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4j), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3t = /* @__PURE__ */ defineComponent({
  __name: "ContextMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3u), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3s = /* @__PURE__ */ defineComponent({
  __name: "MenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      role: "separator",
      "aria-orientation": "horizontal"
    }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3r = /* @__PURE__ */ defineComponent({
  __name: "ContextMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3s), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3q = /* @__PURE__ */ defineComponent({
  __name: "MenuAnchor",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3Y), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
function isTouchOrPen(e) {
  return e.pointerType !== "mouse";
}
const _sfc_main$3p = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "ContextMenuTrigger",
  props: {
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, { disabled: n } = toRefs(t), { forwardRef: a, currentElement: o } = useForwardExpose(), s = injectContextMenuRootContext(), u = ref({ x: 0, y: 0 }), d = computed(() => ({
      getBoundingClientRect: () => ({
        width: 0,
        height: 0,
        left: u.value.x,
        right: u.value.x,
        top: u.value.y,
        bottom: u.value.y,
        ...u.value
      })
    })), f = ref(0);
    function g() {
      window.clearTimeout(f.value);
    }
    function v(k) {
      u.value = { x: k.clientX, y: k.clientY }, s.onOpenChange(!0);
    }
    async function b(k) {
      n.value || (await nextTick(), k.defaultPrevented || (g(), v(k), k.preventDefault()));
    }
    async function w(k) {
      n.value || (await nextTick(), isTouchOrPen(k) && !k.defaultPrevented && (g(), f.value = window.setTimeout(() => v(k), 700)));
    }
    async function C(k) {
      n.value || (await nextTick(), isTouchOrPen(k) && !k.defaultPrevented && g());
    }
    return onMounted(() => {
      o.value && (s.triggerElement.value = o.value);
    }), (k, E) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(_sfc_main$3q), {
        as: "template",
        reference: d.value
      }, null, 8, ["reference"]),
      createVNode(unref(Primitive), mergeProps({
        ref: unref(a),
        as: k.as,
        "as-child": k.asChild,
        "data-state": unref(s).open.value ? "open" : "closed",
        "data-disabled": unref(n) ? "" : void 0,
        style: {
          WebkitTouchCallout: "none",
          pointerEvents: "auto"
        }
      }, k.$attrs, {
        onContextmenu: b,
        onPointerdown: w,
        onPointermove: C,
        onPointercancel: C,
        onPointerup: C
      }), {
        default: withCtx(() => [
          renderSlot(k.$slots, "default")
        ]),
        _: 3
      }, 16, ["as", "as-child", "data-state", "data-disabled"])
    ], 64));
  }
});
function isSegmentNavigationKey(e) {
  const t = useKbd();
  return e === t.ARROW_RIGHT || e === t.ARROW_LEFT;
}
function isNumberString(e) {
  return !Number.isNaN(Number.parseInt(e));
}
function isAcceptableSegmentKey(e) {
  const t = useKbd();
  return !!([
    t.ENTER,
    t.ARROW_UP,
    t.ARROW_DOWN,
    t.ARROW_LEFT,
    t.ARROW_RIGHT,
    t.BACKSPACE,
    t.SPACE,
    "a",
    "A",
    "p",
    "P"
  ].includes(e) || isNumberString(e));
}
function getSegmentElements(e) {
  return Array.from(e.querySelectorAll("[data-reka-date-field-segment]")).filter((t) => t.getAttribute("data-reka-date-field-segment") !== "literal");
}
function getTimeFieldSegmentElements(e) {
  return Array.from(e.querySelectorAll("[data-reka-time-field-segment]")).filter((t) => t.getAttribute("data-reka-time-field-segment") !== "literal");
}
function commonSegmentAttrs(e) {
  return {
    role: "spinbutton",
    contenteditable: !0,
    tabindex: e.disabled ? void 0 : 0,
    spellcheck: !1,
    inputmode: "numeric",
    autocorrect: "off",
    enterkeyhint: "next",
    style: "caret-color: transparent;"
  };
}
function daySegmentAttrs(e) {
  const { segmentValues: t, placeholder: n } = e, a = t.day === null, o = t.day ? n.set({ day: t.day }) : n, s = o.day, u = 1, d = getDaysInMonth(o), f = a ? "Empty" : `${s}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "day,",
    "aria-valuemin": u,
    "aria-valuemax": d,
    "aria-valuenow": s,
    "aria-valuetext": f,
    "data-placeholder": a ? "" : void 0
  };
}
function monthSegmentAttrs(e) {
  const { segmentValues: t, placeholder: n, formatter: a } = e, o = t.month === null, s = t.month ? n.set({ month: t.month }) : n, u = s.month, d = 1, f = 12, g = o ? "Empty" : `${u} - ${a.fullMonth(toDate(s))}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "month, ",
    contenteditable: !0,
    "aria-valuemin": d,
    "aria-valuemax": f,
    "aria-valuenow": u,
    "aria-valuetext": g,
    "data-placeholder": o ? "" : void 0
  };
}
function yearSegmentAttrs(e) {
  const { segmentValues: t, placeholder: n } = e, a = t.year === null, o = t.year ? n.set({ year: t.year }) : n, s = 1, u = 9999, d = o.year, f = a ? "Empty" : `${d}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "year, ",
    "aria-valuemin": s,
    "aria-valuemax": u,
    "aria-valuenow": d,
    "aria-valuetext": f,
    "data-placeholder": a ? "" : void 0
  };
}
function hourSegmentAttrs(e) {
  const { segmentValues: t, hourCycle: n, placeholder: a } = e;
  if (!("hour" in t) || !("hour" in a))
    return {};
  const o = t.hour === null, s = t.hour ? a.set({ hour: t.hour }) : a, u = n === 12 ? 1 : 0, d = n === 12 ? 12 : 23, f = s.hour, g = o ? "Empty" : `${f} ${t.dayPeriod ?? ""}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "hour, ",
    "aria-valuemin": u,
    "aria-valuemax": d,
    "aria-valuenow": f,
    "aria-valuetext": g,
    "data-placeholder": o ? "" : void 0
  };
}
function minuteSegmentAttrs(e) {
  const { segmentValues: t, placeholder: n } = e;
  if (!("minute" in t) || !("minute" in n))
    return {};
  const a = t.minute === null, s = (t.minute ? n.set({ minute: t.minute }) : n).minute, u = 0, d = 59, f = a ? "Empty" : `${s}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "minute, ",
    "aria-valuemin": u,
    "aria-valuemax": d,
    "aria-valuenow": s,
    "aria-valuetext": f,
    "data-placeholder": a ? "" : void 0
  };
}
function secondSegmentAttrs(e) {
  const { segmentValues: t, placeholder: n } = e;
  if (!("second" in t) || !("second" in n))
    return {};
  const a = t.second === null, s = (t.second ? n.set({ second: t.second }) : n).second, u = 0, d = 59, f = a ? "Empty" : `${s}`;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "second, ",
    "aria-valuemin": u,
    "aria-valuemax": d,
    "aria-valuenow": s,
    "aria-valuetext": f,
    "data-placeholder": a ? "" : void 0
  };
}
function dayPeriodSegmentAttrs(e) {
  const { segmentValues: t } = e;
  if (!("dayPeriod" in t))
    return {};
  const n = 0, a = 12, o = t.hour ? t.hour > 12 ? t.hour - 12 : t.hour : 0, s = t.dayPeriod ?? "AM";
  return {
    ...commonSegmentAttrs(e),
    inputmode: "text",
    "aria-label": "AM/PM",
    "aria-valuemin": n,
    "aria-valuemax": a,
    "aria-valuenow": o,
    "aria-valuetext": s
  };
}
function literalSegmentAttrs(e) {
  return {
    "aria-hidden": !0,
    "data-segment": "literal"
  };
}
function timeZoneSegmentAttrs(e) {
  return {
    role: "textbox",
    "aria-label": "timezone, ",
    "data-readonly": !0,
    "data-segment": "timeZoneName",
    tabindex: e.disabled ? void 0 : 0,
    style: "caret-color: transparent;"
  };
}
function eraSegmentAttrs(e) {
  const { segmentValues: t, placeholder: n } = e, a = 0, o = 0, s = 0, u = "era" in t ? t.era : n.era;
  return {
    ...commonSegmentAttrs(e),
    "aria-label": "era",
    "aria-valuemin": a,
    "aria-valuemax": o,
    "aria-valuenow": s,
    "aria-valuetext": u
  };
}
const segmentBuilders = {
  day: {
    attrs: daySegmentAttrs
  },
  month: {
    attrs: monthSegmentAttrs
  },
  year: {
    attrs: yearSegmentAttrs
  },
  hour: {
    attrs: hourSegmentAttrs
  },
  minute: {
    attrs: minuteSegmentAttrs
  },
  second: {
    attrs: secondSegmentAttrs
  },
  dayPeriod: {
    attrs: dayPeriodSegmentAttrs
  },
  literal: {
    attrs: literalSegmentAttrs
  },
  timeZoneName: {
    attrs: timeZoneSegmentAttrs
  },
  era: {
    attrs: eraSegmentAttrs
  }
};
function useDateField(e) {
  const t = useKbd();
  function n({ e: B, part: _, dateRef: T, prevValue: O }) {
    const I = e.step.value[_] ?? 1, q = B.key === t.ARROW_UP ? I : -I, F = 0, W = 59;
    if (O === null)
      return q > 0 ? F : W;
    const K = [_, q];
    return T.set({ [_]: O }).cycle(...K)[_];
  }
  function a(B) {
    if (e.hasLeftFocus.value = !1, B === null)
      return B;
    const _ = B.toString();
    return _.length === 1 ? (e.modelValue.value = void 0, null) : Number.parseInt(_.slice(0, -1));
  }
  function o({ e: B, part: _, dateRef: T, prevValue: O, hourCycle: I }) {
    const q = e.step.value[_] ?? 1, F = B.key === t.ARROW_UP ? q : -q;
    if (O === null)
      return T[_];
    if (_ === "hour" && "hour" in T) {
      const K = [_, F, { hourCycle: I }];
      return T.set({ [_]: O }).cycle(...K)[_];
    }
    const W = [_, F];
    return _ === "day" ? T.set({
      [_]: O,
      /**
       * Edge case for the day field:
       *
       * 1. If the month is filled,
       *   we need to ensure that the day snaps to the maximum value of that month.
       * 2. If the month is not filled,
       *   we default to the month with the maximum number of days (here just using January, 31 days),
       *   so that user can input any possible day.
       */
      month: e.segmentValues.value.month ?? 1
    }).cycle(...W)[_] : T.set({ [_]: O }).cycle(...W)[_];
  }
  function s(B, _, T) {
    let O = !1;
    const I = Math.floor(B / 10);
    if (e.hasLeftFocus.value && (e.hasLeftFocus.value = !1, T = null), T === null)
      return _ === 0 ? (e.lastKeyZero.value = !0, { value: null, moveToNext: O }) : ((e.lastKeyZero.value || _ > I) && (O = !0), e.lastKeyZero.value = !1, { value: _, moveToNext: O });
    const q = T.toString().length, F = Number.parseInt(T.toString() + _.toString());
    return q === 2 || F > B ? ((_ > I || F > B) && (O = !0), { value: _, moveToNext: O }) : (O = !0, { value: F, moveToNext: O });
  }
  function u(B, _) {
    let O = !1;
    const I = Math.floor(59 / 10);
    if (e.hasLeftFocus.value && (e.hasLeftFocus.value = !1, _ = null), _ === null)
      return B === 0 ? (e.lastKeyZero.value = !0, { value: 0, moveToNext: O }) : ((e.lastKeyZero.value || B > I) && (O = !0), e.lastKeyZero.value = !1, { value: B, moveToNext: O });
    const q = _.toString().length, F = Number.parseInt(_.toString() + B.toString());
    return q === 2 || F > 59 ? (B > I && (O = !0), { value: B, moveToNext: O }) : (O = !0, { value: F, moveToNext: O });
  }
  function d(B, _) {
    let O = !1;
    const I = Math.floor(24 / 10);
    if (e.hasLeftFocus.value && (e.hasLeftFocus.value = !1, _ = null), _ === null)
      return B === 0 ? (e.lastKeyZero.value = !0, { value: 0, moveToNext: O }) : ((e.lastKeyZero.value || B > I) && (O = !0), e.lastKeyZero.value = !1, { value: B, moveToNext: O });
    const q = _.toString().length, F = Number.parseInt(_.toString() + B.toString());
    return q === 2 || F > 24 ? (B > I && (O = !0), { value: B, moveToNext: O }) : (O = !0, { value: F, moveToNext: O });
  }
  function f(B, _) {
    let T = !1;
    if (e.hasLeftFocus.value && (e.hasLeftFocus.value = !1, _ = null), _ === null)
      return { value: B === 0 ? 1 : B, moveToNext: T };
    const O = _.toString() + B.toString();
    return O.length > 4 ? { value: B === 0 ? 1 : B, moveToNext: T } : (O.length === 4 && (T = !0), { value: Number.parseInt(O), moveToNext: T });
  }
  const g = computed(() => segmentBuilders[e.part]?.attrs({
    disabled: e.disabled.value,
    placeholder: e.placeholder.value,
    hourCycle: e.hourCycle,
    segmentValues: e.segmentValues.value,
    formatter: e.formatter
  }) ?? {});
  function v(B) {
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key))
      return;
    const _ = e.segmentValues.value.day;
    if (B.key === t.ARROW_DOWN || B.key === t.ARROW_UP) {
      e.segmentValues.value.day = o({ e: B, part: "day", dateRef: e.placeholder.value, prevValue: _ });
      return;
    }
    if (isNumberString(B.key)) {
      const T = Number.parseInt(B.key), O = e.segmentValues.value.month, I = O ? getDaysInMonth(e.placeholder.value.set({ month: O })) : 31, { value: q, moveToNext: F } = s(I, T, _);
      e.segmentValues.value.day = q, F && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.day = a(_));
  }
  function b(B) {
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key))
      return;
    const _ = e.segmentValues.value.month;
    if (B.key === t.ARROW_DOWN || B.key === t.ARROW_UP) {
      e.segmentValues.value.month = o({ e: B, part: "month", dateRef: e.placeholder.value, prevValue: _ });
      return;
    }
    if (isNumberString(B.key)) {
      const T = Number.parseInt(B.key), { value: O, moveToNext: I } = s(12, T, _);
      e.segmentValues.value.month = O, I && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.month = a(_));
  }
  function w(B) {
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key))
      return;
    const _ = e.segmentValues.value.year;
    if (B.key === t.ARROW_DOWN || B.key === t.ARROW_UP) {
      e.segmentValues.value.year = o({ e: B, part: "year", dateRef: e.placeholder.value, prevValue: _ });
      return;
    }
    if (isNumberString(B.key)) {
      const T = Number.parseInt(B.key), { value: O, moveToNext: I } = f(T, _);
      e.segmentValues.value.year = O, I && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.year = a(_));
  }
  function C(B) {
    const _ = e.placeholder.value;
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key) || !("hour" in _) || !("hour" in e.segmentValues.value))
      return;
    const T = e.segmentValues.value.hour, O = e.hourCycle;
    if (B.key === t.ARROW_UP || B.key === t.ARROW_DOWN) {
      e.segmentValues.value.hour = o({ e: B, part: "hour", dateRef: e.placeholder.value, prevValue: T, hourCycle: O }), "dayPeriod" in e.segmentValues.value && (e.segmentValues.value.hour < 12 ? e.segmentValues.value.dayPeriod = "AM" : e.segmentValues.value.hour && (e.segmentValues.value.dayPeriod = "PM"));
      return;
    }
    if (isNumberString(B.key)) {
      const I = Number.parseInt(B.key), { value: q, moveToNext: F } = d(I, T);
      "dayPeriod" in e.segmentValues.value && q && q > 12 ? e.segmentValues.value.dayPeriod = "PM" : "dayPeriod" in e.segmentValues.value && q && (e.segmentValues.value.dayPeriod = "AM"), e.segmentValues.value.hour = q, F && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.hour = a(T));
  }
  function k(B) {
    const _ = e.placeholder.value;
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key) || !("minute" in _) || !("minute" in e.segmentValues.value))
      return;
    const T = e.segmentValues.value.minute;
    if ((B.key === t.ARROW_UP || B.key === t.ARROW_DOWN) && (e.segmentValues.value.minute = n({ e: B, part: "minute", dateRef: e.placeholder.value, prevValue: T })), isNumberString(B.key)) {
      const O = Number.parseInt(B.key), { value: I, moveToNext: q } = u(O, T);
      e.segmentValues.value.minute = I, q && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.minute = a(T));
  }
  function E(B) {
    const _ = e.placeholder.value;
    if (!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key) || !("second" in _) || !("second" in e.segmentValues.value))
      return;
    const T = e.segmentValues.value.second;
    if ((B.key === t.ARROW_UP || B.key === t.ARROW_DOWN) && (e.segmentValues.value.second = n({ e: B, part: "second", dateRef: e.placeholder.value, prevValue: T })), isNumberString(B.key)) {
      const O = Number.parseInt(B.key), { value: I, moveToNext: q } = u(O, T);
      e.segmentValues.value.second = I, q && e.focusNext();
    }
    B.key === t.BACKSPACE && (e.hasLeftFocus.value = !1, e.segmentValues.value.second = a(T));
  }
  function A(B) {
    if (!((!isAcceptableSegmentKey(B.key) || isSegmentNavigationKey(B.key)) && B.key !== "a" && B.key !== "p" || !("hour" in e.placeholder.value) || !("dayPeriod" in e.segmentValues.value))) {
      if (B.key === t.ARROW_UP || B.key === t.ARROW_DOWN) {
        if (e.segmentValues.value.dayPeriod === "AM") {
          e.segmentValues.value.dayPeriod = "PM", e.segmentValues.value.hour = e.segmentValues.value.hour + 12;
          return;
        }
        e.segmentValues.value.dayPeriod = "AM", e.segmentValues.value.hour = e.segmentValues.value.hour - 12;
        return;
      }
      if (["a", "A"].includes(B.key) && e.segmentValues.value.dayPeriod !== "AM") {
        e.segmentValues.value.dayPeriod = "AM", e.segmentValues.value.hour = e.segmentValues.value.hour - 12;
        return;
      }
      ["p", "P"].includes(B.key) && e.segmentValues.value.dayPeriod !== "PM" && (e.segmentValues.value.dayPeriod = "PM", e.segmentValues.value.hour = e.segmentValues.value.hour + 12);
    }
  }
  function P(B) {
    e.disabled.value && B.preventDefault();
  }
  function M(B) {
    const _ = e.disabled.value, T = e.readonly.value;
    if (B.key !== t.TAB && B.preventDefault(), _ || T)
      return;
    if ({
      day: v,
      month: b,
      year: w,
      hour: C,
      minute: k,
      second: E,
      dayPeriod: A,
      timeZoneName: () => {
      }
    }[e.part](B), ![t.ARROW_LEFT, t.ARROW_RIGHT].includes(B.key) && B.key !== t.TAB && B.key !== t.SHIFT && isAcceptableSegmentKey(B.key) && Object.values(e.segmentValues.value).every((I) => I !== null)) {
      const I = { ...e.segmentValues.value };
      let q = e.placeholder.value.copy();
      Object.keys(I).forEach((F) => {
        const W = I[F];
        q = q.set({ [F]: W });
      }), e.modelValue.value = q.copy();
    }
  }
  return {
    handleSegmentClick: P,
    handleSegmentKeydown: M,
    attributes: g
  };
}
const DATE_SEGMENT_PARTS = ["day", "month", "year"], TIME_SEGMENT_PARTS = ["hour", "minute", "second", "dayPeriod"], EDITABLE_SEGMENT_PARTS = [...DATE_SEGMENT_PARTS, ...TIME_SEGMENT_PARTS];
function isDateSegmentPart(e) {
  return DATE_SEGMENT_PARTS.includes(e);
}
function isSegmentPart(e) {
  return EDITABLE_SEGMENT_PARTS.includes(e);
}
const supportedLocales = [
  "ach",
  "af",
  "am",
  "an",
  "ar",
  "ast",
  "az",
  "be",
  "bg",
  "bn",
  "br",
  "bs",
  "ca",
  "cak",
  "ckb",
  "cs",
  "cy",
  "da",
  "de",
  "dsb",
  "el",
  "en",
  "eo",
  "es",
  "et",
  "eu",
  "fa",
  "ff",
  "fi",
  "fr",
  "fy",
  "ga",
  "gd",
  "gl",
  "he",
  "hr",
  "hsb",
  "hu",
  "ia",
  "id",
  "it",
  "ja",
  "ka",
  "kk",
  "kn",
  "ko",
  "lb",
  "lo",
  "lt",
  "lv",
  "meh",
  "ml",
  "ms",
  "nl",
  "nn",
  "no",
  "oc",
  "pl",
  "pt",
  "rm",
  "ro",
  "ru",
  "sc",
  "scn",
  "sk",
  "sl",
  "sr",
  "sv",
  "szl",
  "tg",
  "th",
  "tr",
  "uk",
  "zh-CN",
  "zh-TW"
], placeholderFields = ["year", "month", "day"], placeholders = {
  ach: { year: "mwaka", month: "dwe", day: "nino" },
  af: { year: "jjjj", month: "mm", day: "dd" },
  am: { year: "", month: "", day: "" },
  an: { year: "aaaa", month: "mm", day: "dd" },
  ar: { year: "", month: "", day: "" },
  ast: { year: "aaaa", month: "mm", day: "dd" },
  az: { year: "iiii", month: "aa", day: "gg" },
  be: { year: "", month: "", day: "" },
  bg: { year: "", month: "", day: "" },
  bn: { year: "yyyy", month: "", day: "dd" },
  br: { year: "bbbb", month: "mm", day: "dd" },
  bs: { year: "gggg", month: "mm", day: "dd" },
  ca: { year: "aaaa", month: "mm", day: "dd" },
  cak: { year: "jjjj", month: "ii", day: "q'q'" },
  ckb: { year: "", month: "", day: "" },
  cs: { year: "rrrr", month: "mm", day: "dd" },
  cy: { year: "bbbb", month: "mm", day: "dd" },
  da: { year: "", month: "mm", day: "dd" },
  de: { year: "jjjj", month: "mm", day: "tt" },
  dsb: { year: "llll", month: "mm", day: "" },
  el: { year: "", month: "", day: "" },
  en: { year: "yyyy", month: "mm", day: "dd" },
  eo: { year: "jjjj", month: "mm", day: "tt" },
  es: { year: "aaaa", month: "mm", day: "dd" },
  et: { year: "aaaa", month: "kk", day: "pp" },
  eu: { year: "uuuu", month: "hh", day: "ee" },
  fa: { year: "", month: "", day: "" },
  ff: { year: "hhhh", month: "ll", day: "" },
  fi: { year: "vvvv", month: "kk", day: "pp" },
  fr: { year: "aaaa", month: "mm", day: "jj" },
  fy: { year: "jjjj", month: "mm", day: "dd" },
  ga: { year: "bbbb", month: "mm", day: "ll" },
  gd: { year: "bbbb", month: "mm", day: "ll" },
  gl: { year: "aaaa", month: "mm", day: "dd" },
  he: { year: "", month: "", day: "" },
  hr: { year: "gggg", month: "mm", day: "dd" },
  hsb: { year: "llll", month: "mm", day: "dd" },
  hu: { year: "", month: "hh", day: "nn" },
  ia: { year: "aaaa", month: "mm", day: "dd" },
  id: { year: "tttt", month: "bb", day: "hh" },
  it: { year: "aaaa", month: "mm", day: "gg" },
  ja: { year: "  ", month: "", day: "" },
  ka: { year: "", month: "", day: "" },
  kk: { year: "", month: "", day: "" },
  kn: { year: "", month: "", day: "" },
  ko: { year: "", month: "", day: "" },
  lb: { year: "jjjj", month: "mm", day: "dd" },
  lo: { year: "", month: "", day: "" },
  lt: { year: "mmmm", month: "mm", day: "dd" },
  lv: { year: "gggg", month: "mm", day: "dd" },
  meh: { year: "aaaa", month: "mm", day: "dd" },
  ml: { year: "", month: "", day: "" },
  ms: { year: "tttt", month: "mm", day: "hh" },
  nl: { year: "jjjj", month: "mm", day: "dd" },
  nn: { year: "", month: "mm", day: "dd" },
  no: { year: "", month: "mm", day: "dd" },
  oc: { year: "aaaa", month: "mm", day: "jj" },
  pl: { year: "rrrr", month: "mm", day: "dd" },
  pt: { year: "aaaa", month: "mm", day: "dd" },
  rm: { year: "oooo", month: "mm", day: "dd" },
  ro: { year: "aaaa", month: "ll", day: "zz" },
  ru: { year: "", month: "", day: "" },
  sc: { year: "aaaa", month: "mm", day: "dd" },
  scn: { year: "aaaa", month: "mm", day: "jj" },
  sk: { year: "rrrr", month: "mm", day: "dd" },
  sl: { year: "llll", month: "mm", day: "dd" },
  sr: { year: "", month: "", day: "" },
  sv: { year: "", month: "mm", day: "dd" },
  szl: { year: "rrrr", month: "mm", day: "dd" },
  tg: { year: "", month: "", day: "" },
  th: { year: "", month: "", day: "" },
  tr: { year: "yyyy", month: "aa", day: "gg" },
  uk: { year: "", month: "", day: "" },
  "zh-CN": { year: "", month: "", day: "" },
  "zh-TW": { year: "", month: "", day: "" }
};
function getPlaceholderObj(e) {
  if (isSupportedLocale(e))
    return placeholders[e];
  {
    const t = getLocaleLanguage(e);
    return isSupportedLocale(t) ? placeholders[t] : placeholders.en;
  }
}
function getPlaceholder(e, t, n) {
  return isPlaceholderField(e) ? getPlaceholderObj(n)[e] : isDefaultField(e) ? t : isTimeField(e) ? "" : "";
}
function isSupportedLocale(e) {
  return supportedLocales.includes(e);
}
function isPlaceholderField(e) {
  return placeholderFields.includes(e);
}
function isTimeField(e) {
  return e === "hour" || e === "minute" || e === "second";
}
function isDefaultField(e) {
  return e === "era" || e === "dayPeriod";
}
function getLocaleLanguage(e) {
  return Intl.Locale ? new Intl.Locale(e).language : e.split("-")[0];
}
const calendarDateTimeGranularities = ["hour", "minute", "second"];
function syncTimeSegmentValues(e) {
  return Object.fromEntries(TIME_SEGMENT_PARTS.map((t) => t === "dayPeriod" ? [t, e.formatter.dayPeriod(toDate(e.value))] : [t, e.value[t]]));
}
function syncSegmentValues(e) {
  const { formatter: t } = e, n = DATE_SEGMENT_PARTS.map((a) => [a, e.value[a]]);
  if ("hour" in e.value) {
    const a = syncTimeSegmentValues({ value: e.value, formatter: t });
    return { ...Object.fromEntries(n), ...a };
  }
  return Object.fromEntries(n);
}
function initializeTimeSegmentValues(e) {
  return Object.fromEntries(
    TIME_SEGMENT_PARTS.map((t) => t === "dayPeriod" ? [t, "AM"] : [t, null]).filter(([t]) => !(t === "literal" || t === null || e === "minute" && t === "second" || e === "hour" && (t === "second" || t === "minute")))
  );
}
function initializeSegmentValues(e) {
  const t = EDITABLE_SEGMENT_PARTS.map((n) => n === "dayPeriod" ? [n, "AM"] : [n, null]).filter(([n]) => n === "literal" || n === null || e === "minute" && n === "second" || e === "hour" && (n === "second" || n === "minute") ? !1 : e === "day" ? !calendarDateTimeGranularities.includes(n) && n !== "dayPeriod" : !0);
  return Object.fromEntries(t);
}
function createContentObj(e) {
  const { segmentValues: t, formatter: n, locale: a } = e;
  function o(u) {
    if ("hour" in t) {
      const d = t[u];
      return d !== null ? u === "day" ? n.part(e.dateRef.set({
        [u]: d,
        /**
         * Edge case for the day field:
         *
         * 1. If the month is filled,
         *   we need to ensure that the day snaps to the maximum value of that month.
         * 2. If the month is not filled,
         *   we default to the month with the maximum number of days (here just using January, 31 days),
         *   so that user can input any possible day.
         */
        month: t.month ?? 1
      }), u, { hourCycle: normalizeHourCycle(e.hourCycle) }) : n.part(e.dateRef.set({ [u]: d }), u, {
        hourCycle: normalizeHourCycle(e.hourCycle)
      }) : getPlaceholder(u, "", a.value);
    } else {
      if (isDateSegmentPart(u)) {
        const d = t[u];
        return d !== null ? u === "day" ? n.part(e.dateRef.set({
          [u]: d,
          // Same logic as above for the day field
          month: t.month ?? 1
        }), u) : n.part(e.dateRef.set({ [u]: d }), u) : getPlaceholder(u, "", a.value);
      }
      return "";
    }
  }
  return Object.keys(t).reduce((u, d) => {
    if (!isSegmentPart(d))
      return u;
    if ("hour" in t && d === "dayPeriod") {
      const f = t[d];
      f !== null ? u[d] = f : u[d] = getPlaceholder(d, "AM", a.value);
    } else
      u[d] = o(d);
    return u;
  }, {});
}
function createContentArr(e) {
  const { granularity: t, formatter: n, contentObj: a, hideTimeZone: o, hourCycle: s, isTimeValue: u } = e;
  return n.toParts(e.dateRef, getOptsByGranularity(t, s, u)).map((g) => ["literal", "timeZoneName", null].includes(g.type) || !isSegmentPart(g.type) ? {
    part: g.type,
    value: g.value
  } : {
    part: g.type,
    value: a[g.type]
  }).filter((g) => !(g.part === null || g.value === null || g.part === "timeZoneName" && (!isZonedDateTime(e.dateRef) || o)));
}
function createContent(e) {
  const t = createContentObj(e), n = createContentArr({
    contentObj: t,
    ...e
  });
  return {
    obj: t,
    arr: n
  };
}
const [injectDateFieldRootContext, provideDateFieldRootContext] = createContext$2("DateFieldRoot"), _sfc_main$3o = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "DateFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    step: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { disabled: s, readonly: u, isDateUnavailable: d, granularity: f, defaultValue: g, dir: v, locale: b } = toRefs(a), w = useLocale(b), C = useDirection(v), k = useDateFormatter(w.value, {
      hourCycle: normalizeHourCycle(a.hourCycle)
    }), { primitiveElement: E, currentElement: A } = usePrimitiveElement(), P = ref(/* @__PURE__ */ new Set());
    onMounted(() => {
      getSegmentElements(A.value).forEach((ue) => P.value.add(ue));
    });
    const M = useVModel(a, "modelValue", o, {
      defaultValue: g.value,
      passive: a.modelValue === void 0
    }), B = getDefaultDate({
      defaultPlaceholder: a.placeholder,
      granularity: f.value,
      defaultValue: M.value,
      locale: a.locale
    }), _ = useVModel(a, "placeholder", o, {
      defaultValue: a.defaultPlaceholder ?? B.copy(),
      passive: a.placeholder === void 0
    }), T = computed(() => normalizeDateStep(a)), O = computed(() => a.granularity ? hasTime(_.value) ? a.granularity : "day" : hasTime(_.value) ? "minute" : "day"), I = computed(() => M.value ? !!(d.value?.(M.value) || a.minValue && isBefore(M.value, a.minValue) || a.maxValue && isBefore(a.maxValue, M.value)) : !1), q = initializeSegmentValues(O.value), F = ref(M.value ? { ...syncSegmentValues({ value: M.value, formatter: k }) } : { ...q }), W = computed(() => createContent({
      granularity: O.value,
      dateRef: _.value,
      formatter: k,
      hideTimeZone: a.hideTimeZone,
      hourCycle: a.hourCycle,
      segmentValues: F.value,
      locale: w
    })), K = computed(() => W.value.arr), Z = computed(() => K.value.filter(({ part: ue }) => ue !== "literal"));
    watch(w, (ue) => {
      k.getLocale() !== ue && (k.setLocale(ue), nextTick(() => {
        P.value.clear(), getSegmentElements(A.value).forEach((Be) => P.value.add(Be));
      }));
    }), watch(M, (ue) => {
      !isNullish$1(ue) && _.value.compare(ue) !== 0 && (_.value = ue.copy());
    }), watch([M, w], ([ue]) => {
      isNullish$1(ue) ? Object.values(F.value).every((Be) => Be !== null) && isNullish$1(ue) && (F.value = { ...q }) : F.value = { ...syncSegmentValues({ value: ue, formatter: k }) };
    });
    const J = ref(null), re = computed(() => Array.from(P.value).findIndex((ue) => ue.getAttribute("data-reka-date-field-segment") === J.value?.getAttribute("data-reka-date-field-segment"))), V = computed(() => {
      const ue = C.value === "rtl" ? -1 : 1;
      return (ue < 0 ? re.value < 0 : re.value > P.value.size - 1) ? null : Array.from(P.value)[re.value + ue];
    }), ne = computed(() => {
      const ue = C.value === "rtl" ? -1 : 1;
      return (ue > 0 ? re.value < 0 : re.value > P.value.size - 1) ? null : Array.from(P.value)[re.value - ue];
    }), Q = useKbd();
    function z(ue) {
      isSegmentNavigationKey(ue.key) && (ue.key === Q.ARROW_LEFT && ne.value?.focus(), ue.key === Q.ARROW_RIGHT && V.value?.focus());
    }
    function X(ue) {
      J.value = ue;
    }
    return provideDateFieldRootContext({
      isDateUnavailable: d.value,
      locale: w,
      modelValue: M,
      placeholder: _,
      disabled: s,
      formatter: k,
      hourCycle: a.hourCycle,
      step: T,
      readonly: u,
      segmentValues: F,
      isInvalid: I,
      segmentContents: Z,
      elements: P,
      setFocusedElement: X,
      focusNext() {
        V.value?.focus();
      }
    }), t({
      /** Helper to set the focused element inside the DateField */
      setFocusedElement: X
    }), (ue, Be) => (openBlock(), createBlock(unref(Primitive), mergeProps(ue.$attrs, {
      ref_key: "primitiveElement",
      ref: E,
      role: "group",
      "aria-disabled": unref(s) ? !0 : void 0,
      "data-disabled": unref(s) ? "" : void 0,
      "data-readonly": unref(u) ? "" : void 0,
      "data-invalid": I.value ? "" : void 0,
      dir: unref(C),
      onKeydown: withKeys(z, ["left", "right"])
    }), {
      default: withCtx(() => [
        renderSlot(ue.$slots, "default", {
          modelValue: unref(M),
          segments: K.value,
          isInvalid: I.value
        }),
        createVNode(unref(_sfc_main$4u), {
          id: ue.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: unref(M) ? unref(M).toString() : "",
          name: ue.name,
          disabled: unref(s),
          required: ue.required,
          onFocus: Be[0] || (Be[0] = (te) => Array.from(P.value)?.[0]?.focus())
        }, null, 8, ["id", "value", "name", "disabled", "required"])
      ]),
      _: 3
    }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]));
  }
}), _sfc_main$3n = /* @__PURE__ */ defineComponent({
  __name: "DateFieldInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectDateFieldRootContext(), a = ref(!0), o = ref(!1), {
      handleSegmentClick: s,
      handleSegmentKeydown: u,
      attributes: d
    } = useDateField({
      hasLeftFocus: a,
      lastKeyZero: o,
      placeholder: n.placeholder,
      hourCycle: n.hourCycle,
      step: n.step,
      segmentValues: n.segmentValues,
      formatter: n.formatter,
      part: t.part,
      disabled: n.disabled,
      readonly: n.readonly,
      focusNext: n.focusNext,
      modelValue: n.modelValue
    }), f = computed(() => n.disabled.value), g = computed(() => n.readonly.value), v = computed(() => n.isInvalid.value);
    return (b, w) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      as: b.as,
      "as-child": b.asChild
    }, unref(d), {
      contenteditable: f.value || g.value ? !1 : b.part !== "literal",
      "data-reka-date-field-segment": b.part,
      "aria-disabled": f.value ? !0 : void 0,
      "aria-readonly": g.value ? !0 : void 0,
      "data-disabled": f.value ? "" : void 0,
      "data-invalid": v.value ? "" : void 0,
      "aria-invalid": v.value ? !0 : void 0
    }, toHandlers(b.part !== "literal" ? {
      mousedown: unref(s),
      keydown: unref(u),
      focusout: () => {
        a.value = !0;
      },
      focusin: (C) => {
        unref(n).setFocusedElement(C.target);
      }
    } : {})), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "contenteditable", "data-reka-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-invalid", "aria-invalid"]));
  }
}), [injectPopoverRootContext, providePopoverRootContext] = createContext$2("PopoverRoot"), _sfc_main$3m = /* @__PURE__ */ defineComponent({
  __name: "PopoverRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, { modal: o } = toRefs(n), s = useVModel(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), u = ref(), d = ref(!1);
    return providePopoverRootContext({
      contentId: "",
      triggerId: "",
      modal: o,
      open: s,
      onOpenChange: (f) => {
        s.value = f;
      },
      onOpenToggle: () => {
        s.value = !s.value;
      },
      triggerElement: u,
      hasCustomAnchor: d
    }), (f, g) => (openBlock(), createBlock(unref(_sfc_main$3Z), null, {
      default: withCtx(() => [
        renderSlot(f.$slots, "default", { open: unref(s) })
      ]),
      _: 3
    }));
  }
}), _sfc_main$3l = /* @__PURE__ */ defineComponent({
  __name: "PopoverArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    rounded: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3U), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [injectDatePickerRootContext, provideDatePickerRootContext] = createContext$2("DatePickerRoot"), _sfc_main$3k = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "DatePickerRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    step: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: !1 },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "update:placeholder", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, {
      locale: o,
      disabled: s,
      readonly: u,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      preventDeselect: w,
      isDateDisabled: C,
      isDateUnavailable: k,
      defaultOpen: E,
      modal: A,
      id: P,
      name: M,
      required: B,
      minValue: _,
      maxValue: T,
      granularity: O,
      hideTimeZone: I,
      hourCycle: q,
      defaultValue: F,
      dir: W
    } = toRefs(n), K = useDirection(W), Z = useVModel(n, "modelValue", a, {
      defaultValue: F.value,
      passive: n.modelValue === void 0
    }), J = computed(() => getDefaultDate({
      defaultPlaceholder: n.placeholder,
      granularity: n.granularity,
      defaultValue: Z.value,
      locale: n.locale
    })), re = useVModel(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? J.value.copy(),
      passive: n.placeholder === void 0
    }), V = useVModel(n, "open", a, {
      defaultValue: E.value,
      passive: n.open === void 0
    }), ne = ref();
    return watch(Z, (Q) => {
      Q && Q.compare(re.value) !== 0 && (re.value = Q.copy());
    }), provideDatePickerRootContext({
      isDateUnavailable: k.value,
      isDateDisabled: C.value,
      locale: o,
      disabled: s,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      readonly: u,
      preventDeselect: w,
      modelValue: Z,
      placeholder: re,
      defaultOpen: E,
      modal: A,
      open: V,
      id: P,
      name: M,
      required: B,
      minValue: _,
      maxValue: T,
      granularity: O,
      hideTimeZone: I,
      hourCycle: q,
      dateFieldRef: ne,
      dir: K,
      onDateChange(Q) {
        !Q || !Z.value ? Z.value = Q?.copy() ?? void 0 : !w.value && Q && Z.value.compare(Q) === 0 ? Z.value = void 0 : Z.value = Q.copy();
      },
      onPlaceholderChange(Q) {
        re.value = Q.copy();
      }
    }), (Q, z) => (openBlock(), createBlock(unref(_sfc_main$3m), {
      open: unref(V),
      "onUpdate:open": z[0] || (z[0] = (X) => isRef(V) ? V.value = X : null),
      "default-open": unref(E),
      modal: unref(A)
    }, {
      default: withCtx(() => [
        renderSlot(Q.$slots, "default")
      ]),
      _: 3
    }, 8, ["open", "default-open", "modal"]));
  }
}), _sfc_main$3j = /* @__PURE__ */ defineComponent({
  __name: "DatePickerCalendar",
  setup(e) {
    const t = injectDatePickerRootContext();
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4g), mergeProps({
      isDateDisabled: unref(t).isDateDisabled,
      isDateUnavailable: unref(t).isDateUnavailable,
      minValue: unref(t).minValue.value,
      maxValue: unref(t).maxValue.value,
      locale: unref(t).locale.value,
      disabled: unref(t).disabled.value,
      pagedNavigation: unref(t).pagedNavigation.value,
      weekStartsOn: unref(t).weekStartsOn.value,
      weekdayFormat: unref(t).weekdayFormat.value,
      fixedWeeks: unref(t).fixedWeeks.value,
      numberOfMonths: unref(t).numberOfMonths.value,
      readonly: unref(t).readonly.value,
      preventDeselect: unref(t).preventDeselect.value,
      dir: unref(t).dir.value
    }, {
      "model-value": unref(t).modelValue.value,
      placeholder: unref(t).placeholder.value,
      "initial-focus": "",
      multiple: !1,
      "onUpdate:modelValue": a[0] || (a[0] = (o) => {
        o && unref(t).modelValue.value && unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o, unref(t).modelValue.value) || unref(t).onDateChange(o);
      }),
      "onUpdate:placeholder": a[1] || (a[1] = (o) => {
        unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o, unref(t).placeholder.value) || unref(t).onPlaceholderChange(o);
      })
    }), {
      default: withCtx(({ weekDays: o, grid: s, date: u, weekStartsOn: d, locale: f, fixedWeeks: g }) => [
        renderSlot(n.$slots, "default", {
          date: u,
          grid: s,
          weekDays: o,
          weekStartsOn: d,
          locale: f,
          fixedWeeks: g
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), _sfc_main$3i = /* @__PURE__ */ defineComponent({
  __name: "DatePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4f), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3h = /* @__PURE__ */ defineComponent({
  __name: "DatePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4e), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3g = /* @__PURE__ */ defineComponent({
  __name: "PopoverClose",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e;
    useForwardExpose();
    const n = injectPopoverRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Primitive), {
      type: a.as === "button" ? "button" : void 0,
      as: a.as,
      "as-child": t.asChild,
      onClick: o[0] || (o[0] = (s) => unref(n).onOpenChange(!1))
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "as", "as-child"]));
  }
}), _sfc_main$3f = /* @__PURE__ */ defineComponent({
  __name: "PopoverPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4j), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3e = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentImpl",
  props: {
    trapFocus: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useForwardProps(reactiveOmit(n, "trapFocus", "disableOutsidePointerEvents")), { forwardRef: s } = useForwardExpose(), u = injectPopoverRootContext();
    return useFocusGuards(), (d, f) => (openBlock(), createBlock(unref(_sfc_main$4r), {
      "as-child": "",
      loop: "",
      trapped: d.trapFocus,
      onMountAutoFocus: f[5] || (f[5] = (g) => a("openAutoFocus", g)),
      onUnmountAutoFocus: f[6] || (f[6] = (g) => a("closeAutoFocus", g))
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$4q), {
          "as-child": "",
          "disable-outside-pointer-events": d.disableOutsidePointerEvents,
          onPointerDownOutside: f[0] || (f[0] = (g) => a("pointerDownOutside", g)),
          onInteractOutside: f[1] || (f[1] = (g) => a("interactOutside", g)),
          onEscapeKeyDown: f[2] || (f[2] = (g) => a("escapeKeyDown", g)),
          onFocusOutside: f[3] || (f[3] = (g) => a("focusOutside", g)),
          onDismiss: f[4] || (f[4] = (g) => unref(u).onOpenChange(!1))
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$3V), mergeProps(unref(o), {
              id: unref(u).contentId,
              ref: unref(s),
              "data-state": unref(u).open.value ? "open" : "closed",
              "aria-labelledby": unref(u).triggerId,
              style: {
                "--reka-popover-content-transform-origin": "var(--reka-popper-transform-origin)",
                "--reka-popover-content-available-width": "var(--reka-popper-available-width)",
                "--reka-popover-content-available-height": "var(--reka-popper-available-height)",
                "--reka-popover-trigger-width": "var(--reka-popper-anchor-width)",
                "--reka-popover-trigger-height": "var(--reka-popper-anchor-height)"
              },
              role: "dialog"
            }), {
              default: withCtx(() => [
                renderSlot(d.$slots, "default")
              ]),
              _: 3
            }, 16, ["id", "data-state", "aria-labelledby"])
          ]),
          _: 3
        }, 8, ["disable-outside-pointer-events"])
      ]),
      _: 3
    }, 8, ["trapped"]));
  }
}), _sfc_main$3d = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectPopoverRootContext(), s = ref(!1);
    useBodyScrollLock(!0);
    const u = useForwardPropsEmits(n, a), { forwardRef: d, currentElement: f } = useForwardExpose();
    return useHideOthers(f), (g, v) => (openBlock(), createBlock(_sfc_main$3e, mergeProps(unref(u), {
      ref: unref(d),
      "trap-focus": unref(o).open.value,
      "disable-outside-pointer-events": "",
      onCloseAutoFocus: v[0] || (v[0] = withModifiers(
        (b) => {
          a("closeAutoFocus", b), s.value || unref(o).triggerElement.value?.focus();
        },
        ["prevent"]
      )),
      onPointerDownOutside: v[1] || (v[1] = (b) => {
        a("pointerDownOutside", b);
        const w = b.detail.originalEvent, C = w.button === 0 && w.ctrlKey === !0, k = w.button === 2 || C;
        s.value = k;
      }),
      onFocusOutside: v[2] || (v[2] = withModifiers(() => {
      }, ["prevent"]))
    }), {
      default: withCtx(() => [
        renderSlot(g.$slots, "default")
      ]),
      _: 3
    }, 16, ["trap-focus"]));
  }
}), _sfc_main$3c = /* @__PURE__ */ defineComponent({
  __name: "PopoverContentNonModal",
  props: {
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectPopoverRootContext(), s = ref(!1), u = ref(!1), d = useForwardPropsEmits(n, a);
    return (f, g) => (openBlock(), createBlock(_sfc_main$3e, mergeProps(unref(d), {
      "trap-focus": !1,
      "disable-outside-pointer-events": !1,
      onCloseAutoFocus: g[0] || (g[0] = (v) => {
        a("closeAutoFocus", v), v.defaultPrevented || (s.value || unref(o).triggerElement.value?.focus(), v.preventDefault()), s.value = !1, u.value = !1;
      }),
      onInteractOutside: g[1] || (g[1] = async (v) => {
        a("interactOutside", v), v.defaultPrevented || (s.value = !0, v.detail.originalEvent.type === "pointerdown" && (u.value = !0));
        const b = v.target;
        unref(o).triggerElement.value?.contains(b) && v.preventDefault(), v.detail.originalEvent.type === "focusin" && u.value && v.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$3b = /* @__PURE__ */ defineComponent({
  __name: "PopoverContent",
  props: {
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectPopoverRootContext(), s = useForwardPropsEmits(n, a), { forwardRef: u } = useForwardExpose();
    return o.contentId ||= useId(void 0, "reka-popover-content"), (d, f) => (openBlock(), createBlock(unref(Presence), {
      present: d.forceMount || unref(o).open.value
    }, {
      default: withCtx(() => [
        unref(o).modal.value ? (openBlock(), createBlock(_sfc_main$3d, mergeProps({ key: 0 }, unref(s), { ref: unref(u) }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16)) : (openBlock(), createBlock(_sfc_main$3c, mergeProps({ key: 1 }, unref(s), { ref: unref(u) }), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), _sfc_main$3a = /* @__PURE__ */ defineComponent({
  __name: "DatePickerContent",
  props: {
    portal: {},
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = computed(() => ({
      ...n,
      portal: void 0
    })), s = useForwardPropsEmits(o, a);
    return (u, d) => (openBlock(), createBlock(unref(_sfc_main$3f), normalizeProps(guardReactiveProps(u.portal)), {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$3b), normalizeProps(guardReactiveProps({ ...unref(s), ...u.$attrs })), {
          default: withCtx(() => [
            renderSlot(u.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$39 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerField",
  setup(e) {
    const t = injectDatePickerRootContext();
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3o), mergeProps({
      ref: unref(t).dateFieldRef,
      "model-value": unref(t).modelValue.value,
      placeholder: unref(t).placeholder.value
    }, {
      id: unref(t).id.value,
      name: unref(t).name.value,
      disabled: unref(t).disabled.value,
      minValue: unref(t).minValue.value,
      maxValue: unref(t).maxValue.value,
      readonly: unref(t).readonly.value,
      hourCycle: unref(t).hourCycle.value,
      granularity: unref(t).granularity.value,
      hideTimeZone: unref(t).hideTimeZone.value,
      locale: unref(t).locale.value,
      isDateUnavailable: unref(t).isDateUnavailable,
      required: unref(t).required.value,
      dir: unref(t).dir.value
    }, {
      "onUpdate:modelValue": a[0] || (a[0] = (o) => {
        o && unref(t).modelValue.value && o.compare(unref(t).modelValue.value) === 0 || unref(t).onDateChange(o);
      }),
      "onUpdate:placeholder": a[1] || (a[1] = (o) => {
        o.compare(unref(t).placeholder.value) !== 0 && unref(t).onPlaceholderChange(o);
      })
    }), {
      default: withCtx(({ segments: o, modelValue: s }) => [
        renderSlot(n.$slots, "default", {
          segments: o,
          modelValue: s
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), _sfc_main$38 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4d), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$37 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4c), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$36 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4b), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$35 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4a), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$34 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$49), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$33 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$48), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$32 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$47), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(({ headingValue: o }) => [
        renderSlot(n.$slots, "default", { headingValue: o }, () => [
          createTextVNode(toDisplayString(o), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$31 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3n), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$30 = /* @__PURE__ */ defineComponent({
  __name: "DatePickerNext",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$46), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2$ = /* @__PURE__ */ defineComponent({
  __name: "DatePickerPrev",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$45), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2_ = /* @__PURE__ */ defineComponent({
  __name: "PopoverTrigger",
  props: {
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = injectPopoverRootContext(), { forwardRef: a, currentElement: o } = useForwardExpose();
    return n.triggerId ||= useId(void 0, "reka-popover-trigger"), onMounted(() => {
      n.triggerElement.value = o.value;
    }), (s, u) => (openBlock(), createBlock(resolveDynamicComponent(unref(n).hasCustomAnchor.value ? unref(Primitive) : unref(_sfc_main$3Y)), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          id: unref(n).triggerId,
          ref: unref(a),
          type: s.as === "button" ? "button" : void 0,
          "aria-haspopup": "dialog",
          "aria-expanded": unref(n).open.value,
          "aria-controls": unref(n).contentId,
          "data-state": unref(n).open.value ? "open" : "closed",
          as: s.as,
          "as-child": t.asChild,
          onClick: unref(n).onOpenToggle
        }, {
          default: withCtx(() => [
            renderSlot(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "aria-expanded", "aria-controls", "data-state", "as", "as-child", "onClick"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$2Z = /* @__PURE__ */ defineComponent({
  __name: "DatePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectDatePickerRootContext();
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$2_), mergeProps({ "data-reka-date-field-segment": "trigger" }, t, {
      disabled: unref(n).disabled.value,
      onFocusin: o[0] || (o[0] = (s) => {
        unref(n).dateFieldRef.value?.setFocusedElement(s.target);
      })
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["disabled"]));
  }
}), [injectDateRangeFieldRootContext, provideDateRangeFieldRootContext] = createContext$2("DateRangeFieldRoot"), _sfc_main$2Y = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "DateRangeFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    step: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { disabled: s, readonly: u, isDateUnavailable: d, dir: f, locale: g } = toRefs(a), v = useLocale(g), b = useDirection(f), w = useDateFormatter(v.value, {
      hourCycle: normalizeHourCycle(a.hourCycle)
    }), { primitiveElement: C, currentElement: k } = usePrimitiveElement(), E = ref(/* @__PURE__ */ new Set());
    onMounted(() => {
      getSegmentElements(k.value).forEach((ie) => E.value.add(ie));
    });
    const A = useVModel(a, "modelValue", o, {
      defaultValue: a.defaultValue ?? { start: void 0, end: void 0 },
      passive: a.modelValue === void 0
    }), P = getDefaultDate({
      defaultPlaceholder: a.placeholder,
      granularity: a.granularity,
      defaultValue: A.value?.start,
      locale: a.locale
    }), M = useVModel(a, "placeholder", o, {
      defaultValue: a.defaultPlaceholder ?? P.copy(),
      passive: a.placeholder === void 0
    }), B = computed(() => normalizeDateStep(a)), _ = computed(() => a.granularity ? hasTime(M.value) ? a.granularity : "day" : hasTime(M.value) ? "minute" : "day"), T = computed(() => A.value?.start ? !!(d.value?.(A.value.start) || a.minValue && isBefore(A.value.start, a.minValue) || a.maxValue && isBefore(a.maxValue, A.value.start)) : !1), O = computed(() => A.value?.end ? !!(d.value?.(A.value.end) || a.minValue && isBefore(A.value.end, a.minValue) || a.maxValue && isBefore(a.maxValue, A.value.end)) : !1), I = computed(() => T.value || O.value ? !0 : !A.value?.start || !A.value?.end ? !1 : !isBeforeOrSame(A.value.start, A.value.end) || d.value !== void 0 && !areAllDaysBetweenValid(
      A.value.start,
      A.value.end,
      d.value,
      void 0
    )), q = initializeSegmentValues(_.value), F = ref(A.value?.start ? { ...syncSegmentValues({ value: A.value.start, formatter: w }) } : { ...q }), W = ref(A.value?.end ? { ...syncSegmentValues({ value: A.value.end, formatter: w }) } : { ...q }), K = computed(() => createContent({
      granularity: _.value,
      dateRef: M.value,
      formatter: w,
      hideTimeZone: a.hideTimeZone,
      hourCycle: a.hourCycle,
      segmentValues: F.value,
      locale: v
    })), Z = computed(() => createContent({
      granularity: _.value,
      dateRef: M.value,
      formatter: w,
      hideTimeZone: a.hideTimeZone,
      hourCycle: a.hourCycle,
      segmentValues: W.value,
      locale: v
    })), J = computed(() => ({
      start: K.value.arr,
      end: Z.value.arr
    })), re = computed(() => ({ start: J.value.start.filter(({ part: ie }) => ie !== "literal"), end: J.value.end.filter(({ part: ie }) => ie !== "literal") })), V = ref(A.value?.start?.copy()), ne = ref(A.value?.end?.copy());
    watch([V, ne], ([ie, oe]) => {
      A.value = { start: ie?.copy(), end: oe?.copy() };
    }), watch(A, (ie) => {
      (ie?.start && V.value ? ie.start.compare(V.value) !== 0 : ie?.start !== V.value) && (V.value = ie?.start?.copy()), (ie?.end && ne.value ? ie.end.compare(ne.value) !== 0 : ie?.end !== ne.value) && (ne.value = ie?.end?.copy());
    }), watch([V, v], ([ie]) => {
      ie !== void 0 ? F.value = { ...syncSegmentValues({ value: ie, formatter: w }) } : Object.values(F.value).every((oe) => oe !== null) && ie === void 0 && (F.value = { ...q });
    }), watch(v, (ie) => {
      w.getLocale() !== ie && (w.setLocale(ie), nextTick(() => {
        E.value.clear(), getSegmentElements(k.value).forEach((oe) => E.value.add(oe));
      }));
    }), watch(A, (ie) => {
      ie && ie.start !== void 0 && M.value.compare(ie.start) !== 0 && (M.value = ie.start.copy());
    }), watch([ne, v], ([ie]) => {
      ie !== void 0 ? W.value = { ...syncSegmentValues({ value: ie, formatter: w }) } : Object.values(W.value).every((oe) => oe !== null) && ie === void 0 && (W.value = { ...q });
    });
    const Q = ref(null), z = computed(() => Array.from(E.value).findIndex((ie) => ie.getAttribute("data-reka-date-field-segment") === Q.value?.getAttribute("data-reka-date-field-segment") && ie.getAttribute("data-reka-date-range-field-segment-type") === Q.value?.getAttribute("data-reka-date-range-field-segment-type"))), X = computed(() => {
      const ie = b.value === "rtl" ? -1 : 1;
      return (ie < 0 ? z.value < 0 : z.value > E.value.size - 1) ? null : Array.from(E.value)[z.value + ie];
    }), ue = computed(() => {
      const ie = b.value === "rtl" ? -1 : 1;
      return (ie > 0 ? z.value < 0 : z.value > E.value.size - 1) ? null : Array.from(E.value)[z.value - ie];
    }), Be = useKbd();
    function te(ie) {
      isSegmentNavigationKey(ie.key) && (ie.key === Be.ARROW_LEFT && ue.value?.focus(), ie.key === Be.ARROW_RIGHT && X.value?.focus());
    }
    function G(ie) {
      Q.value = ie;
    }
    return provideDateRangeFieldRootContext({
      isDateUnavailable: d.value,
      locale: v,
      startValue: V,
      endValue: ne,
      placeholder: M,
      disabled: s,
      formatter: w,
      hourCycle: a.hourCycle,
      step: B,
      readonly: u,
      segmentValues: { start: F, end: W },
      isInvalid: I,
      segmentContents: re,
      elements: E,
      setFocusedElement: G,
      focusNext() {
        X.value?.focus();
      }
    }), t({
      setFocusedElement: G
    }), (ie, oe) => (openBlock(), createBlock(unref(Primitive), mergeProps(ie.$attrs, {
      ref_key: "primitiveElement",
      ref: C,
      role: "group",
      "aria-disabled": unref(s) ? !0 : void 0,
      "data-disabled": unref(s) ? "" : void 0,
      "data-readonly": unref(u) ? "" : void 0,
      "data-invalid": I.value ? "" : void 0,
      dir: unref(b),
      onKeydown: withKeys(te, ["left", "right"])
    }), {
      default: withCtx(() => [
        renderSlot(ie.$slots, "default", {
          modelValue: unref(A),
          segments: J.value
        }),
        createVNode(unref(_sfc_main$4u), {
          id: ie.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: `${unref(A)?.start?.toString()} - ${unref(A)?.end?.toString()}`,
          name: ie.name,
          disabled: unref(s),
          required: ie.required,
          onFocus: oe[0] || (oe[0] = (ye) => Array.from(E.value)?.[0]?.focus())
        }, null, 8, ["id", "value", "name", "disabled", "required"])
      ]),
      _: 3
    }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]));
  }
}), _sfc_main$2X = /* @__PURE__ */ defineComponent({
  __name: "DateRangeFieldInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectDateRangeFieldRootContext(), a = ref(!0), o = ref(!1), {
      handleSegmentClick: s,
      handleSegmentKeydown: u,
      attributes: d
    } = useDateField({
      hasLeftFocus: a,
      lastKeyZero: o,
      placeholder: n.placeholder,
      hourCycle: n.hourCycle,
      step: n.step,
      segmentValues: n.segmentValues[t.type],
      formatter: n.formatter,
      part: t.part,
      disabled: n.disabled,
      readonly: n.readonly,
      focusNext: n.focusNext,
      modelValue: t.type === "start" ? n.startValue : n.endValue
    }), f = computed(() => n.disabled.value), g = computed(() => n.readonly.value), v = computed(() => n.isInvalid.value);
    return (b, w) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      as: b.as,
      "as-child": b.asChild
    }, unref(d), {
      contenteditable: f.value || g.value ? !1 : b.part !== "literal",
      "data-reka-date-field-segment": b.part,
      "aria-disabled": f.value ? !0 : void 0,
      "aria-readonly": g.value ? !0 : void 0,
      "data-disabled": f.value ? "" : void 0,
      "data-reka-date-range-field-segment-type": b.type,
      "data-invalid": v.value ? "" : void 0,
      "aria-invalid": v.value ? !0 : void 0
    }, toHandlers(b.part !== "literal" ? {
      mousedown: unref(s),
      keydown: unref(u),
      focusout: () => {
        a.value = !0;
      },
      focusin: (C) => {
        unref(n).setFocusedElement(C.target);
      }
    } : {})), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "contenteditable", "data-reka-date-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-reka-date-range-field-segment-type", "data-invalid", "aria-invalid"]));
  }
}), [injectDateRangePickerRootContext, provideDateRangePickerRootContext] = createContext$2("DateRangePickerRoot"), _sfc_main$2W = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "DateRangePickerRoot",
  props: {
    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    step: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: { default: "en" },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    isDateUnavailable: { type: Function, default: void 0 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    modal: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    pagedNavigation: { type: Boolean, default: !1 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    fixedWeeks: { type: Boolean, default: !1 },
    numberOfMonths: { default: 1 },
    preventDeselect: { type: Boolean, default: !1 },
    isDateHighlightable: { type: Function, default: void 0 },
    allowNonContiguousRanges: { type: Boolean, default: !1 },
    fixedDate: {},
    maximumDays: { default: void 0 }
  },
  emits: ["update:modelValue", "update:placeholder", "update:startValue", "update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t, {
      locale: o,
      disabled: s,
      readonly: u,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      preventDeselect: w,
      isDateDisabled: C,
      isDateUnavailable: k,
      isDateHighlightable: E,
      defaultOpen: A,
      modal: P,
      id: M,
      name: B,
      required: _,
      minValue: T,
      maxValue: O,
      granularity: I,
      hideTimeZone: q,
      hourCycle: F,
      dir: W,
      allowNonContiguousRanges: K,
      fixedDate: Z,
      maximumDays: J
    } = toRefs(n), re = useDirection(W), V = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },
      passive: n.modelValue === void 0
    }), ne = getDefaultDate({
      defaultPlaceholder: n.placeholder,
      granularity: n.granularity,
      defaultValue: V.value?.start,
      locale: n.locale
    }), Q = useVModel(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ne.copy(),
      passive: n.placeholder === void 0
    }), z = useVModel(n, "open", a, {
      defaultValue: A.value,
      passive: n.open === void 0
    }), X = ref();
    return watch(V, (ue) => {
      ue && ue.start && ue.start.compare(Q.value) !== 0 && (Q.value = ue.start.copy());
    }), provideDateRangePickerRootContext({
      allowNonContiguousRanges: K,
      isDateUnavailable: k.value,
      isDateDisabled: C.value,
      isDateHighlightable: E.value,
      locale: o,
      disabled: s,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      readonly: u,
      preventDeselect: w,
      modelValue: V,
      placeholder: Q,
      defaultOpen: A,
      modal: P,
      open: z,
      id: M,
      name: B,
      required: _,
      minValue: T,
      maxValue: O,
      granularity: I,
      hideTimeZone: q,
      hourCycle: F,
      dateFieldRef: X,
      dir: re,
      fixedDate: Z,
      maximumDays: J,
      onStartValueChange(ue) {
        a("update:startValue", ue);
      },
      onDateChange(ue) {
        V.value = { start: ue.start?.copy(), end: ue.end?.copy() };
      },
      onPlaceholderChange(ue) {
        Q.value = ue.copy();
      }
    }), (ue, Be) => (openBlock(), createBlock(unref(_sfc_main$3m), {
      open: unref(z),
      "onUpdate:open": Be[0] || (Be[0] = (te) => isRef(z) ? z.value = te : null),
      "default-open": unref(A),
      modal: unref(P)
    }, {
      default: withCtx(() => [
        renderSlot(ue.$slots, "default", {
          modelValue: unref(V),
          open: unref(z)
        })
      ]),
      _: 3
    }, 8, ["open", "default-open", "modal"]));
  }
});
function useRangeCalendarState(e) {
  const t = computed(() => e.start.value ? !!e.isDateDisabled(e.start.value) : !1), n = computed(() => e.end.value ? !!e.isDateDisabled(e.end.value) : !1), a = computed(
    () => t.value || n.value ? !1 : !!(e.start.value && e.end.value && isBefore(e.end.value, e.start.value))
  ), o = (w) => e.start.value ? $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.start.value, w) : !1, s = (w) => e.end.value ? $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.end.value, w) : !1, u = (w) => e.start.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.start.value, w) || e.end.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.end.value, w) ? !0 : e.end.value && e.start.value ? isBetween(w, e.start.value, e.end.value) : !1, d = (w) => {
    if (e.isDateDisabled(w))
      return !0;
    if (e.maximumDays?.value) {
      if (e.start.value && e.end.value) {
        if (e.fixedDate.value) {
          const C = getDaysBetween(e.start.value, e.end.value).length;
          if (C <= e.maximumDays.value) {
            const k = e.maximumDays.value - C - 1, E = e.start.value.subtract({ days: k }), A = e.end.value.add({ days: k });
            return !isBetween(w, E, A);
          }
        }
        return !1;
      }
      if (e.start.value) {
        const C = e.start.value.add({ days: e.maximumDays.value }), k = e.start.value.subtract({ days: e.maximumDays.value });
        return !isBetween(w, k, C);
      }
    }
    return !e.start.value || e.end.value || $14e0f24ef4ac5c92$export$ea39ec197993aef0(e.start.value, w), !1;
  }, f = (w) => !!e.isDateHighlightable?.(w), g = computed(() => {
    if (e.start.value && e.end.value && !e.fixedDate.value || !e.start.value || !e.focusedValue.value)
      return null;
    const w = isBefore(e.start.value, e.focusedValue.value), C = w ? e.start.value : e.focusedValue.value, k = w ? e.focusedValue.value : e.start.value;
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(C, k))
      return {
        start: C,
        end: k
      };
    if (e.maximumDays?.value && !e.end.value) {
      const A = w ? C.add({ days: e.maximumDays.value }) : C.subtract({ days: e.maximumDays.value });
      return {
        start: C,
        end: A
      };
    }
    return areAllDaysBetweenValid(C, k, e.allowNonContiguousRanges.value ? () => !1 : e.isDateUnavailable, d, e.isDateHighlightable) ? {
      start: C,
      end: k
    } : null;
  });
  return {
    isInvalid: a,
    isSelected: u,
    isDateHighlightable: f,
    highlightedRange: g,
    isSelectionStart: o,
    isSelectionEnd: s,
    isHighlightedStart: (w) => !g.value || !g.value.start ? !1 : $14e0f24ef4ac5c92$export$ea39ec197993aef0(g.value.start, w),
    isHighlightedEnd: (w) => !g.value || !g.value.end ? !1 : $14e0f24ef4ac5c92$export$ea39ec197993aef0(g.value.end, w),
    isDateDisabled: d
  };
}
const _hoisted_1$12 = { style: { border: "0px", clip: "rect(0px, 0px, 0px, 0px)", "clip-path": "inset(50%)", height: "1px", margin: "-1px", overflow: "hidden", padding: "0px", position: "absolute", "white-space": "nowrap", width: "1px" } }, _hoisted_2$D = {
  role: "heading",
  "aria-level": "2"
}, [injectRangeCalendarRootContext, provideRangeCalendarRootContext] = createContext$2("RangeCalendarRoot"), _sfc_main$2V = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarRoot",
  props: {
    defaultPlaceholder: {},
    defaultValue: { default: () => ({ start: void 0, end: void 0 }) },
    modelValue: {},
    placeholder: { default: void 0 },
    allowNonContiguousRanges: { type: Boolean, default: !1 },
    pagedNavigation: { type: Boolean, default: !1 },
    preventDeselect: { type: Boolean, default: !1 },
    maximumDays: { default: void 0 },
    weekStartsOn: { default: 0 },
    weekdayFormat: { default: "narrow" },
    calendarLabel: {},
    fixedWeeks: { type: Boolean, default: !1 },
    maxValue: {},
    minValue: {},
    locale: {},
    numberOfMonths: { default: 1 },
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    initialFocus: { type: Boolean, default: !1 },
    isDateDisabled: { type: Function, default: void 0 },
    isDateUnavailable: { type: Function, default: void 0 },
    isDateHighlightable: { type: Function, default: void 0 },
    dir: {},
    nextPage: {},
    prevPage: {},
    disableDaysOutsideCurrentView: { type: Boolean, default: !1 },
    fixedDate: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  emits: ["update:modelValue", "update:placeholder", "update:startValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, {
      disabled: o,
      readonly: s,
      initialFocus: u,
      pagedNavigation: d,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      preventDeselect: w,
      isDateUnavailable: C,
      isDateHighlightable: k,
      isDateDisabled: E,
      calendarLabel: A,
      maxValue: P,
      minValue: M,
      dir: B,
      locale: _,
      nextPage: T,
      prevPage: O,
      allowNonContiguousRanges: I,
      disableDaysOutsideCurrentView: q,
      fixedDate: F,
      maximumDays: W
    } = toRefs(n), { primitiveElement: K, currentElement: Z } = usePrimitiveElement(), J = useDirection(B), re = useLocale(_), V = ref(), ne = ref(), Q = ref(!1), z = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue ?? { start: void 0, end: void 0 },
      passive: n.modelValue === void 0
    }), X = computed(
      () => isNullish$1(z.value) ? { start: void 0, end: void 0 } : z.value
    ), ue = getDefaultDate({
      defaultPlaceholder: n.placeholder,
      defaultValue: X.value.start,
      locale: n.locale
    }), Be = ref(X.value.start), te = ref(X.value.end), G = useVModel(n, "placeholder", a, {
      defaultValue: n.defaultPlaceholder ?? ue.copy(),
      passive: n.placeholder === void 0
    });
    function ie(Ge) {
      G.value = Ge.copy();
    }
    const {
      fullCalendarLabel: oe,
      headingValue: ye,
      isDateDisabled: ve,
      isDateUnavailable: ke,
      isNextButtonDisabled: Ae,
      isPrevButtonDisabled: be,
      grid: Ie,
      weekdays: Se,
      isOutsideVisibleView: ze,
      nextPage: Ne,
      prevPage: tt,
      formatter: Qe
    } = useCalendar({
      locale: re,
      placeholder: G,
      weekStartsOn: f,
      fixedWeeks: v,
      numberOfMonths: b,
      minValue: M,
      maxValue: P,
      disabled: o,
      weekdayFormat: g,
      pagedNavigation: d,
      isDateDisabled: E.value,
      isDateUnavailable: C.value,
      calendarLabel: A,
      nextPage: T,
      prevPage: O
    }), {
      isInvalid: et,
      isSelected: ce,
      isDateHighlightable: pe,
      highlightedRange: je,
      isSelectionStart: lt,
      isSelectionEnd: Ce,
      isHighlightedStart: Oe,
      isHighlightedEnd: Te,
      isDateDisabled: ot
    } = useRangeCalendarState({
      start: Be,
      end: te,
      isDateDisabled: ve,
      isDateUnavailable: ke,
      isDateHighlightable: k.value,
      focusedValue: ne,
      allowNonContiguousRanges: I,
      fixedDate: F,
      maximumDays: W
    });
    watch(z, (Ge, He) => {
      (!He?.start && Ge?.start || !Ge || !Ge.start || Be.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(Ge.start, Be.value)) && (Be.value = Ge?.start?.copy?.()), (!He?.end && Ge.end || !Ge || !Ge.end || te.value && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(Ge.end, te.value)) && (te.value = Ge?.end?.copy?.());
    }), watch(Be, (Ge) => {
      Ge && !$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(Ge, G.value) && ie(Ge), a("update:startValue", Ge);
    }), watch([Be, te], ([Ge, He]) => {
      const me = X.value;
      if (!(me && me.start && me.end && Ge && He && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(me.start, Ge) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(me.end, He)) && (Q.value = !0, Ge && He)) {
        if (Q.value = !1, me.start && me.end && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(me.start, Ge) && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(me.end, He))
          return;
        isBefore(He, Ge) ? z.value = {
          start: He.copy(),
          end: Ge.copy()
        } : z.value = {
          start: Ge.copy(),
          end: He.copy()
        };
      }
    });
    const We = useKbd();
    return useEventListener("keydown", (Ge) => {
      Ge.key === We.ESCAPE && Q.value && (Be.value = z.value.start?.copy(), te.value = z.value.end?.copy());
    }), provideRangeCalendarRootContext({
      isDateUnavailable: ke,
      isDateHighlightable: pe,
      startValue: Be,
      endValue: te,
      formatter: Qe,
      modelValue: z,
      placeholder: G,
      disabled: o,
      initialFocus: u,
      pagedNavigation: d,
      grid: Ie,
      weekDays: Se,
      weekStartsOn: f,
      weekdayFormat: g,
      fixedWeeks: v,
      numberOfMonths: b,
      readonly: s,
      preventDeselect: w,
      fullCalendarLabel: oe,
      headingValue: ye,
      isInvalid: et,
      isDateDisabled: ot,
      allowNonContiguousRanges: I,
      highlightedRange: je,
      focusedValue: ne,
      lastPressedDateValue: V,
      isSelected: ce,
      isSelectionEnd: Ce,
      isSelectionStart: lt,
      isNextButtonDisabled: Ae,
      isPrevButtonDisabled: be,
      isOutsideVisibleView: ze,
      nextPage: Ne,
      prevPage: tt,
      parentElement: Z,
      onPlaceholderChange: ie,
      locale: re,
      dir: J,
      isHighlightedStart: Oe,
      isHighlightedEnd: Te,
      disableDaysOutsideCurrentView: q,
      fixedDate: F,
      maximumDays: W
    }), onMounted(() => {
      u.value && handleCalendarInitialFocus(Z.value);
    }), (Ge, He) => (openBlock(), createBlock(unref(Primitive), {
      ref_key: "primitiveElement",
      ref: K,
      as: Ge.as,
      "as-child": Ge.asChild,
      role: "application",
      "aria-label": unref(oe),
      "data-readonly": unref(s) ? "" : void 0,
      "data-disabled": unref(o) ? "" : void 0,
      "data-invalid": unref(et) ? "" : void 0,
      dir: unref(J)
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$12, [
          createElementVNode("div", _hoisted_2$D, toDisplayString(unref(oe)), 1)
        ]),
        renderSlot(Ge.$slots, "default", {
          date: unref(G),
          grid: unref(Ie),
          weekDays: unref(Se),
          weekStartsOn: unref(f),
          locale: unref(re),
          fixedWeeks: unref(v),
          modelValue: unref(z)
        })
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-label", "data-readonly", "data-disabled", "data-invalid", "dir"]));
  }
}), _sfc_main$2U = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerCalendar",
  setup(e) {
    const t = injectDateRangePickerRootContext();
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2V), mergeProps({
      allowNonContiguousRanges: unref(t).allowNonContiguousRanges.value,
      isDateDisabled: unref(t).isDateDisabled,
      isDateUnavailable: unref(t).isDateUnavailable,
      isDateHighlightable: unref(t).isDateHighlightable,
      locale: unref(t).locale.value,
      disabled: unref(t).disabled.value,
      pagedNavigation: unref(t).pagedNavigation.value,
      weekStartsOn: unref(t).weekStartsOn.value,
      weekdayFormat: unref(t).weekdayFormat.value,
      fixedWeeks: unref(t).fixedWeeks.value,
      numberOfMonths: unref(t).numberOfMonths.value,
      readonly: unref(t).readonly.value,
      preventDeselect: unref(t).preventDeselect.value,
      minValue: unref(t).minValue.value,
      maxValue: unref(t).maxValue.value,
      dir: unref(t).dir.value,
      fixedDate: unref(t).fixedDate.value,
      maximumDays: unref(t).maximumDays?.value
    }, {
      "initial-focus": "",
      "model-value": unref(t).modelValue.value,
      placeholder: unref(t).placeholder.value,
      "onUpdate:startValue": a[0] || (a[0] = (o) => {
        unref(t).onStartValueChange(o);
      }),
      "onUpdate:modelValue": a[1] || (a[1] = (o) => {
        o.start && unref(t).modelValue.value?.start && o.end && unref(t).modelValue.value?.end && unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o.start, unref(t).modelValue.value?.start) && unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o.end, unref(t).modelValue.value?.end) || unref(t).onDateChange(o);
      }),
      "onUpdate:placeholder": a[2] || (a[2] = (o) => {
        unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o, unref(t).placeholder.value) || unref(t).onPlaceholderChange(o);
      })
    }), {
      default: withCtx(({ weekDays: o, grid: s, date: u, weekStartsOn: d, locale: f, fixedWeeks: g }) => [
        renderSlot(n.$slots, "default", {
          date: u,
          grid: s,
          weekDays: o,
          weekStartsOn: d,
          locale: f,
          fixedWeeks: g
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), _sfc_main$2T = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: { default: "td" }
  },
  setup(e) {
    const t = injectRangeCalendarRootContext();
    return (n, a) => (openBlock(), createBlock(unref(Primitive), {
      as: n.as,
      "as-child": n.asChild,
      role: "gridcell",
      "aria-selected": unref(t).isSelected(n.date) ? !0 : void 0,
      "aria-disabled": unref(t).isDateDisabled(n.date) || unref(t).isDateUnavailable?.(n.date) || unref(t).disableDaysOutsideCurrentView.value,
      "data-disabled": unref(t).isDateDisabled(n.date) || unref(t).disableDaysOutsideCurrentView.value ? "" : void 0
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as", "as-child", "aria-selected", "aria-disabled", "data-disabled"]));
  }
}), _sfc_main$2S = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerCell",
  props: {
    date: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2T), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2R = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = injectRangeCalendarRootContext(), a = useKbd(), { primitiveElement: o, currentElement: s } = usePrimitiveElement(), u = computed(() => n.formatter.custom(toDate(t.day), {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    })), d = computed(() => n.isDateUnavailable?.(t.day) ?? !1), f = computed(() => n.isSelected(t.day)), g = computed(() => n.isSelectionStart(t.day)), v = computed(() => n.isSelectionEnd(t.day)), b = computed(() => n.isHighlightedStart(t.day)), w = computed(() => n.isHighlightedEnd(t.day)), C = computed(() => n.highlightedRange.value ? isBetweenInclusive(t.day, n.highlightedRange.value.start, n.highlightedRange.value.end) : !1), k = computed(() => n.allowNonContiguousRanges.value), E = computed(() => $14e0f24ef4ac5c92$export$629b0a497aa65267(t.day, $14e0f24ef4ac5c92$export$aa8b41735afcabd2())), A = computed(() => !$14e0f24ef4ac5c92$export$a18c89cbd24170ff(t.day, t.month)), P = computed(
      () => n.isOutsideVisibleView(t.day)
    ), M = computed(() => n.isDateDisabled(t.day) || n.disableDaysOutsideCurrentView.value && A.value), B = computed(() => t.day.day.toLocaleString(n.locale.value)), _ = computed(() => !n.disabled.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(t.day, n.placeholder.value));
    function T(F, W) {
      if (!n.readonly.value && !(n.isDateDisabled(W) || n.isDateUnavailable?.(W))) {
        if (n.lastPressedDateValue.value = W.copy(), n.startValue.value && n.highlightedRange.value === null) {
          if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(W, n.startValue.value) && !n.preventDeselect.value && !n.endValue.value) {
            n.startValue.value = void 0, n.onPlaceholderChange(W);
            return;
          } else if (!n.endValue.value) {
            F.preventDefault(), n.lastPressedDateValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(n.lastPressedDateValue.value, W) && (n.startValue.value = W.copy());
            return;
          }
        }
        if (n.startValue.value && n.endValue.value && $14e0f24ef4ac5c92$export$ea39ec197993aef0(n.endValue.value, W) && !n.preventDeselect.value) {
          n.startValue.value = void 0, n.endValue.value = void 0, n.onPlaceholderChange(W);
          return;
        }
        n.startValue.value ? n.endValue.value ? n.endValue.value && n.startValue.value && (n.fixedDate.value ? n.fixedDate.value === "start" ? W.compare(n.startValue.value) < 0 ? n.startValue.value = W.copy() : n.endValue.value = W.copy() : n.fixedDate.value === "end" && (W.compare(n.endValue.value) > 0 ? n.endValue.value = W.copy() : n.startValue.value = W.copy()) : (n.endValue.value = void 0, n.startValue.value = W.copy())) : n.endValue.value = W.copy() : n.startValue.value = W.copy();
      }
    }
    function O(F) {
      M.value || T(F, t.day);
    }
    function I() {
      M.value || n.isDateUnavailable?.(t.day) || (n.focusedValue.value = t.day.copy());
    }
    function q(F) {
      if (M.value)
        return;
      F.preventDefault(), F.stopPropagation();
      const W = n.parentElement.value, K = 7, Z = n.dir.value === "rtl" ? -1 : 1;
      switch (F.code) {
        case a.ARROW_RIGHT:
          J(s.value, Z);
          break;
        case a.ARROW_LEFT:
          J(s.value, -Z);
          break;
        case a.ARROW_UP:
          J(s.value, -7);
          break;
        case a.ARROW_DOWN:
          J(s.value, K);
          break;
        case a.ENTER:
        case a.SPACE_CODE:
          T(F, t.day);
      }
      function J(re, V) {
        const ne = getSelectableCells(W);
        if (!ne.length)
          return;
        const z = ne.indexOf(re) + V;
        if (z >= 0 && z < ne.length) {
          ne[z].hasAttribute("data-disabled") && J(ne[z], V), ne[z].focus();
          return;
        }
        if (z < 0) {
          if (n.isPrevButtonDisabled())
            return;
          n.prevPage(), nextTick(() => {
            const X = getSelectableCells(W);
            if (!X.length)
              return;
            if (!n.pagedNavigation.value && n.numberOfMonths.value > 1) {
              const te = getDaysInMonth(n.placeholder.value) - Math.abs(z);
              X[te].hasAttribute("data-disabled") && J(X[te], V), X[te].focus();
              return;
            }
            const ue = X.length - Math.abs(z);
            X[ue].hasAttribute("data-disabled") && J(X[ue], V), X[ue].focus();
          });
          return;
        }
        if (z >= ne.length) {
          if (n.isNextButtonDisabled())
            return;
          n.nextPage(), nextTick(() => {
            const X = getSelectableCells(W);
            if (!X.length)
              return;
            if (!n.pagedNavigation.value && n.numberOfMonths.value > 1) {
              const Be = getDaysInMonth(
                n.placeholder.value.add({ months: n.numberOfMonths.value - 1 })
              ), te = z - ne.length + (X.length - Be);
              X[te].hasAttribute("data-disabled") && J(X[te], V), X[te].focus();
              return;
            }
            const ue = z - ne.length;
            X[ue].hasAttribute("data-disabled") && J(X[ue], V), X[ue].focus();
          });
        }
      }
    }
    return (F, W) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      ref_key: "primitiveElement",
      ref: o
    }, t, {
      role: "button",
      "aria-label": u.value,
      "data-reka-calendar-cell-trigger": "",
      "aria-selected": f.value && (k.value || !d.value) ? !0 : void 0,
      "aria-disabled": M.value || d.value ? !0 : void 0,
      "data-highlighted": C.value && (k.value || !d.value) ? "" : void 0,
      "data-selection-start": g.value ? !0 : void 0,
      "data-selection-end": v.value ? !0 : void 0,
      "data-highlighted-start": b.value ? !0 : void 0,
      "data-highlighted-end": w.value ? !0 : void 0,
      "data-selected": f.value && (k.value || !d.value) ? !0 : void 0,
      "data-outside-visible-view": P.value ? "" : void 0,
      "data-value": F.day.toString(),
      "data-disabled": M.value ? "" : void 0,
      "data-unavailable": d.value ? "" : void 0,
      "data-today": E.value ? "" : void 0,
      "data-outside-view": A.value ? "" : void 0,
      "data-focused": _.value ? "" : void 0,
      tabindex: _.value ? 0 : A.value || M.value ? void 0 : -1,
      onClick: O,
      onFocusin: I,
      onMouseenter: I,
      onKeydown: withKeys(q, ["up", "down", "left", "right", "enter", "space"])
    }), {
      default: withCtx(() => [
        renderSlot(F.$slots, "default", {
          dayValue: B.value,
          disabled: M.value,
          today: E.value,
          selected: f.value,
          outsideView: A.value,
          outsideVisibleView: P.value,
          unavailable: d.value,
          highlighted: C.value && (k.value || !d.value),
          highlightedStart: b.value,
          highlightedEnd: w.value,
          selectionStart: g.value,
          selectionEnd: v.value
        }, () => [
          createTextVNode(toDisplayString(B.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["aria-label", "aria-selected", "aria-disabled", "data-highlighted", "data-selection-start", "data-selection-end", "data-highlighted-start", "data-highlighted-end", "data-selected", "data-outside-visible-view", "data-value", "data-disabled", "data-unavailable", "data-today", "data-outside-view", "data-focused", "tabindex"]));
  }
}), _sfc_main$2Q = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerCellTrigger",
  props: {
    day: {},
    month: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2R), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2P = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerContent",
  props: {
    portal: {},
    forceMount: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {},
    disableOutsidePointerEvents: { type: Boolean }
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "openAutoFocus", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = computed(() => ({
      ...n,
      portal: void 0
    })), s = useForwardPropsEmits(o, a);
    return (u, d) => (openBlock(), createBlock(unref(_sfc_main$3f), normalizeProps(guardReactiveProps(u.portal)), {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$3b), normalizeProps(guardReactiveProps({ ...unref(s), ...u.$attrs })), {
          default: withCtx(() => [
            renderSlot(u.$slots, "default")
          ]),
          _: 3
        }, 16)
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2O = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerField",
  setup(e) {
    const t = injectDateRangePickerRootContext();
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2Y), mergeProps({
      ref: unref(t).dateFieldRef,
      "model-value": unref(t).modelValue.value,
      placeholder: unref(t).placeholder.value
    }, {
      id: unref(t).id.value,
      name: unref(t).name.value,
      disabled: unref(t).disabled.value,
      minValue: unref(t).minValue.value,
      maxValue: unref(t).maxValue.value,
      readonly: unref(t).readonly.value,
      hourCycle: unref(t).hourCycle.value,
      granularity: unref(t).granularity.value,
      hideTimeZone: unref(t).hideTimeZone.value,
      locale: unref(t).locale.value,
      isDateUnavailable: unref(t).isDateUnavailable,
      required: unref(t).required.value,
      dir: unref(t).dir.value
    }, {
      "onUpdate:modelValue": a[0] || (a[0] = (o) => {
        o.start && unref(t).modelValue.value.start && o.end && unref(t).modelValue.value.end && o.start.compare(unref(t).modelValue.value.start) === 0 && o.end.compare(unref(t).modelValue.value.end) === 0 || unref(t).onDateChange(o);
      }),
      "onUpdate:placeholder": a[1] || (a[1] = (o) => {
        unref($14e0f24ef4ac5c92$export$91b62ebf2ba703ee)(o, unref(t).placeholder.value) && o.compare(unref(t).placeholder.value) === 0 || unref(t).onPlaceholderChange(o);
      })
    }), {
      default: withCtx(({ segments: o, modelValue: s }) => [
        renderSlot(n.$slots, "default", {
          segments: o,
          modelValue: s
        })
      ]),
      _: 3
    }, 16, ["model-value", "placeholder"]));
  }
}), _sfc_main$2N = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarGrid",
  props: {
    asChild: { type: Boolean },
    as: { default: "table" }
  },
  setup(e) {
    const t = e, n = injectRangeCalendarRootContext(), a = computed(() => n.disabled.value ? !0 : void 0), o = computed(() => n.readonly.value ? !0 : void 0);
    return (s, u) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      tabindex: "-1",
      role: "grid",
      "aria-readonly": o.value,
      "aria-disabled": a.value,
      "data-readonly": o.value && "",
      "data-disabled": a.value && ""
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16, ["aria-readonly", "aria-disabled", "data-readonly", "data-disabled"]));
  }
}), _sfc_main$2M = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerGrid",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2N), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2L = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarGridBody",
  props: {
    asChild: { type: Boolean },
    as: { default: "tbody" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2K = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerGridBody",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2L), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2J = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarGridHead",
  props: {
    asChild: { type: Boolean },
    as: { default: "thead" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, { "aria-hidden": "true" }), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2I = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerGridHead",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2J), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2H = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarGridRow",
  props: {
    asChild: { type: Boolean },
    as: { default: "tr" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2G = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerGridRow",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2H), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2F = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarHeadCell",
  props: {
    asChild: { type: Boolean },
    as: { default: "th" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2E = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerHeadCell",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2F), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2D = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarHeader",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(Primitive), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2C = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerHeader",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2D), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2B = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarHeading",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = injectRangeCalendarRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      "data-disabled": unref(n).disabled.value ? "" : void 0
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default", {
          headingValue: unref(n).headingValue.value
        }, () => [
          createTextVNode(toDisplayString(unref(n).headingValue.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["data-disabled"]));
  }
}), _sfc_main$2A = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerHeading",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2B), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(({ headingValue: o }) => [
        renderSlot(n.$slots, "default", { headingValue: o }, () => [
          createTextVNode(toDisplayString(o), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2z = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerInput",
  props: {
    part: {},
    type: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2X), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2y = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarNext",
  props: {
    nextPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = computed(() => a.disabled.value || a.isNextButtonDisabled(t.nextPage)), a = injectRangeCalendarRootContext();
    return (o, s) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      "aria-label": "Next page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: s[0] || (s[0] = (u) => unref(a).nextPage(t.nextPage))
    }), {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", { disabled: n.value }, () => [
          s[1] || (s[1] = createTextVNode(" Next page "))
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled"]));
  }
}), _sfc_main$2x = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerNext",
  props: {
    nextPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2y), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2w = /* @__PURE__ */ defineComponent({
  __name: "RangeCalendarPrev",
  props: {
    prevPage: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = computed(() => a.disabled.value || a.isPrevButtonDisabled(t.prevPage)), a = injectRangeCalendarRootContext();
    return (o, s) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      "aria-label": "Previous page",
      type: o.as === "button" ? "button" : void 0,
      "aria-disabled": n.value || void 0,
      "data-disabled": n.value || void 0,
      disabled: n.value,
      onClick: s[0] || (s[0] = (u) => unref(a).prevPage(t.prevPage))
    }), {
      default: withCtx(() => [
        renderSlot(o.$slots, "default", { disabled: n.value }, () => [
          s[1] || (s[1] = createTextVNode(" Prev page "))
        ])
      ]),
      _: 3
    }, 16, ["type", "aria-disabled", "data-disabled", "disabled"]));
  }
}), _sfc_main$2v = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerPrev",
  props: {
    prevPage: { type: Function },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$2w), normalizeProps(guardReactiveProps(t)), {
      default: withCtx((o) => [
        renderSlot(n.$slots, "default", normalizeProps(guardReactiveProps(o)))
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2u = /* @__PURE__ */ defineComponent({
  __name: "DateRangePickerTrigger",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectDateRangePickerRootContext();
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$2_), mergeProps({ "data-reka-date-field-segment": "trigger" }, t, {
      disabled: unref(n).disabled.value,
      onFocusin: o[0] || (o[0] = (s) => {
        unref(n).dateFieldRef.value?.setFocusedElement(s.target);
      })
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["disabled"]));
  }
}), _sfc_main$2t = /* @__PURE__ */ defineComponent({
  __name: "DialogPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4j), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), [injectDropdownMenuRootContext, provideDropdownMenuRootContext] = createContext$2("DropdownMenuRoot"), _sfc_main$2s = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuRoot",
  props: {
    defaultOpen: { type: Boolean },
    open: { type: Boolean, default: void 0 },
    dir: {},
    modal: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    useForwardExpose();
    const o = useVModel(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    }), s = ref(), { modal: u, dir: d } = toRefs(n), f = useDirection(d);
    return provideDropdownMenuRootContext({
      open: o,
      onOpenChange: (g) => {
        o.value = g;
      },
      onOpenToggle: () => {
        o.value = !o.value;
      },
      triggerId: "",
      triggerElement: s,
      contentId: "",
      modal: u,
      dir: f
    }), (g, v) => (openBlock(), createBlock(unref(_sfc_main$3G), {
      open: unref(o),
      "onUpdate:open": v[0] || (v[0] = (b) => isRef(o) ? o.value = b : null),
      dir: unref(f),
      modal: unref(u)
    }, {
      default: withCtx(() => [
        renderSlot(g.$slots, "default", { open: unref(o) })
      ]),
      _: 3
    }, 8, ["open", "dir", "modal"]));
  }
}), _sfc_main$2r = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuContent",
  props: {
    forceMount: { type: Boolean },
    loop: { type: Boolean },
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {},
    disableUpdateOnLayoutShift: { type: Boolean },
    prioritizePosition: { type: Boolean },
    reference: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "closeAutoFocus"],
  setup(e, { emit: t }) {
    const o = useForwardPropsEmits(e, t);
    useForwardExpose();
    const s = injectDropdownMenuRootContext(), u = ref(!1);
    function d(f) {
      f.defaultPrevented || (u.value || setTimeout(() => {
        s.triggerElement.value?.focus();
      }, 0), u.value = !1, f.preventDefault());
    }
    return s.contentId ||= useId(void 0, "reka-dropdown-menu-content"), (f, g) => (openBlock(), createBlock(unref(_sfc_main$3A), mergeProps(unref(o), {
      id: unref(s).contentId,
      "aria-labelledby": unref(s)?.triggerId,
      style: {
        "--reka-dropdown-menu-content-transform-origin": "var(--reka-popper-transform-origin)",
        "--reka-dropdown-menu-content-available-width": "var(--reka-popper-available-width)",
        "--reka-dropdown-menu-content-available-height": "var(--reka-popper-available-height)",
        "--reka-dropdown-menu-trigger-width": "var(--reka-popper-anchor-width)",
        "--reka-dropdown-menu-trigger-height": "var(--reka-popper-anchor-height)"
      },
      onCloseAutoFocus: d,
      onInteractOutside: g[0] || (g[0] = (v) => {
        if (v.defaultPrevented) return;
        const b = v.detail.originalEvent, w = b.button === 0 && b.ctrlKey === !0, C = b.button === 2 || w;
        (!unref(s).modal.value || C) && (u.value = !0), unref(s).triggerElement.value?.contains(v.target) && v.preventDefault();
      })
    }), {
      default: withCtx(() => [
        renderSlot(f.$slots, "default")
      ]),
      _: 3
    }, 16, ["id", "aria-labelledby"]));
  }
}), _sfc_main$2q = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuItem",
  props: {
    disabled: { type: Boolean },
    textValue: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, o = useEmitAsProps(t);
    return useForwardExpose(), (s, u) => (openBlock(), createBlock(unref(_sfc_main$3D), normalizeProps(guardReactiveProps({ ...n, ...unref(o) })), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2p = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuLabel",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3w), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2o = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$3u), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2n = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuSeparator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3s), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2m = /* @__PURE__ */ defineComponent({
  __name: "DropdownMenuTrigger",
  props: {
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = injectDropdownMenuRootContext(), { forwardRef: a, currentElement: o } = useForwardExpose();
    return onMounted(() => {
      n.triggerElement = o;
    }), n.triggerId ||= useId(void 0, "reka-dropdown-menu-trigger"), (s, u) => (openBlock(), createBlock(unref(_sfc_main$3q), { "as-child": "" }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          id: unref(n).triggerId,
          ref: unref(a),
          type: s.as === "button" ? "button" : void 0,
          "as-child": t.asChild,
          as: s.as,
          "aria-haspopup": "menu",
          "aria-expanded": unref(n).open.value,
          "aria-controls": unref(n).open.value ? unref(n).contentId : void 0,
          "data-disabled": s.disabled ? "" : void 0,
          disabled: s.disabled,
          "data-state": unref(n).open.value ? "open" : "closed",
          onClick: u[0] || (u[0] = async (d) => {
            !s.disabled && d.button === 0 && d.ctrlKey === !1 && (unref(n)?.onOpenToggle(), await nextTick(), unref(n).open.value && d.preventDefault());
          }),
          onKeydown: u[1] || (u[1] = withKeys(
            (d) => {
              s.disabled || (["Enter", " "].includes(d.key) && unref(n).onOpenToggle(), d.key === "ArrowDown" && unref(n).onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(d.key) && d.preventDefault());
            },
            ["enter", "space", "arrow-down"]
          ))
        }, {
          default: withCtx(() => [
            renderSlot(s.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as-child", "as", "aria-expanded", "aria-controls", "data-disabled", "disabled", "data-state"])
      ]),
      _: 3
    }));
  }
}), [injectEditableRootContext, provideEditableRootContext] = createContext$2("EditableRoot"), _sfc_main$2l = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "EditableRoot",
  props: {
    defaultValue: {},
    modelValue: {},
    placeholder: { default: "Enter text..." },
    dir: {},
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean },
    activationMode: { default: "focus" },
    selectOnFocus: { type: Boolean, default: !1 },
    submitMode: { default: "blur" },
    startWithEditMode: { type: Boolean },
    maxLength: {},
    autoResize: { type: Boolean, default: !1 },
    id: {},
    asChild: { type: Boolean },
    as: { default: "div" },
    name: {},
    required: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue", "submit", "update:state"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, {
      id: s,
      name: u,
      defaultValue: d,
      startWithEditMode: f,
      placeholder: g,
      maxLength: v,
      disabled: b,
      dir: w,
      submitMode: C,
      activationMode: k,
      selectOnFocus: E,
      readonly: A,
      autoResize: P,
      required: M
    } = toRefs(a), B = ref(), _ = useDirection(w), T = ref(f.value ?? !1), O = useVModel(a, "modelValue", o, {
      defaultValue: d.value ?? "",
      passive: a.modelValue === void 0
    }), { primitiveElement: I, currentElement: q } = usePrimitiveElement(), F = useFormControl(q), W = computed(() => typeof g.value == "string" ? { edit: g.value, preview: g.value } : g.value), K = ref(O.value);
    watch(() => O.value, () => {
      K.value = O.value;
    }, { immediate: !0, deep: !0 });
    function Z() {
      T.value = !1, o("update:state", "cancel");
    }
    function J() {
      T.value = !0, K.value = O.value, o("update:state", "edit");
    }
    function re() {
      O.value = K.value, T.value = !1, o("update:state", "submit"), o("submit", O.value);
    }
    function V() {
      T.value && (C.value === "blur" || C.value === "both" ? re() : Z());
    }
    const ne = usePointerDownOutside(() => V(), q, T), Q = useFocusOutside(() => V(), q, T), z = computed(() => O.value === "");
    return t({
      /** Function to submit the value of the editable */
      submit: re,
      /** Function to cancel the value of the editable */
      cancel: Z,
      /** Function to set the editable in edit mode */
      edit: J
    }), provideEditableRootContext({
      id: s,
      name: u,
      disabled: b,
      isEditing: T,
      maxLength: v,
      modelValue: O,
      inputValue: K,
      placeholder: W,
      edit: J,
      cancel: Z,
      submit: re,
      activationMode: k,
      submitMode: C,
      selectOnFocus: E,
      inputRef: B,
      startWithEditMode: f,
      isEmpty: z,
      readonly: A,
      autoResize: P
    }), (X, ue) => (openBlock(), createBlock(unref(Primitive), mergeProps(X.$attrs, {
      ref_key: "primitiveElement",
      ref: I,
      as: X.as,
      "as-child": X.asChild,
      dir: unref(_),
      "data-dismissable-layer": "",
      onFocusCapture: unref(Q).onFocusCapture,
      onBlurCapture: unref(Q).onBlurCapture,
      onPointerdownCapture: unref(ne).onPointerDownCapture
    }), {
      default: withCtx(() => [
        renderSlot(X.$slots, "default", {
          modelValue: unref(O),
          isEditing: T.value,
          isEmpty: z.value,
          submit: re,
          cancel: Z,
          edit: J
        }),
        unref(F) && unref(u) ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          type: "text",
          value: unref(O),
          name: unref(u),
          disabled: unref(b),
          required: unref(M)
        }, null, 8, ["value", "name", "disabled", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 16, ["as", "as-child", "dir", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"]));
  }
}), _sfc_main$2k = /* @__PURE__ */ defineComponent({
  __name: "EditableArea",
  props: {
    asChild: { type: Boolean },
    as: { default: "div" }
  },
  setup(e) {
    const t = e, n = injectEditableRootContext();
    return (a, o) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      "data-placeholder-shown": unref(n).isEditing.value ? void 0 : "",
      "data-focus": unref(n).isEditing.value ? "" : void 0,
      "data-focused": unref(n).isEditing.value ? "" : void 0,
      "data-empty": unref(n).isEmpty.value ? "" : void 0,
      "data-readonly": unref(n).readonly.value ? "" : void 0,
      "data-disabled": unref(n).disabled.value ? "" : void 0,
      style: unref(n).autoResize.value ? { display: "inline-grid" } : void 0
    }), {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 16, ["data-placeholder-shown", "data-focus", "data-focused", "data-empty", "data-readonly", "data-disabled", "style"]));
  }
}), _sfc_main$2j = /* @__PURE__ */ defineComponent({
  __name: "EditableInput",
  props: {
    asChild: { type: Boolean },
    as: { default: "input" }
  },
  setup(e) {
    const t = e, n = useKbd(), a = injectEditableRootContext(), o = computed(() => a.disabled.value), s = computed(() => a.placeholder.value?.edit), { primitiveElement: u, currentElement: d } = usePrimitiveElement();
    onMounted(() => {
      a.inputRef.value = d.value, a.startWithEditMode.value && (a.inputRef.value?.focus({ preventScroll: !0 }), a.selectOnFocus.value && a.inputRef.value?.select());
    }), watch(a.isEditing, (g) => {
      g && nextTick(() => {
        a.inputRef.value?.focus({ preventScroll: !0 }), a.selectOnFocus.value && a.inputRef.value?.select();
      });
    });
    function f(g) {
      (a.submitMode.value === "enter" || a.submitMode.value === "both") && g.key === n.ENTER && !g.shiftKey && !g.metaKey && a.submit();
    }
    return (g, v) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      ref_key: "primitiveElement",
      ref: u
    }, t, {
      value: unref(a).inputValue.value,
      placeholder: s.value,
      disabled: o.value,
      maxlength: unref(a).maxLength.value,
      "data-disabled": o.value ? "" : void 0,
      "data-readonly": unref(a).readonly.value ? "" : void 0,
      readonly: unref(a).readonly.value,
      "aria-label": "editable input",
      hidden: unref(a).autoResize.value ? void 0 : !unref(a).isEditing.value,
      style: unref(a).autoResize.value ? { all: "unset", gridArea: "1 / 1 / auto / auto", visibility: unref(a).isEditing.value ? void 0 : "hidden" } : void 0,
      onInput: v[0] || (v[0] = (b) => unref(a).inputValue.value = b.target.value),
      onKeydown: [
        withKeys(f, ["enter", "space"]),
        withKeys(unref(a).cancel, ["esc"])
      ]
    }), {
      default: withCtx(() => [
        renderSlot(g.$slots, "default")
      ]),
      _: 3
    }, 16, ["value", "placeholder", "disabled", "maxlength", "data-disabled", "data-readonly", "readonly", "hidden", "style", "onKeydown"]));
  }
}), _sfc_main$2i = /* @__PURE__ */ defineComponent({
  __name: "EditablePreview",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, n = injectEditableRootContext(), a = computed(() => n.placeholder.value?.preview);
    function o() {
      n.activationMode.value === "focus" && n.edit();
    }
    function s() {
      n.activationMode.value === "dblclick" && n.edit();
    }
    return (u, d) => (openBlock(), createBlock(unref(Primitive), mergeProps(t, {
      tabindex: "0",
      "data-placeholder-shown": unref(n).isEditing.value ? void 0 : "",
      hidden: unref(n).autoResize.value ? void 0 : unref(n).isEditing.value,
      style: unref(n).autoResize.value ? {
        whiteSpace: "pre",
        userSelect: "none",
        gridArea: "1 / 1 / auto / auto",
        visibility: unref(n).isEditing.value ? "hidden" : void 0,
        overflow: "hidden",
        textOverflow: "ellipsis"
      } : void 0,
      onFocusin: o,
      onDblclick: s
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(unref(n).modelValue.value || a.value), 1)
        ])
      ]),
      _: 3
    }, 16, ["data-placeholder-shown", "hidden", "style"]));
  }
});
function useGraceArea(e, t) {
  const n = refAutoReset(!1, 300), a = ref(null), o = createEventHook();
  function s() {
    a.value = null, n.value = !1;
  }
  function u(d, f) {
    const g = d.currentTarget, v = { x: d.clientX, y: d.clientY }, b = getExitSideFromRect(v, g.getBoundingClientRect()), w = getPaddedExitPoints(v, b), C = getPointsFromRect(f.getBoundingClientRect()), k = getHull([...w, ...C]);
    a.value = k, n.value = !0;
  }
  return watchEffect((d) => {
    if (e.value && t.value) {
      const f = (v) => u(v, t.value), g = (v) => u(v, e.value);
      e.value.addEventListener("pointerleave", f), t.value.addEventListener("pointerleave", g), d(() => {
        e.value?.removeEventListener("pointerleave", f), t.value?.removeEventListener("pointerleave", g);
      });
    }
  }), watchEffect((d) => {
    if (a.value) {
      const f = (g) => {
        if (!a.value || !(g.target instanceof HTMLElement))
          return;
        const v = g.target, b = { x: g.clientX, y: g.clientY }, w = e.value?.contains(v) || t.value?.contains(v), C = !isPointInPolygon(b, a.value), k = !!v.closest("[data-grace-area-trigger]");
        w ? s() : (C || k) && (s(), o.trigger());
      };
      e.value?.ownerDocument.addEventListener("pointermove", f), d(() => e.value?.ownerDocument.removeEventListener("pointermove", f));
    }
  }), {
    isPointerInTransit: n,
    onPointerExit: o.on
  };
}
function getExitSideFromRect(e, t) {
  const n = Math.abs(t.top - e.y), a = Math.abs(t.bottom - e.y), o = Math.abs(t.right - e.x), s = Math.abs(t.left - e.x);
  switch (Math.min(n, a, o, s)) {
    case s:
      return "left";
    case o:
      return "right";
    case n:
      return "top";
    case a:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(e, t, n = 5) {
  const a = [];
  switch (t) {
    case "top":
      a.push(
        { x: e.x - n, y: e.y + n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "bottom":
      a.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x + n, y: e.y - n }
      );
      break;
    case "left":
      a.push(
        { x: e.x + n, y: e.y - n },
        { x: e.x + n, y: e.y + n }
      );
      break;
    case "right":
      a.push(
        { x: e.x - n, y: e.y - n },
        { x: e.x - n, y: e.y + n }
      );
      break;
  }
  return a;
}
function getPointsFromRect(e) {
  const { top: t, right: n, bottom: a, left: o } = e;
  return [
    { x: o, y: t },
    { x: n, y: t },
    { x: n, y: a },
    { x: o, y: a }
  ];
}
function isPointInPolygon(e, t) {
  const { x: n, y: a } = e;
  let o = !1;
  for (let s = 0, u = t.length - 1; s < t.length; u = s++) {
    const d = t[s].x, f = t[s].y, g = t[u].x, v = t[u].y;
    f > a != v > a && n < (g - d) * (a - f) / (v - f) + d && (o = !o);
  }
  return o;
}
function getHull(e) {
  const t = e.slice();
  return t.sort((n, a) => n.x < a.x ? -1 : n.x > a.x ? 1 : n.y < a.y ? -1 : n.y > a.y ? 1 : 0), getHullPresorted(t);
}
function getHullPresorted(e) {
  if (e.length <= 1)
    return e.slice();
  const t = [];
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    for (; t.length >= 2; ) {
      const s = t[t.length - 1], u = t[t.length - 2];
      if ((s.x - u.x) * (o.y - u.y) >= (s.y - u.y) * (o.x - u.x))
        t.pop();
      else break;
    }
    t.push(o);
  }
  t.pop();
  const n = [];
  for (let a = e.length - 1; a >= 0; a--) {
    const o = e[a];
    for (; n.length >= 2; ) {
      const s = n[n.length - 1], u = n[n.length - 2];
      if ((s.x - u.x) * (o.y - u.y) >= (s.y - u.y) * (o.x - u.x))
        n.pop();
      else break;
    }
    n.push(o);
  }
  return n.pop(), t.length === 1 && n.length === 1 && t[0].x === n[0].x && t[0].y === n[0].y ? t : t.concat(n);
}
function clamp$1(e, t = Number.NEGATIVE_INFINITY, n = Number.POSITIVE_INFINITY) {
  return Math.min(n, Math.max(t, e));
}
const RADIO_SELECT = "radio.select";
function handleSelect(e, t, n) {
  handleAndDispatchCustomEvent(RADIO_SELECT, n, { originalEvent: e, value: t });
}
const _sfc_main$2h = /* @__PURE__ */ defineComponent({
  __name: "Radio",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    checked: { type: Boolean, default: void 0 },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:checked", "select"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useVModel(n, "checked", a, {
      passive: n.checked === void 0
    }), { value: s } = toRefs(n), { forwardRef: u, currentElement: d } = useForwardExpose(), f = useFormControl(d), g = computed(() => n.id && d.value ? document.querySelector(`[for="${n.id}"]`)?.innerText ?? n.value : void 0);
    function v(b) {
      n.disabled || handleSelect(b, n.value, (w) => {
        a("select", w), !w?.defaultPrevented && (o.value = !0, f.value && w.stopPropagation());
      });
    }
    return (b, w) => (openBlock(), createBlock(unref(Primitive), mergeProps(b.$attrs, {
      id: b.id,
      ref: unref(u),
      role: "radio",
      type: b.as === "button" ? "button" : void 0,
      as: b.as,
      "aria-checked": unref(o),
      "aria-label": g.value,
      "as-child": b.asChild,
      disabled: b.disabled ? "" : void 0,
      "data-state": unref(o) ? "checked" : "unchecked",
      "data-disabled": b.disabled ? "" : void 0,
      value: unref(s),
      required: b.required,
      name: b.name,
      onClick: withModifiers(v, ["stop"])
    }), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default", { checked: unref(o) }),
        unref(f) && b.name ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          type: "radio",
          tabindex: "-1",
          value: unref(s),
          checked: !!unref(o),
          name: b.name,
          disabled: b.disabled,
          required: b.required
        }, null, 8, ["value", "checked", "name", "disabled", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 16, ["id", "type", "as", "aria-checked", "aria-label", "as-child", "disabled", "data-state", "data-disabled", "value", "required", "name"]));
  }
}), [injectRadioGroupRootContext, provideRadioGroupRootContext] = createContext$2("RadioGroupRoot"), _sfc_main$2g = /* @__PURE__ */ defineComponent({
  __name: "RadioGroupRoot",
  props: {
    modelValue: {},
    defaultValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: void 0 },
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), { disabled: d, loop: f, orientation: g, name: v, required: b, dir: w } = toRefs(n), C = useDirection(w), k = useFormControl(s);
    return provideRadioGroupRootContext({
      modelValue: u,
      changeModelValue: (E) => {
        u.value = E;
      },
      disabled: d,
      loop: f,
      orientation: g,
      name: v?.value,
      required: b
    }), (E, A) => (openBlock(), createBlock(unref(_sfc_main$44), {
      "as-child": "",
      orientation: unref(g),
      dir: unref(C),
      loop: unref(f)
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          ref: unref(o),
          role: "radiogroup",
          "data-disabled": unref(d) ? "" : void 0,
          "as-child": E.asChild,
          as: E.as,
          "aria-orientation": unref(g),
          "aria-required": unref(b),
          dir: unref(C)
        }, {
          default: withCtx(() => [
            renderSlot(E.$slots, "default", { modelValue: unref(u) }),
            unref(k) && unref(v) ? (openBlock(), createBlock(unref(_sfc_main$42), {
              key: 0,
              required: unref(b),
              disabled: unref(d),
              value: unref(u),
              name: unref(v)
            }, null, 8, ["required", "disabled", "value", "name"])) : createCommentVNode("", !0)
          ]),
          _: 3
        }, 8, ["data-disabled", "as-child", "as", "aria-orientation", "aria-required", "dir"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), [injectRadioGroupItemContext, provideRadiogroupItemContext] = createContext$2("RadioGroupItem"), _sfc_main$2f = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "RadioGroupItem",
  props: {
    id: {},
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["select"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = injectRadioGroupRootContext(), d = computed(() => u.disabled.value || n.disabled), f = computed(() => u.required.value || n.required), g = computed(() => isEqual(u.modelValue?.value, n.value));
    provideRadiogroupItemContext({ disabled: d, checked: g });
    const v = ref(!1), b = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
    useEventListener("keydown", (C) => {
      b.includes(C.key) && (v.value = !0);
    }), useEventListener("keyup", () => {
      v.value = !1;
    });
    function w() {
      setTimeout(() => {
        v.value && s.value?.click();
      }, 0);
    }
    return (C, k) => (openBlock(), createBlock(unref(_sfc_main$40), {
      checked: g.value,
      disabled: d.value,
      "as-child": "",
      focusable: !d.value,
      active: g.value
    }, {
      default: withCtx(() => [
        createVNode(_sfc_main$2h, mergeProps({ ...C.$attrs, ...n }, {
          ref: unref(o),
          checked: g.value,
          required: f.value,
          disabled: d.value,
          "onUpdate:checked": k[0] || (k[0] = (E) => unref(u).changeModelValue(C.value)),
          onSelect: k[1] || (k[1] = (E) => a("select", E)),
          onKeydown: k[2] || (k[2] = withKeys(withModifiers(() => {
          }, ["prevent"]), ["enter"])),
          onFocus: w
        }), {
          default: withCtx(() => [
            renderSlot(C.$slots, "default", {
              checked: g.value,
              required: f.value,
              disabled: d.value
            })
          ]),
          _: 3
        }, 16, ["checked", "required", "disabled"])
      ]),
      _: 3
    }, 8, ["checked", "disabled", "focusable", "active"]));
  }
}), _sfc_main$2e = /* @__PURE__ */ defineComponent({
  __name: "RadioGroupIndicator",
  props: {
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const { forwardRef: t } = useForwardExpose(), n = injectRadioGroupItemContext();
    return (a, o) => (openBlock(), createBlock(unref(Presence), {
      present: a.forceMount || unref(n).checked.value
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps({
          ref: unref(t),
          "data-state": unref(n).checked.value ? "checked" : "unchecked",
          "data-disabled": unref(n).disabled.value ? "" : void 0,
          "as-child": a.asChild,
          as: a.as
        }, a.$attrs), {
          default: withCtx(() => [
            renderSlot(a.$slots, "default")
          ]),
          _: 3
        }, 16, ["data-state", "data-disabled", "as-child", "as"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
});
function getNextSortedValues(e = [], t, n) {
  const a = [...e];
  return a[n] = t, a.sort((o, s) => o - s);
}
function convertValueToPercentage(e, t, n) {
  const s = 100 / (n - t) * (e - t);
  return clamp$1(s, 0, 100);
}
function getLabel(e, t) {
  return t > 2 ? `Value ${e + 1} of ${t}` : t === 2 ? ["Minimum", "Maximum"][e] : void 0;
}
function getClosestValueIndex(e, t) {
  if (e.length === 1)
    return 0;
  const n = e.map((o) => Math.abs(o - t)), a = Math.min(...n);
  return n.indexOf(a);
}
function getThumbInBoundsOffset(e, t, n) {
  const a = e / 2, s = linearScale([0, 50], [0, a]);
  return (a - s(t) * n) * n;
}
function getStepsBetweenValues(e) {
  return e.slice(0, -1).map((t, n) => e[n + 1] - t);
}
function hasMinStepsBetweenValues(e, t) {
  if (t > 0) {
    const n = getStepsBetweenValues(e);
    return Math.min(...n) >= t;
  }
  return !0;
}
function linearScale(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const a = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + a * (n - e[0]);
  };
}
function getDecimalCount(e) {
  return (String(e).split(".")[1] || "").length;
}
function roundValue(e, t) {
  const n = 10 ** t;
  return Math.round(e * n) / n;
}
const PAGE_KEYS = ["PageUp", "PageDown"], ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageUp", "ArrowUp", "ArrowLeft"]
}, [injectSliderOrientationContext, provideSliderOrientationContext] = createContext$2(["SliderVertical", "SliderHorizontal"]), _sfc_main$2d = /* @__PURE__ */ defineComponent({
  __name: "SliderImpl",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  emits: ["slideStart", "slideMove", "slideEnd", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectSliderRootContext();
    return (s, u) => (openBlock(), createBlock(unref(Primitive), mergeProps({ "data-slider-impl": "" }, n, {
      onKeydown: u[0] || (u[0] = (d) => {
        d.key === "Home" ? (a("homeKeyDown", d), d.preventDefault()) : d.key === "End" ? (a("endKeyDown", d), d.preventDefault()) : unref(PAGE_KEYS).concat(unref(ARROW_KEYS)).includes(d.key) && (a("stepKeyDown", d), d.preventDefault());
      }),
      onPointerdown: u[1] || (u[1] = (d) => {
        const f = d.target;
        f.setPointerCapture(d.pointerId), d.preventDefault(), unref(o).thumbElements.value.includes(f) ? f.focus() : a("slideStart", d);
      }),
      onPointermove: u[2] || (u[2] = (d) => {
        d.target.hasPointerCapture(d.pointerId) && a("slideMove", d);
      }),
      onPointerup: u[3] || (u[3] = (d) => {
        const f = d.target;
        f.hasPointerCapture(d.pointerId) && (f.releasePointerCapture(d.pointerId), a("slideEnd", d));
      })
    }), {
      default: withCtx(() => [
        renderSlot(s.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$2c = /* @__PURE__ */ defineComponent({
  __name: "SliderHorizontal",
  props: {
    dir: {},
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: o, min: s, dir: u, inverted: d } = toRefs(n), { forwardRef: f, currentElement: g } = useForwardExpose(), v = injectSliderRootContext(), b = ref(), w = ref(), C = computed(() => u?.value !== "rtl" && !d.value || u?.value !== "ltr" && d.value);
    function k(M, B) {
      const _ = w.value || g.value.getBoundingClientRect(), T = [...v.thumbElements.value][v.valueIndexToChangeRef.value], O = v.thumbAlignment.value === "contain" ? T.clientWidth : 0;
      !b.value && !B && v.thumbAlignment.value === "contain" && (b.value = M.clientX - T.getBoundingClientRect().left);
      const I = [0, _.width - O], q = C.value ? [s.value, o.value] : [o.value, s.value], F = linearScale(I, q);
      w.value = _;
      const W = B ? M.clientX - _.left - O / 2 : M.clientX - _.left - (b.value ?? 0);
      return F(W);
    }
    const E = computed(() => C.value ? "left" : "right"), A = computed(() => C.value ? "right" : "left"), P = computed(() => C.value ? 1 : -1);
    return provideSliderOrientationContext({
      startEdge: E,
      endEdge: A,
      direction: P,
      size: "width"
    }), (M, B) => (openBlock(), createBlock(_sfc_main$2d, {
      ref: unref(f),
      dir: unref(u),
      "data-orientation": "horizontal",
      style: normalizeStyle({
        "--reka-slider-thumb-transform": !C.value && unref(v).thumbAlignment.value === "overflow" ? "translateX(50%)" : "translateX(-50%)"
      }),
      onSlideStart: B[0] || (B[0] = (_) => {
        const T = k(_, !0);
        a("slideStart", T);
      }),
      onSlideMove: B[1] || (B[1] = (_) => {
        const T = k(_);
        a("slideMove", T);
      }),
      onSlideEnd: B[2] || (B[2] = () => {
        w.value = void 0, b.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: B[3] || (B[3] = (_) => {
        const T = C.value ? "from-left" : "from-right", O = unref(BACK_KEYS)[T].includes(_.key);
        a("stepKeyDown", _, O ? -1 : 1);
      }),
      onEndKeyDown: B[4] || (B[4] = (_) => a("endKeyDown", _)),
      onHomeKeyDown: B[5] || (B[5] = (_) => a("homeKeyDown", _))
    }, {
      default: withCtx(() => [
        renderSlot(M.$slots, "default")
      ]),
      _: 3
    }, 8, ["dir", "style"]));
  }
}), _sfc_main$2b = /* @__PURE__ */ defineComponent({
  __name: "SliderVertical",
  props: {
    min: {},
    max: {},
    inverted: { type: Boolean }
  },
  emits: ["slideEnd", "slideStart", "slideMove", "homeKeyDown", "endKeyDown", "stepKeyDown"],
  setup(e, { emit: t }) {
    const n = e, a = t, { max: o, min: s, inverted: u } = toRefs(n), d = injectSliderRootContext(), { forwardRef: f, currentElement: g } = useForwardExpose(), v = ref(), b = ref(), w = computed(() => !u.value);
    function C(P, M) {
      const B = b.value || g.value.getBoundingClientRect(), _ = [...d.thumbElements.value][d.valueIndexToChangeRef.value], T = d.thumbAlignment.value === "contain" ? _.clientHeight : 0;
      !v.value && !M && d.thumbAlignment.value === "contain" && (v.value = P.clientY - _.getBoundingClientRect().top);
      const O = [0, B.height - T], I = w.value ? [o.value, s.value] : [s.value, o.value], q = linearScale(O, I), F = M ? P.clientY - B.top - T / 2 : P.clientY - B.top - (v.value ?? 0);
      return b.value = B, q(F);
    }
    const k = computed(() => w.value ? "bottom" : "top"), E = computed(() => w.value ? "top" : "bottom"), A = computed(() => w.value ? 1 : -1);
    return provideSliderOrientationContext({
      startEdge: k,
      endEdge: E,
      direction: A,
      size: "height"
    }), (P, M) => (openBlock(), createBlock(_sfc_main$2d, {
      ref: unref(f),
      "data-orientation": "vertical",
      style: normalizeStyle({
        "--reka-slider-thumb-transform": !w.value && unref(d).thumbAlignment.value === "overflow" ? "translateY(-50%)" : "translateY(50%)"
      }),
      onSlideStart: M[0] || (M[0] = (B) => {
        const _ = C(B, !0);
        a("slideStart", _);
      }),
      onSlideMove: M[1] || (M[1] = (B) => {
        const _ = C(B);
        a("slideMove", _);
      }),
      onSlideEnd: M[2] || (M[2] = () => {
        b.value = void 0, v.value = void 0, a("slideEnd");
      }),
      onStepKeyDown: M[3] || (M[3] = (B) => {
        const _ = w.value ? "from-bottom" : "from-top", T = unref(BACK_KEYS)[_].includes(B.key);
        a("stepKeyDown", B, T ? -1 : 1);
      }),
      onEndKeyDown: M[4] || (M[4] = (B) => a("endKeyDown", B)),
      onHomeKeyDown: M[5] || (M[5] = (B) => a("homeKeyDown", B))
    }, {
      default: withCtx(() => [
        renderSlot(P.$slots, "default")
      ]),
      _: 3
    }, 8, ["style"]));
  }
}), [injectSliderRootContext, provideSliderRootContext] = createContext$2("SliderRoot"), _sfc_main$2a = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "SliderRoot",
  props: {
    defaultValue: { default: () => [0] },
    modelValue: {},
    disabled: { type: Boolean, default: !1 },
    orientation: { default: "horizontal" },
    dir: {},
    inverted: { type: Boolean, default: !1 },
    min: { default: 0 },
    max: { default: 100 },
    step: { default: 1 },
    minStepsBetweenThumbs: { default: 0 },
    thumbAlignment: { default: "contain" },
    asChild: { type: Boolean },
    as: { default: "span" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "valueCommit"],
  setup(e, { emit: t }) {
    const n = e, a = t, { min: o, max: s, step: u, minStepsBetweenThumbs: d, orientation: f, disabled: g, thumbAlignment: v, dir: b } = toRefs(n), w = useDirection(b), { forwardRef: C, currentElement: k } = useForwardExpose(), E = useFormControl(k), { CollectionSlot: A } = useCollection({ isProvider: !0 }), P = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), M = computed(() => Array.isArray(P.value) ? [...P.value] : []), B = ref(0), _ = ref(M.value);
    function T(W) {
      const K = getClosestValueIndex(M.value, W);
      q(W, K);
    }
    function O(W) {
      q(W, B.value);
    }
    function I() {
      const W = _.value[B.value];
      M.value[B.value] !== W && a("valueCommit", toRaw(M.value));
    }
    function q(W, K, { commit: Z } = { commit: !1 }) {
      const J = getDecimalCount(u.value), re = roundValue(Math.round((W - o.value) / u.value) * u.value + o.value, J), V = clamp$1(re, o.value, s.value), ne = getNextSortedValues(M.value, V, K);
      if (hasMinStepsBetweenValues(ne, d.value * u.value)) {
        B.value = ne.indexOf(V);
        const Q = String(ne) !== String(P.value);
        Q && Z && a("valueCommit", ne), Q && (F.value[B.value]?.focus(), P.value = ne);
      }
    }
    const F = ref([]);
    return provideSliderRootContext({
      modelValue: P,
      currentModelValue: M,
      valueIndexToChangeRef: B,
      thumbElements: F,
      orientation: f,
      min: o,
      max: s,
      disabled: g,
      thumbAlignment: v
    }), (W, K) => (openBlock(), createBlock(unref(A), null, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(f) === "horizontal" ? _sfc_main$2c : _sfc_main$2b), mergeProps(W.$attrs, {
          ref: unref(C),
          "as-child": W.asChild,
          as: W.as,
          min: unref(o),
          max: unref(s),
          dir: unref(w),
          inverted: W.inverted,
          "aria-disabled": unref(g),
          "data-disabled": unref(g) ? "" : void 0,
          onPointerdown: K[0] || (K[0] = () => {
            unref(g) || (_.value = M.value);
          }),
          onSlideStart: K[1] || (K[1] = (Z) => !unref(g) && T(Z)),
          onSlideMove: K[2] || (K[2] = (Z) => !unref(g) && O(Z)),
          onSlideEnd: K[3] || (K[3] = (Z) => !unref(g) && I()),
          onHomeKeyDown: K[4] || (K[4] = (Z) => !unref(g) && q(unref(o), 0, { commit: !0 })),
          onEndKeyDown: K[5] || (K[5] = (Z) => !unref(g) && q(unref(s), M.value.length - 1, { commit: !0 })),
          onStepKeyDown: K[6] || (K[6] = (Z, J) => {
            if (!unref(g)) {
              const ne = unref(PAGE_KEYS).includes(Z.key) || Z.shiftKey && unref(ARROW_KEYS).includes(Z.key) ? 10 : 1, Q = B.value, z = M.value[Q], X = unref(u) * ne * J;
              q(z + X, Q, { commit: !0 });
            }
          })
        }), {
          default: withCtx(() => [
            renderSlot(W.$slots, "default", { modelValue: unref(P) }),
            unref(E) && W.name ? (openBlock(), createBlock(unref(_sfc_main$42), {
              key: 0,
              type: "number",
              value: unref(P),
              name: W.name,
              required: W.required,
              disabled: unref(g),
              step: unref(u)
            }, null, 8, ["value", "name", "required", "disabled", "step"])) : createCommentVNode("", !0)
          ]),
          _: 3
        }, 16, ["as-child", "as", "min", "max", "dir", "inverted", "aria-disabled", "data-disabled"]))
      ]),
      _: 3
    }));
  }
}), _sfc_main$29 = /* @__PURE__ */ defineComponent({
  __name: "SliderRange",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = injectSliderRootContext(), n = injectSliderOrientationContext();
    useForwardExpose();
    const a = computed(() => t.currentModelValue.value.map(
      (u) => convertValueToPercentage(u, t.min.value, t.max.value)
    )), o = computed(() => t.currentModelValue.value.length > 1 ? Math.min(...a.value) : 0), s = computed(() => 100 - Math.max(...a.value, 0));
    return (u, d) => (openBlock(), createBlock(unref(Primitive), {
      "data-disabled": unref(t).disabled.value ? "" : void 0,
      "data-orientation": unref(t).orientation.value,
      "as-child": u.asChild,
      as: u.as,
      style: normalizeStyle({
        [unref(n).startEdge.value]: `${o.value}%`,
        [unref(n).endEdge.value]: `${s.value}%`
      })
    }, {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-disabled", "data-orientation", "as-child", "as", "style"]));
  }
}), _sfc_main$28 = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "SliderThumbImpl",
  props: {
    index: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectSliderRootContext(), a = injectSliderOrientationContext(), { forwardRef: o, currentElement: s } = useForwardExpose(), { CollectionItem: u } = useCollection(), d = computed(() => n.modelValue?.value?.[t.index]), f = computed(() => d.value === void 0 ? 0 : convertValueToPercentage(d.value, n.min.value ?? 0, n.max.value ?? 100)), g = computed(() => getLabel(t.index, n.modelValue?.value?.length ?? 0)), v = useSize(s), b = computed(() => v[a.size].value), w = computed(() => n.thumbAlignment.value === "overflow" || !b.value ? 0 : getThumbInBoundsOffset(b.value, f.value, a.direction.value)), C = useMounted();
    return onMounted(() => {
      n.thumbElements.value.push(s.value);
    }), onUnmounted(() => {
      const k = n.thumbElements.value.findIndex((E) => E === s.value) ?? -1;
      n.thumbElements.value.splice(k, 1);
    }), (k, E) => (openBlock(), createBlock(unref(u), null, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps(k.$attrs, {
          ref: unref(o),
          role: "slider",
          tabindex: unref(n).disabled.value ? void 0 : 0,
          "aria-label": k.$attrs["aria-label"] || g.value,
          "data-disabled": unref(n).disabled.value ? "" : void 0,
          "data-orientation": unref(n).orientation.value,
          "aria-valuenow": d.value,
          "aria-valuemin": unref(n).min.value,
          "aria-valuemax": unref(n).max.value,
          "aria-orientation": unref(n).orientation.value,
          "as-child": k.asChild,
          as: k.as,
          style: {
            transform: "var(--reka-slider-thumb-transform)",
            position: "absolute",
            [unref(a).startEdge.value]: `calc(${f.value}% + ${w.value}px)`,
            /**
             * There will be no value on initial render while we work out the index so we hide thumbs
             * without a value, otherwise SSR will render them in the wrong position before they
             * snap into the correct position during hydration which would be visually jarring for
             * slower connections.
             */
            display: !unref(C) && d.value === void 0 ? "none" : void 0
          },
          onFocus: E[0] || (E[0] = () => {
            unref(n).valueIndexToChangeRef.value = k.index;
          })
        }), {
          default: withCtx(() => [
            renderSlot(k.$slots, "default")
          ]),
          _: 3
        }, 16, ["tabindex", "aria-label", "data-disabled", "data-orientation", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-orientation", "as-child", "as", "style"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$27 = /* @__PURE__ */ defineComponent({
  __name: "SliderThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = e, { getItems: n } = useCollection(), { forwardRef: a, currentElement: o } = useForwardExpose(), s = computed(() => o.value ? n(!0).findIndex((u) => u.ref === o.value) : -1);
    return (u, d) => (openBlock(), createBlock(_sfc_main$28, mergeProps({ ref: unref(a) }, t, { index: s.value }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["index"]));
  }
}), _sfc_main$26 = /* @__PURE__ */ defineComponent({
  __name: "SliderTrack",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = injectSliderRootContext();
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(Primitive), {
      "as-child": n.asChild,
      as: n.as,
      "data-disabled": unref(t).disabled.value ? "" : void 0,
      "data-orientation": unref(t).orientation.value
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["as-child", "as", "data-disabled", "data-orientation"]));
  }
});
function assert(e, t = "Assertion failed!") {
  if (!e)
    throw console.error(t), new Error(t);
}
const isBrowser$2 = typeof document < "u";
function getPanelGroupElement(e, t = document) {
  if (!isBrowser$2)
    return null;
  if (t instanceof HTMLElement && t?.dataset?.panelGroupId === e)
    return t;
  const n = t.querySelector(
    `[data-panel-group][data-panel-group-id="${e}"]`
  );
  return n || null;
}
function getResizeHandleElement(e, t = document) {
  if (!isBrowser$2)
    return null;
  const n = t.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return n || null;
}
function getResizeHandleElementIndex(e, t, n = document) {
  return isBrowser$2 ? getResizeHandleElementsForGroup(e, n).findIndex(
    (s) => s.getAttribute("data-panel-resize-handle-id") === t
  ) ?? null : null;
}
function getResizeHandleElementsForGroup(e, t = document) {
  return isBrowser$2 ? Array.from(
    t.querySelectorAll(
      `[data-panel-resize-handle-id][data-panel-group-id="${e}"]`
    )
  ) : [];
}
function getResizeHandlePanelIds(e, t, n, a = document) {
  const o = getResizeHandleElement(t, a), s = getResizeHandleElementsForGroup(e, a), u = o ? s.indexOf(o) : -1, d = n[u]?.id ?? null, f = n[u + 1]?.id ?? null;
  return [d, f];
}
function isKeyDown(e) {
  return e.type === "keydown";
}
function isMouseEvent(e) {
  return e.type.startsWith("mouse");
}
function isTouchEvent(e) {
  return e.type.startsWith("touch");
}
function getResizeEventCoordinates(e) {
  if (isMouseEvent(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  if (isTouchEvent(e)) {
    const t = e.touches[0];
    if (t && t.clientX && t.clientY)
      return {
        x: t.clientX,
        y: t.clientY
      };
  }
  return {
    x: Number.POSITIVE_INFINITY,
    y: Number.POSITIVE_INFINITY
  };
}
function getResizeEventCursorPosition(e, t) {
  const n = e === "horizontal", { x: a, y: o } = getResizeEventCoordinates(t);
  return n ? a : o;
}
function calculateDragOffsetPercentage(e, t, n, a, o) {
  const s = n === "horizontal", u = getResizeHandleElement(t, o);
  assert(u);
  const d = u.getAttribute("data-panel-group-id");
  assert(d);
  const { initialCursorPosition: f } = a, g = getResizeEventCursorPosition(n, e), v = getPanelGroupElement(d, o);
  assert(v);
  const b = v.getBoundingClientRect(), w = s ? b.width : b.height;
  return (g - f) / w * 100;
}
function calculateDeltaPercentage(e, t, n, a, o, s) {
  if (isKeyDown(e)) {
    const u = n === "horizontal";
    let d = 0;
    e.shiftKey ? d = 100 : d = o ?? 10;
    let f = 0;
    switch (e.key) {
      case "ArrowDown":
        f = u ? 0 : d;
        break;
      case "ArrowLeft":
        f = u ? -d : 0;
        break;
      case "ArrowRight":
        f = u ? d : 0;
        break;
      case "ArrowUp":
        f = u ? 0 : -d;
        break;
      case "End":
        f = 100;
        break;
      case "Home":
        f = -100;
        break;
    }
    return f;
  } else
    return a == null ? 0 : calculateDragOffsetPercentage(
      e,
      t,
      n,
      a,
      s
    );
}
function calculateAriaValues({
  layout: e,
  panelsArray: t,
  pivotIndices: n
}) {
  let a = 0, o = 100, s = 0, u = 0;
  const d = n[0];
  assert(d != null), t.forEach((b, w) => {
    const { constraints: C } = b, { maxSize: k = 100, minSize: E = 0 } = C;
    w === d ? (a = E, o = k) : (s += E, u += k);
  });
  const f = Math.min(o, 100 - s), g = Math.max(a, 100 - u), v = e[d];
  return {
    valueMax: f,
    valueMin: g,
    valueNow: v
  };
}
function calculateUnsafeDefaultLayout({
  panelDataArray: e
}) {
  const t = Array.from({ length: e.length }), n = e.map(
    (s) => s.constraints
  );
  let a = 0, o = 100;
  for (let s = 0; s < e.length; s++) {
    const u = n[s];
    assert(u);
    const { defaultSize: d } = u;
    d != null && (a++, t[s] = d, o -= d);
  }
  for (let s = 0; s < e.length; s++) {
    const u = n[s];
    assert(u);
    const { defaultSize: d } = u;
    if (d != null)
      continue;
    const f = e.length - a, g = o / f;
    a++, t[s] = g, o -= g;
  }
  return t;
}
function callPanelCallbacks(e, t, n) {
  t.forEach((a, o) => {
    const s = e[o];
    assert(s);
    const { callbacks: u, constraints: d, id: f } = s, { collapsedSize: g = 0, collapsible: v } = d, b = n[f];
    if (b == null || a !== b) {
      n[f] = a;
      const { onCollapse: w, onExpand: C, onResize: k } = u;
      k && k(a, b), v && (w || C) && (C && (b == null || b === g) && a !== g && C(), w && (b == null || b !== g) && a === g && w());
    }
  });
}
function debounce$1(e, t = 10) {
  let n = null;
  return (...o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(...o);
    }, t);
  };
}
const PRECISION = 10;
function fuzzyCompareNumbers(e, t, n = PRECISION) {
  e = Number.parseFloat(e.toFixed(n)), t = Number.parseFloat(t.toFixed(n));
  const a = e - t;
  return a === 0 ? 0 : a > 0 ? 1 : -1;
}
function fuzzyNumbersEqual(e, t, n) {
  return fuzzyCompareNumbers(e, t, n) === 0;
}
function resizePanel({
  panelConstraints: e,
  panelIndex: t,
  size: n
}) {
  const a = e[t];
  assert(a != null);
  const { collapsedSize: o = 0, collapsible: s, maxSize: u = 100, minSize: d = 0 } = a;
  if (fuzzyCompareNumbers(n, d) < 0)
    if (s) {
      const f = (o + d) / 2;
      fuzzyCompareNumbers(n, f) < 0 ? n = o : n = d;
    } else
      n = d;
  return n = Math.min(u, n), n = Number.parseFloat(n.toFixed(PRECISION)), n;
}
function compareLayouts(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function adjustLayoutByDelta({
  delta: e,
  layout: t,
  panelConstraints: n,
  pivotIndices: a,
  trigger: o
}) {
  if (fuzzyNumbersEqual(e, 0))
    return t;
  const s = [...t], [u, d] = a;
  assert(u != null), assert(d != null);
  let f = 0;
  if (o === "keyboard") {
    {
      const v = e < 0 ? d : u, b = n[v];
      if (assert(b), b.collapsible) {
        const w = t[v];
        assert(w != null);
        const C = n[v];
        assert(C);
        const { collapsedSize: k = 0, minSize: E = 0 } = C;
        if (fuzzyNumbersEqual(w, k)) {
          const A = E - w;
          fuzzyCompareNumbers(A, Math.abs(e)) > 0 && (e = e < 0 ? 0 - A : A);
        }
      }
    }
    {
      const v = e < 0 ? u : d, b = n[v];
      assert(b);
      const { collapsible: w } = b;
      if (w) {
        const C = t[v];
        assert(C != null);
        const k = n[v];
        assert(k);
        const { collapsedSize: E = 0, minSize: A = 0 } = k;
        if (fuzzyNumbersEqual(C, A)) {
          const P = C - E;
          fuzzyCompareNumbers(P, Math.abs(e)) > 0 && (e = e < 0 ? 0 - P : P);
        }
      }
    }
  }
  {
    const v = e < 0 ? 1 : -1;
    let b = e < 0 ? d : u, w = 0;
    for (; ; ) {
      const k = t[b];
      assert(k != null);
      const A = resizePanel({
        panelConstraints: n,
        panelIndex: b,
        size: 100
      }) - k;
      if (w += A, b += v, b < 0 || b >= n.length)
        break;
    }
    const C = Math.min(Math.abs(e), Math.abs(w));
    e = e < 0 ? 0 - C : C;
  }
  {
    let b = e < 0 ? u : d;
    for (; b >= 0 && b < n.length; ) {
      const w = Math.abs(e) - Math.abs(f), C = t[b];
      assert(C != null);
      const k = C - w, E = resizePanel({
        panelConstraints: n,
        panelIndex: b,
        size: k
      });
      if (!fuzzyNumbersEqual(C, E) && (f += C - E, s[b] = E, f.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? b-- : b++;
    }
  }
  if (fuzzyNumbersEqual(f, 0))
    return t;
  {
    const v = e < 0 ? d : u, b = t[v];
    assert(b != null);
    const w = b + f, C = resizePanel({
      panelConstraints: n,
      panelIndex: v,
      size: w
    });
    if (s[v] = C, !fuzzyNumbersEqual(C, w)) {
      let k = w - C, A = e < 0 ? d : u;
      for (; A >= 0 && A < n.length; ) {
        const P = s[A];
        assert(P != null);
        const M = P + k, B = resizePanel({
          panelConstraints: n,
          panelIndex: A,
          size: M
        });
        if (fuzzyNumbersEqual(P, B) || (k -= B - P, s[A] = B), fuzzyNumbersEqual(k, 0))
          break;
        e > 0 ? A-- : A++;
      }
    }
  }
  const g = s.reduce((v, b) => b + v, 0);
  return fuzzyNumbersEqual(g, 100) ? s : t;
}
function determinePivotIndices(e, t, n) {
  const a = getResizeHandleElementIndex(
    e,
    t,
    n
  );
  return a != null ? [a, a + 1] : [-1, -1];
}
function intersects(e, t, n) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function compare(e, t) {
  if (e === t)
    throw new Error("Cannot compare node with itself");
  const n = {
    a: getAncestors(e),
    b: getAncestors(t)
  };
  let a;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), a = e;
  assert(a);
  const o = {
    a: getZIndex(findStackingContext(n.a)),
    b: getZIndex(findStackingContext(n.b))
  };
  if (o.a === o.b) {
    const s = a.childNodes, u = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let d = s.length;
    for (; d--; ) {
      const f = s[d];
      if (f === u.a)
        return 1;
      if (f === u.b)
        return -1;
    }
  }
  return Math.sign(o.a - o.b);
}
const props = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function isFlexItem(e) {
  const t = getComputedStyle(getParent(e)).display;
  return t === "flex" || t === "inline-flex";
}
function createsStackingContext(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || isFlexItem(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || props.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function findStackingContext(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (assert(n), createsStackingContext(n))
      return n;
  }
  return null;
}
function getZIndex(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function getAncestors(e) {
  const t = [];
  for (; e; )
    t.push(e), e = getParent(e);
  return t;
}
function getParent(e) {
  return e.parentNode instanceof DocumentFragment && e.parentNode?.host || e.parentNode;
}
let currentCursorStyle = null, styleElement = null;
function getCursorStyle(e, t) {
  if (t) {
    const n = (t & EXCEEDED_HORIZONTAL_MIN) !== 0, a = (t & EXCEEDED_HORIZONTAL_MAX) !== 0, o = (t & EXCEEDED_VERTICAL_MIN) !== 0, s = (t & EXCEEDED_VERTICAL_MAX) !== 0;
    if (n)
      return o ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (a)
      return o ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (o)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function resetGlobalCursorStyle() {
  styleElement !== null && (document.head.removeChild(styleElement), currentCursorStyle = null, styleElement = null);
}
function setGlobalCursorStyle(e, t) {
  const n = getCursorStyle(e, t);
  currentCursorStyle !== n && (currentCursorStyle = n, styleElement === null && (styleElement = document.createElement("style"), document.head.appendChild(styleElement)), styleElement.innerHTML = `*{cursor: ${n}!important;}`);
}
function computePanelFlexBoxStyle({
  defaultSize: e,
  dragState: t,
  layout: n,
  panelData: a,
  panelIndex: o,
  precision: s = 3
}) {
  const u = n[o];
  let d;
  return u == null ? d = e !== void 0 ? e.toPrecision(s) : "1" : a.length === 1 ? d = "1" : d = u.toPrecision(s), {
    flexBasis: 0,
    flexGrow: d,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: t !== null ? "none" : void 0
  };
}
const EXCEEDED_HORIZONTAL_MIN = 1, EXCEEDED_HORIZONTAL_MAX = 2, EXCEEDED_VERTICAL_MIN = 4, EXCEEDED_VERTICAL_MAX = 8;
function getInputType() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
const isCoarsePointer = getInputType() === "coarse", intersectingHandles = [];
let isPointerDown = !1;
const ownerDocumentCounts = /* @__PURE__ */ new Map(), panelConstraintFlags = /* @__PURE__ */ new Map(), registeredResizeHandlers = /* @__PURE__ */ new Set();
function registerResizeHandle(e, t, n, a, o) {
  const { ownerDocument: s } = t, u = {
    direction: n,
    element: t,
    hitAreaMargins: a,
    setResizeHandlerState: o
  }, d = ownerDocumentCounts.get(s) ?? 0;
  return ownerDocumentCounts.set(s, d + 1), registeredResizeHandlers.add(u), updateListeners(), function() {
    panelConstraintFlags.delete(e), registeredResizeHandlers.delete(u);
    const g = ownerDocumentCounts.get(s) ?? 1;
    ownerDocumentCounts.set(s, g - 1), updateListeners(), resetGlobalCursorStyle(), g === 1 && ownerDocumentCounts.delete(s);
  };
}
function handlePointerDown(e) {
  const { target: t } = e, { x: n, y: a } = getResizeEventCoordinates(e);
  isPointerDown = !0, recalculateIntersectingHandles({ target: t, x: n, y: a }), updateListeners(), intersectingHandles.length > 0 && (updateResizeHandlerStates("down", e), e.preventDefault());
}
function handlePointerMove(e) {
  const { x: t, y: n } = getResizeEventCoordinates(e);
  if (!isPointerDown) {
    const { target: a } = e;
    recalculateIntersectingHandles({ target: a, x: t, y: n });
  }
  updateResizeHandlerStates("move", e), updateCursor(), intersectingHandles.length > 0 && e.preventDefault();
}
function handlePointerUp(e) {
  const { target: t } = e, { x: n, y: a } = getResizeEventCoordinates(e);
  panelConstraintFlags.clear(), isPointerDown = !1, intersectingHandles.length > 0 && e.preventDefault(), updateResizeHandlerStates("up", e), recalculateIntersectingHandles({ target: t, x: n, y: a }), updateCursor(), updateListeners();
}
function recalculateIntersectingHandles({
  target: e,
  x: t,
  y: n
}) {
  intersectingHandles.splice(0);
  let a = null;
  e instanceof HTMLElement && (a = e), registeredResizeHandlers.forEach((o) => {
    const { element: s, hitAreaMargins: u } = o, d = s.getBoundingClientRect(), { bottom: f, left: g, right: v, top: b } = d, w = isCoarsePointer ? u.coarse : u.fine;
    if (t >= g - w && t <= v + w && n >= b - w && n <= f + w) {
      if (a !== null && s !== a && !s.contains(a) && !a.contains(s) && compare(a, s) > 0) {
        let k = a, E = !1;
        for (; k && !k.contains(s); ) {
          if (intersects(
            k.getBoundingClientRect(),
            d
          )) {
            E = !0;
            break;
          }
          k = k.parentElement;
        }
        if (E)
          return;
      }
      intersectingHandles.push(o);
    }
  });
}
function reportConstraintsViolation(e, t) {
  panelConstraintFlags.set(e, t);
}
function updateCursor() {
  let e = !1, t = !1;
  intersectingHandles.forEach((a) => {
    const { direction: o } = a;
    o.value === "horizontal" ? e = !0 : t = !0;
  });
  let n = 0;
  panelConstraintFlags.forEach((a) => {
    n |= a;
  }), e && t ? setGlobalCursorStyle("intersection", n) : e ? setGlobalCursorStyle("horizontal", n) : t ? setGlobalCursorStyle("vertical", n) : resetGlobalCursorStyle();
}
function updateListeners() {
  ownerDocumentCounts.forEach((e, t) => {
    const { body: n } = t;
    n.removeEventListener("contextmenu", handlePointerUp), n.removeEventListener("mousedown", handlePointerDown), n.removeEventListener("mouseleave", handlePointerMove), n.removeEventListener("mousemove", handlePointerMove), n.removeEventListener("touchmove", handlePointerMove), n.removeEventListener("touchstart", handlePointerDown);
  }), window.removeEventListener("mouseup", handlePointerUp), window.removeEventListener("touchcancel", handlePointerUp), window.removeEventListener("touchend", handlePointerUp), registeredResizeHandlers.size > 0 && (isPointerDown ? (intersectingHandles.length > 0 && ownerDocumentCounts.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("contextmenu", handlePointerUp), n.addEventListener("mouseleave", handlePointerMove), n.addEventListener("mousemove", handlePointerMove), n.addEventListener("touchmove", handlePointerMove, {
      passive: !1
    }));
  }), window.addEventListener("mouseup", handlePointerUp), window.addEventListener("touchcancel", handlePointerUp), window.addEventListener("touchend", handlePointerUp)) : ownerDocumentCounts.forEach((e, t) => {
    const { body: n } = t;
    e > 0 && (n.addEventListener("mousedown", handlePointerDown), n.addEventListener("mousemove", handlePointerMove), n.addEventListener("touchmove", handlePointerMove, {
      passive: !1
    }), n.addEventListener("touchstart", handlePointerDown));
  }));
}
function updateResizeHandlerStates(e, t) {
  registeredResizeHandlers.forEach((n) => {
    const { setResizeHandlerState: a } = n, o = intersectingHandles.includes(n);
    a(e, o, t);
  });
}
function validatePanelGroupLayout({
  layout: e,
  panelConstraints: t
}) {
  const n = [...e], a = n.reduce(
    (s, u) => s + u,
    0
  );
  if (n.length !== t.length)
    throw new Error(
      `Invalid ${t.length} panel layout: ${n.map((s) => `${s}%`).join(", ")}`
    );
  if (!fuzzyNumbersEqual(a, 100)) {
    console.warn(
      `WARNING: Invalid layout total size: ${n.map((s) => `${s}%`).join(", ")}. Layout normalization will be applied.`
    );
    for (let s = 0; s < t.length; s++) {
      const u = n[s];
      assert(u != null);
      const d = 100 / a * u;
      n[s] = d;
    }
  }
  let o = 0;
  for (let s = 0; s < t.length; s++) {
    const u = n[s];
    assert(u != null);
    const d = resizePanel({
      panelConstraints: t,
      panelIndex: s,
      size: u
    });
    u !== d && (o += u - d, n[s] = d);
  }
  if (!fuzzyNumbersEqual(o, 0))
    for (let s = 0; s < t.length; s++) {
      const u = n[s];
      assert(u != null);
      const d = u + o, f = resizePanel({
        panelConstraints: t,
        panelIndex: s,
        size: d
      });
      if (u !== f && (o -= f - u, n[s] = f, fuzzyNumbersEqual(o, 0)))
        break;
    }
  return n;
}
function useWindowSplitterPanelGroupBehavior({
  eagerValuesRef: e,
  groupId: t,
  layout: n,
  panelDataArray: a,
  panelGroupElement: o,
  setLayout: s
}) {
  watchEffect((u) => {
    const d = o.value;
    if (!d)
      return;
    const f = getResizeHandleElementsForGroup(
      t,
      d
    );
    for (let g = 0; g < a.length - 1; g++) {
      const { valueMax: v, valueMin: b, valueNow: w } = calculateAriaValues({
        layout: n.value,
        panelsArray: a,
        pivotIndices: [g, g + 1]
      }), C = f[g];
      if (C != null) {
        const k = a[g];
        assert(k), C.setAttribute("aria-controls", k.id), C.setAttribute(
          "aria-valuemax",
          `${Math.round(v)}`
        ), C.setAttribute(
          "aria-valuemin",
          `${Math.round(b)}`
        ), C.setAttribute(
          "aria-valuenow",
          w != null ? `${Math.round(w)}` : ""
        );
      }
    }
    u(() => {
      f.forEach((g) => {
        g.removeAttribute("aria-controls"), g.removeAttribute("aria-valuemax"), g.removeAttribute("aria-valuemin"), g.removeAttribute("aria-valuenow");
      });
    });
  }), watchEffect((u) => {
    const d = o.value;
    if (!d)
      return;
    const f = e.value;
    assert(f);
    const { panelDataArray: g } = f, v = getPanelGroupElement(t, d);
    assert(v != null, `No group found for id "${t}"`);
    const b = getResizeHandleElementsForGroup(t, d);
    assert(b);
    const w = b.map((C) => {
      const k = C.getAttribute("data-panel-resize-handle-id");
      assert(k);
      const [E, A] = getResizeHandlePanelIds(
        t,
        k,
        g,
        d
      );
      if (E == null || A == null)
        return () => {
        };
      const P = (M) => {
        if (!M.defaultPrevented)
          switch (M.key) {
            case "Enter": {
              M.preventDefault();
              const B = g.findIndex(
                (_) => _.id === E
              );
              if (B >= 0) {
                const _ = g[B];
                assert(_);
                const T = n.value[B], {
                  collapsedSize: O = 0,
                  collapsible: I,
                  minSize: q = 0
                } = _.constraints;
                if (T != null && I) {
                  const F = adjustLayoutByDelta({
                    delta: fuzzyNumbersEqual(T, O) ? q - O : O - T,
                    layout: n.value,
                    panelConstraints: g.map(
                      (W) => W.constraints
                    ),
                    pivotIndices: determinePivotIndices(
                      t,
                      k,
                      d
                    ),
                    trigger: "keyboard"
                  });
                  n.value !== F && s(F);
                }
              }
              break;
            }
          }
      };
      return C.addEventListener("keydown", P), () => {
        C.removeEventListener("keydown", P);
      };
    });
    u(() => {
      w.forEach((C) => C());
    });
  });
}
function initializeDefaultStorage(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (t) => localStorage.getItem(t), e.setItem = (t, n) => {
        localStorage.setItem(t, n);
      };
    else
      throw new TypeError("localStorage not supported in this environment");
  } catch (t) {
    console.error(t), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function getPanelGroupKey(e) {
  return `reka:${e}`;
}
function getPanelKey(e) {
  return e.map((t) => {
    const { constraints: n, id: a, idIsFromProps: o, order: s } = t;
    return o ? a : s ? `${s}:${JSON.stringify(n)}` : JSON.stringify(n);
  }).sort((t, n) => t.localeCompare(n)).join(",");
}
function loadSerializedPanelGroupState(e, t) {
  try {
    const n = getPanelGroupKey(e), a = t.getItem(n);
    if (a) {
      const o = JSON.parse(a);
      if (typeof o == "object" && o != null)
        return o;
    }
  } catch {
  }
  return null;
}
function loadPanelGroupState(e, t, n) {
  const a = loadSerializedPanelGroupState(e, n) ?? {}, o = getPanelKey(t);
  return a[o] ?? null;
}
function savePanelGroupState(e, t, n, a, o) {
  const s = getPanelGroupKey(e), u = getPanelKey(t), d = loadSerializedPanelGroupState(e, o) ?? {};
  d[u] = {
    expandToSizes: Object.fromEntries(n.entries()),
    layout: a
  };
  try {
    o.setItem(s, JSON.stringify(d));
  } catch (f) {
    console.error(f);
  }
}
const LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100, defaultStorage = {
  getItem: (e) => (initializeDefaultStorage(defaultStorage), defaultStorage.getItem(e)),
  setItem: (e, t) => {
    initializeDefaultStorage(defaultStorage), defaultStorage.setItem(e, t);
  }
}, [injectPanelGroupContext, providePanelGroupContext] = createContext$2("PanelGroup"), _sfc_main$25 = /* @__PURE__ */ defineComponent({
  __name: "SplitterGroup",
  props: {
    id: {},
    autoSaveId: { default: null },
    direction: {},
    keyboardResizeBy: { default: 10 },
    storage: { default: () => defaultStorage },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["layout"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = {}, { direction: s } = toRefs(n), u = useId(n.id, "reka-splitter-group"), d = useDirection(), { forwardRef: f, currentElement: g } = useForwardExpose(), v = ref(null), b = ref([]), w = ref({}), C = ref(/* @__PURE__ */ new Map()), k = ref(0), E = computed(() => ({
      autoSaveId: n.autoSaveId,
      direction: n.direction,
      dragState: v.value,
      id: u,
      keyboardResizeBy: n.keyboardResizeBy,
      storage: n.storage
    })), A = ref({
      layout: b.value,
      panelDataArray: [],
      panelDataArrayChanged: !1
    }), P = (Q) => b.value = Q;
    useWindowSplitterPanelGroupBehavior({
      eagerValuesRef: A,
      groupId: u,
      layout: b,
      panelDataArray: A.value.panelDataArray,
      setLayout: P,
      panelGroupElement: g
    }), watchEffect(() => {
      const { panelDataArray: Q } = A.value, { autoSaveId: z } = n;
      if (z) {
        if (b.value.length === 0 || b.value.length !== Q.length)
          return;
        let X = o[z];
        X || (X = debounce$1(
          savePanelGroupState,
          LOCAL_STORAGE_DEBOUNCE_INTERVAL
        ), o[z] = X);
        const ue = [...Q], Be = new Map(
          C.value
        );
        X(
          z,
          ue,
          Be,
          b.value,
          n.storage
        );
      }
    });
    function M(Q, z) {
      const { panelDataArray: X } = A.value, ue = V(X, Q);
      return computePanelFlexBoxStyle({
        defaultSize: z,
        dragState: v.value,
        layout: b.value,
        panelData: X,
        panelIndex: ue
      });
    }
    function B(Q) {
      const { panelDataArray: z } = A.value;
      z.push(Q), z.sort((X, ue) => {
        const Be = X.order, te = ue.order;
        return Be == null && te == null ? 0 : Be == null ? -1 : te == null ? 1 : Be - te;
      }), A.value.panelDataArrayChanged = !0;
    }
    watch(() => A.value.panelDataArrayChanged, () => {
      if (A.value.panelDataArrayChanged) {
        A.value.panelDataArrayChanged = !1;
        const { autoSaveId: Q, storage: z } = E.value, { layout: X, panelDataArray: ue } = A.value;
        let Be = null;
        if (Q) {
          const G = loadPanelGroupState(Q, ue, z);
          G && (C.value = new Map(
            Object.entries(G.expandToSizes)
          ), Be = G.layout);
        }
        Be === null && (Be = calculateUnsafeDefaultLayout({
          panelDataArray: ue
        }));
        const te = validatePanelGroupLayout({
          layout: Be,
          panelConstraints: ue.map(
            (G) => G.constraints
          )
        });
        areEqual(X, te) || (P(te), A.value.layout = te, a("layout", te), callPanelCallbacks(
          ue,
          te,
          w.value
        ));
      }
    });
    function _(Q) {
      return function(X) {
        X.preventDefault();
        const ue = g.value;
        if (!ue)
          return () => null;
        const { direction: Be, dragState: te, id: G, keyboardResizeBy: ie } = E.value, { layout: oe, panelDataArray: ye } = A.value, { initialLayout: ve } = te ?? {}, ke = determinePivotIndices(
          G,
          Q,
          ue
        );
        let Ae = calculateDeltaPercentage(
          X,
          Q,
          Be,
          te,
          ie,
          ue
        );
        if (Ae === 0)
          return;
        const be = Be === "horizontal";
        d.value === "rtl" && be && (Ae = -Ae);
        const Ie = ye.map((Ne) => Ne.constraints), Se = adjustLayoutByDelta({
          delta: Ae,
          layout: ve ?? oe,
          panelConstraints: Ie,
          pivotIndices: ke,
          trigger: isKeyDown(X) ? "keyboard" : "mouse-or-touch"
        }), ze = !compareLayouts(oe, Se);
        (isMouseEvent(X) || isTouchEvent(X)) && k.value !== Ae && (k.value = Ae, ze ? reportConstraintsViolation(Q, 0) : be ? reportConstraintsViolation(
          Q,
          Ae < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX
        ) : reportConstraintsViolation(
          Q,
          Ae < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX
        )), ze && (P(Se), A.value.layout = Se, a("layout", Se), callPanelCallbacks(
          ye,
          Se,
          w.value
        ));
      };
    }
    function T(Q, z) {
      const { layout: X, panelDataArray: ue } = A.value, Be = ue.map((ve) => ve.constraints), { panelSize: te, pivotIndices: G } = ne(
        ue,
        Q,
        X
      );
      assert(te != null);
      const oe = V(ue, Q) === ue.length - 1 ? te - z : z - te, ye = adjustLayoutByDelta({
        delta: oe,
        layout: X,
        panelConstraints: Be,
        pivotIndices: G,
        trigger: "imperative-api"
      });
      compareLayouts(X, ye) || (P(ye), A.value.layout = ye, a("layout", ye), callPanelCallbacks(
        ue,
        ye,
        w.value
      ));
    }
    function O(Q, z) {
      const { layout: X, panelDataArray: ue } = A.value, Be = V(ue, Q);
      ue[Be] = Q, A.value.panelDataArrayChanged = !0;
      const {
        collapsedSize: te = 0,
        collapsible: G
      } = z, {
        collapsedSize: ie = 0,
        collapsible: oe,
        maxSize: ye = 100,
        minSize: ve = 0
      } = Q.constraints, { panelSize: ke } = ne(
        ue,
        Q,
        X
      );
      ke !== null && (G && oe && ke === te ? te !== ie && T(Q, ie) : ke < ve ? T(Q, ve) : ke > ye && T(Q, ye));
    }
    function I(Q, z) {
      const { direction: X } = E.value, { layout: ue } = A.value;
      if (!g.value)
        return;
      const Be = getResizeHandleElement(
        Q,
        g.value
      );
      assert(Be);
      const te = getResizeEventCursorPosition(
        X,
        z
      );
      v.value = {
        dragHandleId: Q,
        dragHandleRect: Be.getBoundingClientRect(),
        initialCursorPosition: te,
        initialLayout: ue
      };
    }
    function q() {
      v.value = null;
    }
    function F(Q) {
      const { panelDataArray: z } = A.value, X = V(z, Q);
      X >= 0 && (z.splice(X, 1), delete w.value[Q.id], A.value.panelDataArrayChanged = !0);
    }
    function W(Q) {
      const { layout: z, panelDataArray: X } = A.value;
      if (Q.constraints.collapsible) {
        const ue = X.map(
          (ie) => ie.constraints
        ), {
          collapsedSize: Be = 0,
          panelSize: te,
          pivotIndices: G
        } = ne(X, Q, z);
        if (assert(
          te != null,
          `Panel size not found for panel "${Q.id}"`
        ), te !== Be) {
          C.value.set(Q.id, te);
          const oe = V(X, Q) === X.length - 1 ? te - Be : Be - te, ye = adjustLayoutByDelta({
            delta: oe,
            layout: z,
            panelConstraints: ue,
            pivotIndices: G,
            trigger: "imperative-api"
          });
          compareLayouts(z, ye) || (P(ye), A.value.layout = ye, a("layout", ye), callPanelCallbacks(
            X,
            ye,
            w.value
          ));
        }
      }
    }
    function K(Q) {
      const { layout: z, panelDataArray: X } = A.value;
      if (Q.constraints.collapsible) {
        const ue = X.map(
          (oe) => oe.constraints
        ), {
          collapsedSize: Be = 0,
          panelSize: te,
          minSize: G = 0,
          pivotIndices: ie
        } = ne(X, Q, z);
        if (te === Be) {
          const oe = C.value.get(
            Q.id
          ), ye = oe != null && oe >= G ? oe : G, ke = V(X, Q) === X.length - 1 ? te - ye : ye - te, Ae = adjustLayoutByDelta({
            delta: ke,
            layout: z,
            panelConstraints: ue,
            pivotIndices: ie,
            trigger: "imperative-api"
          });
          compareLayouts(z, Ae) || (P(Ae), A.value.layout = Ae, a("layout", Ae), callPanelCallbacks(
            X,
            Ae,
            w.value
          ));
        }
      }
    }
    function Z(Q) {
      const { layout: z, panelDataArray: X } = A.value, { panelSize: ue } = ne(X, Q, z);
      return assert(
        ue != null,
        `Panel size not found for panel "${Q.id}"`
      ), ue;
    }
    function J(Q) {
      const { layout: z, panelDataArray: X } = A.value, {
        collapsedSize: ue = 0,
        collapsible: Be,
        panelSize: te
      } = ne(X, Q, z);
      return Be ? te === void 0 ? Q.constraints.defaultSize === Q.constraints.collapsedSize : te === ue : !1;
    }
    function re(Q) {
      const { layout: z, panelDataArray: X } = A.value, {
        collapsedSize: ue = 0,
        collapsible: Be,
        panelSize: te
      } = ne(X, Q, z);
      return assert(
        te != null,
        `Panel size not found for panel "${Q.id}"`
      ), !Be || te > ue;
    }
    providePanelGroupContext({
      direction: s,
      dragState: v.value,
      groupId: u,
      reevaluatePanelConstraints: O,
      registerPanel: B,
      registerResizeHandle: _,
      resizePanel: T,
      startDragging: I,
      stopDragging: q,
      unregisterPanel: F,
      panelGroupElement: g,
      collapsePanel: W,
      expandPanel: K,
      isPanelCollapsed: J,
      isPanelExpanded: re,
      getPanelSize: Z,
      getPanelStyle: M
    });
    function V(Q, z) {
      return Q.findIndex(
        (X) => X === z || X.id === z.id
      );
    }
    function ne(Q, z, X) {
      const ue = V(Q, z), te = ue === Q.length - 1 ? [ue - 1, ue] : [ue, ue + 1], G = X[ue];
      return {
        ...z.constraints,
        panelSize: G,
        pivotIndices: te
      };
    }
    return (Q, z) => (openBlock(), createBlock(unref(Primitive), {
      ref: unref(f),
      as: Q.as,
      "as-child": Q.asChild,
      style: normalizeStyle({
        display: "flex",
        flexDirection: unref(s) === "horizontal" ? "row" : "column",
        height: "100%",
        overflow: "hidden",
        width: "100%"
      }),
      "data-panel-group": "",
      "data-orientation": unref(s),
      "data-panel-group-id": unref(u)
    }, {
      default: withCtx(() => [
        renderSlot(Q.$slots, "default", { layout: b.value })
      ]),
      _: 3
    }, 8, ["as", "as-child", "style", "data-orientation", "data-panel-group-id"]));
  }
}), _sfc_main$24 = /* @__PURE__ */ defineComponent({
  __name: "SplitterPanel",
  props: {
    collapsedSize: {},
    collapsible: { type: Boolean },
    defaultSize: {},
    id: {},
    maxSize: {},
    minSize: {},
    order: {},
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["collapse", "expand", "resize"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, s = injectPanelGroupContext();
    if (s === null)
      throw new Error(
        "SplitterPanel components must be rendered within a SplitterGroup container"
      );
    const { collapsePanel: u, expandPanel: d, getPanelSize: f, getPanelStyle: g, isPanelCollapsed: v, resizePanel: b, groupId: w, reevaluatePanelConstraints: C, registerPanel: k, unregisterPanel: E } = s, A = useId(a.id, "reka-splitter-panel"), P = computed(() => ({
      callbacks: {
        onCollapse: () => o("collapse"),
        onExpand: () => o("expand"),
        onResize: (...q) => o("resize", ...q)
      },
      constraints: {
        collapsedSize: a.collapsedSize && Number.parseFloat(a.collapsedSize.toFixed(PRECISION)),
        collapsible: a.collapsible,
        defaultSize: a.defaultSize,
        /** Panel id (unique within group); falls back to useId when not provided */
        /** Panel id (unique within group); falls back to useId when not provided */
        maxSize: a.maxSize,
        minSize: a.minSize
      },
      id: A,
      idIsFromProps: a.id !== void 0,
      order: a.order
    }));
    watch(() => P.value.constraints, (q, F) => {
      (F.collapsedSize !== q.collapsedSize || F.collapsible !== q.collapsible || F.maxSize !== q.maxSize || F.minSize !== q.minSize) && C(P.value, F);
    }, { deep: !0 }), onMounted(() => {
      const q = P.value;
      k(q), onUnmounted(() => {
        E(q);
      });
    });
    const M = computed(() => g(P.value, a.defaultSize)), B = computed(() => v(P.value)), _ = computed(() => !B.value);
    function T() {
      u(P.value);
    }
    function O() {
      d(P.value);
    }
    function I(q) {
      b(P.value, q);
    }
    return t({
      /** If panel is `collapsible`, collapse it fully. */
      collapse: T,
      /** If panel is currently collapsed, expand it to its most recent size. */
      expand: O,
      /** Gets the current size of the panel as a percentage (1 - 100). */
      getSize() {
        return f(P.value);
      },
      /** Resize panel to the specified percentage (1 - 100). */
      resize: I,
      /** Returns `true` if the panel is currently collapsed */
      isCollapsed: B,
      /** Returns `true` if the panel is currently not collapsed */
      isExpanded: _
    }), (q, F) => (openBlock(), createBlock(unref(Primitive), {
      id: unref(A),
      style: normalizeStyle(M.value),
      as: q.as,
      "as-child": q.asChild,
      "data-panel": "",
      "data-panel-collapsible": q.collapsible || void 0,
      "data-panel-group-id": unref(w),
      "data-panel-id": unref(A),
      "data-panel-size": Number.parseFloat(`${M.value.flexGrow}`).toFixed(1),
      "data-state": q.collapsible ? B.value ? "collapsed" : "expanded" : void 0
    }, {
      default: withCtx(() => [
        renderSlot(q.$slots, "default", {
          isCollapsed: B.value,
          isExpanded: _.value,
          expand: O,
          collapse: T,
          resize: I
        })
      ]),
      _: 3
    }, 8, ["id", "style", "as", "as-child", "data-panel-collapsible", "data-panel-group-id", "data-panel-id", "data-panel-size", "data-state"]));
  }
});
function useWindowSplitterResizeHandlerBehavior({
  disabled: e,
  handleId: t,
  resizeHandler: n,
  panelGroupElement: a
}) {
  watchEffect((o) => {
    const s = a.value;
    if (e.value || n.value === null || s === null)
      return;
    const u = getResizeHandleElement(t, s);
    if (u == null)
      return;
    const d = (f) => {
      if (!f.defaultPrevented)
        switch (f.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            f.preventDefault(), n.value?.(f);
            break;
          }
          case "F6": {
            f.preventDefault();
            const g = u.getAttribute("data-panel-group-id");
            assert(g);
            const v = getResizeHandleElementsForGroup(
              g,
              s
            ), b = getResizeHandleElementIndex(
              g,
              t,
              s
            );
            assert(b !== null);
            const w = f.shiftKey ? b > 0 ? b - 1 : v.length - 1 : b + 1 < v.length ? b + 1 : 0;
            v[w].focus();
            break;
          }
        }
    };
    u.addEventListener("keydown", d), o(() => {
      u.removeEventListener("keydown", d);
    });
  });
}
const _sfc_main$23 = /* @__PURE__ */ defineComponent({
  __name: "SplitterResizeHandle",
  props: {
    id: {},
    hitAreaMargins: {},
    tabindex: { default: 0 },
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["dragging"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), { disabled: u } = toRefs(n), d = injectPanelGroupContext();
    if (d === null)
      throw new Error(
        "PanelResizeHandle components must be rendered within a PanelGroup container"
      );
    const {
      direction: f,
      groupId: g,
      registerResizeHandle: v,
      startDragging: b,
      stopDragging: w,
      panelGroupElement: C
    } = d, k = useId(n.id, "reka-splitter-resize-handle"), E = ref("inactive"), A = ref(!1), P = ref(null);
    return watch(u, () => {
      isBrowser$2 && (u.value ? P.value = null : P.value = v(k));
    }, { immediate: !0 }), watchEffect((M) => {
      if (u.value || P.value === null)
        return;
      const B = s.value;
      if (!B)
        return;
      assert(B);
      const _ = (T, O, I) => {
        if (O)
          switch (T) {
            case "down": {
              E.value = "drag", b(k, I), a("dragging", !0);
              break;
            }
            case "move": {
              E.value !== "drag" && (E.value = "hover"), P.value?.(I);
              break;
            }
            case "up": {
              E.value = "hover", w(), a("dragging", !1);
              break;
            }
          }
        else
          E.value = "inactive";
      };
      M(registerResizeHandle(
        k,
        B,
        f,
        {
          // Coarse inputs (e.g. finger/touch)
          coarse: n.hitAreaMargins?.coarse ?? 15,
          // Fine inputs (e.g. mouse)
          fine: n.hitAreaMargins?.fine ?? 5
        },
        _
      ));
    }), useWindowSplitterResizeHandlerBehavior({
      disabled: u,
      resizeHandler: P,
      handleId: k,
      panelGroupElement: C
    }), (M, B) => (openBlock(), createBlock(unref(Primitive), {
      id: unref(k),
      ref: unref(o),
      style: {
        touchAction: "none",
        userSelect: "none"
      },
      as: M.as,
      "as-child": M.asChild,
      role: "separator",
      "data-resize-handle": "",
      tabindex: M.tabindex,
      "data-state": E.value,
      "data-disabled": unref(u) ? "" : void 0,
      "data-orientation": unref(f),
      "data-panel-group-id": unref(g),
      "data-resize-handle-active": E.value === "drag" ? "pointer" : A.value ? "keyboard" : void 0,
      "data-resize-handle-state": E.value,
      "data-panel-resize-handle-enabled": !unref(u),
      "data-panel-resize-handle-id": unref(k),
      onBlur: B[0] || (B[0] = (_) => A.value = !1),
      onFocus: B[1] || (B[1] = (_) => A.value = !1)
    }, {
      default: withCtx(() => [
        renderSlot(M.$slots, "default")
      ]),
      _: 3
    }, 8, ["id", "as", "as-child", "tabindex", "data-state", "data-disabled", "data-orientation", "data-panel-group-id", "data-resize-handle-active", "data-resize-handle-state", "data-panel-resize-handle-enabled", "data-panel-resize-handle-id"]));
  }
}), [injectSwitchRootContext, provideSwitchRootContext] = createContext$2("SwitchRoot"), _sfc_main$22 = /* @__PURE__ */ defineComponent({
  __name: "SwitchRoot",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null], default: void 0 },
    disabled: { type: Boolean },
    id: {},
    value: { default: "on" },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { disabled: o } = toRefs(n), s = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function u() {
      o.value || (s.value = !s.value);
    }
    const { forwardRef: d, currentElement: f } = useForwardExpose(), g = useFormControl(f), v = computed(() => n.id && f.value ? document.querySelector(`[for="${n.id}"]`)?.innerText : void 0);
    return provideSwitchRootContext({
      modelValue: s,
      toggleCheck: u,
      disabled: o
    }), (b, w) => (openBlock(), createBlock(unref(Primitive), mergeProps(b.$attrs, {
      id: b.id,
      ref: unref(d),
      role: "switch",
      type: b.as === "button" ? "button" : void 0,
      value: b.value,
      "aria-label": b.$attrs["aria-label"] || v.value,
      "aria-checked": unref(s),
      "aria-required": b.required,
      "data-state": unref(s) ? "checked" : "unchecked",
      "data-disabled": unref(o) ? "" : void 0,
      "as-child": b.asChild,
      as: b.as,
      disabled: unref(o),
      onClick: u,
      onKeydown: withKeys(withModifiers(u, ["prevent"]), ["enter"])
    }), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default", { modelValue: unref(s) }),
        unref(g) && b.name ? (openBlock(), createBlock(unref(_sfc_main$42), {
          key: 0,
          type: "checkbox",
          name: b.name,
          disabled: unref(o),
          required: b.required,
          value: b.value,
          checked: !!unref(s)
        }, null, 8, ["name", "disabled", "required", "value", "checked"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 16, ["id", "type", "value", "aria-label", "aria-checked", "aria-required", "data-state", "data-disabled", "as-child", "as", "disabled", "onKeydown"]));
  }
}), _sfc_main$21 = /* @__PURE__ */ defineComponent({
  __name: "SwitchThumb",
  props: {
    asChild: { type: Boolean },
    as: { default: "span" }
  },
  setup(e) {
    const t = injectSwitchRootContext();
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(Primitive), {
      "data-state": unref(t).modelValue?.value ? "checked" : "unchecked",
      "data-disabled": unref(t).disabled.value ? "" : void 0,
      "as-child": n.asChild,
      as: n.as
    }, {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 8, ["data-state", "data-disabled", "as-child", "as"]));
  }
});
function makeTriggerId(e, t) {
  return `${e}-trigger-${t}`;
}
function makeContentId(e, t) {
  return `${e}-content-${t}`;
}
const [injectTabsRootContext, provideTabsRootContext] = createContext$2("TabsRoot"), _sfc_main$20 = /* @__PURE__ */ defineComponent({
  __name: "TabsRoot",
  props: {
    defaultValue: {},
    orientation: { default: "horizontal" },
    dir: {},
    activationMode: { default: "automatic" },
    modelValue: {},
    unmountOnHide: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { orientation: o, unmountOnHide: s, dir: u } = toRefs(n), d = useDirection(u);
    useForwardExpose();
    const f = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    }), g = ref();
    return provideTabsRootContext({
      modelValue: f,
      changeModelValue: (v) => {
        f.value = v;
      },
      orientation: o,
      dir: d,
      unmountOnHide: s,
      activationMode: n.activationMode,
      baseId: useId(void 0, "reka-tabs"),
      tabsList: g
    }), (v, b) => (openBlock(), createBlock(unref(Primitive), {
      dir: unref(d),
      "data-orientation": unref(o),
      "as-child": v.asChild,
      as: v.as
    }, {
      default: withCtx(() => [
        renderSlot(v.$slots, "default", { modelValue: unref(f) })
      ]),
      _: 3
    }, 8, ["dir", "data-orientation", "as-child", "as"]));
  }
}), _sfc_main$1$ = /* @__PURE__ */ defineComponent({
  __name: "TabsContent",
  props: {
    value: {},
    forceMount: { type: Boolean },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { forwardRef: n } = useForwardExpose(), a = injectTabsRootContext(), o = computed(() => makeTriggerId(a.baseId, t.value)), s = computed(() => makeContentId(a.baseId, t.value)), u = computed(() => t.value === a.modelValue.value), d = ref(u.value);
    return onMounted(() => {
      requestAnimationFrame(() => {
        d.value = !1;
      });
    }), (f, g) => (openBlock(), createBlock(unref(Presence), {
      present: f.forceMount || u.value,
      "force-mount": ""
    }, {
      default: withCtx(({ present: v }) => [
        createVNode(unref(Primitive), {
          id: s.value,
          ref: unref(n),
          "as-child": f.asChild,
          as: f.as,
          role: "tabpanel",
          "data-state": u.value ? "active" : "inactive",
          "data-orientation": unref(a).orientation.value,
          "aria-labelledby": o.value,
          hidden: !v,
          tabindex: "0",
          style: normalizeStyle({
            animationDuration: d.value ? "0s" : void 0
          })
        }, {
          default: withCtx(() => [
            !unref(a).unmountOnHide.value || v ? renderSlot(f.$slots, "default", { key: 0 }) : createCommentVNode("", !0)
          ]),
          _: 2
        }, 1032, ["id", "as-child", "as", "data-state", "data-orientation", "aria-labelledby", "hidden", "style"])
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), _sfc_main$1_ = /* @__PURE__ */ defineComponent({
  __name: "TabsIndicator",
  props: {
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectTabsRootContext();
    useForwardExpose();
    const a = ref(), o = ref({
      size: null,
      position: null
    });
    watch(() => [n.modelValue.value, n?.dir.value], async () => {
      await nextTick(), s();
    }, { immediate: !0 }), useResizeObserver([n.tabsList, a], s);
    function s() {
      a.value = n.tabsList.value?.querySelector('[role="tab"][data-state="active"]'), a.value && (n.orientation.value === "horizontal" ? o.value = {
        size: a.value.offsetWidth,
        position: a.value.offsetLeft
      } : o.value = {
        size: a.value.offsetHeight,
        position: a.value.offsetTop
      });
    }
    return (u, d) => typeof o.value.size == "number" ? (openBlock(), createBlock(unref(Primitive), mergeProps({ key: 0 }, t, {
      style: {
        "--reka-tabs-indicator-size": `${o.value.size}px`,
        "--reka-tabs-indicator-position": `${o.value.position}px`
      }
    }), {
      default: withCtx(() => [
        renderSlot(u.$slots, "default")
      ]),
      _: 3
    }, 16, ["style"])) : createCommentVNode("", !0);
  }
}), _sfc_main$1Z = /* @__PURE__ */ defineComponent({
  __name: "TabsList",
  props: {
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, { loop: n } = toRefs(t), { forwardRef: a, currentElement: o } = useForwardExpose(), s = injectTabsRootContext();
    return s.tabsList = o, (u, d) => (openBlock(), createBlock(unref(_sfc_main$44), {
      "as-child": "",
      orientation: unref(s).orientation.value,
      dir: unref(s).dir.value,
      loop: unref(n)
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          ref: unref(a),
          role: "tablist",
          "as-child": u.asChild,
          as: u.as,
          "aria-orientation": unref(s).orientation.value
        }, {
          default: withCtx(() => [
            renderSlot(u.$slots, "default")
          ]),
          _: 3
        }, 8, ["as-child", "as", "aria-orientation"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), _sfc_main$1Y = /* @__PURE__ */ defineComponent({
  __name: "TabsTrigger",
  props: {
    value: {},
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, { forwardRef: n } = useForwardExpose(), a = injectTabsRootContext(), o = computed(() => makeTriggerId(a.baseId, t.value)), s = computed(() => makeContentId(a.baseId, t.value)), u = computed(() => t.value === a.modelValue.value);
    return (d, f) => (openBlock(), createBlock(unref(_sfc_main$40), {
      "as-child": "",
      focusable: !d.disabled,
      active: u.value
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          id: o.value,
          ref: unref(n),
          role: "tab",
          type: d.as === "button" ? "button" : void 0,
          as: d.as,
          "as-child": d.asChild,
          "aria-selected": u.value ? "true" : "false",
          "aria-controls": s.value,
          "data-state": u.value ? "active" : "inactive",
          disabled: d.disabled,
          "data-disabled": d.disabled ? "" : void 0,
          "data-orientation": unref(a).orientation.value,
          onMousedown: f[0] || (f[0] = withModifiers((g) => {
            !d.disabled && g.ctrlKey === !1 ? unref(a).changeModelValue(d.value) : g.preventDefault();
          }, ["left"])),
          onKeydown: f[1] || (f[1] = withKeys((g) => unref(a).changeModelValue(d.value), ["enter", "space"])),
          onFocus: f[2] || (f[2] = () => {
            const g = unref(a).activationMode !== "manual";
            !u.value && !d.disabled && g && unref(a).changeModelValue(d.value);
          })
        }, {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 8, ["id", "type", "as", "as-child", "aria-selected", "aria-controls", "data-state", "disabled", "data-disabled", "data-orientation"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), [injectTimeFieldRootContext, provideTimeFieldRootContext] = createContext$2("TimeFieldRoot");
function convertValue(e, t = $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3($14e0f24ef4ac5c92$export$aa8b41735afcabd2())) {
  return e && "day" in e ? e : $11d87f3f76e88657$export$b21e0b124e224484(t, e);
}
const _sfc_main$1X = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "TimeFieldRoot",
  props: {
    defaultValue: { default: void 0 },
    defaultPlaceholder: {},
    placeholder: { default: void 0 },
    modelValue: {},
    hourCycle: {},
    step: {},
    granularity: {},
    hideTimeZone: { type: Boolean },
    maxValue: {},
    minValue: {},
    locale: {},
    disabled: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 },
    id: {},
    dir: {},
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue", "update:placeholder"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { disabled: s, readonly: u, granularity: d, defaultValue: f, minValue: g, maxValue: v, dir: b, locale: w } = toRefs(a), C = useLocale(w), k = useDirection(b), E = useDateFormatter(C.value, {
      hourCycle: normalizeHourCycle(a.hourCycle)
    }), { primitiveElement: A, currentElement: P } = usePrimitiveElement(), M = ref(/* @__PURE__ */ new Set()), B = computed(() => normalizeDateStep(a)), _ = computed(() => g.value ? convertValue(g.value) : void 0), T = computed(() => v.value ? convertValue(v.value) : void 0);
    onMounted(() => {
      getTimeFieldSegmentElements(P.value).forEach((oe) => M.value.add(oe));
    });
    const O = useVModel(a, "modelValue", o, {
      defaultValue: f.value,
      passive: a.modelValue === void 0
    }), I = computed({
      get() {
        return isNullish$1(O.value) ? O.value : convertValue(O.value);
      },
      set(oe) {
        return oe ? O.value = O.value && "day" in O.value ? oe : new $35ea8db9cb2ccb90$export$680ea196effce5f(oe.hour, oe.minute, oe.second, O.value?.millisecond) : O.value = oe, oe;
      }
    }), q = getDefaultTime({
      defaultPlaceholder: a.placeholder,
      defaultValue: O.value
    }), F = useVModel(a, "placeholder", o, {
      defaultValue: a.defaultPlaceholder ?? q.copy(),
      passive: a.placeholder === void 0
    }), W = computed({
      get() {
        return convertValue(F.value);
      },
      set(oe) {
        return oe && (F.value = "day" in F.value ? oe.copy() : new $35ea8db9cb2ccb90$export$680ea196effce5f(oe.hour, oe.minute, oe.second, F.value?.millisecond)), oe;
      }
    }), K = computed(() => d.value ? d.value : "minute"), Z = computed(() => O.value ? !!(_.value && isBefore(I.value, _.value) || T.value && isBefore(T.value, I.value)) : !1), J = initializeTimeSegmentValues(K.value), re = ref(O.value ? { ...syncTimeSegmentValues({ value: I.value, formatter: E }) } : { ...J }), V = computed(() => createContent({
      granularity: K.value,
      dateRef: W.value,
      formatter: E,
      hideTimeZone: a.hideTimeZone,
      hourCycle: a.hourCycle,
      segmentValues: re.value,
      locale: C,
      isTimeValue: !0
    })), ne = computed(() => V.value.arr), Q = computed(() => ne.value.filter(({ part: oe }) => oe !== "literal"));
    watch(C, (oe) => {
      E.getLocale() !== oe && (E.setLocale(oe), nextTick(() => {
        M.value.clear(), getTimeFieldSegmentElements(P.value).forEach((ye) => M.value.add(ye));
      }));
    }), watch(I, (oe) => {
      !isNullish$1(oe) && (!$14e0f24ef4ac5c92$export$91b62ebf2ba703ee(W.value, oe) || W.value.compare(oe) !== 0) && (F.value = oe.copy());
    }), watch([I, C], ([oe]) => {
      isNullish$1(oe) ? Object.values(re.value).every((ye) => ye !== null) && isNullish$1(oe) && (re.value = { ...J }) : re.value = { ...syncTimeSegmentValues({ value: oe, formatter: E }) };
    });
    const z = ref(null), X = computed(() => Array.from(M.value).findIndex((oe) => oe.getAttribute("data-reka-time-field-segment") === z.value?.getAttribute("data-reka-time-field-segment"))), ue = computed(() => {
      const oe = k.value === "rtl" ? -1 : 1;
      return (oe < 0 ? X.value < 0 : X.value > M.value.size - 1) ? null : Array.from(M.value)[X.value + oe];
    }), Be = computed(() => {
      const oe = k.value === "rtl" ? -1 : 1;
      return (oe > 0 ? X.value < 0 : X.value > M.value.size - 1) ? null : Array.from(M.value)[X.value - oe];
    }), te = useKbd();
    function G(oe) {
      isSegmentNavigationKey(oe.key) && (oe.key === te.ARROW_LEFT && Be.value?.focus(), oe.key === te.ARROW_RIGHT && ue.value?.focus());
    }
    function ie(oe) {
      z.value = oe;
    }
    return provideTimeFieldRootContext({
      locale: C,
      modelValue: I,
      placeholder: W,
      disabled: s,
      formatter: E,
      hourCycle: a.hourCycle,
      step: B,
      readonly: u,
      segmentValues: re,
      isInvalid: Z,
      segmentContents: Q,
      elements: M,
      setFocusedElement: ie,
      focusNext() {
        ue.value?.focus();
      }
    }), t({
      /** Helper to set the focused element inside the DateField */
      setFocusedElement: ie
    }), (oe, ye) => (openBlock(), createBlock(unref(Primitive), mergeProps(oe.$attrs, {
      ref_key: "primitiveElement",
      ref: A,
      role: "group",
      "aria-disabled": unref(s) ? !0 : void 0,
      "data-disabled": unref(s) ? "" : void 0,
      "data-readonly": unref(u) ? "" : void 0,
      "data-invalid": Z.value ? "" : void 0,
      dir: unref(k),
      onKeydown: withKeys(G, ["left", "right"])
    }), {
      default: withCtx(() => [
        renderSlot(oe.$slots, "default", {
          modelValue: unref(O),
          segments: ne.value,
          isInvalid: Z.value
        }),
        createVNode(unref(_sfc_main$4u), {
          id: oe.id,
          as: "input",
          feature: "focusable",
          tabindex: "-1",
          value: unref(O) ? unref(O).toString() : "",
          name: oe.name,
          disabled: unref(s),
          required: oe.required,
          onFocus: ye[0] || (ye[0] = (ve) => Array.from(M.value)?.[0]?.focus())
        }, null, 8, ["id", "value", "name", "disabled", "required"])
      ]),
      _: 3
    }, 16, ["aria-disabled", "data-disabled", "data-readonly", "data-invalid", "dir"]));
  }
}), _sfc_main$1W = /* @__PURE__ */ defineComponent({
  __name: "TimeFieldInput",
  props: {
    part: {},
    asChild: { type: Boolean },
    as: {}
  },
  setup(e) {
    const t = e, n = injectTimeFieldRootContext(), a = ref(!0), o = ref(!1), {
      handleSegmentClick: s,
      handleSegmentKeydown: u,
      attributes: d
    } = useDateField({
      hasLeftFocus: a,
      lastKeyZero: o,
      placeholder: n.placeholder,
      hourCycle: n.hourCycle,
      step: n.step,
      segmentValues: n.segmentValues,
      formatter: n.formatter,
      part: t.part,
      disabled: n.disabled,
      readonly: n.readonly,
      focusNext: n.focusNext,
      modelValue: n.modelValue
    }), f = computed(() => n.disabled.value), g = computed(() => n.readonly.value), v = computed(() => n.isInvalid.value);
    return (b, w) => (openBlock(), createBlock(unref(Primitive), mergeProps({
      as: b.as,
      "as-child": b.asChild
    }, unref(d), {
      contenteditable: f.value || g.value ? !1 : b.part !== "literal",
      "data-reka-time-field-segment": b.part,
      "aria-disabled": f.value ? !0 : void 0,
      "aria-readonly": g.value ? !0 : void 0,
      "data-disabled": f.value ? "" : void 0,
      "data-invalid": v.value ? "" : void 0,
      "aria-invalid": v.value ? !0 : void 0
    }, toHandlers(b.part !== "literal" ? {
      mousedown: unref(s),
      keydown: unref(u),
      focusout: () => {
        a.value = !0;
      },
      focusin: (C) => {
        unref(n).setFocusedElement(C.target);
      }
    } : {})), {
      default: withCtx(() => [
        renderSlot(b.$slots, "default")
      ]),
      _: 3
    }, 16, ["as", "as-child", "contenteditable", "data-reka-time-field-segment", "aria-disabled", "aria-readonly", "data-disabled", "data-invalid", "aria-invalid"]));
  }
}), [injectToggleGroupRootContext, provideToggleGroupRootContext] = createContext$2("ToggleGroupRoot"), _sfc_main$1V = /* @__PURE__ */ defineComponent({
  __name: "ToggleGroupRoot",
  props: {
    rovingFocus: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    orientation: {},
    dir: {},
    loop: { type: Boolean, default: !0 },
    asChild: { type: Boolean },
    as: {},
    name: {},
    required: { type: Boolean },
    type: {},
    modelValue: {},
    defaultValue: {}
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { loop: o, rovingFocus: s, disabled: u, dir: d } = toRefs(n), f = useDirection(d), { forwardRef: g, currentElement: v } = useForwardExpose(), { modelValue: b, changeModelValue: w, isSingle: C } = useSingleOrMultipleValue(n, a), k = useFormControl(v);
    return provideToggleGroupRootContext({
      isSingle: C,
      modelValue: b,
      changeModelValue: w,
      dir: f,
      orientation: n.orientation,
      loop: o,
      rovingFocus: s,
      disabled: u
    }), (E, A) => (openBlock(), createBlock(resolveDynamicComponent(unref(s) ? unref(_sfc_main$44) : unref(Primitive)), {
      "as-child": "",
      orientation: unref(s) ? E.orientation : void 0,
      dir: unref(f),
      loop: unref(s) ? unref(o) : void 0
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), {
          ref: unref(g),
          role: "group",
          "as-child": E.asChild,
          as: E.as
        }, {
          default: withCtx(() => [
            renderSlot(E.$slots, "default", { modelValue: unref(b) }),
            unref(k) && E.name ? (openBlock(), createBlock(_sfc_main$42, {
              key: 0,
              name: E.name,
              required: E.required,
              value: unref(b)
            }, null, 8, ["name", "required", "value"])) : createCommentVNode("", !0)
          ]),
          _: 3
        }, 8, ["as-child", "as"])
      ]),
      _: 3
    }, 8, ["orientation", "dir", "loop"]));
  }
}), _sfc_main$1U = /* @__PURE__ */ defineComponent({
  __name: "Toggle",
  props: {
    defaultValue: { type: Boolean },
    modelValue: { type: [Boolean, null], default: void 0 },
    disabled: { type: Boolean, default: !1 },
    asChild: { type: Boolean },
    as: { default: "button" },
    name: {},
    required: { type: Boolean }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, { forwardRef: o, currentElement: s } = useForwardExpose(), u = injectToggleGroupRootContext(null), d = useVModel(n, "modelValue", a, {
      defaultValue: n.defaultValue,
      passive: n.modelValue === void 0
    });
    function f() {
      d.value = !d.value;
    }
    const g = computed(() => d.value ? "on" : "off"), v = useFormControl(s);
    return (b, w) => (openBlock(), createBlock(unref(Primitive), {
      ref: unref(o),
      type: b.as === "button" ? "button" : void 0,
      "as-child": n.asChild,
      as: b.as,
      "aria-pressed": unref(d),
      "data-state": g.value,
      "data-disabled": b.disabled ? "" : void 0,
      disabled: b.disabled,
      onClick: f
    }, {
      default: withCtx(() => [
        renderSlot(b.$slots, "default", {
          modelValue: unref(d),
          disabled: b.disabled,
          pressed: unref(d),
          state: g.value
        }),
        unref(v) && b.name && !unref(u) ? (openBlock(), createBlock(_sfc_main$42, {
          key: 0,
          type: "checkbox",
          name: b.name,
          value: unref(d),
          required: b.required
        }, null, 8, ["name", "value", "required"])) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["type", "as-child", "as", "aria-pressed", "data-state", "data-disabled", "disabled"]));
  }
}), _sfc_main$1T = /* @__PURE__ */ defineComponent({
  __name: "ToggleGroupItem",
  props: {
    value: {},
    disabled: { type: Boolean },
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = injectToggleGroupRootContext(), a = computed(() => n.disabled?.value || t.disabled), o = computed(() => isValueEqualOrExist(n.modelValue.value, t.value)), { forwardRef: s } = useForwardExpose();
    return (u, d) => (openBlock(), createBlock(resolveDynamicComponent(unref(n).rovingFocus.value ? unref(_sfc_main$40) : unref(Primitive)), {
      "as-child": "",
      focusable: !a.value,
      active: o.value
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$1U), mergeProps(t, {
          ref: unref(s),
          disabled: a.value,
          "model-value": o.value,
          "onUpdate:modelValue": d[0] || (d[0] = (f) => unref(n).changeModelValue(u.value))
        }), {
          default: withCtx((f) => [
            renderSlot(u.$slots, "default", normalizeProps(guardReactiveProps(f)))
          ]),
          _: 3
        }, 16, ["disabled", "model-value"])
      ]),
      _: 3
    }, 8, ["focusable", "active"]));
  }
}), _sfc_main$1S = /* @__PURE__ */ defineComponent({
  __name: "TooltipArrow",
  props: {
    width: { default: 10 },
    height: { default: 5 },
    asChild: { type: Boolean },
    as: { default: "svg" }
  },
  setup(e) {
    const t = e;
    return useForwardExpose(), (n, a) => (openBlock(), createBlock(unref(_sfc_main$3U), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), TOOLTIP_OPEN = "tooltip.open", [injectTooltipProviderContext, provideTooltipProviderContext] = createContext$2("TooltipProvider"), _sfc_main$1R = /* @__PURE__ */ defineComponent({
  inheritAttrs: !1,
  __name: "TooltipProvider",
  props: {
    delayDuration: { default: 700 },
    skipDelayDuration: { default: 300 },
    disableHoverableContent: { type: Boolean, default: !1 },
    disableClosingTrigger: { type: Boolean },
    disabled: { type: Boolean },
    ignoreNonKeyboardFocus: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, { delayDuration: n, skipDelayDuration: a, disableHoverableContent: o, disableClosingTrigger: s, ignoreNonKeyboardFocus: u, disabled: d } = toRefs(t);
    useForwardExpose();
    const f = ref(!0), g = ref(!1), { start: v, stop: b } = useTimeoutFn(() => {
      f.value = !0;
    }, a, { immediate: !1 });
    return provideTooltipProviderContext({
      isOpenDelayed: f,
      delayDuration: n,
      onOpen() {
        b(), f.value = !1;
      },
      onClose() {
        v();
      },
      isPointerInTransitRef: g,
      disableHoverableContent: o,
      disableClosingTrigger: s,
      disabled: d,
      ignoreNonKeyboardFocus: u
    }), (w, C) => renderSlot(w.$slots, "default");
  }
}), [injectTooltipRootContext, provideTooltipRootContext] = createContext$2("TooltipRoot"), _sfc_main$1Q = /* @__PURE__ */ defineComponent({
  __name: "TooltipRoot",
  props: {
    defaultOpen: { type: Boolean, default: !1 },
    open: { type: Boolean, default: void 0 },
    delayDuration: { default: void 0 },
    disableHoverableContent: { type: Boolean, default: void 0 },
    disableClosingTrigger: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: void 0 },
    ignoreNonKeyboardFocus: { type: Boolean, default: void 0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = e, a = t;
    useForwardExpose();
    const o = injectTooltipProviderContext(), s = computed(() => n.disableHoverableContent ?? o.disableHoverableContent.value), u = computed(() => n.disableClosingTrigger ?? o.disableClosingTrigger.value), d = computed(() => n.disabled ?? o.disabled.value), f = computed(() => n.delayDuration ?? o.delayDuration.value), g = computed(() => n.ignoreNonKeyboardFocus ?? o.ignoreNonKeyboardFocus.value), v = useVModel(n, "open", a, {
      defaultValue: n.defaultOpen,
      passive: n.open === void 0
    });
    watch(v, (B) => {
      o.onClose && (B ? (o.onOpen(), document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))) : o.onClose());
    });
    const b = ref(!1), w = ref(), C = computed(() => v.value ? b.value ? "delayed-open" : "instant-open" : "closed"), { start: k, stop: E } = useTimeoutFn(() => {
      b.value = !0, v.value = !0;
    }, f, { immediate: !1 });
    function A() {
      E(), b.value = !1, v.value = !0;
    }
    function P() {
      E(), v.value = !1;
    }
    function M() {
      k();
    }
    return provideTooltipRootContext({
      contentId: "",
      open: v,
      stateAttribute: C,
      trigger: w,
      onTriggerChange(B) {
        w.value = B;
      },
      onTriggerEnter() {
        o.isOpenDelayed.value ? M() : A();
      },
      onTriggerLeave() {
        s.value ? P() : E();
      },
      onOpen: A,
      onClose: P,
      disableHoverableContent: s,
      disableClosingTrigger: u,
      disabled: d,
      ignoreNonKeyboardFocus: g
    }), (B, _) => (openBlock(), createBlock(unref(_sfc_main$3Z), null, {
      default: withCtx(() => [
        renderSlot(B.$slots, "default", { open: unref(v) })
      ]),
      _: 3
    }));
  }
}), _sfc_main$1P = /* @__PURE__ */ defineComponent({
  __name: "TooltipContentImpl",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: { default: 0 },
    align: { default: "center" },
    alignOffset: {},
    avoidCollisions: { type: Boolean, default: !0 },
    collisionBoundary: { default: () => [] },
    collisionPadding: { default: 0 },
    arrowPadding: { default: 0 },
    sticky: { default: "partial" },
    hideWhenDetached: { type: Boolean, default: !1 },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectTooltipRootContext(), { forwardRef: s } = useForwardExpose(), u = useSlots(), d = computed(() => u.default?.({})), f = computed(() => {
      if (n.ariaLabel)
        return n.ariaLabel;
      let v = "";
      function b(w) {
        typeof w.children == "string" && w.type !== Comment ? v += w.children : Array.isArray(w.children) && w.children.forEach((C) => b(C));
      }
      return d.value?.forEach((w) => b(w)), v;
    }), g = computed(() => {
      const { ariaLabel: v, ...b } = n;
      return b;
    });
    return onMounted(() => {
      useEventListener(window, "scroll", (v) => {
        v.target?.contains(o.trigger.value) && o.onClose();
      }), useEventListener(window, TOOLTIP_OPEN, o.onClose);
    }), (v, b) => (openBlock(), createBlock(unref(_sfc_main$4q), {
      "as-child": "",
      "disable-outside-pointer-events": !1,
      onEscapeKeyDown: b[0] || (b[0] = (w) => a("escapeKeyDown", w)),
      onPointerDownOutside: b[1] || (b[1] = (w) => {
        unref(o).disableClosingTrigger.value && unref(o).trigger.value?.contains(w.target) && w.preventDefault(), a("pointerDownOutside", w);
      }),
      onFocusOutside: b[2] || (b[2] = withModifiers(() => {
      }, ["prevent"])),
      onDismiss: b[3] || (b[3] = (w) => unref(o).onClose())
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$3V), mergeProps({
          ref: unref(s),
          "data-state": unref(o).stateAttribute.value
        }, { ...v.$attrs, ...g.value }, { style: {
          "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)",
          "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)",
          "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)",
          "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)",
          "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)"
        } }), {
          default: withCtx(() => [
            renderSlot(v.$slots, "default"),
            createVNode(unref(_sfc_main$4u), {
              id: unref(o).contentId,
              role: "tooltip"
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(f.value), 1)
              ]),
              _: 1
            }, 8, ["id"])
          ]),
          _: 3
        }, 16, ["data-state"])
      ]),
      _: 3
    }));
  }
}), _sfc_main$1O = /* @__PURE__ */ defineComponent({
  __name: "TooltipContentHoverable",
  props: {
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: {},
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  setup(e) {
    const n = useForwardProps(e), { forwardRef: a, currentElement: o } = useForwardExpose(), { trigger: s, onClose: u } = injectTooltipRootContext(), d = injectTooltipProviderContext(), { isPointerInTransit: f, onPointerExit: g } = useGraceArea(s, o);
    return d.isPointerInTransitRef = f, g(() => {
      u();
    }), (v, b) => (openBlock(), createBlock(_sfc_main$1P, mergeProps({ ref: unref(a) }, unref(n)), {
      default: withCtx(() => [
        renderSlot(v.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$1N = /* @__PURE__ */ defineComponent({
  __name: "TooltipContent",
  props: {
    forceMount: { type: Boolean },
    ariaLabel: {},
    asChild: { type: Boolean },
    as: {},
    side: { default: "top" },
    sideOffset: {},
    align: {},
    alignOffset: {},
    avoidCollisions: { type: Boolean },
    collisionBoundary: {},
    collisionPadding: {},
    arrowPadding: {},
    sticky: {},
    hideWhenDetached: { type: Boolean },
    positionStrategy: {},
    updatePositionStrategy: {}
  },
  emits: ["escapeKeyDown", "pointerDownOutside"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = injectTooltipRootContext(), s = useForwardPropsEmits(n, a), { forwardRef: u } = useForwardExpose();
    return (d, f) => (openBlock(), createBlock(unref(Presence), {
      present: d.forceMount || unref(o).open.value
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(unref(o).disableHoverableContent.value ? _sfc_main$1P : _sfc_main$1O), mergeProps({ ref: unref(u) }, unref(s)), {
          default: withCtx(() => [
            renderSlot(d.$slots, "default")
          ]),
          _: 3
        }, 16))
      ]),
      _: 3
    }, 8, ["present"]));
  }
}), _sfc_main$1M = /* @__PURE__ */ defineComponent({
  __name: "TooltipPortal",
  props: {
    to: {},
    disabled: { type: Boolean },
    defer: { type: Boolean },
    forceMount: { type: Boolean }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$4j), normalizeProps(guardReactiveProps(t)), {
      default: withCtx(() => [
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), _sfc_main$1L = /* @__PURE__ */ defineComponent({
  __name: "TooltipTrigger",
  props: {
    reference: {},
    asChild: { type: Boolean },
    as: { default: "button" }
  },
  setup(e) {
    const t = e, n = injectTooltipRootContext(), a = injectTooltipProviderContext();
    n.contentId ||= useId(void 0, "reka-tooltip-content");
    const { forwardRef: o, currentElement: s } = useForwardExpose(), u = ref(!1), d = ref(!1), f = computed(() => n.disabled.value ? {} : {
      click: E,
      focus: C,
      pointermove: b,
      pointerleave: w,
      pointerdown: v,
      blur: k
    });
    onMounted(() => {
      n.onTriggerChange(s.value);
    });
    function g() {
      setTimeout(() => {
        u.value = !1;
      }, 1);
    }
    function v() {
      n.open && !n.disableClosingTrigger.value && n.onClose(), u.value = !0, document.addEventListener("pointerup", g, { once: !0 });
    }
    function b(A) {
      A.pointerType !== "touch" && !d.value && !a.isPointerInTransitRef.value && (n.onTriggerEnter(), d.value = !0);
    }
    function w() {
      n.onTriggerLeave(), d.value = !1;
    }
    function C(A) {
      u.value || n.ignoreNonKeyboardFocus.value && !A.target.matches?.(":focus-visible") || n.onOpen();
    }
    function k() {
      n.onClose();
    }
    function E() {
      n.disableClosingTrigger.value || n.onClose();
    }
    return (A, P) => (openBlock(), createBlock(unref(_sfc_main$3Y), {
      "as-child": "",
      reference: A.reference
    }, {
      default: withCtx(() => [
        createVNode(unref(Primitive), mergeProps({
          ref: unref(o),
          "aria-describedby": unref(n).open.value ? unref(n).contentId : void 0,
          "data-state": unref(n).stateAttribute.value,
          as: A.as,
          "as-child": t.asChild,
          "data-grace-area-trigger": ""
        }, toHandlers(f.value)), {
          default: withCtx(() => [
            renderSlot(A.$slots, "default")
          ]),
          _: 3
        }, 16, ["aria-describedby", "data-state", "as", "as-child"])
      ]),
      _: 3
    }, 8, ["reference"]));
  }
}), _sfc_main$1K = /* @__PURE__ */ Object.assign({ name: "Calendar" }, {
  __name: "Calendar",
  props: {
    modelValue: { type: [String, Object], default: null },
    min: { type: [String, Object], default: null },
    max: { type: [String, Object], default: null },
    components: { type: Object, default: () => ({}) },
    numberOfMonths: { type: Number, default: 1 },
    inline: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = computed(() => ({
      CalendarRoot: n.components.Root || _sfc_main$4g,
      CalendarHeader: n.components.Header || _sfc_main$48,
      CalendarHeading: n.components.Heading || _sfc_main$47,
      CalendarPrev: n.components.Prev || _sfc_main$45,
      CalendarNext: n.components.Next || _sfc_main$46,
      CalendarGrid: n.components.Grid || _sfc_main$4d,
      CalendarGridHead: n.components.GridHead || _sfc_main$4b,
      CalendarGridBody: n.components.GridBody || _sfc_main$4c,
      CalendarGridRow: n.components.GridRow || _sfc_main$4a,
      CalendarHeadCell: n.components.HeadCell || _sfc_main$49,
      CalendarCell: n.components.Cell || _sfc_main$4f,
      CalendarCellTrigger: n.components.CellTrigger || _sfc_main$4e
    })), o = t, s = computed(
      () => n.min ? typeof n.min == "string" ? $fae977aafc393c5c$export$5adfdab05168c219(n.min) : n.min : null
    ), u = computed(
      () => n.max ? typeof n.max == "string" ? $fae977aafc393c5c$export$5adfdab05168c219(n.max) : n.max : null
    ), d = computed(() => {
      const f = n.numberOfMonths;
      return f <= 2 ? {
        "grid-template-columns": `repeat(${f}, minmax(250px, 1fr))`,
        "grid-template-rows": "auto"
      } : {
        "grid-template-columns": "repeat(auto-fit, minmax(250px, 1fr))",
        "grid-template-rows": "auto"
      };
    });
    return (f, g) => {
      const v = resolveComponent("ui-badge");
      return openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarRoot), {
        "model-value": e.modelValue,
        minValue: s.value,
        maxValue: u.value,
        locale: f.$date.locale,
        "fixed-weeks": "",
        "number-of-months": e.inline ? e.numberOfMonths : 1,
        "onUpdate:modelValue": g[0] || (g[0] = (b) => o("update:modelValue", b))
      }, {
        default: withCtx(({ weekDays: b, grid: w }) => [
          (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarHeader), { class: "flex items-center justify-between" }, {
            default: withCtx(() => [
              (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarHeading), { class: "text-sm font-medium text-black dark:text-white" })),
              createElementVNode("div", null, [
                (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarPrev), { class: "inline-flex size-8 cursor-pointer items-center justify-center rounded-md hover:bg-gray-50 active:scale-90 dark:hover:bg-gray-950" }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$1a), {
                      name: "ui/chevron-left",
                      class: "size-4"
                    })
                  ]),
                  _: 1
                })),
                (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarNext), { class: "inline-flex size-8 cursor-pointer items-center justify-center rounded-md hover:bg-gray-50 active:scale-90 dark:hover:bg-gray-950" }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$1a), {
                      name: "ui/chevron-right",
                      class: "size-4"
                    })
                  ]),
                  _: 1
                }))
              ])
            ]),
            _: 1
          })),
          createElementVNode("div", {
            class: "grid gap-8",
            style: normalizeStyle(d.value)
          }, [
            (openBlock(!0), createElementBlock(Fragment, null, renderList(w, (C) => (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarGrid), {
              key: C.value.toString(),
              class: "w-full border-collapse space-y-1 select-none"
            }, {
              default: withCtx(() => [
                (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarGridHead), null, {
                  default: withCtx(() => [
                    e.inline && e.numberOfMonths > 1 ? (openBlock(), createBlock(v, {
                      key: 0,
                      variant: "flat",
                      class: "mb-2"
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(new Date(C.value.toString()).toLocaleString(f.$date.locale, { month: "long" })), 1)
                      ]),
                      _: 2
                    }, 1024)) : createCommentVNode("", !0),
                    (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarGridRow), { class: "mb-1 grid w-full grid-cols-7" }, {
                      default: withCtx(() => [
                        (openBlock(!0), createElementBlock(Fragment, null, renderList(b, (k) => (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarHeadCell), {
                          key: k,
                          class: "rounded-md text-xs text-black dark:text-white"
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(k), 1)
                          ]),
                          _: 2
                        }, 1024))), 128))
                      ]),
                      _: 2
                    }, 1024))
                  ]),
                  _: 2
                }, 1024)),
                (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarGridBody), { class: "grid space-y-1" }, {
                  default: withCtx(() => [
                    (openBlock(!0), createElementBlock(Fragment, null, renderList(C.rows, (k, E) => (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarGridRow), {
                      key: `weekDate-${E}`,
                      class: "grid grid-cols-7"
                    }, {
                      default: withCtx(() => [
                        (openBlock(!0), createElementBlock(Fragment, null, renderList(k, (A) => (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarCell), {
                          key: A.toString(),
                          date: A,
                          class: "relative flex justify-center text-sm"
                        }, {
                          default: withCtx(() => [
                            (openBlock(), createBlock(resolveDynamicComponent(a.value.CalendarCellTrigger), {
                              day: A,
                              month: C.value,
                              class: normalizeClass([
                                "relative flex size-8 items-center justify-center rounded-lg text-sm font-normal whitespace-nowrap text-black outline-hidden dark:text-white",
                                "data-outside-view:text-gray-400 dark:data-outside-view:text-gray-600",
                                "data-selected:bg-gray-800! data-selected:text-white dark:data-selected:bg-gray-200! dark:data-selected:text-black",
                                "hover:bg-gray-100 data-highlighted:bg-gray-200 dark:hover:bg-black dark:data-highlighted:bg-black",
                                "data-disabled:pointer-events-none data-disabled:hover:bg-transparent",
                                "data-disabled:text-gray-400 dark:data-disabled:text-gray-600",
                                "data-unavailable:pointer-events-none data-unavailable:text-black/30 data-unavailable:line-through",
                                "before:absolute before:top-[3px] before:hidden before:h-1 before:w-1 before:rounded-lg before:bg-white",
                                "data-today:before:block data-today:before:bg-green-600"
                              ])
                            }, null, 8, ["day", "month"]))
                          ]),
                          _: 2
                        }, 1032, ["date"]))), 128))
                      ]),
                      _: 2
                    }, 1024))), 128))
                  ]),
                  _: 2
                }, 1024))
              ]),
              _: 2
            }, 1024))), 128))
          ], 4)
        ]),
        _: 1
      }, 8, ["model-value", "minValue", "maxValue", "locale", "number-of-months"]);
    };
  }
}), _hoisted_1$11 = ["data-inset"], _sfc_main$1J = {
  __name: "Card",
  props: {
    inset: { type: Boolean, default: !1 },
    variant: { type: String, default: "default" }
  },
  setup(e) {
    const t = e, n = cva({
      base: "bg-white dark:bg-gray-800 rounded-xl ring ring-gray-200 dark:ring-x-0 dark:ring-b-0 dark:ring-gray-700",
      variants: {
        variant: {
          default: "shadow-ui-md",
          flat: "shadow-none"
        },
        inset: { false: "px-4.5 py-5 space-y-2" }
      }
    })({ ...t });
    return (a, o) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(n)),
      "data-ui-card": "",
      "data-inset": e.inset
    }, [
      renderSlot(a.$slots, "default")
    ], 10, _hoisted_1$11));
  }
}, _sfc_main$1I = {
  __name: "List",
  props: {
    heading: { type: String, default: null },
    subheading: { type: String, default: null }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$A), null, {
      default: withCtx(() => [
        e.heading ? (openBlock(), createBlock(unref(_sfc_main$y), { key: 0 }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$1b), { innerHTML: e.heading }, null, 8, ["innerHTML"]),
            e.subheading ? (openBlock(), createBlock(unref(_sfc_main$i), {
              key: 0,
              innerHTML: e.subheading
            }, null, 8, ["innerHTML"])) : createCommentVNode("", !0)
          ]),
          _: 1
        })) : createCommentVNode("", !0),
        createVNode(unref(_sfc_main$1J), {
          inset: "",
          class: "divide-y divide-gray-200 dark:divide-gray-950"
        }, {
          default: withCtx(() => [
            renderSlot(t.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}, _sfc_main$1H = {}, _hoisted_1$10 = { class: "flex items-center justify-between py-3 px-5" };
function _sfc_render$d(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$10, [
    renderSlot(e.$slots, "default")
  ]);
}
const ListItem = /* @__PURE__ */ _export_sfc(_sfc_main$1H, [["render", _sfc_render$d]]), _sfc_main$1G = {
  __name: "Panel",
  props: {
    heading: { type: String, default: null },
    subheading: { type: String, default: null }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$A), null, {
      default: withCtx(() => [
        e.heading ? (openBlock(), createBlock(unref(_sfc_main$y), { key: 0 }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$1b), { innerHTML: e.heading }, null, 8, ["innerHTML"]),
            e.subheading ? (openBlock(), createBlock(unref(_sfc_main$i), {
              key: 0,
              innerHTML: e.subheading
            }, null, 8, ["innerHTML"])) : createCommentVNode("", !0)
          ]),
          _: 1
        })) : createCommentVNode("", !0),
        createVNode(unref(_sfc_main$1J), null, {
          default: withCtx(() => [
            renderSlot(t.$slots, "default")
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}, _hoisted_1$$ = ["stroke-dashoffset"], _hoisted_2$C = {
  key: 0,
  x1: "20",
  y1: "20",
  x2: "80",
  y2: "80",
  stroke: "currentColor",
  "stroke-width": "8"
}, _hoisted_3$j = {
  key: 0,
  class: "text-2xs absolute z-10 text-red-600"
}, _sfc_main$1F = {
  __name: "CharacterCounter",
  props: {
    text: { type: String, default: "" },
    limit: { type: Number, default: null },
    dangerZone: { type: Number, default: 20 }
  },
  emits: ["update:text"],
  setup(e, { emit: t }) {
    const n = e, a = computed(() => n.text?.length || 0), o = computed(() => n.limit - a.value), s = computed(() => o.value < 0), u = computed(() => o.value <= n.dangerZone && o.value > 0), d = computed(() => o.value <= 0), f = computed(() => a.value + "/" + n.limit), g = computed(() => d.value ? 100 : a.value / n.limit * 100), v = ref(!1), b = ref(a.value);
    watch(
      () => a.value,
      (C, k) => {
        const E = k !== n.limit, A = C === n.limit;
        E && A && (v.value = !0, setTimeout(() => {
          v.value = !1;
        }, 275)), b.value = C;
      }
    );
    const w = cva({
      base: "absolute h-full w-full",
      variants: {
        color: {
          green: "text-green-500",
          amber: "text-amber-500",
          red: "text-red-600",
          gray: "text-gray-200 dark:text-gray-700"
        }
      }
    });
    return (C, k) => (openBlock(), createBlock(unref(_sfc_main$2), {
      text: f.value,
      position: "top",
      "delay-duration": "0"
    }, {
      default: withCtx(() => [
        createElementVNode("div", {
          class: normalizeClass(["relative flex size-6 items-center justify-center", { "animate-pop": v.value }])
        }, [
          (openBlock(), createElementBlock("svg", {
            class: normalizeClass(unref(w)({ color: "gray" })),
            viewBox: "0 0 100 100"
          }, [...k[0] || (k[0] = [
            createElementVNode("circle", {
              cx: "50",
              cy: "50",
              r: "40",
              fill: "none",
              stroke: "currentColor",
              "stroke-width": "8"
            }, null, -1)
          ])], 2)),
          (openBlock(), createElementBlock("svg", {
            class: normalizeClass(
              unref(w)({
                color: s.value ? "red" : g.value < 70 ? "green" : g.value < 90 ? "amber" : "red"
              }) + " -rotate-90"
            ),
            viewBox: "0 0 100 100"
          }, [
            createElementVNode("circle", {
              cx: "50",
              cy: "50",
              r: "40",
              fill: "none",
              stroke: "currentColor",
              "stroke-width": "8",
              "stroke-dasharray": "251.2",
              "stroke-dashoffset": 251.2 - 251.2 * g.value / 100,
              "stroke-linecap": "round"
            }, null, 8, _hoisted_1$$),
            s.value ? (openBlock(), createElementBlock("line", _hoisted_2$C)) : createCommentVNode("", !0)
          ], 2)),
          u.value ? (openBlock(), createElementBlock("span", _hoisted_3$j, toDisplayString(o.value), 1)) : createCommentVNode("", !0)
        ], 2)
      ]),
      _: 1
    }, 8, ["text"]));
  }
}, CharacterCounter = /* @__PURE__ */ _export_sfc(_sfc_main$1F, [["__scopeId", "data-v-58407b74"]]), _hoisted_1$_ = { class: "sr-only" }, _hoisted_2$B = {
  key: 0,
  class: "flex flex-col"
}, _hoisted_3$i = ["for"], _hoisted_4$c = ["id"], _sfc_main$1E = {
  __name: "Item",
  props: {
    align: { type: String, default: "start", validator: (e) => ["start", "center"].includes(e) },
    description: { type: String, default: null },
    disabled: { type: Boolean, default: !1 },
    label: { type: String, default: null },
    modelValue: { type: [Boolean, null], default: null },
    name: { type: String, default: null },
    readOnly: { type: Boolean, default: !1 },
    size: { type: String, default: "base" },
    solo: { type: Boolean, default: !1 },
    tabindex: { type: Number, default: null },
    value: { type: [String, Number, Boolean], required: !0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = useId(), s = computed(() => cva({
      base: [
        "shadow-ui-xs mt-0.5 cursor-default rounded-sm border border-gray-400/75 bg-white",
        "dark:bg-gray-400 dark:border-gray-900",
        "data-[state=checked]:border-ui-accent data-[state=checked]:bg-ui-accent",
        "dark:border-none dark:data-[state=checked]:bg-dark-ui-accent dark:data-[state=checked]:border-dark-ui-accent",
        "dark:data-[disabled]:bg-dark-ui-accent/60 dark:data-[disabled]:border-dark-ui-accent/70",
        "dark:data-[disabled]:text-gray-400 dark:data-[disabled]:cursor-not-allowed",
        "shrink-0"
      ],
      variants: {
        size: {
          sm: "size-3.75",
          base: "size-4"
        }
      }
    })({ ...n })), u = computed(() => cva({
      base: "flex gap-2",
      variants: {
        align: {
          start: "items-start",
          center: "items-center"
        }
      }
    })({ ...n })), d = computed(() => {
      const f = {};
      return n.modelValue !== null && (f.modelValue = n.modelValue), n.description && !n.solo && (f["aria-describedby"] = `${o}-description`), n.solo && (n.label || n.value) && (f["aria-label"] = n.label || n.value), f;
    });
    return (f, g) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(u.value)
    }, [
      createVNode(unref(_sfc_main$3$), mergeProps({
        disabled: e.readOnly || e.disabled,
        id: unref(o),
        name: e.name,
        value: e.value
      }, d.value, {
        "onUpdate:modelValue": g[0] || (g[0] = (v) => a("update:modelValue", v)),
        class: s.value,
        tabindex: e.tabindex
      }), {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$3_), { class: "relative flex h-full w-full items-center justify-center text-white" }, {
            default: withCtx(() => [...g[1] || (g[1] = [
              createElementVNode("svg", {
                viewBox: "0 0 10 8",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                class: "size-2.5",
                "aria-hidden": "true"
              }, [
                createElementVNode("path", {
                  d: "M9 1L3.5 6.5L1 4",
                  stroke: "currentColor",
                  "stroke-width": "1.5",
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round"
                })
              ], -1)
            ])]),
            _: 1
          }),
          createElementVNode("span", _hoisted_1$_, toDisplayString(e.modelValue ? "Checked" : "Unchecked"), 1)
        ]),
        _: 1
      }, 16, ["disabled", "id", "name", "value", "class", "tabindex"]),
      e.solo ? createCommentVNode("", !0) : (openBlock(), createElementBlock("div", _hoisted_2$B, [
        createElementVNode("label", {
          class: "text-sm font-normal antialiased",
          for: unref(o)
        }, [
          renderSlot(f.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(e.label || e.value), 1)
          ])
        ], 8, _hoisted_3$i),
        e.description ? (openBlock(), createElementBlock("p", {
          key: 0,
          id: `${unref(o)}-description`,
          class: "mt-0.5 block text-xs leading-snug text-gray-500 dark:text-gray-200"
        }, toDisplayString(e.description), 9, _hoisted_4$c)) : createCommentVNode("", !0)
      ]))
    ], 2));
  }
}, _sfc_main$1D = {
  __name: "Group",
  props: {
    inline: { type: Boolean, default: !1 },
    modelValue: { type: Array, default: () => [] },
    name: { type: String, default: () => useId$1() },
    required: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t }) {
    return t({ focus: function() {
      console.log("focusing. todo.");
    } }), (a, o) => (openBlock(), createBlock(unref(_sfc_main$41), {
      modelValue: e.modelValue,
      "onUpdate:modelValue": o[0] || (o[0] = (s) => a.$emit("update:modelValue", s)),
      name: e.name,
      class: normalizeClass(["relative block w-full space-y-2", { "flex flex-wrap space-y-0 gap-x-4 gap-y-2": e.inline }]),
      "data-ui-input": ""
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["modelValue", "name", "class"]));
  }
};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function getAugmentedNamespace(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function a() {
      var o = !1;
      try {
        o = this instanceof a;
      } catch {
      }
      return o ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(a) {
    var o = Object.getOwnPropertyDescriptor(e, a);
    Object.defineProperty(n, a, o.get ? o : {
      enumerable: !0,
      get: function() {
        return e[a];
      }
    });
  }), n;
}
var codemirror$1 = { exports: {} }, codemirror = codemirror$1.exports, hasRequiredCodemirror;
function requireCodemirror() {
  return hasRequiredCodemirror || (hasRequiredCodemirror = 1, (function(e, t) {
    (function(n, a) {
      e.exports = a();
    })(codemirror, (function() {
      var n = navigator.userAgent, a = navigator.platform, o = /gecko\/\d/i.test(n), s = /MSIE \d/.test(n), u = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(n), d = /Edge\/(\d+)/.exec(n), f = s || u || d, g = f && (s ? document.documentMode || 6 : +(d || u)[1]), v = !d && /WebKit\//.test(n), b = v && /Qt\/\d+\.\d+/.test(n), w = !d && /Chrome\/(\d+)/.exec(n), C = w && +w[1], k = /Opera\//.test(n), E = /Apple Computer/.test(navigator.vendor), A = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(n), P = /PhantomJS/.test(n), M = E && (/Mobile\/\w+/.test(n) || navigator.maxTouchPoints > 2), B = /Android/.test(n), _ = M || B || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(n), T = M || /Mac/.test(a), O = /\bCrOS\b/.test(n), I = /win/i.test(a), q = k && n.match(/Version\/(\d*\.\d*)/);
      q && (q = Number(q[1])), q && q >= 15 && (k = !1, v = !0);
      var F = T && (b || k && (q == null || q < 12.11)), W = o || f && g >= 9;
      function K(i) {
        return new RegExp("(^|\\s)" + i + "(?:$|\\s)\\s*");
      }
      var Z = function(i, l) {
        var m = i.className, p = K(l).exec(m);
        if (p) {
          var y = m.slice(p.index + p[0].length);
          i.className = m.slice(0, p.index) + (y ? p[1] + y : "");
        }
      };
      function J(i) {
        for (var l = i.childNodes.length; l > 0; --l)
          i.removeChild(i.firstChild);
        return i;
      }
      function re(i, l) {
        return J(i).appendChild(l);
      }
      function V(i, l, m, p) {
        var y = document.createElement(i);
        if (m && (y.className = m), p && (y.style.cssText = p), typeof l == "string")
          y.appendChild(document.createTextNode(l));
        else if (l)
          for (var S = 0; S < l.length; ++S)
            y.appendChild(l[S]);
        return y;
      }
      function ne(i, l, m, p) {
        var y = V(i, l, m, p);
        return y.setAttribute("role", "presentation"), y;
      }
      var Q;
      document.createRange ? Q = function(i, l, m, p) {
        var y = document.createRange();
        return y.setEnd(p || i, m), y.setStart(i, l), y;
      } : Q = function(i, l, m) {
        var p = document.body.createTextRange();
        try {
          p.moveToElementText(i.parentNode);
        } catch {
          return p;
        }
        return p.collapse(!0), p.moveEnd("character", m), p.moveStart("character", l), p;
      };
      function z(i, l) {
        if (l.nodeType == 3 && (l = l.parentNode), i.contains)
          return i.contains(l);
        do
          if (l.nodeType == 11 && (l = l.host), l == i)
            return !0;
        while (l = l.parentNode);
      }
      function X(i) {
        var l;
        try {
          l = i.activeElement;
        } catch {
          l = i.body || null;
        }
        for (; l && l.shadowRoot && l.shadowRoot.activeElement; )
          l = l.shadowRoot.activeElement;
        return l;
      }
      function ue(i, l) {
        var m = i.className;
        K(l).test(m) || (i.className += (m ? " " : "") + l);
      }
      function Be(i, l) {
        for (var m = i.split(" "), p = 0; p < m.length; p++)
          m[p] && !K(m[p]).test(l) && (l += " " + m[p]);
        return l;
      }
      var te = function(i) {
        i.select();
      };
      M ? te = function(i) {
        i.selectionStart = 0, i.selectionEnd = i.value.length;
      } : f && (te = function(i) {
        try {
          i.select();
        } catch {
        }
      });
      function G(i) {
        return i.display.wrapper.ownerDocument;
      }
      function ie(i) {
        return G(i).defaultView;
      }
      function oe(i) {
        var l = Array.prototype.slice.call(arguments, 1);
        return function() {
          return i.apply(null, l);
        };
      }
      function ye(i, l, m) {
        l || (l = {});
        for (var p in i)
          i.hasOwnProperty(p) && (m !== !1 || !l.hasOwnProperty(p)) && (l[p] = i[p]);
        return l;
      }
      function ve(i, l, m, p, y) {
        l == null && (l = i.search(/[^\s\u00a0]/), l == -1 && (l = i.length));
        for (var S = p || 0, R = y || 0; ; ) {
          var N = i.indexOf("	", S);
          if (N < 0 || N >= l)
            return R + (l - S);
          R += N - S, R += m - R % m, S = N + 1;
        }
      }
      var ke = function() {
        this.id = null, this.f = null, this.time = 0, this.handler = oe(this.onTimeout, this);
      };
      ke.prototype.onTimeout = function(i) {
        i.id = 0, i.time <= +/* @__PURE__ */ new Date() ? i.f() : setTimeout(i.handler, i.time - +/* @__PURE__ */ new Date());
      }, ke.prototype.set = function(i, l) {
        this.f = l;
        var m = +/* @__PURE__ */ new Date() + i;
        (!this.id || m < this.time) && (clearTimeout(this.id), this.id = setTimeout(this.handler, i), this.time = m);
      };
      function Ae(i, l) {
        for (var m = 0; m < i.length; ++m)
          if (i[m] == l)
            return m;
        return -1;
      }
      var be = 50, Ie = { toString: function() {
        return "CodeMirror.Pass";
      } }, Se = { scroll: !1 }, ze = { origin: "*mouse" }, Ne = { origin: "+move" };
      function tt(i, l, m) {
        for (var p = 0, y = 0; ; ) {
          var S = i.indexOf("	", p);
          S == -1 && (S = i.length);
          var R = S - p;
          if (S == i.length || y + R >= l)
            return p + Math.min(R, l - y);
          if (y += S - p, y += m - y % m, p = S + 1, y >= l)
            return p;
        }
      }
      var Qe = [""];
      function et(i) {
        for (; Qe.length <= i; )
          Qe.push(ce(Qe) + " ");
        return Qe[i];
      }
      function ce(i) {
        return i[i.length - 1];
      }
      function pe(i, l) {
        for (var m = [], p = 0; p < i.length; p++)
          m[p] = l(i[p], p);
        return m;
      }
      function je(i, l, m) {
        for (var p = 0, y = m(l); p < i.length && m(i[p]) <= y; )
          p++;
        i.splice(p, 0, l);
      }
      function lt() {
      }
      function Ce(i, l) {
        var m;
        return Object.create ? m = Object.create(i) : (lt.prototype = i, m = new lt()), l && ye(l, m), m;
      }
      var Oe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function Te(i) {
        return /\w/.test(i) || i > "" && (i.toUpperCase() != i.toLowerCase() || Oe.test(i));
      }
      function ot(i, l) {
        return l ? l.source.indexOf("\\w") > -1 && Te(i) ? !0 : l.test(i) : Te(i);
      }
      function We(i) {
        for (var l in i)
          if (i.hasOwnProperty(l) && i[l])
            return !1;
        return !0;
      }
      var Ge = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function He(i) {
        return i.charCodeAt(0) >= 768 && Ge.test(i);
      }
      function me(i, l, m) {
        for (; (m < 0 ? l > 0 : l < i.length) && He(i.charAt(l)); )
          l += m;
        return l;
      }
      function de(i, l, m) {
        for (var p = l > m ? -1 : 1; ; ) {
          if (l == m)
            return l;
          var y = (l + m) / 2, S = p < 0 ? Math.ceil(y) : Math.floor(y);
          if (S == l)
            return i(S) ? l : m;
          i(S) ? m = S : l = S + p;
        }
      }
      function Fe(i, l, m, p) {
        if (!i)
          return p(l, m, "ltr", 0);
        for (var y = !1, S = 0; S < i.length; ++S) {
          var R = i[S];
          (R.from < m && R.to > l || l == m && R.to == l) && (p(Math.max(R.from, l), Math.min(R.to, m), R.level == 1 ? "rtl" : "ltr", S), y = !0);
        }
        y || p(l, m, "ltr");
      }
      var Ze = null;
      function $e(i, l, m) {
        var p;
        Ze = null;
        for (var y = 0; y < i.length; ++y) {
          var S = i[y];
          if (S.from < l && S.to > l)
            return y;
          S.to == l && (S.from != S.to && m == "before" ? p = y : Ze = y), S.from == l && (S.from != S.to && m != "before" ? p = y : Ze = y);
        }
        return p ?? Ze;
      }
      var ct = /* @__PURE__ */ (function() {
        var i = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN", l = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function m(Y) {
          return Y <= 247 ? i.charAt(Y) : 1424 <= Y && Y <= 1524 ? "R" : 1536 <= Y && Y <= 1785 ? l.charAt(Y - 1536) : 1774 <= Y && Y <= 2220 ? "r" : 8192 <= Y && Y <= 8203 ? "w" : Y == 8204 ? "b" : "L";
        }
        var p = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/, y = /[stwN]/, S = /[LRr]/, R = /[Lb1n]/, N = /[1n]/;
        function H(Y, le, he) {
          this.level = Y, this.from = le, this.to = he;
        }
        return function(Y, le) {
          var he = le == "ltr" ? "L" : "R";
          if (Y.length == 0 || le == "ltr" && !p.test(Y))
            return !1;
          for (var Pe = Y.length, Ee = [], Ve = 0; Ve < Pe; ++Ve)
            Ee.push(m(Y.charCodeAt(Ve)));
          for (var Ke = 0, Ye = he; Ke < Pe; ++Ke) {
            var nt = Ee[Ke];
            nt == "m" ? Ee[Ke] = Ye : Ye = nt;
          }
          for (var it = 0, rt = he; it < Pe; ++it) {
            var st = Ee[it];
            st == "1" && rt == "r" ? Ee[it] = "n" : S.test(st) && (rt = st, st == "r" && (Ee[it] = "R"));
          }
          for (var ft = 1, dt = Ee[0]; ft < Pe - 1; ++ft) {
            var bt = Ee[ft];
            bt == "+" && dt == "1" && Ee[ft + 1] == "1" ? Ee[ft] = "1" : bt == "," && dt == Ee[ft + 1] && (dt == "1" || dt == "n") && (Ee[ft] = dt), dt = bt;
          }
          for (var Dt = 0; Dt < Pe; ++Dt) {
            var tn = Ee[Dt];
            if (tn == ",")
              Ee[Dt] = "N";
            else if (tn == "%") {
              var Nt = void 0;
              for (Nt = Dt + 1; Nt < Pe && Ee[Nt] == "%"; ++Nt)
                ;
              for (var En = Dt && Ee[Dt - 1] == "!" || Nt < Pe && Ee[Nt] == "1" ? "1" : "N", wn = Dt; wn < Nt; ++wn)
                Ee[wn] = En;
              Dt = Nt - 1;
            }
          }
          for (var qt = 0, kn = he; qt < Pe; ++qt) {
            var ln = Ee[qt];
            kn == "L" && ln == "1" ? Ee[qt] = "L" : S.test(ln) && (kn = ln);
          }
          for (var Gt = 0; Gt < Pe; ++Gt)
            if (y.test(Ee[Gt])) {
              var Ht = void 0;
              for (Ht = Gt + 1; Ht < Pe && y.test(Ee[Ht]); ++Ht)
                ;
              for (var Ft = (Gt ? Ee[Gt - 1] : he) == "L", _n = (Ht < Pe ? Ee[Ht] : he) == "L", ia = Ft == _n ? Ft ? "L" : "R" : he, pr = Gt; pr < Ht; ++pr)
                Ee[pr] = ia;
              Gt = Ht - 1;
            }
          for (var dn = [], Kn, nn = 0; nn < Pe; )
            if (R.test(Ee[nn])) {
              var ao = nn;
              for (++nn; nn < Pe && R.test(Ee[nn]); ++nn)
                ;
              dn.push(new H(0, ao, nn));
            } else {
              var Jn = nn, Mr = dn.length, Or = le == "rtl" ? 1 : 0;
              for (++nn; nn < Pe && Ee[nn] != "L"; ++nn)
                ;
              for (var mn = Jn; mn < nn; )
                if (N.test(Ee[mn])) {
                  Jn < mn && (dn.splice(Mr, 0, new H(1, Jn, mn)), Mr += Or);
                  var oa = mn;
                  for (++mn; mn < nn && N.test(Ee[mn]); ++mn)
                    ;
                  dn.splice(Mr, 0, new H(2, oa, mn)), Mr += Or, Jn = mn;
                } else
                  ++mn;
              Jn < nn && dn.splice(Mr, 0, new H(1, Jn, nn));
            }
          return le == "ltr" && (dn[0].level == 1 && (Kn = Y.match(/^\s+/)) && (dn[0].from = Kn[0].length, dn.unshift(new H(0, 0, Kn[0].length))), ce(dn).level == 1 && (Kn = Y.match(/\s+$/)) && (ce(dn).to -= Kn[0].length, dn.push(new H(0, Pe - Kn[0].length, Pe)))), le == "rtl" ? dn.reverse() : dn;
        };
      })();
      function Je(i, l) {
        var m = i.order;
        return m == null && (m = i.order = ct(i.text, l)), m;
      }
      var wt = [], qe = function(i, l, m) {
        if (i.addEventListener)
          i.addEventListener(l, m, !1);
        else if (i.attachEvent)
          i.attachEvent("on" + l, m);
        else {
          var p = i._handlers || (i._handlers = {});
          p[l] = (p[l] || wt).concat(m);
        }
      };
      function $t(i, l) {
        return i._handlers && i._handlers[l] || wt;
      }
      function Mt(i, l, m) {
        if (i.removeEventListener)
          i.removeEventListener(l, m, !1);
        else if (i.detachEvent)
          i.detachEvent("on" + l, m);
        else {
          var p = i._handlers, y = p && p[l];
          if (y) {
            var S = Ae(y, m);
            S > -1 && (p[l] = y.slice(0, S).concat(y.slice(S + 1)));
          }
        }
      }
      function Tt(i, l) {
        var m = $t(i, l);
        if (m.length)
          for (var p = Array.prototype.slice.call(arguments, 2), y = 0; y < m.length; ++y)
            m[y].apply(null, p);
      }
      function yt(i, l, m) {
        return typeof l == "string" && (l = { type: l, preventDefault: function() {
          this.defaultPrevented = !0;
        } }), Tt(i, m || l.type, i, l), mr(l) || l.codemirrorIgnore;
      }
      function Qn(i) {
        var l = i._handlers && i._handlers.cursorActivity;
        if (l)
          for (var m = i.curOp.cursorActivityHandlers || (i.curOp.cursorActivityHandlers = []), p = 0; p < l.length; ++p)
            Ae(m, l[p]) == -1 && m.push(l[p]);
      }
      function rn(i, l) {
        return $t(i, l).length > 0;
      }
      function an(i) {
        i.prototype.on = function(l, m) {
          qe(this, l, m);
        }, i.prototype.off = function(l, m) {
          Mt(this, l, m);
        };
      }
      function Ut(i) {
        i.preventDefault ? i.preventDefault() : i.returnValue = !1;
      }
      function Fn(i) {
        i.stopPropagation ? i.stopPropagation() : i.cancelBubble = !0;
      }
      function mr(i) {
        return i.defaultPrevented != null ? i.defaultPrevented : i.returnValue == !1;
      }
      function Dn(i) {
        Ut(i), Fn(i);
      }
      function on(i) {
        return i.target || i.srcElement;
      }
      function gr(i) {
        var l = i.which;
        return l == null && (i.button & 1 ? l = 1 : i.button & 2 ? l = 3 : i.button & 4 && (l = 2)), T && i.ctrlKey && l == 1 && (l = 3), l;
      }
      var zn = (function() {
        if (f && g < 9)
          return !1;
        var i = V("div");
        return "draggable" in i || "dragDrop" in i;
      })(), fn;
      function sa(i) {
        if (fn == null) {
          var l = V("span", "");
          re(i, V("span", [l, document.createTextNode("x")])), i.firstChild.offsetHeight != 0 && (fn = l.offsetWidth <= 1 && l.offsetHeight > 2 && !(f && g < 8));
        }
        var m = fn ? V("span", "") : V("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
        return m.setAttribute("cm-text", ""), m;
      }
      var un;
      function Lr(i) {
        if (un != null)
          return un;
        var l = re(i, document.createTextNode("AA")), m = Q(l, 0, 1).getBoundingClientRect(), p = Q(l, 1, 2).getBoundingClientRect();
        return J(i), !m || m.left == m.right ? !1 : un = p.right - m.right < 3;
      }
      var vr = `

b`.split(/\n/).length != 3 ? function(i) {
        for (var l = 0, m = [], p = i.length; l <= p; ) {
          var y = i.indexOf(`
`, l);
          y == -1 && (y = i.length);
          var S = i.slice(l, i.charAt(y - 1) == "\r" ? y - 1 : y), R = S.indexOf("\r");
          R != -1 ? (m.push(S.slice(0, R)), l += R + 1) : (m.push(S), l = y + 1);
        }
        return m;
      } : function(i) {
        return i.split(/\r\n?|\n/);
      }, Yt = window.getSelection ? function(i) {
        try {
          return i.selectionStart != i.selectionEnd;
        } catch {
          return !1;
        }
      } : function(i) {
        var l;
        try {
          l = i.ownerDocument.selection.createRange();
        } catch {
        }
        return !l || l.parentElement() != i ? !1 : l.compareEndPoints("StartToEnd", l) != 0;
      }, gn = (function() {
        var i = V("div");
        return "oncopy" in i ? !0 : (i.setAttribute("oncopy", "return;"), typeof i.oncopy == "function");
      })(), Tn = null;
      function yr(i) {
        if (Tn != null)
          return Tn;
        var l = re(i, V("span", "x")), m = l.getBoundingClientRect(), p = Q(l, 0, 1).getBoundingClientRect();
        return Tn = Math.abs(m.left - p.left) > 1;
      }
      var Sn = {}, jn = {};
      function xr(i, l) {
        arguments.length > 2 && (l.dependencies = Array.prototype.slice.call(arguments, 2)), Sn[i] = l;
      }
      function er(i, l) {
        jn[i] = l;
      }
      function pn(i) {
        if (typeof i == "string" && jn.hasOwnProperty(i))
          i = jn[i];
        else if (i && typeof i.name == "string" && jn.hasOwnProperty(i.name)) {
          var l = jn[i.name];
          typeof l == "string" && (l = { name: l }), i = Ce(l, i), i.name = l.name;
        } else {
          if (typeof i == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(i))
            return pn("application/xml");
          if (typeof i == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(i))
            return pn("application/json");
        }
        return typeof i == "string" ? { name: i } : i || { name: "null" };
      }
      function Rn(i, l) {
        l = pn(l);
        var m = Sn[l.name];
        if (!m)
          return Rn(i, "text/plain");
        var p = m(i, l);
        if (Mn.hasOwnProperty(l.name)) {
          var y = Mn[l.name];
          for (var S in y)
            y.hasOwnProperty(S) && (p.hasOwnProperty(S) && (p["_" + S] = p[S]), p[S] = y[S]);
        }
        if (p.name = l.name, l.helperType && (p.helperType = l.helperType), l.modeProps)
          for (var R in l.modeProps)
            p[R] = l.modeProps[R];
        return p;
      }
      var Mn = {};
      function tr(i, l) {
        var m = Mn.hasOwnProperty(i) ? Mn[i] : Mn[i] = {};
        ye(l, m);
      }
      function On(i, l) {
        if (l === !0)
          return l;
        if (i.copyState)
          return i.copyState(l);
        var m = {};
        for (var p in l) {
          var y = l[p];
          y instanceof Array && (y = y.concat([])), m[p] = y;
        }
        return m;
      }
      function sn(i, l) {
        for (var m; i.innerMode && (m = i.innerMode(l), !(!m || m.mode == i)); )
          l = m.state, i = m.mode;
        return m || { mode: i, state: l };
      }
      function wr(i, l, m) {
        return i.startState ? i.startState(l, m) : !0;
      }
      var Rt = function(i, l, m) {
        this.pos = this.start = 0, this.string = i, this.tabSize = l || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = m;
      };
      Rt.prototype.eol = function() {
        return this.pos >= this.string.length;
      }, Rt.prototype.sol = function() {
        return this.pos == this.lineStart;
      }, Rt.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      }, Rt.prototype.next = function() {
        if (this.pos < this.string.length)
          return this.string.charAt(this.pos++);
      }, Rt.prototype.eat = function(i) {
        var l = this.string.charAt(this.pos), m;
        if (typeof i == "string" ? m = l == i : m = l && (i.test ? i.test(l) : i(l)), m)
          return ++this.pos, l;
      }, Rt.prototype.eatWhile = function(i) {
        for (var l = this.pos; this.eat(i); )
          ;
        return this.pos > l;
      }, Rt.prototype.eatSpace = function() {
        for (var i = this.pos; /[\s\u00a0]/.test(this.string.charAt(this.pos)); )
          ++this.pos;
        return this.pos > i;
      }, Rt.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      }, Rt.prototype.skipTo = function(i) {
        var l = this.string.indexOf(i, this.pos);
        if (l > -1)
          return this.pos = l, !0;
      }, Rt.prototype.backUp = function(i) {
        this.pos -= i;
      }, Rt.prototype.column = function() {
        return this.lastColumnPos < this.start && (this.lastColumnValue = ve(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? ve(this.string, this.lineStart, this.tabSize) : 0);
      }, Rt.prototype.indentation = function() {
        return ve(this.string, null, this.tabSize) - (this.lineStart ? ve(this.string, this.lineStart, this.tabSize) : 0);
      }, Rt.prototype.match = function(i, l, m) {
        if (typeof i == "string") {
          var p = function(R) {
            return m ? R.toLowerCase() : R;
          }, y = this.string.substr(this.pos, i.length);
          if (p(y) == p(i))
            return l !== !1 && (this.pos += i.length), !0;
        } else {
          var S = this.string.slice(this.pos).match(i);
          return S && S.index > 0 ? null : (S && l !== !1 && (this.pos += S[0].length), S);
        }
      }, Rt.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      }, Rt.prototype.hideFirstChars = function(i, l) {
        this.lineStart += i;
        try {
          return l();
        } finally {
          this.lineStart -= i;
        }
      }, Rt.prototype.lookAhead = function(i) {
        var l = this.lineOracle;
        return l && l.lookAhead(i);
      }, Rt.prototype.baseToken = function() {
        var i = this.lineOracle;
        return i && i.baseToken(this.pos);
      };
      function ut(i, l) {
        if (l -= i.first, l < 0 || l >= i.size)
          throw new Error("There is no line " + (l + i.first) + " in the document.");
        for (var m = i; !m.lines; )
          for (var p = 0; ; ++p) {
            var y = m.children[p], S = y.chunkSize();
            if (l < S) {
              m = y;
              break;
            }
            l -= S;
          }
        return m.lines[l];
      }
      function Ln(i, l, m) {
        var p = [], y = l.line;
        return i.iter(l.line, m.line + 1, function(S) {
          var R = S.text;
          y == m.line && (R = R.slice(0, m.ch)), y == l.line && (R = R.slice(l.ch)), p.push(R), ++y;
        }), p;
      }
      function nr(i, l, m) {
        var p = [];
        return i.iter(l, m, function(y) {
          p.push(y.text);
        }), p;
      }
      function Cn(i, l) {
        var m = l - i.height;
        if (m)
          for (var p = i; p; p = p.parent)
            p.height += m;
      }
      function _t(i) {
        if (i.parent == null)
          return null;
        for (var l = i.parent, m = Ae(l.lines, i), p = l.parent; p; l = p, p = p.parent)
          for (var y = 0; p.children[y] != l; ++y)
            m += p.children[y].chunkSize();
        return m + l.first;
      }
      function jt(i, l) {
        var m = i.first;
        e: do {
          for (var p = 0; p < i.children.length; ++p) {
            var y = i.children[p], S = y.height;
            if (l < S) {
              i = y;
              continue e;
            }
            l -= S, m += y.chunkSize();
          }
          return m;
        } while (!i.lines);
        for (var R = 0; R < i.lines.length; ++R) {
          var N = i.lines[R], H = N.height;
          if (l < H)
            break;
          l -= H;
        }
        return m + R;
      }
      function ee(i, l) {
        return l >= i.first && l < i.first + i.size;
      }
      function ge(i, l) {
        return String(i.lineNumberFormatter(l + i.firstLineNumber));
      }
      function xe(i, l, m) {
        if (m === void 0 && (m = null), !(this instanceof xe))
          return new xe(i, l, m);
        this.line = i, this.ch = l, this.sticky = m;
      }
      function De(i, l) {
        return i.line - l.line || i.ch - l.ch;
      }
      function ht(i, l) {
        return i.sticky == l.sticky && De(i, l) == 0;
      }
      function xt(i) {
        return xe(i.line, i.ch);
      }
      function St(i, l) {
        return De(i, l) < 0 ? l : i;
      }
      function It(i, l) {
        return De(i, l) < 0 ? i : l;
      }
      function vn(i, l) {
        return Math.max(i.first, Math.min(l, i.first + i.size - 1));
      }
      function mt(i, l) {
        if (l.line < i.first)
          return xe(i.first, 0);
        var m = i.first + i.size - 1;
        return l.line > m ? xe(m, ut(i, m).text.length) : qn(l, ut(i, l.line).text.length);
      }
      function qn(i, l) {
        var m = i.ch;
        return m == null || m > l ? xe(i.line, l) : m < 0 ? xe(i.line, 0) : i;
      }
      function Bt(i, l) {
        for (var m = [], p = 0; p < l.length; p++)
          m[p] = mt(i, l[p]);
        return m;
      }
      var Vr = function(i, l) {
        this.state = i, this.lookAhead = l;
      }, yn = function(i, l, m, p) {
        this.state = l, this.doc = i, this.line = m, this.maxLookAhead = p || 0, this.baseTokens = null, this.baseTokenPos = 1;
      };
      yn.prototype.lookAhead = function(i) {
        var l = this.doc.getLine(this.line + i);
        return l != null && i > this.maxLookAhead && (this.maxLookAhead = i), l;
      }, yn.prototype.baseToken = function(i) {
        if (!this.baseTokens)
          return null;
        for (; this.baseTokens[this.baseTokenPos] <= i; )
          this.baseTokenPos += 2;
        var l = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: l && l.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - i
        };
      }, yn.prototype.nextLine = function() {
        this.line++, this.maxLookAhead > 0 && this.maxLookAhead--;
      }, yn.fromSaved = function(i, l, m) {
        return l instanceof Vr ? new yn(i, On(i.mode, l.state), m, l.lookAhead) : new yn(i, On(i.mode, l), m);
      }, yn.prototype.save = function(i) {
        var l = i !== !1 ? On(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new Vr(l, this.maxLookAhead) : l;
      };
      function Ia(i, l, m, p) {
        var y = [i.state.modeGen], S = {};
        Fr(
          i,
          l.text,
          i.doc.mode,
          m,
          function(Y, le) {
            return y.push(Y, le);
          },
          S,
          p
        );
        for (var R = m.state, N = function(Y) {
          m.baseTokens = y;
          var le = i.state.overlays[Y], he = 1, Pe = 0;
          m.state = !0, Fr(i, l.text, le.mode, m, function(Ee, Ve) {
            for (var Ke = he; Pe < Ee; ) {
              var Ye = y[he];
              Ye > Ee && y.splice(he, 1, Ee, y[he + 1], Ye), he += 2, Pe = Math.min(Ee, Ye);
            }
            if (Ve)
              if (le.opaque)
                y.splice(Ke, he - Ke, Ee, "overlay " + Ve), he = Ke + 2;
              else
                for (; Ke < he; Ke += 2) {
                  var nt = y[Ke + 1];
                  y[Ke + 1] = (nt ? nt + " " : "") + "overlay " + Ve;
                }
          }, S), m.state = R, m.baseTokens = null, m.baseTokenPos = 1;
        }, H = 0; H < i.state.overlays.length; ++H) N(H);
        return { styles: y, classes: S.bgClass || S.textClass ? S : null };
      }
      function rr(i, l, m) {
        if (!l.styles || l.styles[0] != i.state.modeGen) {
          var p = kr(i, _t(l)), y = l.text.length > i.options.maxHighlightLength && On(i.doc.mode, p.state), S = Ia(i, l, p);
          y && (p.state = y), l.stateAfter = p.save(!y), l.styles = S.styles, S.classes ? l.styleClasses = S.classes : l.styleClasses && (l.styleClasses = null), m === i.doc.highlightFrontier && (i.doc.modeFrontier = Math.max(i.doc.modeFrontier, ++i.doc.highlightFrontier));
        }
        return l.styles;
      }
      function kr(i, l, m) {
        var p = i.doc, y = i.display;
        if (!p.mode.startState)
          return new yn(p, !0, l);
        var S = ja(i, l, m), R = S > p.first && ut(p, S - 1).stateAfter, N = R ? yn.fromSaved(p, R, S) : new yn(p, wr(p.mode), S);
        return p.iter(S, l, function(H) {
          ar(i, H.text, N);
          var Y = N.line;
          H.stateAfter = Y == l - 1 || Y % 5 == 0 || Y >= y.viewFrom && Y < y.viewTo ? N.save() : null, N.nextLine();
        }), m && (p.modeFrontier = N.line), N;
      }
      function ar(i, l, m, p) {
        var y = i.doc.mode, S = new Rt(l, i.options.tabSize, m);
        for (S.start = S.pos = p || 0, l == "" && la(y, m.state); !S.eol(); )
          Nr(y, S, m.state), S.start = S.pos;
      }
      function la(i, l) {
        if (i.blankLine)
          return i.blankLine(l);
        if (i.innerMode) {
          var m = sn(i, l);
          if (m.mode.blankLine)
            return m.mode.blankLine(m.state);
        }
      }
      function Nr(i, l, m, p) {
        for (var y = 0; y < 10; y++) {
          p && (p[0] = sn(i, m).mode);
          var S = i.token(l, m);
          if (l.pos > l.start)
            return S;
        }
        throw new Error("Mode " + i.name + " failed to advance stream.");
      }
      var Fa = function(i, l, m) {
        this.start = i.start, this.end = i.pos, this.string = i.current(), this.type = l || null, this.state = m;
      };
      function Ir(i, l, m, p) {
        var y = i.doc, S = y.mode, R;
        l = mt(y, l);
        var N = ut(y, l.line), H = kr(i, l.line, m), Y = new Rt(N.text, i.options.tabSize, H), le;
        for (p && (le = []); (p || Y.pos < l.ch) && !Y.eol(); )
          Y.start = Y.pos, R = Nr(S, Y, H.state), p && le.push(new Fa(Y, R, On(y.mode, H.state)));
        return p ? le : new Fa(Y, R, H.state);
      }
      function za(i, l) {
        if (i)
          for (; ; ) {
            var m = i.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!m)
              break;
            i = i.slice(0, m.index) + i.slice(m.index + m[0].length);
            var p = m[1] ? "bgClass" : "textClass";
            l[p] == null ? l[p] = m[2] : new RegExp("(?:^|\\s)" + m[2] + "(?:$|\\s)").test(l[p]) || (l[p] += " " + m[2]);
          }
        return i;
      }
      function Fr(i, l, m, p, y, S, R) {
        var N = m.flattenSpans;
        N == null && (N = i.options.flattenSpans);
        var H = 0, Y = null, le = new Rt(l, i.options.tabSize, p), he, Pe = i.options.addModeClass && [null];
        for (l == "" && za(la(m, p.state), S); !le.eol(); ) {
          if (le.pos > i.options.maxHighlightLength ? (N = !1, R && ar(i, l, p, le.pos), le.pos = l.length, he = null) : he = za(Nr(m, le, p.state, Pe), S), Pe) {
            var Ee = Pe[0].name;
            Ee && (he = "m-" + (he ? Ee + " " + he : Ee));
          }
          if (!N || Y != he) {
            for (; H < le.start; )
              H = Math.min(le.start, H + 5e3), y(H, Y);
            Y = he;
          }
          le.start = le.pos;
        }
        for (; H < le.pos; ) {
          var Ve = Math.min(le.pos, H + 5e3);
          y(Ve, Y), H = Ve;
        }
      }
      function ja(i, l, m) {
        for (var p, y, S = i.doc, R = m ? -1 : l - (i.doc.mode.innerMode ? 1e3 : 100), N = l; N > R; --N) {
          if (N <= S.first)
            return S.first;
          var H = ut(S, N - 1), Y = H.stateAfter;
          if (Y && (!m || N + (Y instanceof Vr ? Y.lookAhead : 0) <= S.modeFrontier))
            return N;
          var le = ve(H.text, null, i.options.tabSize);
          (y == null || p > le) && (y = N - 1, p = le);
        }
        return y;
      }
      function qa(i, l) {
        if (i.modeFrontier = Math.min(i.modeFrontier, l), !(i.highlightFrontier < l - 10)) {
          for (var m = i.first, p = l - 1; p > m; p--) {
            var y = ut(i, p).stateAfter;
            if (y && (!(y instanceof Vr) || p + y.lookAhead < l)) {
              m = p + 1;
              break;
            }
          }
          i.highlightFrontier = Math.min(i.highlightFrontier, m);
        }
      }
      var ua = !1, Pn = !1;
      function Bn() {
        ua = !0;
      }
      function mi() {
        Pn = !0;
      }
      function Hn(i, l, m) {
        this.marker = i, this.from = l, this.to = m;
      }
      function ir(i, l) {
        if (i)
          for (var m = 0; m < i.length; ++m) {
            var p = i[m];
            if (p.marker == l)
              return p;
          }
      }
      function gi(i, l) {
        for (var m, p = 0; p < i.length; ++p)
          i[p] != l && (m || (m = [])).push(i[p]);
        return m;
      }
      function vi(i, l, m) {
        var p = m && window.WeakSet && (m.markedSpans || (m.markedSpans = /* @__PURE__ */ new WeakSet()));
        p && i.markedSpans && p.has(i.markedSpans) ? i.markedSpans.push(l) : (i.markedSpans = i.markedSpans ? i.markedSpans.concat([l]) : [l], p && p.add(i.markedSpans)), l.marker.attachLine(i);
      }
      function yi(i, l, m) {
        var p;
        if (i)
          for (var y = 0; y < i.length; ++y) {
            var S = i[y], R = S.marker, N = S.from == null || (R.inclusiveLeft ? S.from <= l : S.from < l);
            if (N || S.from == l && R.type == "bookmark" && (!m || !S.marker.insertLeft)) {
              var H = S.to == null || (R.inclusiveRight ? S.to >= l : S.to > l);
              (p || (p = [])).push(new Hn(R, S.from, H ? null : S.to));
            }
          }
        return p;
      }
      function bi(i, l, m) {
        var p;
        if (i)
          for (var y = 0; y < i.length; ++y) {
            var S = i[y], R = S.marker, N = S.to == null || (R.inclusiveRight ? S.to >= l : S.to > l);
            if (N || S.from == l && R.type == "bookmark" && (!m || S.marker.insertLeft)) {
              var H = S.from == null || (R.inclusiveLeft ? S.from <= l : S.from < l);
              (p || (p = [])).push(new Hn(
                R,
                H ? null : S.from - l,
                S.to == null ? null : S.to - l
              ));
            }
          }
        return p;
      }
      function ca(i, l) {
        if (l.full)
          return null;
        var m = ee(i, l.from.line) && ut(i, l.from.line).markedSpans, p = ee(i, l.to.line) && ut(i, l.to.line).markedSpans;
        if (!m && !p)
          return null;
        var y = l.from.ch, S = l.to.ch, R = De(l.from, l.to) == 0, N = yi(m, y, R), H = bi(p, S, R), Y = l.text.length == 1, le = ce(l.text).length + (Y ? y : 0);
        if (N)
          for (var he = 0; he < N.length; ++he) {
            var Pe = N[he];
            if (Pe.to == null) {
              var Ee = ir(H, Pe.marker);
              Ee ? Y && (Pe.to = Ee.to == null ? null : Ee.to + le) : Pe.to = y;
            }
          }
        if (H)
          for (var Ve = 0; Ve < H.length; ++Ve) {
            var Ke = H[Ve];
            if (Ke.to != null && (Ke.to += le), Ke.from == null) {
              var Ye = ir(N, Ke.marker);
              Ye || (Ke.from = le, Y && (N || (N = [])).push(Ke));
            } else
              Ke.from += le, Y && (N || (N = [])).push(Ke);
          }
        N && (N = da(N)), H && H != N && (H = da(H));
        var nt = [N];
        if (!Y) {
          var it = l.text.length - 2, rt;
          if (it > 0 && N)
            for (var st = 0; st < N.length; ++st)
              N[st].to == null && (rt || (rt = [])).push(new Hn(N[st].marker, null, null));
          for (var ft = 0; ft < it; ++ft)
            nt.push(rt);
          nt.push(H);
        }
        return nt;
      }
      function da(i) {
        for (var l = 0; l < i.length; ++l) {
          var m = i[l];
          m.from != null && m.from == m.to && m.marker.clearWhenEmpty !== !1 && i.splice(l--, 1);
        }
        return i.length ? i : null;
      }
      function Ha(i, l, m) {
        var p = null;
        if (i.iter(l.line, m.line + 1, function(Ee) {
          if (Ee.markedSpans)
            for (var Ve = 0; Ve < Ee.markedSpans.length; ++Ve) {
              var Ke = Ee.markedSpans[Ve].marker;
              Ke.readOnly && (!p || Ae(p, Ke) == -1) && (p || (p = [])).push(Ke);
            }
        }), !p)
          return null;
        for (var y = [{ from: l, to: m }], S = 0; S < p.length; ++S)
          for (var R = p[S], N = R.find(0), H = 0; H < y.length; ++H) {
            var Y = y[H];
            if (!(De(Y.to, N.from) < 0 || De(Y.from, N.to) > 0)) {
              var le = [H, 1], he = De(Y.from, N.from), Pe = De(Y.to, N.to);
              (he < 0 || !R.inclusiveLeft && !he) && le.push({ from: Y.from, to: N.from }), (Pe > 0 || !R.inclusiveRight && !Pe) && le.push({ from: N.to, to: Y.to }), y.splice.apply(y, le), H += le.length - 3;
            }
          }
        return y;
      }
      function fa(i) {
        var l = i.markedSpans;
        if (l) {
          for (var m = 0; m < l.length; ++m)
            l[m].marker.detachLine(i);
          i.markedSpans = null;
        }
      }
      function zr(i, l) {
        if (l) {
          for (var m = 0; m < l.length; ++m)
            l[m].marker.attachLine(i);
          i.markedSpans = l;
        }
      }
      function _r(i) {
        return i.inclusiveLeft ? -1 : 0;
      }
      function Sr(i) {
        return i.inclusiveRight ? 1 : 0;
      }
      function jr(i, l) {
        var m = i.lines.length - l.lines.length;
        if (m != 0)
          return m;
        var p = i.find(), y = l.find(), S = De(p.from, y.from) || _r(i) - _r(l);
        if (S)
          return -S;
        var R = De(p.to, y.to) || Sr(i) - Sr(l);
        return R || l.id - i.id;
      }
      function qr(i, l) {
        var m = Pn && i.markedSpans, p;
        if (m)
          for (var y = void 0, S = 0; S < m.length; ++S)
            y = m[S], y.marker.collapsed && (l ? y.from : y.to) == null && (!p || jr(p, y.marker) < 0) && (p = y.marker);
        return p;
      }
      function Ua(i) {
        return qr(i, !0);
      }
      function x(i) {
        return qr(i, !1);
      }
      function $(i, l) {
        var m = Pn && i.markedSpans, p;
        if (m)
          for (var y = 0; y < m.length; ++y) {
            var S = m[y];
            S.marker.collapsed && (S.from == null || S.from < l) && (S.to == null || S.to > l) && (!p || jr(p, S.marker) < 0) && (p = S.marker);
          }
        return p;
      }
      function D(i, l, m, p, y) {
        var S = ut(i, l), R = Pn && S.markedSpans;
        if (R)
          for (var N = 0; N < R.length; ++N) {
            var H = R[N];
            if (H.marker.collapsed) {
              var Y = H.marker.find(0), le = De(Y.from, m) || _r(H.marker) - _r(y), he = De(Y.to, p) || Sr(H.marker) - Sr(y);
              if (!(le >= 0 && he <= 0 || le <= 0 && he >= 0) && (le <= 0 && (H.marker.inclusiveRight && y.inclusiveLeft ? De(Y.to, m) >= 0 : De(Y.to, m) > 0) || le >= 0 && (H.marker.inclusiveRight && y.inclusiveLeft ? De(Y.from, p) <= 0 : De(Y.from, p) < 0)))
                return !0;
            }
          }
      }
      function L(i) {
        for (var l; l = Ua(i); )
          i = l.find(-1, !0).line;
        return i;
      }
      function j(i) {
        for (var l; l = x(i); )
          i = l.find(1, !0).line;
        return i;
      }
      function U(i) {
        for (var l, m; l = x(i); )
          i = l.find(1, !0).line, (m || (m = [])).push(i);
        return m;
      }
      function ae(i, l) {
        var m = ut(i, l), p = L(m);
        return m == p ? l : _t(p);
      }
      function fe(i, l) {
        if (l > i.lastLine())
          return l;
        var m = ut(i, l), p;
        if (!se(i, m))
          return l;
        for (; p = x(m); )
          m = p.find(1, !0).line;
        return _t(m) + 1;
      }
      function se(i, l) {
        var m = Pn && l.markedSpans;
        if (m) {
          for (var p = void 0, y = 0; y < m.length; ++y)
            if (p = m[y], !!p.marker.collapsed) {
              if (p.from == null)
                return !0;
              if (!p.marker.widgetNode && p.from == 0 && p.marker.inclusiveLeft && we(i, l, p))
                return !0;
            }
        }
      }
      function we(i, l, m) {
        if (m.to == null) {
          var p = m.marker.find(1, !0);
          return we(i, p.line, ir(p.line.markedSpans, m.marker));
        }
        if (m.marker.inclusiveRight && m.to == l.text.length)
          return !0;
        for (var y = void 0, S = 0; S < l.markedSpans.length; ++S)
          if (y = l.markedSpans[S], y.marker.collapsed && !y.marker.widgetNode && y.from == m.to && (y.to == null || y.to != m.from) && (y.marker.inclusiveLeft || m.marker.inclusiveRight) && we(i, l, y))
            return !0;
      }
      function _e(i) {
        i = L(i);
        for (var l = 0, m = i.parent, p = 0; p < m.lines.length; ++p) {
          var y = m.lines[p];
          if (y == i)
            break;
          l += y.height;
        }
        for (var S = m.parent; S; m = S, S = m.parent)
          for (var R = 0; R < S.children.length; ++R) {
            var N = S.children[R];
            if (N == m)
              break;
            l += N.height;
          }
        return l;
      }
      function Le(i) {
        if (i.height == 0)
          return 0;
        for (var l = i.text.length, m, p = i; m = Ua(p); ) {
          var y = m.find(0, !0);
          p = y.from.line, l += y.from.ch - y.to.ch;
        }
        for (p = i; m = x(p); ) {
          var S = m.find(0, !0);
          l -= p.text.length - S.from.ch, p = S.to.line, l += p.text.length - S.to.ch;
        }
        return l;
      }
      function Ue(i) {
        var l = i.display, m = i.doc;
        l.maxLine = ut(m, m.first), l.maxLineLength = Le(l.maxLine), l.maxLineChanged = !0, m.iter(function(p) {
          var y = Le(p);
          y > l.maxLineLength && (l.maxLineLength = y, l.maxLine = p);
        });
      }
      var Me = function(i, l, m) {
        this.text = i, zr(this, l), this.height = m ? m(this) : 1;
      };
      Me.prototype.lineNo = function() {
        return _t(this);
      }, an(Me);
      function Re(i, l, m, p) {
        i.text = l, i.stateAfter && (i.stateAfter = null), i.styles && (i.styles = null), i.order != null && (i.order = null), fa(i), zr(i, m);
        var y = p ? p(i) : 1;
        y != i.height && Cn(i, y);
      }
      function at(i) {
        i.parent = null, fa(i);
      }
      var Xe = {}, pt = {};
      function vt(i, l) {
        if (!i || /^\s*$/.test(i))
          return null;
        var m = l.addModeClass ? pt : Xe;
        return m[i] || (m[i] = i.replace(/\S+/g, "cm-$&"));
      }
      function gt(i, l) {
        var m = ne("span", null, null, v ? "padding-right: .1px" : null), p = {
          pre: ne("pre", [m], "CodeMirror-line"),
          content: m,
          col: 0,
          pos: 0,
          cm: i,
          trailingSpace: !1,
          splitSpaces: i.getOption("lineWrapping")
        };
        l.measure = {};
        for (var y = 0; y <= (l.rest ? l.rest.length : 0); y++) {
          var S = y ? l.rest[y - 1] : l.line, R = void 0;
          p.pos = 0, p.addToken = Wt, Lr(i.display.measure) && (R = Je(S, i.doc.direction)) && (p.addToken = Xt(p.addToken, R)), p.map = [];
          var N = l != i.display.externalMeasured && _t(S);
          kt(S, p, rr(i, S, N)), S.styleClasses && (S.styleClasses.bgClass && (p.bgClass = Be(S.styleClasses.bgClass, p.bgClass || "")), S.styleClasses.textClass && (p.textClass = Be(S.styleClasses.textClass, p.textClass || ""))), p.map.length == 0 && p.map.push(0, 0, p.content.appendChild(sa(i.display.measure))), y == 0 ? (l.measure.map = p.map, l.measure.cache = {}) : ((l.measure.maps || (l.measure.maps = [])).push(p.map), (l.measure.caches || (l.measure.caches = [])).push({}));
        }
        if (v) {
          var H = p.content.lastChild;
          (/\bcm-tab\b/.test(H.className) || H.querySelector && H.querySelector(".cm-tab")) && (p.content.className = "cm-tab-wrap-hack");
        }
        return Tt(i, "renderLine", i, l.line, p.pre), p.pre.className && (p.textClass = Be(p.pre.className, p.textClass || "")), p;
      }
      function Ct(i) {
        var l = V("span", "", "cm-invalidchar");
        return l.title = "\\u" + i.charCodeAt(0).toString(16), l.setAttribute("aria-label", l.title), l;
      }
      function Wt(i, l, m, p, y, S, R) {
        if (l) {
          var N = i.splitSpaces ? Lt(l, i.trailingSpace) : l, H = i.cm.state.specialChars, Y = !1, le;
          if (!H.test(l))
            i.col += l.length, le = document.createTextNode(N), i.map.push(i.pos, i.pos + l.length, le), f && g < 9 && (Y = !0), i.pos += l.length;
          else {
            le = document.createDocumentFragment();
            for (var he = 0; ; ) {
              H.lastIndex = he;
              var Pe = H.exec(l), Ee = Pe ? Pe.index - he : l.length - he;
              if (Ee) {
                var Ve = document.createTextNode(N.slice(he, he + Ee));
                f && g < 9 ? le.appendChild(V("span", [Ve])) : le.appendChild(Ve), i.map.push(i.pos, i.pos + Ee, Ve), i.col += Ee, i.pos += Ee;
              }
              if (!Pe)
                break;
              he += Ee + 1;
              var Ke = void 0;
              if (Pe[0] == "	") {
                var Ye = i.cm.options.tabSize, nt = Ye - i.col % Ye;
                Ke = le.appendChild(V("span", et(nt), "cm-tab")), Ke.setAttribute("role", "presentation"), Ke.setAttribute("cm-text", "	"), i.col += nt;
              } else Pe[0] == "\r" || Pe[0] == `
` ? (Ke = le.appendChild(V("span", Pe[0] == "\r" ? "" : "", "cm-invalidchar")), Ke.setAttribute("cm-text", Pe[0]), i.col += 1) : (Ke = i.cm.options.specialCharPlaceholder(Pe[0]), Ke.setAttribute("cm-text", Pe[0]), f && g < 9 ? le.appendChild(V("span", [Ke])) : le.appendChild(Ke), i.col += 1);
              i.map.push(i.pos, i.pos + 1, Ke), i.pos++;
            }
          }
          if (i.trailingSpace = N.charCodeAt(l.length - 1) == 32, m || p || y || Y || S || R) {
            var it = m || "";
            p && (it += p), y && (it += y);
            var rt = V("span", [le], it, S);
            if (R)
              for (var st in R)
                R.hasOwnProperty(st) && st != "style" && st != "class" && rt.setAttribute(st, R[st]);
            return i.content.appendChild(rt);
          }
          i.content.appendChild(le);
        }
      }
      function Lt(i, l) {
        if (i.length > 1 && !/  /.test(i))
          return i;
        for (var m = l, p = "", y = 0; y < i.length; y++) {
          var S = i.charAt(y);
          S == " " && m && (y == i.length - 1 || i.charCodeAt(y + 1) == 32) && (S = ""), p += S, m = S == " ";
        }
        return p;
      }
      function Xt(i, l) {
        return function(m, p, y, S, R, N, H) {
          y = y ? y + " cm-force-border" : "cm-force-border";
          for (var Y = m.pos, le = Y + p.length; ; ) {
            for (var he = void 0, Pe = 0; Pe < l.length && (he = l[Pe], !(he.to > Y && he.from <= Y)); Pe++)
              ;
            if (he.to >= le)
              return i(m, p, y, S, R, N, H);
            i(m, p.slice(0, he.to - Y), y, S, null, N, H), S = null, p = p.slice(he.to - Y), Y = he.to;
          }
        };
      }
      function Et(i, l, m, p) {
        var y = !p && m.widgetNode;
        y && i.map.push(i.pos, i.pos + l, y), !p && i.cm.display.input.needsContentAttribute && (y || (y = i.content.appendChild(document.createElement("span"))), y.setAttribute("cm-marker", m.id)), y && (i.cm.display.input.setUneditable(y), i.content.appendChild(y)), i.pos += l, i.trailingSpace = !1;
      }
      function kt(i, l, m) {
        var p = i.markedSpans, y = i.text, S = 0;
        if (!p) {
          for (var R = 1; R < m.length; R += 2)
            l.addToken(l, y.slice(S, S = m[R]), vt(m[R + 1], l.cm.options));
          return;
        }
        for (var N = y.length, H = 0, Y = 1, le = "", he, Pe, Ee = 0, Ve, Ke, Ye, nt, it; ; ) {
          if (Ee == H) {
            Ve = Ke = Ye = Pe = "", it = null, nt = null, Ee = 1 / 0;
            for (var rt = [], st = void 0, ft = 0; ft < p.length; ++ft) {
              var dt = p[ft], bt = dt.marker;
              if (bt.type == "bookmark" && dt.from == H && bt.widgetNode)
                rt.push(bt);
              else if (dt.from <= H && (dt.to == null || dt.to > H || bt.collapsed && dt.to == H && dt.from == H)) {
                if (dt.to != null && dt.to != H && Ee > dt.to && (Ee = dt.to, Ke = ""), bt.className && (Ve += " " + bt.className), bt.css && (Pe = (Pe ? Pe + ";" : "") + bt.css), bt.startStyle && dt.from == H && (Ye += " " + bt.startStyle), bt.endStyle && dt.to == Ee && (st || (st = [])).push(bt.endStyle, dt.to), bt.title && ((it || (it = {})).title = bt.title), bt.attributes)
                  for (var Dt in bt.attributes)
                    (it || (it = {}))[Dt] = bt.attributes[Dt];
                bt.collapsed && (!nt || jr(nt.marker, bt) < 0) && (nt = dt);
              } else dt.from > H && Ee > dt.from && (Ee = dt.from);
            }
            if (st)
              for (var tn = 0; tn < st.length; tn += 2)
                st[tn + 1] == Ee && (Ke += " " + st[tn]);
            if (!nt || nt.from == H)
              for (var Nt = 0; Nt < rt.length; ++Nt)
                Et(l, 0, rt[Nt]);
            if (nt && (nt.from || 0) == H) {
              if (Et(
                l,
                (nt.to == null ? N + 1 : nt.to) - H,
                nt.marker,
                nt.from == null
              ), nt.to == null)
                return;
              nt.to == H && (nt = !1);
            }
          }
          if (H >= N)
            break;
          for (var En = Math.min(N, Ee); ; ) {
            if (le) {
              var wn = H + le.length;
              if (!nt) {
                var qt = wn > En ? le.slice(0, En - H) : le;
                l.addToken(
                  l,
                  qt,
                  he ? he + Ve : Ve,
                  Ye,
                  H + qt.length == Ee ? Ke : "",
                  Pe,
                  it
                );
              }
              if (wn >= En) {
                le = le.slice(En - H), H = En;
                break;
              }
              H = wn, Ye = "";
            }
            le = y.slice(S, S = m[Y++]), he = vt(m[Y++], l.cm.options);
          }
        }
      }
      function Kt(i, l, m) {
        this.line = l, this.rest = U(l), this.size = this.rest ? _t(ce(this.rest)) - m + 1 : 1, this.node = this.text = null, this.hidden = se(i, l);
      }
      function Zt(i, l, m) {
        for (var p = [], y, S = l; S < m; S = y) {
          var R = new Kt(i.doc, ut(i.doc, S), S);
          y = S + R.size, p.push(R);
        }
        return p;
      }
      var Vt = null;
      function Gn(i) {
        Vt ? Vt.ops.push(i) : i.ownsGroup = Vt = {
          ops: [i],
          delayedCallbacks: []
        };
      }
      function Cr(i) {
        var l = i.delayedCallbacks, m = 0;
        do {
          for (; m < l.length; m++)
            l[m].call(null);
          for (var p = 0; p < i.ops.length; p++) {
            var y = i.ops[p];
            if (y.cursorActivityHandlers)
              for (; y.cursorActivityCalled < y.cursorActivityHandlers.length; )
                y.cursorActivityHandlers[y.cursorActivityCalled++].call(null, y.cm);
          }
        } while (m < l.length);
      }
      function pa(i, l) {
        var m = i.ownsGroup;
        if (m)
          try {
            Cr(m);
          } finally {
            Vt = null, l(m);
          }
      }
      var ha = null;
      function Jt(i, l) {
        var m = $t(i, l);
        if (m.length) {
          var p = Array.prototype.slice.call(arguments, 2), y;
          Vt ? y = Vt.delayedCallbacks : ha ? y = ha : (y = ha = [], setTimeout(qs, 0));
          for (var S = function(N) {
            y.push(function() {
              return m[N].apply(null, p);
            });
          }, R = 0; R < m.length; ++R)
            S(R);
        }
      }
      function qs() {
        var i = ha;
        ha = null;
        for (var l = 0; l < i.length; ++l)
          i[l]();
      }
      function lo(i, l, m, p) {
        for (var y = 0; y < l.changes.length; y++) {
          var S = l.changes[y];
          S == "text" ? Us(i, l) : S == "gutter" ? co(i, l, m, p) : S == "class" ? xi(i, l) : S == "widget" && Ws(i, l, p);
        }
        l.changes = null;
      }
      function ma(i) {
        return i.node == i.text && (i.node = V("div", null, null, "position: relative"), i.text.parentNode && i.text.parentNode.replaceChild(i.node, i.text), i.node.appendChild(i.text), f && g < 8 && (i.node.style.zIndex = 2)), i.node;
      }
      function Hs(i, l) {
        var m = l.bgClass ? l.bgClass + " " + (l.line.bgClass || "") : l.line.bgClass;
        if (m && (m += " CodeMirror-linebackground"), l.background)
          m ? l.background.className = m : (l.background.parentNode.removeChild(l.background), l.background = null);
        else if (m) {
          var p = ma(l);
          l.background = p.insertBefore(V("div", null, m), p.firstChild), i.display.input.setUneditable(l.background);
        }
      }
      function uo(i, l) {
        var m = i.display.externalMeasured;
        return m && m.line == l.line ? (i.display.externalMeasured = null, l.measure = m.measure, m.built) : gt(i, l);
      }
      function Us(i, l) {
        var m = l.text.className, p = uo(i, l);
        l.text == l.node && (l.node = p.pre), l.text.parentNode.replaceChild(p.pre, l.text), l.text = p.pre, p.bgClass != l.bgClass || p.textClass != l.textClass ? (l.bgClass = p.bgClass, l.textClass = p.textClass, xi(i, l)) : m && (l.text.className = m);
      }
      function xi(i, l) {
        Hs(i, l), l.line.wrapClass ? ma(l).className = l.line.wrapClass : l.node != l.text && (l.node.className = "");
        var m = l.textClass ? l.textClass + " " + (l.line.textClass || "") : l.line.textClass;
        l.text.className = m || "";
      }
      function co(i, l, m, p) {
        if (l.gutter && (l.node.removeChild(l.gutter), l.gutter = null), l.gutterBackground && (l.node.removeChild(l.gutterBackground), l.gutterBackground = null), l.line.gutterClass) {
          var y = ma(l);
          l.gutterBackground = V(
            "div",
            null,
            "CodeMirror-gutter-background " + l.line.gutterClass,
            "left: " + (i.options.fixedGutter ? p.fixedPos : -p.gutterTotalWidth) + "px; width: " + p.gutterTotalWidth + "px"
          ), i.display.input.setUneditable(l.gutterBackground), y.insertBefore(l.gutterBackground, l.text);
        }
        var S = l.line.gutterMarkers;
        if (i.options.lineNumbers || S) {
          var R = ma(l), N = l.gutter = V("div", null, "CodeMirror-gutter-wrapper", "left: " + (i.options.fixedGutter ? p.fixedPos : -p.gutterTotalWidth) + "px");
          if (N.setAttribute("aria-hidden", "true"), i.display.input.setUneditable(N), R.insertBefore(N, l.text), l.line.gutterClass && (N.className += " " + l.line.gutterClass), i.options.lineNumbers && (!S || !S["CodeMirror-linenumbers"]) && (l.lineNumber = N.appendChild(
            V(
              "div",
              ge(i.options, m),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              "left: " + p.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + i.display.lineNumInnerWidth + "px"
            )
          )), S)
            for (var H = 0; H < i.display.gutterSpecs.length; ++H) {
              var Y = i.display.gutterSpecs[H].className, le = S.hasOwnProperty(Y) && S[Y];
              le && N.appendChild(V(
                "div",
                [le],
                "CodeMirror-gutter-elt",
                "left: " + p.gutterLeft[Y] + "px; width: " + p.gutterWidth[Y] + "px"
              ));
            }
        }
      }
      function Ws(i, l, m) {
        l.alignable && (l.alignable = null);
        for (var p = K("CodeMirror-linewidget"), y = l.node.firstChild, S = void 0; y; y = S)
          S = y.nextSibling, p.test(y.className) && l.node.removeChild(y);
        fo(i, l, m);
      }
      function Ks(i, l, m, p) {
        var y = uo(i, l);
        return l.text = l.node = y.pre, y.bgClass && (l.bgClass = y.bgClass), y.textClass && (l.textClass = y.textClass), xi(i, l), co(i, l, m, p), fo(i, l, p), l.node;
      }
      function fo(i, l, m) {
        if (po(i, l.line, l, m, !0), l.rest)
          for (var p = 0; p < l.rest.length; p++)
            po(i, l.rest[p], l, m, !1);
      }
      function po(i, l, m, p, y) {
        if (l.widgets)
          for (var S = ma(m), R = 0, N = l.widgets; R < N.length; ++R) {
            var H = N[R], Y = V("div", [H.node], "CodeMirror-linewidget" + (H.className ? " " + H.className : ""));
            H.handleMouseEvents || Y.setAttribute("cm-ignore-events", "true"), Gs(H, Y, m, p), i.display.input.setUneditable(Y), y && H.above ? S.insertBefore(Y, m.gutter || m.text) : S.appendChild(Y), Jt(H, "redraw");
          }
      }
      function Gs(i, l, m, p) {
        if (i.noHScroll) {
          (m.alignable || (m.alignable = [])).push(l);
          var y = p.wrapperWidth;
          l.style.left = p.fixedPos + "px", i.coverGutter || (y -= p.gutterTotalWidth, l.style.paddingLeft = p.gutterTotalWidth + "px"), l.style.width = y + "px";
        }
        i.coverGutter && (l.style.zIndex = 5, l.style.position = "relative", i.noHScroll || (l.style.marginLeft = -p.gutterTotalWidth + "px"));
      }
      function ga(i) {
        if (i.height != null)
          return i.height;
        var l = i.doc.cm;
        if (!l)
          return 0;
        if (!z(document.body, i.node)) {
          var m = "position: relative;";
          i.coverGutter && (m += "margin-left: -" + l.display.gutters.offsetWidth + "px;"), i.noHScroll && (m += "width: " + l.display.wrapper.clientWidth + "px;"), re(l.display.measure, V("div", [i.node], null, m));
        }
        return i.height = i.node.parentNode.offsetHeight;
      }
      function Yn(i, l) {
        for (var m = on(l); m != i.wrapper; m = m.parentNode)
          if (!m || m.nodeType == 1 && m.getAttribute("cm-ignore-events") == "true" || m.parentNode == i.sizer && m != i.mover)
            return !0;
      }
      function Wa(i) {
        return i.lineSpace.offsetTop;
      }
      function wi(i) {
        return i.mover.offsetHeight - i.lineSpace.offsetHeight;
      }
      function ho(i) {
        if (i.cachedPaddingH)
          return i.cachedPaddingH;
        var l = re(i.measure, V("pre", "x", "CodeMirror-line-like")), m = window.getComputedStyle ? window.getComputedStyle(l) : l.currentStyle, p = { left: parseInt(m.paddingLeft), right: parseInt(m.paddingRight) };
        return !isNaN(p.left) && !isNaN(p.right) && (i.cachedPaddingH = p), p;
      }
      function Un(i) {
        return be - i.display.nativeBarWidth;
      }
      function $r(i) {
        return i.display.scroller.clientWidth - Un(i) - i.display.barWidth;
      }
      function ki(i) {
        return i.display.scroller.clientHeight - Un(i) - i.display.barHeight;
      }
      function Ys(i, l, m) {
        var p = i.options.lineWrapping, y = p && $r(i);
        if (!l.measure.heights || p && l.measure.width != y) {
          var S = l.measure.heights = [];
          if (p) {
            l.measure.width = y;
            for (var R = l.text.firstChild.getClientRects(), N = 0; N < R.length - 1; N++) {
              var H = R[N], Y = R[N + 1];
              Math.abs(H.bottom - Y.bottom) > 2 && S.push((H.bottom + Y.top) / 2 - m.top);
            }
          }
          S.push(m.bottom - m.top);
        }
      }
      function mo(i, l, m) {
        if (i.line == l)
          return { map: i.measure.map, cache: i.measure.cache };
        if (i.rest) {
          for (var p = 0; p < i.rest.length; p++)
            if (i.rest[p] == l)
              return { map: i.measure.maps[p], cache: i.measure.caches[p] };
          for (var y = 0; y < i.rest.length; y++)
            if (_t(i.rest[y]) > m)
              return { map: i.measure.maps[y], cache: i.measure.caches[y], before: !0 };
        }
      }
      function Xs(i, l) {
        l = L(l);
        var m = _t(l), p = i.display.externalMeasured = new Kt(i.doc, l, m);
        p.lineN = m;
        var y = p.built = gt(i, p);
        return p.text = y.pre, re(i.display.lineMeasure, y.pre), p;
      }
      function vo(i, l, m, p) {
        return Wn(i, Hr(i, l), m, p);
      }
      function _i(i, l) {
        if (l >= i.display.viewFrom && l < i.display.viewTo)
          return i.display.view[Tr(i, l)];
        var m = i.display.externalMeasured;
        if (m && l >= m.lineN && l < m.lineN + m.size)
          return m;
      }
      function Hr(i, l) {
        var m = _t(l), p = _i(i, m);
        p && !p.text ? p = null : p && p.changes && (lo(i, p, m, Ai(i)), i.curOp.forceUpdate = !0), p || (p = Xs(i, l));
        var y = mo(p, l, m);
        return {
          line: l,
          view: p,
          rect: null,
          map: y.map,
          cache: y.cache,
          before: y.before,
          hasHeights: !1
        };
      }
      function Wn(i, l, m, p, y) {
        l.before && (m = -1);
        var S = m + (p || ""), R;
        return l.cache.hasOwnProperty(S) ? R = l.cache[S] : (l.rect || (l.rect = l.view.text.getBoundingClientRect()), l.hasHeights || (Ys(i, l.view, l.rect), l.hasHeights = !0), R = Js(i, l, m, p), R.bogus || (l.cache[S] = R)), {
          left: R.left,
          right: R.right,
          top: y ? R.rtop : R.top,
          bottom: y ? R.rbottom : R.bottom
        };
      }
      var yo = { left: 0, right: 0, top: 0, bottom: 0 };
      function bo(i, l, m) {
        for (var p, y, S, R, N, H, Y = 0; Y < i.length; Y += 3)
          if (N = i[Y], H = i[Y + 1], l < N ? (y = 0, S = 1, R = "left") : l < H ? (y = l - N, S = y + 1) : (Y == i.length - 3 || l == H && i[Y + 3] > l) && (S = H - N, y = S - 1, l >= H && (R = "right")), y != null) {
            if (p = i[Y + 2], N == H && m == (p.insertLeft ? "left" : "right") && (R = m), m == "left" && y == 0)
              for (; Y && i[Y - 2] == i[Y - 3] && i[Y - 1].insertLeft; )
                p = i[(Y -= 3) + 2], R = "left";
            if (m == "right" && y == H - N)
              for (; Y < i.length - 3 && i[Y + 3] == i[Y + 4] && !i[Y + 5].insertLeft; )
                p = i[(Y += 3) + 2], R = "right";
            break;
          }
        return { node: p, start: y, end: S, collapse: R, coverStart: N, coverEnd: H };
      }
      function Zs(i, l) {
        var m = yo;
        if (l == "left")
          for (var p = 0; p < i.length && (m = i[p]).left == m.right; p++)
            ;
        else
          for (var y = i.length - 1; y >= 0 && (m = i[y]).left == m.right; y--)
            ;
        return m;
      }
      function Js(i, l, m, p) {
        var y = bo(l.map, m, p), S = y.node, R = y.start, N = y.end, H = y.collapse, Y;
        if (S.nodeType == 3) {
          for (var le = 0; le < 4; le++) {
            for (; R && He(l.line.text.charAt(y.coverStart + R)); )
              --R;
            for (; y.coverStart + N < y.coverEnd && He(l.line.text.charAt(y.coverStart + N)); )
              ++N;
            if (f && g < 9 && R == 0 && N == y.coverEnd - y.coverStart ? Y = S.parentNode.getBoundingClientRect() : Y = Zs(Q(S, R, N).getClientRects(), p), Y.left || Y.right || R == 0)
              break;
            N = R, R = R - 1, H = "right";
          }
          f && g < 11 && (Y = Qs(i.display.measure, Y));
        } else {
          R > 0 && (H = p = "right");
          var he;
          i.options.lineWrapping && (he = S.getClientRects()).length > 1 ? Y = he[p == "right" ? he.length - 1 : 0] : Y = S.getBoundingClientRect();
        }
        if (f && g < 9 && !R && (!Y || !Y.left && !Y.right)) {
          var Pe = S.parentNode.getClientRects()[0];
          Pe ? Y = { left: Pe.left, right: Pe.left + Wr(i.display), top: Pe.top, bottom: Pe.bottom } : Y = yo;
        }
        for (var Ee = Y.top - l.rect.top, Ve = Y.bottom - l.rect.top, Ke = (Ee + Ve) / 2, Ye = l.view.measure.heights, nt = 0; nt < Ye.length - 1 && !(Ke < Ye[nt]); nt++)
          ;
        var it = nt ? Ye[nt - 1] : 0, rt = Ye[nt], st = {
          left: (H == "right" ? Y.right : Y.left) - l.rect.left,
          right: (H == "left" ? Y.left : Y.right) - l.rect.left,
          top: it,
          bottom: rt
        };
        return !Y.left && !Y.right && (st.bogus = !0), i.options.singleCursorHeightPerLine || (st.rtop = Ee, st.rbottom = Ve), st;
      }
      function Qs(i, l) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !yr(i))
          return l;
        var m = screen.logicalXDPI / screen.deviceXDPI, p = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: l.left * m,
          right: l.right * m,
          top: l.top * p,
          bottom: l.bottom * p
        };
      }
      function xo(i) {
        if (i.measure && (i.measure.cache = {}, i.measure.heights = null, i.rest))
          for (var l = 0; l < i.rest.length; l++)
            i.measure.caches[l] = {};
      }
      function wo(i) {
        i.display.externalMeasure = null, J(i.display.lineMeasure);
        for (var l = 0; l < i.display.view.length; l++)
          xo(i.display.view[l]);
      }
      function va(i) {
        wo(i), i.display.cachedCharWidth = i.display.cachedTextHeight = i.display.cachedPaddingH = null, i.options.lineWrapping || (i.display.maxLineChanged = !0), i.display.lineNumChars = null;
      }
      function ko(i) {
        return w && B ? -(i.body.getBoundingClientRect().left - parseInt(getComputedStyle(i.body).marginLeft)) : i.defaultView.pageXOffset || (i.documentElement || i.body).scrollLeft;
      }
      function _o(i) {
        return w && B ? -(i.body.getBoundingClientRect().top - parseInt(getComputedStyle(i.body).marginTop)) : i.defaultView.pageYOffset || (i.documentElement || i.body).scrollTop;
      }
      function Si(i) {
        var l = L(i), m = l.widgets, p = 0;
        if (m)
          for (var y = 0; y < m.length; ++y)
            m[y].above && (p += ga(m[y]));
        return p;
      }
      function Ka(i, l, m, p, y) {
        if (!y) {
          var S = Si(l);
          m.top += S, m.bottom += S;
        }
        if (p == "line")
          return m;
        p || (p = "local");
        var R = _e(l);
        if (p == "local" ? R += Wa(i.display) : R -= i.display.viewOffset, p == "page" || p == "window") {
          var N = i.display.lineSpace.getBoundingClientRect();
          R += N.top + (p == "window" ? 0 : _o(G(i)));
          var H = N.left + (p == "window" ? 0 : ko(G(i)));
          m.left += H, m.right += H;
        }
        return m.top += R, m.bottom += R, m;
      }
      function So(i, l, m) {
        if (m == "div")
          return l;
        var p = l.left, y = l.top;
        if (m == "page")
          p -= ko(G(i)), y -= _o(G(i));
        else if (m == "local" || !m) {
          var S = i.display.sizer.getBoundingClientRect();
          p += S.left, y += S.top;
        }
        var R = i.display.lineSpace.getBoundingClientRect();
        return { left: p - R.left, top: y - R.top };
      }
      function Ga(i, l, m, p, y) {
        return p || (p = ut(i.doc, l.line)), Ka(i, p, vo(i, p, l.ch, y), m);
      }
      function Vn(i, l, m, p, y, S) {
        p = p || ut(i.doc, l.line), y || (y = Hr(i, p));
        function R(Ve, Ke) {
          var Ye = Wn(i, y, Ve, Ke ? "right" : "left", S);
          return Ke ? Ye.left = Ye.right : Ye.right = Ye.left, Ka(i, p, Ye, m);
        }
        var N = Je(p, i.doc.direction), H = l.ch, Y = l.sticky;
        if (H >= p.text.length ? (H = p.text.length, Y = "before") : H <= 0 && (H = 0, Y = "after"), !N)
          return R(Y == "before" ? H - 1 : H, Y == "before");
        function le(Ve, Ke, Ye) {
          var nt = N[Ke], it = nt.level == 1;
          return R(Ye ? Ve - 1 : Ve, it != Ye);
        }
        var he = $e(N, H, Y), Pe = Ze, Ee = le(H, he, Y == "before");
        return Pe != null && (Ee.other = le(H, Pe, Y != "before")), Ee;
      }
      function Co(i, l) {
        var m = 0;
        l = mt(i.doc, l), i.options.lineWrapping || (m = Wr(i.display) * l.ch);
        var p = ut(i.doc, l.line), y = _e(p) + Wa(i.display);
        return { left: m, right: m, top: y, bottom: y + p.height };
      }
      function Ci(i, l, m, p, y) {
        var S = xe(i, l, m);
        return S.xRel = y, p && (S.outside = p), S;
      }
      function $i(i, l, m) {
        var p = i.doc;
        if (m += i.display.viewOffset, m < 0)
          return Ci(p.first, 0, null, -1, -1);
        var y = jt(p, m), S = p.first + p.size - 1;
        if (y > S)
          return Ci(p.first + p.size - 1, ut(p, S).text.length, null, 1, 1);
        l < 0 && (l = 0);
        for (var R = ut(p, y); ; ) {
          var N = el(i, R, y, l, m), H = $(R, N.ch + (N.xRel > 0 || N.outside > 0 ? 1 : 0));
          if (!H)
            return N;
          var Y = H.find(1);
          if (Y.line == y)
            return Y;
          R = ut(p, y = Y.line);
        }
      }
      function $o(i, l, m, p) {
        p -= Si(l);
        var y = l.text.length, S = de(function(R) {
          return Wn(i, m, R - 1).bottom <= p;
        }, y, 0);
        return y = de(function(R) {
          return Wn(i, m, R).top > p;
        }, S, y), { begin: S, end: y };
      }
      function Eo(i, l, m, p) {
        m || (m = Hr(i, l));
        var y = Ka(i, l, Wn(i, m, p), "line").top;
        return $o(i, l, m, y);
      }
      function Ei(i, l, m, p) {
        return i.bottom <= m ? !1 : i.top > m ? !0 : (p ? i.left : i.right) > l;
      }
      function el(i, l, m, p, y) {
        y -= _e(l);
        var S = Hr(i, l), R = Si(l), N = 0, H = l.text.length, Y = !0, le = Je(l, i.doc.direction);
        if (le) {
          var he = (i.options.lineWrapping ? nl : tl)(i, l, m, S, le, p, y);
          Y = he.level != 1, N = Y ? he.from : he.to - 1, H = Y ? he.to : he.from - 1;
        }
        var Pe = null, Ee = null, Ve = de(function(ft) {
          var dt = Wn(i, S, ft);
          return dt.top += R, dt.bottom += R, Ei(dt, p, y, !1) ? (dt.top <= y && dt.left <= p && (Pe = ft, Ee = dt), !0) : !1;
        }, N, H), Ke, Ye, nt = !1;
        if (Ee) {
          var it = p - Ee.left < Ee.right - p, rt = it == Y;
          Ve = Pe + (rt ? 0 : 1), Ye = rt ? "after" : "before", Ke = it ? Ee.left : Ee.right;
        } else {
          !Y && (Ve == H || Ve == N) && Ve++, Ye = Ve == 0 ? "after" : Ve == l.text.length ? "before" : Wn(i, S, Ve - (Y ? 1 : 0)).bottom + R <= y == Y ? "after" : "before";
          var st = Vn(i, xe(m, Ve, Ye), "line", l, S);
          Ke = st.left, nt = y < st.top ? -1 : y >= st.bottom ? 1 : 0;
        }
        return Ve = me(l.text, Ve, 1), Ci(m, Ve, Ye, nt, p - Ke);
      }
      function tl(i, l, m, p, y, S, R) {
        var N = de(function(he) {
          var Pe = y[he], Ee = Pe.level != 1;
          return Ei(Vn(
            i,
            xe(m, Ee ? Pe.to : Pe.from, Ee ? "before" : "after"),
            "line",
            l,
            p
          ), S, R, !0);
        }, 0, y.length - 1), H = y[N];
        if (N > 0) {
          var Y = H.level != 1, le = Vn(
            i,
            xe(m, Y ? H.from : H.to, Y ? "after" : "before"),
            "line",
            l,
            p
          );
          Ei(le, S, R, !0) && le.top > R && (H = y[N - 1]);
        }
        return H;
      }
      function nl(i, l, m, p, y, S, R) {
        var N = $o(i, l, p, R), H = N.begin, Y = N.end;
        /\s/.test(l.text.charAt(Y - 1)) && Y--;
        for (var le = null, he = null, Pe = 0; Pe < y.length; Pe++) {
          var Ee = y[Pe];
          if (!(Ee.from >= Y || Ee.to <= H)) {
            var Ve = Ee.level != 1, Ke = Wn(i, p, Ve ? Math.min(Y, Ee.to) - 1 : Math.max(H, Ee.from)).right, Ye = Ke < S ? S - Ke + 1e9 : Ke - S;
            (!le || he > Ye) && (le = Ee, he = Ye);
          }
        }
        return le || (le = y[y.length - 1]), le.from < H && (le = { from: H, to: le.to, level: le.level }), le.to > Y && (le = { from: le.from, to: Y, level: le.level }), le;
      }
      var Er;
      function Ur(i) {
        if (i.cachedTextHeight != null)
          return i.cachedTextHeight;
        if (Er == null) {
          Er = V("pre", null, "CodeMirror-line-like");
          for (var l = 0; l < 49; ++l)
            Er.appendChild(document.createTextNode("x")), Er.appendChild(V("br"));
          Er.appendChild(document.createTextNode("x"));
        }
        re(i.measure, Er);
        var m = Er.offsetHeight / 50;
        return m > 3 && (i.cachedTextHeight = m), J(i.measure), m || 1;
      }
      function Wr(i) {
        if (i.cachedCharWidth != null)
          return i.cachedCharWidth;
        var l = V("span", "xxxxxxxxxx"), m = V("pre", [l], "CodeMirror-line-like");
        re(i.measure, m);
        var p = l.getBoundingClientRect(), y = (p.right - p.left) / 10;
        return y > 2 && (i.cachedCharWidth = y), y || 10;
      }
      function Ai(i) {
        for (var l = i.display, m = {}, p = {}, y = l.gutters.clientLeft, S = l.gutters.firstChild, R = 0; S; S = S.nextSibling, ++R) {
          var N = i.display.gutterSpecs[R].className;
          m[N] = S.offsetLeft + S.clientLeft + y, p[N] = S.clientWidth;
        }
        return {
          fixedPos: Ti(l),
          gutterTotalWidth: l.gutters.offsetWidth,
          gutterLeft: m,
          gutterWidth: p,
          wrapperWidth: l.wrapper.clientWidth
        };
      }
      function Ti(i) {
        return i.scroller.getBoundingClientRect().left - i.sizer.getBoundingClientRect().left;
      }
      function Ao(i) {
        var l = Ur(i.display), m = i.options.lineWrapping, p = m && Math.max(5, i.display.scroller.clientWidth / Wr(i.display) - 3);
        return function(y) {
          if (se(i.doc, y))
            return 0;
          var S = 0;
          if (y.widgets)
            for (var R = 0; R < y.widgets.length; R++)
              y.widgets[R].height && (S += y.widgets[R].height);
          return m ? S + (Math.ceil(y.text.length / p) || 1) * l : S + l;
        };
      }
      function Pi(i) {
        var l = i.doc, m = Ao(i);
        l.iter(function(p) {
          var y = m(p);
          y != p.height && Cn(p, y);
        });
      }
      function Ar(i, l, m, p) {
        var y = i.display;
        if (!m && on(l).getAttribute("cm-not-content") == "true")
          return null;
        var S, R, N = y.lineSpace.getBoundingClientRect();
        try {
          S = l.clientX - N.left, R = l.clientY - N.top;
        } catch {
          return null;
        }
        var H = $i(i, S, R), Y;
        if (p && H.xRel > 0 && (Y = ut(i.doc, H.line).text).length == H.ch) {
          var le = ve(Y, Y.length, i.options.tabSize) - Y.length;
          H = xe(H.line, Math.max(0, Math.round((S - ho(i.display).left) / Wr(i.display)) - le));
        }
        return H;
      }
      function Tr(i, l) {
        if (l >= i.display.viewTo || (l -= i.display.viewFrom, l < 0))
          return null;
        for (var m = i.display.view, p = 0; p < m.length; p++)
          if (l -= m[p].size, l < 0)
            return p;
      }
      function bn(i, l, m, p) {
        l == null && (l = i.doc.first), m == null && (m = i.doc.first + i.doc.size), p || (p = 0);
        var y = i.display;
        if (p && m < y.viewTo && (y.updateLineNumbers == null || y.updateLineNumbers > l) && (y.updateLineNumbers = l), i.curOp.viewChanged = !0, l >= y.viewTo)
          Pn && ae(i.doc, l) < y.viewTo && sr(i);
        else if (m <= y.viewFrom)
          Pn && fe(i.doc, m + p) > y.viewFrom ? sr(i) : (y.viewFrom += p, y.viewTo += p);
        else if (l <= y.viewFrom && m >= y.viewTo)
          sr(i);
        else if (l <= y.viewFrom) {
          var S = Ya(i, m, m + p, 1);
          S ? (y.view = y.view.slice(S.index), y.viewFrom = S.lineN, y.viewTo += p) : sr(i);
        } else if (m >= y.viewTo) {
          var R = Ya(i, l, l, -1);
          R ? (y.view = y.view.slice(0, R.index), y.viewTo = R.lineN) : sr(i);
        } else {
          var N = Ya(i, l, l, -1), H = Ya(i, m, m + p, 1);
          N && H ? (y.view = y.view.slice(0, N.index).concat(Zt(i, N.lineN, H.lineN)).concat(y.view.slice(H.index)), y.viewTo += p) : sr(i);
        }
        var Y = y.externalMeasured;
        Y && (m < Y.lineN ? Y.lineN += p : l < Y.lineN + Y.size && (y.externalMeasured = null));
      }
      function or(i, l, m) {
        i.curOp.viewChanged = !0;
        var p = i.display, y = i.display.externalMeasured;
        if (y && l >= y.lineN && l < y.lineN + y.size && (p.externalMeasured = null), !(l < p.viewFrom || l >= p.viewTo)) {
          var S = p.view[Tr(i, l)];
          if (S.node != null) {
            var R = S.changes || (S.changes = []);
            Ae(R, m) == -1 && R.push(m);
          }
        }
      }
      function sr(i) {
        i.display.viewFrom = i.display.viewTo = i.doc.first, i.display.view = [], i.display.viewOffset = 0;
      }
      function Ya(i, l, m, p) {
        var y = Tr(i, l), S, R = i.display.view;
        if (!Pn || m == i.doc.first + i.doc.size)
          return { index: y, lineN: m };
        for (var N = i.display.viewFrom, H = 0; H < y; H++)
          N += R[H].size;
        if (N != l) {
          if (p > 0) {
            if (y == R.length - 1)
              return null;
            S = N + R[y].size - l, y++;
          } else
            S = N - l;
          l += S, m += S;
        }
        for (; ae(i.doc, m) != m; ) {
          if (y == (p < 0 ? 0 : R.length - 1))
            return null;
          m += p * R[y - (p < 0 ? 1 : 0)].size, y += p;
        }
        return { index: y, lineN: m };
      }
      function rl(i, l, m) {
        var p = i.display, y = p.view;
        y.length == 0 || l >= p.viewTo || m <= p.viewFrom ? (p.view = Zt(i, l, m), p.viewFrom = l) : (p.viewFrom > l ? p.view = Zt(i, l, p.viewFrom).concat(p.view) : p.viewFrom < l && (p.view = p.view.slice(Tr(i, l))), p.viewFrom = l, p.viewTo < m ? p.view = p.view.concat(Zt(i, p.viewTo, m)) : p.viewTo > m && (p.view = p.view.slice(0, Tr(i, m)))), p.viewTo = m;
      }
      function To(i) {
        for (var l = i.display.view, m = 0, p = 0; p < l.length; p++) {
          var y = l[p];
          !y.hidden && (!y.node || y.changes) && ++m;
        }
        return m;
      }
      function ya(i) {
        i.display.input.showSelection(i.display.input.prepareSelection());
      }
      function Po(i, l) {
        l === void 0 && (l = !0);
        var m = i.doc, p = {}, y = p.cursors = document.createDocumentFragment(), S = p.selection = document.createDocumentFragment(), R = i.options.$customCursor;
        R && (l = !0);
        for (var N = 0; N < m.sel.ranges.length; N++)
          if (!(!l && N == m.sel.primIndex)) {
            var H = m.sel.ranges[N];
            if (!(H.from().line >= i.display.viewTo || H.to().line < i.display.viewFrom)) {
              var Y = H.empty();
              if (R) {
                var le = R(i, H);
                le && Bi(i, le, y);
              } else (Y || i.options.showCursorWhenSelecting) && Bi(i, H.head, y);
              Y || al(i, H, S);
            }
          }
        return p;
      }
      function Bi(i, l, m) {
        var p = Vn(i, l, "div", null, null, !i.options.singleCursorHeightPerLine), y = m.appendChild(V("div", "", "CodeMirror-cursor"));
        if (y.style.left = p.left + "px", y.style.top = p.top + "px", y.style.height = Math.max(0, p.bottom - p.top) * i.options.cursorHeight + "px", /\bcm-fat-cursor\b/.test(i.getWrapperElement().className)) {
          var S = Ga(i, l, "div", null, null), R = S.right - S.left;
          y.style.width = (R > 0 ? R : i.defaultCharWidth()) + "px";
        }
        if (p.other) {
          var N = m.appendChild(V("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
          N.style.display = "", N.style.left = p.other.left + "px", N.style.top = p.other.top + "px", N.style.height = (p.other.bottom - p.other.top) * 0.85 + "px";
        }
      }
      function Xa(i, l) {
        return i.top - l.top || i.left - l.left;
      }
      function al(i, l, m) {
        var p = i.display, y = i.doc, S = document.createDocumentFragment(), R = ho(i.display), N = R.left, H = Math.max(p.sizerWidth, $r(i) - p.sizer.offsetLeft) - R.right, Y = y.direction == "ltr";
        function le(rt, st, ft, dt) {
          st < 0 && (st = 0), st = Math.round(st), dt = Math.round(dt), S.appendChild(V("div", null, "CodeMirror-selected", "position: absolute; left: " + rt + `px;
                             top: ` + st + "px; width: " + (ft ?? H - rt) + `px;
                             height: ` + (dt - st) + "px"));
        }
        function he(rt, st, ft) {
          var dt = ut(y, rt), bt = dt.text.length, Dt, tn;
          function Nt(qt, kn) {
            return Ga(i, xe(rt, qt), "div", dt, kn);
          }
          function En(qt, kn, ln) {
            var Gt = Eo(i, dt, null, qt), Ht = kn == "ltr" == (ln == "after") ? "left" : "right", Ft = ln == "after" ? Gt.begin : Gt.end - (/\s/.test(dt.text.charAt(Gt.end - 1)) ? 2 : 1);
            return Nt(Ft, Ht)[Ht];
          }
          var wn = Je(dt, y.direction);
          return Fe(wn, st || 0, ft ?? bt, function(qt, kn, ln, Gt) {
            var Ht = ln == "ltr", Ft = Nt(qt, Ht ? "left" : "right"), _n = Nt(kn - 1, Ht ? "right" : "left"), ia = st == null && qt == 0, pr = ft == null && kn == bt, dn = Gt == 0, Kn = !wn || Gt == wn.length - 1;
            if (_n.top - Ft.top <= 3) {
              var nn = (Y ? ia : pr) && dn, ao = (Y ? pr : ia) && Kn, Jn = nn ? N : (Ht ? Ft : _n).left, Mr = ao ? H : (Ht ? _n : Ft).right;
              le(Jn, Ft.top, Mr - Jn, Ft.bottom);
            } else {
              var Or, mn, oa, io;
              Ht ? (Or = Y && ia && dn ? N : Ft.left, mn = Y ? H : En(qt, ln, "before"), oa = Y ? N : En(kn, ln, "after"), io = Y && pr && Kn ? H : _n.right) : (Or = Y ? En(qt, ln, "before") : N, mn = !Y && ia && dn ? H : Ft.right, oa = !Y && pr && Kn ? N : _n.left, io = Y ? En(kn, ln, "after") : H), le(Or, Ft.top, mn - Or, Ft.bottom), Ft.bottom < _n.top && le(N, Ft.bottom, null, _n.top), le(oa, _n.top, io - oa, _n.bottom);
            }
            (!Dt || Xa(Ft, Dt) < 0) && (Dt = Ft), Xa(_n, Dt) < 0 && (Dt = _n), (!tn || Xa(Ft, tn) < 0) && (tn = Ft), Xa(_n, tn) < 0 && (tn = _n);
          }), { start: Dt, end: tn };
        }
        var Pe = l.from(), Ee = l.to();
        if (Pe.line == Ee.line)
          he(Pe.line, Pe.ch, Ee.ch);
        else {
          var Ve = ut(y, Pe.line), Ke = ut(y, Ee.line), Ye = L(Ve) == L(Ke), nt = he(Pe.line, Pe.ch, Ye ? Ve.text.length + 1 : null).end, it = he(Ee.line, Ye ? 0 : null, Ee.ch).start;
          Ye && (nt.top < it.top - 2 ? (le(nt.right, nt.top, null, nt.bottom), le(N, it.top, it.left, it.bottom)) : le(nt.right, nt.top, it.left - nt.right, nt.bottom)), nt.bottom < it.top && le(N, nt.bottom, null, it.top);
        }
        m.appendChild(S);
      }
      function Di(i) {
        if (i.state.focused) {
          var l = i.display;
          clearInterval(l.blinker);
          var m = !0;
          l.cursorDiv.style.visibility = "", i.options.cursorBlinkRate > 0 ? l.blinker = setInterval(function() {
            i.hasFocus() || Kr(i), l.cursorDiv.style.visibility = (m = !m) ? "" : "hidden";
          }, i.options.cursorBlinkRate) : i.options.cursorBlinkRate < 0 && (l.cursorDiv.style.visibility = "hidden");
        }
      }
      function Bo(i) {
        i.hasFocus() || (i.display.input.focus(), i.state.focused || Mi(i));
      }
      function Ri(i) {
        i.state.delayingBlurEvent = !0, setTimeout(function() {
          i.state.delayingBlurEvent && (i.state.delayingBlurEvent = !1, i.state.focused && Kr(i));
        }, 100);
      }
      function Mi(i, l) {
        i.state.delayingBlurEvent && !i.state.draggingText && (i.state.delayingBlurEvent = !1), i.options.readOnly != "nocursor" && (i.state.focused || (Tt(i, "focus", i, l), i.state.focused = !0, ue(i.display.wrapper, "CodeMirror-focused"), !i.curOp && i.display.selForContextMenu != i.doc.sel && (i.display.input.reset(), v && setTimeout(function() {
          return i.display.input.reset(!0);
        }, 20)), i.display.input.receivedFocus()), Di(i));
      }
      function Kr(i, l) {
        i.state.delayingBlurEvent || (i.state.focused && (Tt(i, "blur", i, l), i.state.focused = !1, Z(i.display.wrapper, "CodeMirror-focused")), clearInterval(i.display.blinker), setTimeout(function() {
          i.state.focused || (i.display.shift = !1);
        }, 150));
      }
      function Za(i) {
        for (var l = i.display, m = l.lineDiv.offsetTop, p = Math.max(0, l.scroller.getBoundingClientRect().top), y = l.lineDiv.getBoundingClientRect().top, S = 0, R = 0; R < l.view.length; R++) {
          var N = l.view[R], H = i.options.lineWrapping, Y = void 0, le = 0;
          if (!N.hidden) {
            if (y += N.line.height, f && g < 8) {
              var he = N.node.offsetTop + N.node.offsetHeight;
              Y = he - m, m = he;
            } else {
              var Pe = N.node.getBoundingClientRect();
              Y = Pe.bottom - Pe.top, !H && N.text.firstChild && (le = N.text.firstChild.getBoundingClientRect().right - Pe.left - 1);
            }
            var Ee = N.line.height - Y;
            if ((Ee > 5e-3 || Ee < -5e-3) && (y < p && (S -= Ee), Cn(N.line, Y), Do(N.line), N.rest))
              for (var Ve = 0; Ve < N.rest.length; Ve++)
                Do(N.rest[Ve]);
            if (le > i.display.sizerWidth) {
              var Ke = Math.ceil(le / Wr(i.display));
              Ke > i.display.maxLineLength && (i.display.maxLineLength = Ke, i.display.maxLine = N.line, i.display.maxLineChanged = !0);
            }
          }
        }
        Math.abs(S) > 2 && (l.scroller.scrollTop += S);
      }
      function Do(i) {
        if (i.widgets)
          for (var l = 0; l < i.widgets.length; ++l) {
            var m = i.widgets[l], p = m.node.parentNode;
            p && (m.height = p.offsetHeight);
          }
      }
      function Ja(i, l, m) {
        var p = m && m.top != null ? Math.max(0, m.top) : i.scroller.scrollTop;
        p = Math.floor(p - Wa(i));
        var y = m && m.bottom != null ? m.bottom : p + i.wrapper.clientHeight, S = jt(l, p), R = jt(l, y);
        if (m && m.ensure) {
          var N = m.ensure.from.line, H = m.ensure.to.line;
          N < S ? (S = N, R = jt(l, _e(ut(l, N)) + i.wrapper.clientHeight)) : Math.min(H, l.lastLine()) >= R && (S = jt(l, _e(ut(l, H)) - i.wrapper.clientHeight), R = H);
        }
        return { from: S, to: Math.max(R, S + 1) };
      }
      function il(i, l) {
        if (!yt(i, "scrollCursorIntoView")) {
          var m = i.display, p = m.sizer.getBoundingClientRect(), y = null, S = m.wrapper.ownerDocument;
          if (l.top + p.top < 0 ? y = !0 : l.bottom + p.top > (S.defaultView.innerHeight || S.documentElement.clientHeight) && (y = !1), y != null && !P) {
            var R = V("div", "", null, `position: absolute;
                         top: ` + (l.top - m.viewOffset - Wa(i.display)) + `px;
                         height: ` + (l.bottom - l.top + Un(i) + m.barHeight) + `px;
                         left: ` + l.left + "px; width: " + Math.max(2, l.right - l.left) + "px;");
            i.display.lineSpace.appendChild(R), R.scrollIntoView(y), i.display.lineSpace.removeChild(R);
          }
        }
      }
      function ol(i, l, m, p) {
        p == null && (p = 0);
        var y;
        !i.options.lineWrapping && l == m && (m = l.sticky == "before" ? xe(l.line, l.ch + 1, "before") : l, l = l.ch ? xe(l.line, l.sticky == "before" ? l.ch - 1 : l.ch, "after") : l);
        for (var S = 0; S < 5; S++) {
          var R = !1, N = Vn(i, l), H = !m || m == l ? N : Vn(i, m);
          y = {
            left: Math.min(N.left, H.left),
            top: Math.min(N.top, H.top) - p,
            right: Math.max(N.left, H.left),
            bottom: Math.max(N.bottom, H.bottom) + p
          };
          var Y = Oi(i, y), le = i.doc.scrollTop, he = i.doc.scrollLeft;
          if (Y.scrollTop != null && (xa(i, Y.scrollTop), Math.abs(i.doc.scrollTop - le) > 1 && (R = !0)), Y.scrollLeft != null && (Pr(i, Y.scrollLeft), Math.abs(i.doc.scrollLeft - he) > 1 && (R = !0)), !R)
            break;
        }
        return y;
      }
      function sl(i, l) {
        var m = Oi(i, l);
        m.scrollTop != null && xa(i, m.scrollTop), m.scrollLeft != null && Pr(i, m.scrollLeft);
      }
      function Oi(i, l) {
        var m = i.display, p = Ur(i.display);
        l.top < 0 && (l.top = 0);
        var y = i.curOp && i.curOp.scrollTop != null ? i.curOp.scrollTop : m.scroller.scrollTop, S = ki(i), R = {};
        l.bottom - l.top > S && (l.bottom = l.top + S);
        var N = i.doc.height + wi(m), H = l.top < p, Y = l.bottom > N - p;
        if (l.top < y)
          R.scrollTop = H ? 0 : l.top;
        else if (l.bottom > y + S) {
          var le = Math.min(l.top, (Y ? N : l.bottom) - S);
          le != y && (R.scrollTop = le);
        }
        var he = i.options.fixedGutter ? 0 : m.gutters.offsetWidth, Pe = i.curOp && i.curOp.scrollLeft != null ? i.curOp.scrollLeft : m.scroller.scrollLeft - he, Ee = $r(i) - m.gutters.offsetWidth, Ve = l.right - l.left > Ee;
        return Ve && (l.right = l.left + Ee), l.left < 10 ? R.scrollLeft = 0 : l.left < Pe ? R.scrollLeft = Math.max(0, l.left + he - (Ve ? 0 : 10)) : l.right > Ee + Pe - 3 && (R.scrollLeft = l.right + (Ve ? 0 : 10) - Ee), R;
      }
      function Li(i, l) {
        l != null && (Qa(i), i.curOp.scrollTop = (i.curOp.scrollTop == null ? i.doc.scrollTop : i.curOp.scrollTop) + l);
      }
      function Gr(i) {
        Qa(i);
        var l = i.getCursor();
        i.curOp.scrollToPos = { from: l, to: l, margin: i.options.cursorScrollMargin };
      }
      function ba(i, l, m) {
        (l != null || m != null) && Qa(i), l != null && (i.curOp.scrollLeft = l), m != null && (i.curOp.scrollTop = m);
      }
      function ll(i, l) {
        Qa(i), i.curOp.scrollToPos = l;
      }
      function Qa(i) {
        var l = i.curOp.scrollToPos;
        if (l) {
          i.curOp.scrollToPos = null;
          var m = Co(i, l.from), p = Co(i, l.to);
          Ro(i, m, p, l.margin);
        }
      }
      function Ro(i, l, m, p) {
        var y = Oi(i, {
          left: Math.min(l.left, m.left),
          top: Math.min(l.top, m.top) - p,
          right: Math.max(l.right, m.right),
          bottom: Math.max(l.bottom, m.bottom) + p
        });
        ba(i, y.scrollLeft, y.scrollTop);
      }
      function xa(i, l) {
        Math.abs(i.doc.scrollTop - l) < 2 || (o || Ni(i, { top: l }), Mo(i, l, !0), o && Ni(i), _a(i, 100));
      }
      function Mo(i, l, m) {
        l = Math.max(0, Math.min(i.display.scroller.scrollHeight - i.display.scroller.clientHeight, l)), !(i.display.scroller.scrollTop == l && !m) && (i.doc.scrollTop = l, i.display.scrollbars.setScrollTop(l), i.display.scroller.scrollTop != l && (i.display.scroller.scrollTop = l));
      }
      function Pr(i, l, m, p) {
        l = Math.max(0, Math.min(l, i.display.scroller.scrollWidth - i.display.scroller.clientWidth)), !((m ? l == i.doc.scrollLeft : Math.abs(i.doc.scrollLeft - l) < 2) && !p) && (i.doc.scrollLeft = l, Io(i), i.display.scroller.scrollLeft != l && (i.display.scroller.scrollLeft = l), i.display.scrollbars.setScrollLeft(l));
      }
      function wa(i) {
        var l = i.display, m = l.gutters.offsetWidth, p = Math.round(i.doc.height + wi(i.display));
        return {
          clientHeight: l.scroller.clientHeight,
          viewHeight: l.wrapper.clientHeight,
          scrollWidth: l.scroller.scrollWidth,
          clientWidth: l.scroller.clientWidth,
          viewWidth: l.wrapper.clientWidth,
          barLeft: i.options.fixedGutter ? m : 0,
          docHeight: p,
          scrollHeight: p + Un(i) + l.barHeight,
          nativeBarWidth: l.nativeBarWidth,
          gutterWidth: m
        };
      }
      var Br = function(i, l, m) {
        this.cm = m;
        var p = this.vert = V("div", [V("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"), y = this.horiz = V("div", [V("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        p.tabIndex = y.tabIndex = -1, i(p), i(y), qe(p, "scroll", function() {
          p.clientHeight && l(p.scrollTop, "vertical");
        }), qe(y, "scroll", function() {
          y.clientWidth && l(y.scrollLeft, "horizontal");
        }), this.checkedZeroWidth = !1, f && g < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px");
      };
      Br.prototype.update = function(i) {
        var l = i.scrollWidth > i.clientWidth + 1, m = i.scrollHeight > i.clientHeight + 1, p = i.nativeBarWidth;
        if (m) {
          this.vert.style.display = "block", this.vert.style.bottom = l ? p + "px" : "0";
          var y = i.viewHeight - (l ? p : 0);
          this.vert.firstChild.style.height = Math.max(0, i.scrollHeight - i.clientHeight + y) + "px";
        } else
          this.vert.scrollTop = 0, this.vert.style.display = "", this.vert.firstChild.style.height = "0";
        if (l) {
          this.horiz.style.display = "block", this.horiz.style.right = m ? p + "px" : "0", this.horiz.style.left = i.barLeft + "px";
          var S = i.viewWidth - i.barLeft - (m ? p : 0);
          this.horiz.firstChild.style.width = Math.max(0, i.scrollWidth - i.clientWidth + S) + "px";
        } else
          this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
        return !this.checkedZeroWidth && i.clientHeight > 0 && (p == 0 && this.zeroWidthHack(), this.checkedZeroWidth = !0), { right: m ? p : 0, bottom: l ? p : 0 };
      }, Br.prototype.setScrollLeft = function(i) {
        this.horiz.scrollLeft != i && (this.horiz.scrollLeft = i), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
      }, Br.prototype.setScrollTop = function(i) {
        this.vert.scrollTop != i && (this.vert.scrollTop = i), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
      }, Br.prototype.zeroWidthHack = function() {
        var i = T && !A ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = i, this.horiz.style.visibility = this.vert.style.visibility = "hidden", this.disableHoriz = new ke(), this.disableVert = new ke();
      }, Br.prototype.enableZeroWidthBar = function(i, l, m) {
        i.style.visibility = "";
        function p() {
          var y = i.getBoundingClientRect(), S = m == "vert" ? document.elementFromPoint(y.right - 1, (y.top + y.bottom) / 2) : document.elementFromPoint((y.right + y.left) / 2, y.bottom - 1);
          S != i ? i.style.visibility = "hidden" : l.set(1e3, p);
        }
        l.set(1e3, p);
      }, Br.prototype.clear = function() {
        var i = this.horiz.parentNode;
        i.removeChild(this.horiz), i.removeChild(this.vert);
      };
      var ka = function() {
      };
      ka.prototype.update = function() {
        return { bottom: 0, right: 0 };
      }, ka.prototype.setScrollLeft = function() {
      }, ka.prototype.setScrollTop = function() {
      }, ka.prototype.clear = function() {
      };
      function Yr(i, l) {
        l || (l = wa(i));
        var m = i.display.barWidth, p = i.display.barHeight;
        Oo(i, l);
        for (var y = 0; y < 4 && m != i.display.barWidth || p != i.display.barHeight; y++)
          m != i.display.barWidth && i.options.lineWrapping && Za(i), Oo(i, wa(i)), m = i.display.barWidth, p = i.display.barHeight;
      }
      function Oo(i, l) {
        var m = i.display, p = m.scrollbars.update(l);
        m.sizer.style.paddingRight = (m.barWidth = p.right) + "px", m.sizer.style.paddingBottom = (m.barHeight = p.bottom) + "px", m.heightForcer.style.borderBottom = p.bottom + "px solid transparent", p.right && p.bottom ? (m.scrollbarFiller.style.display = "block", m.scrollbarFiller.style.height = p.bottom + "px", m.scrollbarFiller.style.width = p.right + "px") : m.scrollbarFiller.style.display = "", p.bottom && i.options.coverGutterNextToScrollbar && i.options.fixedGutter ? (m.gutterFiller.style.display = "block", m.gutterFiller.style.height = p.bottom + "px", m.gutterFiller.style.width = l.gutterWidth + "px") : m.gutterFiller.style.display = "";
      }
      var Lo = { native: Br, null: ka };
      function Vo(i) {
        i.display.scrollbars && (i.display.scrollbars.clear(), i.display.scrollbars.addClass && Z(i.display.wrapper, i.display.scrollbars.addClass)), i.display.scrollbars = new Lo[i.options.scrollbarStyle](function(l) {
          i.display.wrapper.insertBefore(l, i.display.scrollbarFiller), qe(l, "mousedown", function() {
            i.state.focused && setTimeout(function() {
              return i.display.input.focus();
            }, 0);
          }), l.setAttribute("cm-not-content", "true");
        }, function(l, m) {
          m == "horizontal" ? Pr(i, l) : xa(i, l);
        }, i), i.display.scrollbars.addClass && ue(i.display.wrapper, i.display.scrollbars.addClass);
      }
      var ul = 0;
      function Dr(i) {
        i.curOp = {
          cm: i,
          viewChanged: !1,
          // Flag that indicates that lines might need to be redrawn
          startHeight: i.doc.height,
          // Used to detect need to update scrollbar
          forceUpdate: !1,
          // Used to force a redraw
          updateInput: 0,
          // Whether to reset the input textarea
          typing: !1,
          // Whether this reset should be careful to leave existing text (for compositing)
          changeObjs: null,
          // Accumulated changes, for firing change events
          cursorActivityHandlers: null,
          // Set of handlers to fire cursorActivity on
          cursorActivityCalled: 0,
          // Tracks which cursorActivity handlers have been called already
          selectionChanged: !1,
          // Whether the selection needs to be redrawn
          updateMaxLine: !1,
          // Set when the widest line needs to be determined anew
          scrollLeft: null,
          scrollTop: null,
          // Intermediate scroll position, not pushed to DOM yet
          scrollToPos: null,
          // Used to scroll to a specific position
          focus: !1,
          id: ++ul,
          // Unique ID
          markArrays: null
          // Used by addMarkedSpan
        }, Gn(i.curOp);
      }
      function Rr(i) {
        var l = i.curOp;
        l && pa(l, function(m) {
          for (var p = 0; p < m.ops.length; p++)
            m.ops[p].cm.curOp = null;
          cl(m);
        });
      }
      function cl(i) {
        for (var l = i.ops, m = 0; m < l.length; m++)
          dl(l[m]);
        for (var p = 0; p < l.length; p++)
          fl(l[p]);
        for (var y = 0; y < l.length; y++)
          pl(l[y]);
        for (var S = 0; S < l.length; S++)
          hl(l[S]);
        for (var R = 0; R < l.length; R++)
          ml(l[R]);
      }
      function dl(i) {
        var l = i.cm, m = l.display;
        vl(l), i.updateMaxLine && Ue(l), i.mustUpdate = i.viewChanged || i.forceUpdate || i.scrollTop != null || i.scrollToPos && (i.scrollToPos.from.line < m.viewFrom || i.scrollToPos.to.line >= m.viewTo) || m.maxLineChanged && l.options.lineWrapping, i.update = i.mustUpdate && new ei(l, i.mustUpdate && { top: i.scrollTop, ensure: i.scrollToPos }, i.forceUpdate);
      }
      function fl(i) {
        i.updatedDisplay = i.mustUpdate && Vi(i.cm, i.update);
      }
      function pl(i) {
        var l = i.cm, m = l.display;
        i.updatedDisplay && Za(l), i.barMeasure = wa(l), m.maxLineChanged && !l.options.lineWrapping && (i.adjustWidthTo = vo(l, m.maxLine, m.maxLine.text.length).left + 3, l.display.sizerWidth = i.adjustWidthTo, i.barMeasure.scrollWidth = Math.max(m.scroller.clientWidth, m.sizer.offsetLeft + i.adjustWidthTo + Un(l) + l.display.barWidth), i.maxScrollLeft = Math.max(0, m.sizer.offsetLeft + i.adjustWidthTo - $r(l))), (i.updatedDisplay || i.selectionChanged) && (i.preparedSelection = m.input.prepareSelection());
      }
      function hl(i) {
        var l = i.cm;
        i.adjustWidthTo != null && (l.display.sizer.style.minWidth = i.adjustWidthTo + "px", i.maxScrollLeft < l.doc.scrollLeft && Pr(l, Math.min(l.display.scroller.scrollLeft, i.maxScrollLeft), !0), l.display.maxLineChanged = !1);
        var m = i.focus && i.focus == X(G(l));
        i.preparedSelection && l.display.input.showSelection(i.preparedSelection, m), (i.updatedDisplay || i.startHeight != l.doc.height) && Yr(l, i.barMeasure), i.updatedDisplay && Fi(l, i.barMeasure), i.selectionChanged && Di(l), l.state.focused && i.updateInput && l.display.input.reset(i.typing), m && Bo(i.cm);
      }
      function ml(i) {
        var l = i.cm, m = l.display, p = l.doc;
        if (i.updatedDisplay && No(l, i.update), m.wheelStartX != null && (i.scrollTop != null || i.scrollLeft != null || i.scrollToPos) && (m.wheelStartX = m.wheelStartY = null), i.scrollTop != null && Mo(l, i.scrollTop, i.forceScroll), i.scrollLeft != null && Pr(l, i.scrollLeft, !0, !0), i.scrollToPos) {
          var y = ol(
            l,
            mt(p, i.scrollToPos.from),
            mt(p, i.scrollToPos.to),
            i.scrollToPos.margin
          );
          il(l, y);
        }
        var S = i.maybeHiddenMarkers, R = i.maybeUnhiddenMarkers;
        if (S)
          for (var N = 0; N < S.length; ++N)
            S[N].lines.length || Tt(S[N], "hide");
        if (R)
          for (var H = 0; H < R.length; ++H)
            R[H].lines.length && Tt(R[H], "unhide");
        m.wrapper.offsetHeight && (p.scrollTop = l.display.scroller.scrollTop), i.changeObjs && Tt(l, "changes", l, i.changeObjs), i.update && i.update.finish();
      }
      function $n(i, l) {
        if (i.curOp)
          return l();
        Dr(i);
        try {
          return l();
        } finally {
          Rr(i);
        }
      }
      function Qt(i, l) {
        return function() {
          if (i.curOp)
            return l.apply(i, arguments);
          Dr(i);
          try {
            return l.apply(i, arguments);
          } finally {
            Rr(i);
          }
        };
      }
      function hn(i) {
        return function() {
          if (this.curOp)
            return i.apply(this, arguments);
          Dr(this);
          try {
            return i.apply(this, arguments);
          } finally {
            Rr(this);
          }
        };
      }
      function en(i) {
        return function() {
          var l = this.cm;
          if (!l || l.curOp)
            return i.apply(this, arguments);
          Dr(l);
          try {
            return i.apply(this, arguments);
          } finally {
            Rr(l);
          }
        };
      }
      function _a(i, l) {
        i.doc.highlightFrontier < i.display.viewTo && i.state.highlight.set(l, oe(gl, i));
      }
      function gl(i) {
        var l = i.doc;
        if (!(l.highlightFrontier >= i.display.viewTo)) {
          var m = +/* @__PURE__ */ new Date() + i.options.workTime, p = kr(i, l.highlightFrontier), y = [];
          l.iter(p.line, Math.min(l.first + l.size, i.display.viewTo + 500), function(S) {
            if (p.line >= i.display.viewFrom) {
              var R = S.styles, N = S.text.length > i.options.maxHighlightLength ? On(l.mode, p.state) : null, H = Ia(i, S, p, !0);
              N && (p.state = N), S.styles = H.styles;
              var Y = S.styleClasses, le = H.classes;
              le ? S.styleClasses = le : Y && (S.styleClasses = null);
              for (var he = !R || R.length != S.styles.length || Y != le && (!Y || !le || Y.bgClass != le.bgClass || Y.textClass != le.textClass), Pe = 0; !he && Pe < R.length; ++Pe)
                he = R[Pe] != S.styles[Pe];
              he && y.push(p.line), S.stateAfter = p.save(), p.nextLine();
            } else
              S.text.length <= i.options.maxHighlightLength && ar(i, S.text, p), S.stateAfter = p.line % 5 == 0 ? p.save() : null, p.nextLine();
            if (+/* @__PURE__ */ new Date() > m)
              return _a(i, i.options.workDelay), !0;
          }), l.highlightFrontier = p.line, l.modeFrontier = Math.max(l.modeFrontier, p.line), y.length && $n(i, function() {
            for (var S = 0; S < y.length; S++)
              or(i, y[S], "text");
          });
        }
      }
      var ei = function(i, l, m) {
        var p = i.display;
        this.viewport = l, this.visible = Ja(p, i.doc, l), this.editorIsHidden = !p.wrapper.offsetWidth, this.wrapperHeight = p.wrapper.clientHeight, this.wrapperWidth = p.wrapper.clientWidth, this.oldDisplayWidth = $r(i), this.force = m, this.dims = Ai(i), this.events = [];
      };
      ei.prototype.signal = function(i, l) {
        rn(i, l) && this.events.push(arguments);
      }, ei.prototype.finish = function() {
        for (var i = 0; i < this.events.length; i++)
          Tt.apply(null, this.events[i]);
      };
      function vl(i) {
        var l = i.display;
        !l.scrollbarsClipped && l.scroller.offsetWidth && (l.nativeBarWidth = l.scroller.offsetWidth - l.scroller.clientWidth, l.heightForcer.style.height = Un(i) + "px", l.sizer.style.marginBottom = -l.nativeBarWidth + "px", l.sizer.style.borderRightWidth = Un(i) + "px", l.scrollbarsClipped = !0);
      }
      function yl(i) {
        if (i.hasFocus())
          return null;
        var l = X(G(i));
        if (!l || !z(i.display.lineDiv, l))
          return null;
        var m = { activeElt: l };
        if (window.getSelection) {
          var p = ie(i).getSelection();
          p.anchorNode && p.extend && z(i.display.lineDiv, p.anchorNode) && (m.anchorNode = p.anchorNode, m.anchorOffset = p.anchorOffset, m.focusNode = p.focusNode, m.focusOffset = p.focusOffset);
        }
        return m;
      }
      function bl(i) {
        if (!(!i || !i.activeElt || i.activeElt == X(i.activeElt.ownerDocument)) && (i.activeElt.focus(), !/^(INPUT|TEXTAREA)$/.test(i.activeElt.nodeName) && i.anchorNode && z(document.body, i.anchorNode) && z(document.body, i.focusNode))) {
          var l = i.activeElt.ownerDocument, m = l.defaultView.getSelection(), p = l.createRange();
          p.setEnd(i.anchorNode, i.anchorOffset), p.collapse(!1), m.removeAllRanges(), m.addRange(p), m.extend(i.focusNode, i.focusOffset);
        }
      }
      function Vi(i, l) {
        var m = i.display, p = i.doc;
        if (l.editorIsHidden)
          return sr(i), !1;
        if (!l.force && l.visible.from >= m.viewFrom && l.visible.to <= m.viewTo && (m.updateLineNumbers == null || m.updateLineNumbers >= m.viewTo) && m.renderedView == m.view && To(i) == 0)
          return !1;
        Fo(i) && (sr(i), l.dims = Ai(i));
        var y = p.first + p.size, S = Math.max(l.visible.from - i.options.viewportMargin, p.first), R = Math.min(y, l.visible.to + i.options.viewportMargin);
        m.viewFrom < S && S - m.viewFrom < 20 && (S = Math.max(p.first, m.viewFrom)), m.viewTo > R && m.viewTo - R < 20 && (R = Math.min(y, m.viewTo)), Pn && (S = ae(i.doc, S), R = fe(i.doc, R));
        var N = S != m.viewFrom || R != m.viewTo || m.lastWrapHeight != l.wrapperHeight || m.lastWrapWidth != l.wrapperWidth;
        rl(i, S, R), m.viewOffset = _e(ut(i.doc, m.viewFrom)), i.display.mover.style.top = m.viewOffset + "px";
        var H = To(i);
        if (!N && H == 0 && !l.force && m.renderedView == m.view && (m.updateLineNumbers == null || m.updateLineNumbers >= m.viewTo))
          return !1;
        var Y = yl(i);
        return H > 4 && (m.lineDiv.style.display = "none"), xl(i, m.updateLineNumbers, l.dims), H > 4 && (m.lineDiv.style.display = ""), m.renderedView = m.view, bl(Y), J(m.cursorDiv), J(m.selectionDiv), m.gutters.style.height = m.sizer.style.minHeight = 0, N && (m.lastWrapHeight = l.wrapperHeight, m.lastWrapWidth = l.wrapperWidth, _a(i, 400)), m.updateLineNumbers = null, !0;
      }
      function No(i, l) {
        for (var m = l.viewport, p = !0; ; p = !1) {
          if (!p || !i.options.lineWrapping || l.oldDisplayWidth == $r(i)) {
            if (m && m.top != null && (m = { top: Math.min(i.doc.height + wi(i.display) - ki(i), m.top) }), l.visible = Ja(i.display, i.doc, m), l.visible.from >= i.display.viewFrom && l.visible.to <= i.display.viewTo)
              break;
          } else p && (l.visible = Ja(i.display, i.doc, m));
          if (!Vi(i, l))
            break;
          Za(i);
          var y = wa(i);
          ya(i), Yr(i, y), Fi(i, y), l.force = !1;
        }
        l.signal(i, "update", i), (i.display.viewFrom != i.display.reportedViewFrom || i.display.viewTo != i.display.reportedViewTo) && (l.signal(i, "viewportChange", i, i.display.viewFrom, i.display.viewTo), i.display.reportedViewFrom = i.display.viewFrom, i.display.reportedViewTo = i.display.viewTo);
      }
      function Ni(i, l) {
        var m = new ei(i, l);
        if (Vi(i, m)) {
          Za(i), No(i, m);
          var p = wa(i);
          ya(i), Yr(i, p), Fi(i, p), m.finish();
        }
      }
      function xl(i, l, m) {
        var p = i.display, y = i.options.lineNumbers, S = p.lineDiv, R = S.firstChild;
        function N(Ve) {
          var Ke = Ve.nextSibling;
          return v && T && i.display.currentWheelTarget == Ve ? Ve.style.display = "none" : Ve.parentNode.removeChild(Ve), Ke;
        }
        for (var H = p.view, Y = p.viewFrom, le = 0; le < H.length; le++) {
          var he = H[le];
          if (!he.hidden) if (!he.node || he.node.parentNode != S) {
            var Pe = Ks(i, he, Y, m);
            S.insertBefore(Pe, R);
          } else {
            for (; R != he.node; )
              R = N(R);
            var Ee = y && l != null && l <= Y && he.lineNumber;
            he.changes && (Ae(he.changes, "gutter") > -1 && (Ee = !1), lo(i, he, Y, m)), Ee && (J(he.lineNumber), he.lineNumber.appendChild(document.createTextNode(ge(i.options, Y)))), R = he.node.nextSibling;
          }
          Y += he.size;
        }
        for (; R; )
          R = N(R);
      }
      function Ii(i) {
        var l = i.gutters.offsetWidth;
        i.sizer.style.marginLeft = l + "px", Jt(i, "gutterChanged", i);
      }
      function Fi(i, l) {
        i.display.sizer.style.minHeight = l.docHeight + "px", i.display.heightForcer.style.top = l.docHeight + "px", i.display.gutters.style.height = l.docHeight + i.display.barHeight + Un(i) + "px";
      }
      function Io(i) {
        var l = i.display, m = l.view;
        if (!(!l.alignWidgets && (!l.gutters.firstChild || !i.options.fixedGutter))) {
          for (var p = Ti(l) - l.scroller.scrollLeft + i.doc.scrollLeft, y = l.gutters.offsetWidth, S = p + "px", R = 0; R < m.length; R++)
            if (!m[R].hidden) {
              i.options.fixedGutter && (m[R].gutter && (m[R].gutter.style.left = S), m[R].gutterBackground && (m[R].gutterBackground.style.left = S));
              var N = m[R].alignable;
              if (N)
                for (var H = 0; H < N.length; H++)
                  N[H].style.left = S;
            }
          i.options.fixedGutter && (l.gutters.style.left = p + y + "px");
        }
      }
      function Fo(i) {
        if (!i.options.lineNumbers)
          return !1;
        var l = i.doc, m = ge(i.options, l.first + l.size - 1), p = i.display;
        if (m.length != p.lineNumChars) {
          var y = p.measure.appendChild(V(
            "div",
            [V("div", m)],
            "CodeMirror-linenumber CodeMirror-gutter-elt"
          )), S = y.firstChild.offsetWidth, R = y.offsetWidth - S;
          return p.lineGutter.style.width = "", p.lineNumInnerWidth = Math.max(S, p.lineGutter.offsetWidth - R) + 1, p.lineNumWidth = p.lineNumInnerWidth + R, p.lineNumChars = p.lineNumInnerWidth ? m.length : -1, p.lineGutter.style.width = p.lineNumWidth + "px", Ii(i.display), !0;
        }
        return !1;
      }
      function zi(i, l) {
        for (var m = [], p = !1, y = 0; y < i.length; y++) {
          var S = i[y], R = null;
          if (typeof S != "string" && (R = S.style, S = S.className), S == "CodeMirror-linenumbers")
            if (l)
              p = !0;
            else
              continue;
          m.push({ className: S, style: R });
        }
        return l && !p && m.push({ className: "CodeMirror-linenumbers", style: null }), m;
      }
      function zo(i) {
        var l = i.gutters, m = i.gutterSpecs;
        J(l), i.lineGutter = null;
        for (var p = 0; p < m.length; ++p) {
          var y = m[p], S = y.className, R = y.style, N = l.appendChild(V("div", null, "CodeMirror-gutter " + S));
          R && (N.style.cssText = R), S == "CodeMirror-linenumbers" && (i.lineGutter = N, N.style.width = (i.lineNumWidth || 1) + "px");
        }
        l.style.display = m.length ? "" : "none", Ii(i);
      }
      function Sa(i) {
        zo(i.display), bn(i), Io(i);
      }
      function wl(i, l, m, p) {
        var y = this;
        this.input = m, y.scrollbarFiller = V("div", null, "CodeMirror-scrollbar-filler"), y.scrollbarFiller.setAttribute("cm-not-content", "true"), y.gutterFiller = V("div", null, "CodeMirror-gutter-filler"), y.gutterFiller.setAttribute("cm-not-content", "true"), y.lineDiv = ne("div", null, "CodeMirror-code"), y.selectionDiv = V("div", null, null, "position: relative; z-index: 1"), y.cursorDiv = V("div", null, "CodeMirror-cursors"), y.measure = V("div", null, "CodeMirror-measure"), y.lineMeasure = V("div", null, "CodeMirror-measure"), y.lineSpace = ne(
          "div",
          [y.measure, y.lineMeasure, y.selectionDiv, y.cursorDiv, y.lineDiv],
          null,
          "position: relative; outline: none"
        );
        var S = ne("div", [y.lineSpace], "CodeMirror-lines");
        y.mover = V("div", [S], null, "position: relative"), y.sizer = V("div", [y.mover], "CodeMirror-sizer"), y.sizerWidth = null, y.heightForcer = V("div", null, null, "position: absolute; height: " + be + "px; width: 1px;"), y.gutters = V("div", null, "CodeMirror-gutters"), y.lineGutter = null, y.scroller = V("div", [y.sizer, y.heightForcer, y.gutters], "CodeMirror-scroll"), y.scroller.setAttribute("tabIndex", "-1"), y.wrapper = V("div", [y.scrollbarFiller, y.gutterFiller, y.scroller], "CodeMirror"), w && C >= 105 && (y.wrapper.style.clipPath = "inset(0px)"), y.wrapper.setAttribute("translate", "no"), f && g < 8 && (y.gutters.style.zIndex = -1, y.scroller.style.paddingRight = 0), !v && !(o && _) && (y.scroller.draggable = !0), i && (i.appendChild ? i.appendChild(y.wrapper) : i(y.wrapper)), y.viewFrom = y.viewTo = l.first, y.reportedViewFrom = y.reportedViewTo = l.first, y.view = [], y.renderedView = null, y.externalMeasured = null, y.viewOffset = 0, y.lastWrapHeight = y.lastWrapWidth = 0, y.updateLineNumbers = null, y.nativeBarWidth = y.barHeight = y.barWidth = 0, y.scrollbarsClipped = !1, y.lineNumWidth = y.lineNumInnerWidth = y.lineNumChars = null, y.alignWidgets = !1, y.cachedCharWidth = y.cachedTextHeight = y.cachedPaddingH = null, y.maxLine = null, y.maxLineLength = 0, y.maxLineChanged = !1, y.wheelDX = y.wheelDY = y.wheelStartX = y.wheelStartY = null, y.shift = !1, y.selForContextMenu = null, y.activeTouch = null, y.gutterSpecs = zi(p.gutters, p.lineNumbers), zo(y), m.init(y);
      }
      var ti = 0, Xn = null;
      f ? Xn = -0.53 : o ? Xn = 15 : w ? Xn = -0.7 : E && (Xn = -1 / 3);
      function jo(i) {
        var l = i.wheelDeltaX, m = i.wheelDeltaY;
        return l == null && i.detail && i.axis == i.HORIZONTAL_AXIS && (l = i.detail), m == null && i.detail && i.axis == i.VERTICAL_AXIS ? m = i.detail : m == null && (m = i.wheelDelta), { x: l, y: m };
      }
      function kl(i) {
        var l = jo(i);
        return l.x *= Xn, l.y *= Xn, l;
      }
      function qo(i, l) {
        w && C == 102 && (i.display.chromeScrollHack == null ? i.display.sizer.style.pointerEvents = "none" : clearTimeout(i.display.chromeScrollHack), i.display.chromeScrollHack = setTimeout(function() {
          i.display.chromeScrollHack = null, i.display.sizer.style.pointerEvents = "";
        }, 100));
        var m = jo(l), p = m.x, y = m.y, S = Xn;
        l.deltaMode === 0 && (p = l.deltaX, y = l.deltaY, S = 1);
        var R = i.display, N = R.scroller, H = N.scrollWidth > N.clientWidth, Y = N.scrollHeight > N.clientHeight;
        if (p && H || y && Y) {
          if (y && T && v) {
            e: for (var le = l.target, he = R.view; le != N; le = le.parentNode)
              for (var Pe = 0; Pe < he.length; Pe++)
                if (he[Pe].node == le) {
                  i.display.currentWheelTarget = le;
                  break e;
                }
          }
          if (p && !o && !k && S != null) {
            y && Y && xa(i, Math.max(0, N.scrollTop + y * S)), Pr(i, Math.max(0, N.scrollLeft + p * S)), (!y || y && Y) && Ut(l), R.wheelStartX = null;
            return;
          }
          if (y && S != null) {
            var Ee = y * S, Ve = i.doc.scrollTop, Ke = Ve + R.wrapper.clientHeight;
            Ee < 0 ? Ve = Math.max(0, Ve + Ee - 50) : Ke = Math.min(i.doc.height, Ke + Ee + 50), Ni(i, { top: Ve, bottom: Ke });
          }
          ti < 20 && l.deltaMode !== 0 && (R.wheelStartX == null ? (R.wheelStartX = N.scrollLeft, R.wheelStartY = N.scrollTop, R.wheelDX = p, R.wheelDY = y, setTimeout(function() {
            if (R.wheelStartX != null) {
              var Ye = N.scrollLeft - R.wheelStartX, nt = N.scrollTop - R.wheelStartY, it = nt && R.wheelDY && nt / R.wheelDY || Ye && R.wheelDX && Ye / R.wheelDX;
              R.wheelStartX = R.wheelStartY = null, it && (Xn = (Xn * ti + it) / (ti + 1), ++ti);
            }
          }, 200)) : (R.wheelDX += p, R.wheelDY += y));
        }
      }
      var An = function(i, l) {
        this.ranges = i, this.primIndex = l;
      };
      An.prototype.primary = function() {
        return this.ranges[this.primIndex];
      }, An.prototype.equals = function(i) {
        if (i == this)
          return !0;
        if (i.primIndex != this.primIndex || i.ranges.length != this.ranges.length)
          return !1;
        for (var l = 0; l < this.ranges.length; l++) {
          var m = this.ranges[l], p = i.ranges[l];
          if (!ht(m.anchor, p.anchor) || !ht(m.head, p.head))
            return !1;
        }
        return !0;
      }, An.prototype.deepCopy = function() {
        for (var i = [], l = 0; l < this.ranges.length; l++)
          i[l] = new At(xt(this.ranges[l].anchor), xt(this.ranges[l].head));
        return new An(i, this.primIndex);
      }, An.prototype.somethingSelected = function() {
        for (var i = 0; i < this.ranges.length; i++)
          if (!this.ranges[i].empty())
            return !0;
        return !1;
      }, An.prototype.contains = function(i, l) {
        l || (l = i);
        for (var m = 0; m < this.ranges.length; m++) {
          var p = this.ranges[m];
          if (De(l, p.from()) >= 0 && De(i, p.to()) <= 0)
            return m;
        }
        return -1;
      };
      var At = function(i, l) {
        this.anchor = i, this.head = l;
      };
      At.prototype.from = function() {
        return It(this.anchor, this.head);
      }, At.prototype.to = function() {
        return St(this.anchor, this.head);
      }, At.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function Nn(i, l, m) {
        var p = i && i.options.selectionsMayTouch, y = l[m];
        l.sort(function(Pe, Ee) {
          return De(Pe.from(), Ee.from());
        }), m = Ae(l, y);
        for (var S = 1; S < l.length; S++) {
          var R = l[S], N = l[S - 1], H = De(N.to(), R.from());
          if (p && !R.empty() ? H > 0 : H >= 0) {
            var Y = It(N.from(), R.from()), le = St(N.to(), R.to()), he = N.empty() ? R.from() == R.head : N.from() == N.head;
            S <= m && --m, l.splice(--S, 2, new At(he ? le : Y, he ? Y : le));
          }
        }
        return new An(l, m);
      }
      function lr(i, l) {
        return new An([new At(i, l || i)], 0);
      }
      function ur(i) {
        return i.text ? xe(
          i.from.line + i.text.length - 1,
          ce(i.text).length + (i.text.length == 1 ? i.from.ch : 0)
        ) : i.to;
      }
      function Ho(i, l) {
        if (De(i, l.from) < 0)
          return i;
        if (De(i, l.to) <= 0)
          return ur(l);
        var m = i.line + l.text.length - (l.to.line - l.from.line) - 1, p = i.ch;
        return i.line == l.to.line && (p += ur(l).ch - l.to.ch), xe(m, p);
      }
      function ji(i, l) {
        for (var m = [], p = 0; p < i.sel.ranges.length; p++) {
          var y = i.sel.ranges[p];
          m.push(new At(
            Ho(y.anchor, l),
            Ho(y.head, l)
          ));
        }
        return Nn(i.cm, m, i.sel.primIndex);
      }
      function Uo(i, l, m) {
        return i.line == l.line ? xe(m.line, i.ch - l.ch + m.ch) : xe(m.line + (i.line - l.line), i.ch);
      }
      function _l(i, l, m) {
        for (var p = [], y = xe(i.first, 0), S = y, R = 0; R < l.length; R++) {
          var N = l[R], H = Uo(N.from, y, S), Y = Uo(ur(N), y, S);
          if (y = N.to, S = Y, m == "around") {
            var le = i.sel.ranges[R], he = De(le.head, le.anchor) < 0;
            p[R] = new At(he ? Y : H, he ? H : Y);
          } else
            p[R] = new At(H, H);
        }
        return new An(p, i.sel.primIndex);
      }
      function qi(i) {
        i.doc.mode = Rn(i.options, i.doc.modeOption), Ca(i);
      }
      function Ca(i) {
        i.doc.iter(function(l) {
          l.stateAfter && (l.stateAfter = null), l.styles && (l.styles = null);
        }), i.doc.modeFrontier = i.doc.highlightFrontier = i.doc.first, _a(i, 100), i.state.modeGen++, i.curOp && bn(i);
      }
      function Wo(i, l) {
        return l.from.ch == 0 && l.to.ch == 0 && ce(l.text) == "" && (!i.cm || i.cm.options.wholeLineUpdateBefore);
      }
      function Hi(i, l, m, p) {
        function y(it) {
          return m ? m[it] : null;
        }
        function S(it, rt, st) {
          Re(it, rt, st, p), Jt(it, "change", it, l);
        }
        function R(it, rt) {
          for (var st = [], ft = it; ft < rt; ++ft)
            st.push(new Me(Y[ft], y(ft), p));
          return st;
        }
        var N = l.from, H = l.to, Y = l.text, le = ut(i, N.line), he = ut(i, H.line), Pe = ce(Y), Ee = y(Y.length - 1), Ve = H.line - N.line;
        if (l.full)
          i.insert(0, R(0, Y.length)), i.remove(Y.length, i.size - Y.length);
        else if (Wo(i, l)) {
          var Ke = R(0, Y.length - 1);
          S(he, he.text, Ee), Ve && i.remove(N.line, Ve), Ke.length && i.insert(N.line, Ke);
        } else if (le == he)
          if (Y.length == 1)
            S(le, le.text.slice(0, N.ch) + Pe + le.text.slice(H.ch), Ee);
          else {
            var Ye = R(1, Y.length - 1);
            Ye.push(new Me(Pe + le.text.slice(H.ch), Ee, p)), S(le, le.text.slice(0, N.ch) + Y[0], y(0)), i.insert(N.line + 1, Ye);
          }
        else if (Y.length == 1)
          S(le, le.text.slice(0, N.ch) + Y[0] + he.text.slice(H.ch), y(0)), i.remove(N.line + 1, Ve);
        else {
          S(le, le.text.slice(0, N.ch) + Y[0], y(0)), S(he, Pe + he.text.slice(H.ch), Ee);
          var nt = R(1, Y.length - 1);
          Ve > 1 && i.remove(N.line + 1, Ve - 1), i.insert(N.line + 1, nt);
        }
        Jt(i, "change", i, l);
      }
      function cr(i, l, m) {
        function p(y, S, R) {
          if (y.linked)
            for (var N = 0; N < y.linked.length; ++N) {
              var H = y.linked[N];
              if (H.doc != S) {
                var Y = R && H.sharedHist;
                m && !Y || (l(H.doc, Y), p(H.doc, y, Y));
              }
            }
        }
        p(i, null, !0);
      }
      function Ko(i, l) {
        if (l.cm)
          throw new Error("This document is already in use.");
        i.doc = l, l.cm = i, Pi(i), qi(i), Go(i), i.options.direction = l.direction, i.options.lineWrapping || Ue(i), i.options.mode = l.modeOption, bn(i);
      }
      function Go(i) {
        (i.doc.direction == "rtl" ? ue : Z)(i.display.lineDiv, "CodeMirror-rtl");
      }
      function Sl(i) {
        $n(i, function() {
          Go(i), bn(i);
        });
      }
      function ni(i) {
        this.done = [], this.undone = [], this.undoDepth = i ? i.undoDepth : 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = i ? i.maxGeneration : 1;
      }
      function Ui(i, l) {
        var m = { from: xt(l.from), to: ur(l), text: Ln(i, l.from, l.to) };
        return Zo(i, m, l.from.line, l.to.line + 1), cr(i, function(p) {
          return Zo(p, m, l.from.line, l.to.line + 1);
        }, !0), m;
      }
      function Yo(i) {
        for (; i.length; ) {
          var l = ce(i);
          if (l.ranges)
            i.pop();
          else
            break;
        }
      }
      function Cl(i, l) {
        if (l)
          return Yo(i.done), ce(i.done);
        if (i.done.length && !ce(i.done).ranges)
          return ce(i.done);
        if (i.done.length > 1 && !i.done[i.done.length - 2].ranges)
          return i.done.pop(), ce(i.done);
      }
      function Xo(i, l, m, p) {
        var y = i.history;
        y.undone.length = 0;
        var S = +/* @__PURE__ */ new Date(), R, N;
        if ((y.lastOp == p || y.lastOrigin == l.origin && l.origin && (l.origin.charAt(0) == "+" && y.lastModTime > S - (i.cm ? i.cm.options.historyEventDelay : 500) || l.origin.charAt(0) == "*")) && (R = Cl(y, y.lastOp == p)))
          N = ce(R.changes), De(l.from, l.to) == 0 && De(l.from, N.to) == 0 ? N.to = ur(l) : R.changes.push(Ui(i, l));
        else {
          var H = ce(y.done);
          for ((!H || !H.ranges) && ri(i.sel, y.done), R = {
            changes: [Ui(i, l)],
            generation: y.generation
          }, y.done.push(R); y.done.length > y.undoDepth; )
            y.done.shift(), y.done[0].ranges || y.done.shift();
        }
        y.done.push(m), y.generation = ++y.maxGeneration, y.lastModTime = y.lastSelTime = S, y.lastOp = y.lastSelOp = p, y.lastOrigin = y.lastSelOrigin = l.origin, N || Tt(i, "historyAdded");
      }
      function $l(i, l, m, p) {
        var y = l.charAt(0);
        return y == "*" || y == "+" && m.ranges.length == p.ranges.length && m.somethingSelected() == p.somethingSelected() && /* @__PURE__ */ new Date() - i.history.lastSelTime <= (i.cm ? i.cm.options.historyEventDelay : 500);
      }
      function El(i, l, m, p) {
        var y = i.history, S = p && p.origin;
        m == y.lastSelOp || S && y.lastSelOrigin == S && (y.lastModTime == y.lastSelTime && y.lastOrigin == S || $l(i, S, ce(y.done), l)) ? y.done[y.done.length - 1] = l : ri(l, y.done), y.lastSelTime = +/* @__PURE__ */ new Date(), y.lastSelOrigin = S, y.lastSelOp = m, p && p.clearRedo !== !1 && Yo(y.undone);
      }
      function ri(i, l) {
        var m = ce(l);
        m && m.ranges && m.equals(i) || l.push(i);
      }
      function Zo(i, l, m, p) {
        var y = l["spans_" + i.id], S = 0;
        i.iter(Math.max(i.first, m), Math.min(i.first + i.size, p), function(R) {
          R.markedSpans && ((y || (y = l["spans_" + i.id] = {}))[S] = R.markedSpans), ++S;
        });
      }
      function Al(i) {
        if (!i)
          return null;
        for (var l, m = 0; m < i.length; ++m)
          i[m].marker.explicitlyCleared ? l || (l = i.slice(0, m)) : l && l.push(i[m]);
        return l ? l.length ? l : null : i;
      }
      function Tl(i, l) {
        var m = l["spans_" + i.id];
        if (!m)
          return null;
        for (var p = [], y = 0; y < l.text.length; ++y)
          p.push(Al(m[y]));
        return p;
      }
      function Jo(i, l) {
        var m = Tl(i, l), p = ca(i, l);
        if (!m)
          return p;
        if (!p)
          return m;
        for (var y = 0; y < m.length; ++y) {
          var S = m[y], R = p[y];
          if (S && R)
            e: for (var N = 0; N < R.length; ++N) {
              for (var H = R[N], Y = 0; Y < S.length; ++Y)
                if (S[Y].marker == H.marker)
                  continue e;
              S.push(H);
            }
          else R && (m[y] = R);
        }
        return m;
      }
      function Xr(i, l, m) {
        for (var p = [], y = 0; y < i.length; ++y) {
          var S = i[y];
          if (S.ranges) {
            p.push(m ? An.prototype.deepCopy.call(S) : S);
            continue;
          }
          var R = S.changes, N = [];
          p.push({ changes: N });
          for (var H = 0; H < R.length; ++H) {
            var Y = R[H], le = void 0;
            if (N.push({ from: Y.from, to: Y.to, text: Y.text }), l)
              for (var he in Y)
                (le = he.match(/^spans_(\d+)$/)) && Ae(l, Number(le[1])) > -1 && (ce(N)[he] = Y[he], delete Y[he]);
          }
        }
        return p;
      }
      function Wi(i, l, m, p) {
        if (p) {
          var y = i.anchor;
          if (m) {
            var S = De(l, y) < 0;
            S != De(m, y) < 0 ? (y = l, l = m) : S != De(l, m) < 0 && (l = m);
          }
          return new At(y, l);
        } else
          return new At(m || l, l);
      }
      function ai(i, l, m, p, y) {
        y == null && (y = i.cm && (i.cm.display.shift || i.extend)), cn(i, new An([Wi(i.sel.primary(), l, m, y)], 0), p);
      }
      function Qo(i, l, m) {
        for (var p = [], y = i.cm && (i.cm.display.shift || i.extend), S = 0; S < i.sel.ranges.length; S++)
          p[S] = Wi(i.sel.ranges[S], l[S], null, y);
        var R = Nn(i.cm, p, i.sel.primIndex);
        cn(i, R, m);
      }
      function Ki(i, l, m, p) {
        var y = i.sel.ranges.slice(0);
        y[l] = m, cn(i, Nn(i.cm, y, i.sel.primIndex), p);
      }
      function es(i, l, m, p) {
        cn(i, lr(l, m), p);
      }
      function Pl(i, l, m) {
        var p = {
          ranges: l.ranges,
          update: function(y) {
            this.ranges = [];
            for (var S = 0; S < y.length; S++)
              this.ranges[S] = new At(
                mt(i, y[S].anchor),
                mt(i, y[S].head)
              );
          },
          origin: m && m.origin
        };
        return Tt(i, "beforeSelectionChange", i, p), i.cm && Tt(i.cm, "beforeSelectionChange", i.cm, p), p.ranges != l.ranges ? Nn(i.cm, p.ranges, p.ranges.length - 1) : l;
      }
      function ts(i, l, m) {
        var p = i.history.done, y = ce(p);
        y && y.ranges ? (p[p.length - 1] = l, ii(i, l, m)) : cn(i, l, m);
      }
      function cn(i, l, m) {
        ii(i, l, m), El(i, i.sel, i.cm ? i.cm.curOp.id : NaN, m);
      }
      function ii(i, l, m) {
        (rn(i, "beforeSelectionChange") || i.cm && rn(i.cm, "beforeSelectionChange")) && (l = Pl(i, l, m));
        var p = m && m.bias || (De(l.primary().head, i.sel.primary().head) < 0 ? -1 : 1);
        ns(i, as(i, l, p, !0)), !(m && m.scroll === !1) && i.cm && i.cm.getOption("readOnly") != "nocursor" && Gr(i.cm);
      }
      function ns(i, l) {
        l.equals(i.sel) || (i.sel = l, i.cm && (i.cm.curOp.updateInput = 1, i.cm.curOp.selectionChanged = !0, Qn(i.cm)), Jt(i, "cursorActivity", i));
      }
      function rs(i) {
        ns(i, as(i, i.sel, null, !1));
      }
      function as(i, l, m, p) {
        for (var y, S = 0; S < l.ranges.length; S++) {
          var R = l.ranges[S], N = l.ranges.length == i.sel.ranges.length && i.sel.ranges[S], H = oi(i, R.anchor, N && N.anchor, m, p), Y = R.head == R.anchor ? H : oi(i, R.head, N && N.head, m, p);
          (y || H != R.anchor || Y != R.head) && (y || (y = l.ranges.slice(0, S)), y[S] = new At(H, Y));
        }
        return y ? Nn(i.cm, y, l.primIndex) : l;
      }
      function Zr(i, l, m, p, y) {
        var S = ut(i, l.line);
        if (S.markedSpans)
          for (var R = 0; R < S.markedSpans.length; ++R) {
            var N = S.markedSpans[R], H = N.marker, Y = "selectLeft" in H ? !H.selectLeft : H.inclusiveLeft, le = "selectRight" in H ? !H.selectRight : H.inclusiveRight;
            if ((N.from == null || (Y ? N.from <= l.ch : N.from < l.ch)) && (N.to == null || (le ? N.to >= l.ch : N.to > l.ch))) {
              if (y && (Tt(H, "beforeCursorEnter"), H.explicitlyCleared))
                if (S.markedSpans) {
                  --R;
                  continue;
                } else
                  break;
              if (!H.atomic)
                continue;
              if (m) {
                var he = H.find(p < 0 ? 1 : -1), Pe = void 0;
                if ((p < 0 ? le : Y) && (he = is(i, he, -p, he && he.line == l.line ? S : null)), he && he.line == l.line && (Pe = De(he, m)) && (p < 0 ? Pe < 0 : Pe > 0))
                  return Zr(i, he, l, p, y);
              }
              var Ee = H.find(p < 0 ? -1 : 1);
              return (p < 0 ? Y : le) && (Ee = is(i, Ee, p, Ee.line == l.line ? S : null)), Ee ? Zr(i, Ee, l, p, y) : null;
            }
          }
        return l;
      }
      function oi(i, l, m, p, y) {
        var S = p || 1, R = Zr(i, l, m, S, y) || !y && Zr(i, l, m, S, !0) || Zr(i, l, m, -S, y) || !y && Zr(i, l, m, -S, !0);
        return R || (i.cantEdit = !0, xe(i.first, 0));
      }
      function is(i, l, m, p) {
        return m < 0 && l.ch == 0 ? l.line > i.first ? mt(i, xe(l.line - 1)) : null : m > 0 && l.ch == (p || ut(i, l.line)).text.length ? l.line < i.first + i.size - 1 ? xe(l.line + 1, 0) : null : new xe(l.line, l.ch + m);
      }
      function os(i) {
        i.setSelection(xe(i.firstLine(), 0), xe(i.lastLine()), Se);
      }
      function ss(i, l, m) {
        var p = {
          canceled: !1,
          from: l.from,
          to: l.to,
          text: l.text,
          origin: l.origin,
          cancel: function() {
            return p.canceled = !0;
          }
        };
        return m && (p.update = function(y, S, R, N) {
          y && (p.from = mt(i, y)), S && (p.to = mt(i, S)), R && (p.text = R), N !== void 0 && (p.origin = N);
        }), Tt(i, "beforeChange", i, p), i.cm && Tt(i.cm, "beforeChange", i.cm, p), p.canceled ? (i.cm && (i.cm.curOp.updateInput = 2), null) : { from: p.from, to: p.to, text: p.text, origin: p.origin };
      }
      function Jr(i, l, m) {
        if (i.cm) {
          if (!i.cm.curOp)
            return Qt(i.cm, Jr)(i, l, m);
          if (i.cm.state.suppressEdits)
            return;
        }
        if (!((rn(i, "beforeChange") || i.cm && rn(i.cm, "beforeChange")) && (l = ss(i, l, !0), !l))) {
          var p = ua && !m && Ha(i, l.from, l.to);
          if (p)
            for (var y = p.length - 1; y >= 0; --y)
              ls(i, { from: p[y].from, to: p[y].to, text: y ? [""] : l.text, origin: l.origin });
          else
            ls(i, l);
        }
      }
      function ls(i, l) {
        if (!(l.text.length == 1 && l.text[0] == "" && De(l.from, l.to) == 0)) {
          var m = ji(i, l);
          Xo(i, l, m, i.cm ? i.cm.curOp.id : NaN), $a(i, l, m, ca(i, l));
          var p = [];
          cr(i, function(y, S) {
            !S && Ae(p, y.history) == -1 && (fs(y.history, l), p.push(y.history)), $a(y, l, null, ca(y, l));
          });
        }
      }
      function si(i, l, m) {
        var p = i.cm && i.cm.state.suppressEdits;
        if (!(p && !m)) {
          for (var y = i.history, S, R = i.sel, N = l == "undo" ? y.done : y.undone, H = l == "undo" ? y.undone : y.done, Y = 0; Y < N.length && (S = N[Y], !(m ? S.ranges && !S.equals(i.sel) : !S.ranges)); Y++)
            ;
          if (Y != N.length) {
            for (y.lastOrigin = y.lastSelOrigin = null; ; )
              if (S = N.pop(), S.ranges) {
                if (ri(S, H), m && !S.equals(i.sel)) {
                  cn(i, S, { clearRedo: !1 });
                  return;
                }
                R = S;
              } else if (p) {
                N.push(S);
                return;
              } else
                break;
            var le = [];
            ri(R, H), H.push({ changes: le, generation: y.generation }), y.generation = S.generation || ++y.maxGeneration;
            for (var he = rn(i, "beforeChange") || i.cm && rn(i.cm, "beforeChange"), Pe = function(Ke) {
              var Ye = S.changes[Ke];
              if (Ye.origin = l, he && !ss(i, Ye, !1))
                return N.length = 0, {};
              le.push(Ui(i, Ye));
              var nt = Ke ? ji(i, Ye) : ce(N);
              $a(i, Ye, nt, Jo(i, Ye)), !Ke && i.cm && i.cm.scrollIntoView({ from: Ye.from, to: ur(Ye) });
              var it = [];
              cr(i, function(rt, st) {
                !st && Ae(it, rt.history) == -1 && (fs(rt.history, Ye), it.push(rt.history)), $a(rt, Ye, null, Jo(rt, Ye));
              });
            }, Ee = S.changes.length - 1; Ee >= 0; --Ee) {
              var Ve = Pe(Ee);
              if (Ve) return Ve.v;
            }
          }
        }
      }
      function us(i, l) {
        if (l != 0 && (i.first += l, i.sel = new An(pe(i.sel.ranges, function(y) {
          return new At(
            xe(y.anchor.line + l, y.anchor.ch),
            xe(y.head.line + l, y.head.ch)
          );
        }), i.sel.primIndex), i.cm)) {
          bn(i.cm, i.first, i.first - l, l);
          for (var m = i.cm.display, p = m.viewFrom; p < m.viewTo; p++)
            or(i.cm, p, "gutter");
        }
      }
      function $a(i, l, m, p) {
        if (i.cm && !i.cm.curOp)
          return Qt(i.cm, $a)(i, l, m, p);
        if (l.to.line < i.first) {
          us(i, l.text.length - 1 - (l.to.line - l.from.line));
          return;
        }
        if (!(l.from.line > i.lastLine())) {
          if (l.from.line < i.first) {
            var y = l.text.length - 1 - (i.first - l.from.line);
            us(i, y), l = {
              from: xe(i.first, 0),
              to: xe(l.to.line + y, l.to.ch),
              text: [ce(l.text)],
              origin: l.origin
            };
          }
          var S = i.lastLine();
          l.to.line > S && (l = {
            from: l.from,
            to: xe(S, ut(i, S).text.length),
            text: [l.text[0]],
            origin: l.origin
          }), l.removed = Ln(i, l.from, l.to), m || (m = ji(i, l)), i.cm ? Bl(i.cm, l, p) : Hi(i, l, p), ii(i, m, Se), i.cantEdit && oi(i, xe(i.firstLine(), 0)) && (i.cantEdit = !1);
        }
      }
      function Bl(i, l, m) {
        var p = i.doc, y = i.display, S = l.from, R = l.to, N = !1, H = S.line;
        i.options.lineWrapping || (H = _t(L(ut(p, S.line))), p.iter(H, R.line + 1, function(Ee) {
          if (Ee == y.maxLine)
            return N = !0, !0;
        })), p.sel.contains(l.from, l.to) > -1 && Qn(i), Hi(p, l, m, Ao(i)), i.options.lineWrapping || (p.iter(H, S.line + l.text.length, function(Ee) {
          var Ve = Le(Ee);
          Ve > y.maxLineLength && (y.maxLine = Ee, y.maxLineLength = Ve, y.maxLineChanged = !0, N = !1);
        }), N && (i.curOp.updateMaxLine = !0)), qa(p, S.line), _a(i, 400);
        var Y = l.text.length - (R.line - S.line) - 1;
        l.full ? bn(i) : S.line == R.line && l.text.length == 1 && !Wo(i.doc, l) ? or(i, S.line, "text") : bn(i, S.line, R.line + 1, Y);
        var le = rn(i, "changes"), he = rn(i, "change");
        if (he || le) {
          var Pe = {
            from: S,
            to: R,
            text: l.text,
            removed: l.removed,
            origin: l.origin
          };
          he && Jt(i, "change", i, Pe), le && (i.curOp.changeObjs || (i.curOp.changeObjs = [])).push(Pe);
        }
        i.display.selForContextMenu = null;
      }
      function Qr(i, l, m, p, y) {
        var S;
        p || (p = m), De(p, m) < 0 && (S = [p, m], m = S[0], p = S[1]), typeof l == "string" && (l = i.splitLines(l)), Jr(i, { from: m, to: p, text: l, origin: y });
      }
      function cs(i, l, m, p) {
        m < i.line ? i.line += p : l < i.line && (i.line = l, i.ch = 0);
      }
      function ds(i, l, m, p) {
        for (var y = 0; y < i.length; ++y) {
          var S = i[y], R = !0;
          if (S.ranges) {
            S.copied || (S = i[y] = S.deepCopy(), S.copied = !0);
            for (var N = 0; N < S.ranges.length; N++)
              cs(S.ranges[N].anchor, l, m, p), cs(S.ranges[N].head, l, m, p);
            continue;
          }
          for (var H = 0; H < S.changes.length; ++H) {
            var Y = S.changes[H];
            if (m < Y.from.line)
              Y.from = xe(Y.from.line + p, Y.from.ch), Y.to = xe(Y.to.line + p, Y.to.ch);
            else if (l <= Y.to.line) {
              R = !1;
              break;
            }
          }
          R || (i.splice(0, y + 1), y = 0);
        }
      }
      function fs(i, l) {
        var m = l.from.line, p = l.to.line, y = l.text.length - (p - m) - 1;
        ds(i.done, m, p, y), ds(i.undone, m, p, y);
      }
      function Ea(i, l, m, p) {
        var y = l, S = l;
        return typeof l == "number" ? S = ut(i, vn(i, l)) : y = _t(l), y == null ? null : (p(S, y) && i.cm && or(i.cm, y, m), S);
      }
      function Aa(i) {
        this.lines = i, this.parent = null;
        for (var l = 0, m = 0; m < i.length; ++m)
          i[m].parent = this, l += i[m].height;
        this.height = l;
      }
      Aa.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        // Remove the n lines at offset 'at'.
        removeInner: function(i, l) {
          for (var m = i, p = i + l; m < p; ++m) {
            var y = this.lines[m];
            this.height -= y.height, at(y), Jt(y, "delete");
          }
          this.lines.splice(i, l);
        },
        // Helper used to collapse a small branch into a single leaf.
        collapse: function(i) {
          i.push.apply(i, this.lines);
        },
        // Insert the given array of lines at offset 'at', count them as
        // having the given height.
        insertInner: function(i, l, m) {
          this.height += m, this.lines = this.lines.slice(0, i).concat(l).concat(this.lines.slice(i));
          for (var p = 0; p < l.length; ++p)
            l[p].parent = this;
        },
        // Used to iterate over a part of the tree.
        iterN: function(i, l, m) {
          for (var p = i + l; i < p; ++i)
            if (m(this.lines[i]))
              return !0;
        }
      };
      function Ta(i) {
        this.children = i;
        for (var l = 0, m = 0, p = 0; p < i.length; ++p) {
          var y = i[p];
          l += y.chunkSize(), m += y.height, y.parent = this;
        }
        this.size = l, this.height = m, this.parent = null;
      }
      Ta.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(i, l) {
          this.size -= l;
          for (var m = 0; m < this.children.length; ++m) {
            var p = this.children[m], y = p.chunkSize();
            if (i < y) {
              var S = Math.min(l, y - i), R = p.height;
              if (p.removeInner(i, S), this.height -= R - p.height, y == S && (this.children.splice(m--, 1), p.parent = null), (l -= S) == 0)
                break;
              i = 0;
            } else
              i -= y;
          }
          if (this.size - l < 25 && (this.children.length > 1 || !(this.children[0] instanceof Aa))) {
            var N = [];
            this.collapse(N), this.children = [new Aa(N)], this.children[0].parent = this;
          }
        },
        collapse: function(i) {
          for (var l = 0; l < this.children.length; ++l)
            this.children[l].collapse(i);
        },
        insertInner: function(i, l, m) {
          this.size += l.length, this.height += m;
          for (var p = 0; p < this.children.length; ++p) {
            var y = this.children[p], S = y.chunkSize();
            if (i <= S) {
              if (y.insertInner(i, l, m), y.lines && y.lines.length > 50) {
                for (var R = y.lines.length % 25 + 25, N = R; N < y.lines.length; ) {
                  var H = new Aa(y.lines.slice(N, N += 25));
                  y.height -= H.height, this.children.splice(++p, 0, H), H.parent = this;
                }
                y.lines = y.lines.slice(0, R), this.maybeSpill();
              }
              break;
            }
            i -= S;
          }
        },
        // When a node has grown, check whether it should be split.
        maybeSpill: function() {
          if (!(this.children.length <= 10)) {
            var i = this;
            do {
              var l = i.children.splice(i.children.length - 5, 5), m = new Ta(l);
              if (i.parent) {
                i.size -= m.size, i.height -= m.height;
                var y = Ae(i.parent.children, i);
                i.parent.children.splice(y + 1, 0, m);
              } else {
                var p = new Ta(i.children);
                p.parent = i, i.children = [p, m], i = p;
              }
              m.parent = i.parent;
            } while (i.children.length > 10);
            i.parent.maybeSpill();
          }
        },
        iterN: function(i, l, m) {
          for (var p = 0; p < this.children.length; ++p) {
            var y = this.children[p], S = y.chunkSize();
            if (i < S) {
              var R = Math.min(l, S - i);
              if (y.iterN(i, R, m))
                return !0;
              if ((l -= R) == 0)
                break;
              i = 0;
            } else
              i -= S;
          }
        }
      };
      var Pa = function(i, l, m) {
        if (m)
          for (var p in m)
            m.hasOwnProperty(p) && (this[p] = m[p]);
        this.doc = i, this.node = l;
      };
      Pa.prototype.clear = function() {
        var i = this.doc.cm, l = this.line.widgets, m = this.line, p = _t(m);
        if (!(p == null || !l)) {
          for (var y = 0; y < l.length; ++y)
            l[y] == this && l.splice(y--, 1);
          l.length || (m.widgets = null);
          var S = ga(this);
          Cn(m, Math.max(0, m.height - S)), i && ($n(i, function() {
            ps(i, m, -S), or(i, p, "widget");
          }), Jt(i, "lineWidgetCleared", i, this, p));
        }
      }, Pa.prototype.changed = function() {
        var i = this, l = this.height, m = this.doc.cm, p = this.line;
        this.height = null;
        var y = ga(this) - l;
        y && (se(this.doc, p) || Cn(p, p.height + y), m && $n(m, function() {
          m.curOp.forceUpdate = !0, ps(m, p, y), Jt(m, "lineWidgetChanged", m, i, _t(p));
        }));
      }, an(Pa);
      function ps(i, l, m) {
        _e(l) < (i.curOp && i.curOp.scrollTop || i.doc.scrollTop) && Li(i, m);
      }
      function Dl(i, l, m, p) {
        var y = new Pa(i, m, p), S = i.cm;
        return S && y.noHScroll && (S.display.alignWidgets = !0), Ea(i, l, "widget", function(R) {
          var N = R.widgets || (R.widgets = []);
          if (y.insertAt == null ? N.push(y) : N.splice(Math.min(N.length, Math.max(0, y.insertAt)), 0, y), y.line = R, S && !se(i, R)) {
            var H = _e(R) < i.scrollTop;
            Cn(R, R.height + ga(y)), H && Li(S, y.height), S.curOp.forceUpdate = !0;
          }
          return !0;
        }), S && Jt(S, "lineWidgetAdded", S, y, typeof l == "number" ? l : _t(l)), y;
      }
      var hs = 0, dr = function(i, l) {
        this.lines = [], this.type = l, this.doc = i, this.id = ++hs;
      };
      dr.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          var i = this.doc.cm, l = i && !i.curOp;
          if (l && Dr(i), rn(this, "clear")) {
            var m = this.find();
            m && Jt(this, "clear", m.from, m.to);
          }
          for (var p = null, y = null, S = 0; S < this.lines.length; ++S) {
            var R = this.lines[S], N = ir(R.markedSpans, this);
            i && !this.collapsed ? or(i, _t(R), "text") : i && (N.to != null && (y = _t(R)), N.from != null && (p = _t(R))), R.markedSpans = gi(R.markedSpans, N), N.from == null && this.collapsed && !se(this.doc, R) && i && Cn(R, Ur(i.display));
          }
          if (i && this.collapsed && !i.options.lineWrapping)
            for (var H = 0; H < this.lines.length; ++H) {
              var Y = L(this.lines[H]), le = Le(Y);
              le > i.display.maxLineLength && (i.display.maxLine = Y, i.display.maxLineLength = le, i.display.maxLineChanged = !0);
            }
          p != null && i && this.collapsed && bn(i, p, y + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, i && rs(i.doc)), i && Jt(i, "markerCleared", i, this, p, y), l && Rr(i), this.parent && this.parent.clear();
        }
      }, dr.prototype.find = function(i, l) {
        i == null && this.type == "bookmark" && (i = 1);
        for (var m, p, y = 0; y < this.lines.length; ++y) {
          var S = this.lines[y], R = ir(S.markedSpans, this);
          if (R.from != null && (m = xe(l ? S : _t(S), R.from), i == -1))
            return m;
          if (R.to != null && (p = xe(l ? S : _t(S), R.to), i == 1))
            return p;
        }
        return m && { from: m, to: p };
      }, dr.prototype.changed = function() {
        var i = this, l = this.find(-1, !0), m = this, p = this.doc.cm;
        !l || !p || $n(p, function() {
          var y = l.line, S = _t(l.line), R = _i(p, S);
          if (R && (xo(R), p.curOp.selectionChanged = p.curOp.forceUpdate = !0), p.curOp.updateMaxLine = !0, !se(m.doc, y) && m.height != null) {
            var N = m.height;
            m.height = null;
            var H = ga(m) - N;
            H && Cn(y, y.height + H);
          }
          Jt(p, "markerChanged", p, i);
        });
      }, dr.prototype.attachLine = function(i) {
        if (!this.lines.length && this.doc.cm) {
          var l = this.doc.cm.curOp;
          (!l.maybeHiddenMarkers || Ae(l.maybeHiddenMarkers, this) == -1) && (l.maybeUnhiddenMarkers || (l.maybeUnhiddenMarkers = [])).push(this);
        }
        this.lines.push(i);
      }, dr.prototype.detachLine = function(i) {
        if (this.lines.splice(Ae(this.lines, i), 1), !this.lines.length && this.doc.cm) {
          var l = this.doc.cm.curOp;
          (l.maybeHiddenMarkers || (l.maybeHiddenMarkers = [])).push(this);
        }
      }, an(dr);
      function ea(i, l, m, p, y) {
        if (p && p.shared)
          return Rl(i, l, m, p, y);
        if (i.cm && !i.cm.curOp)
          return Qt(i.cm, ea)(i, l, m, p, y);
        var S = new dr(i, y), R = De(l, m);
        if (p && ye(p, S, !1), R > 0 || R == 0 && S.clearWhenEmpty !== !1)
          return S;
        if (S.replacedWith && (S.collapsed = !0, S.widgetNode = ne("span", [S.replacedWith], "CodeMirror-widget"), p.handleMouseEvents || S.widgetNode.setAttribute("cm-ignore-events", "true"), p.insertLeft && (S.widgetNode.insertLeft = !0)), S.collapsed) {
          if (D(i, l.line, l, m, S) || l.line != m.line && D(i, m.line, l, m, S))
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          mi();
        }
        S.addToHistory && Xo(i, { from: l, to: m, origin: "markText" }, i.sel, NaN);
        var N = l.line, H = i.cm, Y;
        if (i.iter(N, m.line + 1, function(he) {
          H && S.collapsed && !H.options.lineWrapping && L(he) == H.display.maxLine && (Y = !0), S.collapsed && N != l.line && Cn(he, 0), vi(he, new Hn(
            S,
            N == l.line ? l.ch : null,
            N == m.line ? m.ch : null
          ), i.cm && i.cm.curOp), ++N;
        }), S.collapsed && i.iter(l.line, m.line + 1, function(he) {
          se(i, he) && Cn(he, 0);
        }), S.clearOnEnter && qe(S, "beforeCursorEnter", function() {
          return S.clear();
        }), S.readOnly && (Bn(), (i.history.done.length || i.history.undone.length) && i.clearHistory()), S.collapsed && (S.id = ++hs, S.atomic = !0), H) {
          if (Y && (H.curOp.updateMaxLine = !0), S.collapsed)
            bn(H, l.line, m.line + 1);
          else if (S.className || S.startStyle || S.endStyle || S.css || S.attributes || S.title)
            for (var le = l.line; le <= m.line; le++)
              or(H, le, "text");
          S.atomic && rs(H.doc), Jt(H, "markerAdded", H, S);
        }
        return S;
      }
      var Ba = function(i, l) {
        this.markers = i, this.primary = l;
        for (var m = 0; m < i.length; ++m)
          i[m].parent = this;
      };
      Ba.prototype.clear = function() {
        if (!this.explicitlyCleared) {
          this.explicitlyCleared = !0;
          for (var i = 0; i < this.markers.length; ++i)
            this.markers[i].clear();
          Jt(this, "clear");
        }
      }, Ba.prototype.find = function(i, l) {
        return this.primary.find(i, l);
      }, an(Ba);
      function Rl(i, l, m, p, y) {
        p = ye(p), p.shared = !1;
        var S = [ea(i, l, m, p, y)], R = S[0], N = p.widgetNode;
        return cr(i, function(H) {
          N && (p.widgetNode = N.cloneNode(!0)), S.push(ea(H, mt(H, l), mt(H, m), p, y));
          for (var Y = 0; Y < H.linked.length; ++Y)
            if (H.linked[Y].isParent)
              return;
          R = ce(S);
        }), new Ba(S, R);
      }
      function ms(i) {
        return i.findMarks(xe(i.first, 0), i.clipPos(xe(i.lastLine())), function(l) {
          return l.parent;
        });
      }
      function Ml(i, l) {
        for (var m = 0; m < l.length; m++) {
          var p = l[m], y = p.find(), S = i.clipPos(y.from), R = i.clipPos(y.to);
          if (De(S, R)) {
            var N = ea(i, S, R, p.primary, p.primary.type);
            p.markers.push(N), N.parent = p;
          }
        }
      }
      function Ol(i) {
        for (var l = function(p) {
          var y = i[p], S = [y.primary.doc];
          cr(y.primary.doc, function(H) {
            return S.push(H);
          });
          for (var R = 0; R < y.markers.length; R++) {
            var N = y.markers[R];
            Ae(S, N.doc) == -1 && (N.parent = null, y.markers.splice(R--, 1));
          }
        }, m = 0; m < i.length; m++) l(m);
      }
      var Ll = 0, xn = function(i, l, m, p, y) {
        if (!(this instanceof xn))
          return new xn(i, l, m, p, y);
        m == null && (m = 0), Ta.call(this, [new Aa([new Me("", null)])]), this.first = m, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = m;
        var S = xe(m, 0);
        this.sel = lr(S), this.history = new ni(null), this.id = ++Ll, this.modeOption = l, this.lineSep = p, this.direction = y == "rtl" ? "rtl" : "ltr", this.extend = !1, typeof i == "string" && (i = this.splitLines(i)), Hi(this, { from: S, to: S, text: i }), cn(this, lr(S), Se);
      };
      xn.prototype = Ce(Ta.prototype, {
        constructor: xn,
        // Iterate over the document. Supports two forms -- with only one
        // argument, it calls that for each line in the document. With
        // three, it iterates over the range given by the first two (with
        // the second being non-inclusive).
        iter: function(i, l, m) {
          m ? this.iterN(i - this.first, l - i, m) : this.iterN(this.first, this.first + this.size, i);
        },
        // Non-public interface for adding and removing lines.
        insert: function(i, l) {
          for (var m = 0, p = 0; p < l.length; ++p)
            m += l[p].height;
          this.insertInner(i - this.first, l, m);
        },
        remove: function(i, l) {
          this.removeInner(i - this.first, l);
        },
        // From here, the methods are part of the public interface. Most
        // are also available from CodeMirror (editor) instances.
        getValue: function(i) {
          var l = nr(this, this.first, this.first + this.size);
          return i === !1 ? l : l.join(i || this.lineSeparator());
        },
        setValue: en(function(i) {
          var l = xe(this.first, 0), m = this.first + this.size - 1;
          Jr(this, {
            from: l,
            to: xe(m, ut(this, m).text.length),
            text: this.splitLines(i),
            origin: "setValue",
            full: !0
          }, !0), this.cm && ba(this.cm, 0, 0), cn(this, lr(l), Se);
        }),
        replaceRange: function(i, l, m, p) {
          l = mt(this, l), m = m ? mt(this, m) : l, Qr(this, i, l, m, p);
        },
        getRange: function(i, l, m) {
          var p = Ln(this, mt(this, i), mt(this, l));
          return m === !1 ? p : m === "" ? p.join("") : p.join(m || this.lineSeparator());
        },
        getLine: function(i) {
          var l = this.getLineHandle(i);
          return l && l.text;
        },
        getLineHandle: function(i) {
          if (ee(this, i))
            return ut(this, i);
        },
        getLineNumber: function(i) {
          return _t(i);
        },
        getLineHandleVisualStart: function(i) {
          return typeof i == "number" && (i = ut(this, i)), L(i);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(i) {
          return mt(this, i);
        },
        getCursor: function(i) {
          var l = this.sel.primary(), m;
          return i == null || i == "head" ? m = l.head : i == "anchor" ? m = l.anchor : i == "end" || i == "to" || i === !1 ? m = l.to() : m = l.from(), m;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: en(function(i, l, m) {
          es(this, mt(this, typeof i == "number" ? xe(i, l || 0) : i), null, m);
        }),
        setSelection: en(function(i, l, m) {
          es(this, mt(this, i), mt(this, l || i), m);
        }),
        extendSelection: en(function(i, l, m) {
          ai(this, mt(this, i), l && mt(this, l), m);
        }),
        extendSelections: en(function(i, l) {
          Qo(this, Bt(this, i), l);
        }),
        extendSelectionsBy: en(function(i, l) {
          var m = pe(this.sel.ranges, i);
          Qo(this, Bt(this, m), l);
        }),
        setSelections: en(function(i, l, m) {
          if (i.length) {
            for (var p = [], y = 0; y < i.length; y++)
              p[y] = new At(
                mt(this, i[y].anchor),
                mt(this, i[y].head || i[y].anchor)
              );
            l == null && (l = Math.min(i.length - 1, this.sel.primIndex)), cn(this, Nn(this.cm, p, l), m);
          }
        }),
        addSelection: en(function(i, l, m) {
          var p = this.sel.ranges.slice(0);
          p.push(new At(mt(this, i), mt(this, l || i))), cn(this, Nn(this.cm, p, p.length - 1), m);
        }),
        getSelection: function(i) {
          for (var l = this.sel.ranges, m, p = 0; p < l.length; p++) {
            var y = Ln(this, l[p].from(), l[p].to());
            m = m ? m.concat(y) : y;
          }
          return i === !1 ? m : m.join(i || this.lineSeparator());
        },
        getSelections: function(i) {
          for (var l = [], m = this.sel.ranges, p = 0; p < m.length; p++) {
            var y = Ln(this, m[p].from(), m[p].to());
            i !== !1 && (y = y.join(i || this.lineSeparator())), l[p] = y;
          }
          return l;
        },
        replaceSelection: function(i, l, m) {
          for (var p = [], y = 0; y < this.sel.ranges.length; y++)
            p[y] = i;
          this.replaceSelections(p, l, m || "+input");
        },
        replaceSelections: en(function(i, l, m) {
          for (var p = [], y = this.sel, S = 0; S < y.ranges.length; S++) {
            var R = y.ranges[S];
            p[S] = { from: R.from(), to: R.to(), text: this.splitLines(i[S]), origin: m };
          }
          for (var N = l && l != "end" && _l(this, p, l), H = p.length - 1; H >= 0; H--)
            Jr(this, p[H]);
          N ? ts(this, N) : this.cm && Gr(this.cm);
        }),
        undo: en(function() {
          si(this, "undo");
        }),
        redo: en(function() {
          si(this, "redo");
        }),
        undoSelection: en(function() {
          si(this, "undo", !0);
        }),
        redoSelection: en(function() {
          si(this, "redo", !0);
        }),
        setExtending: function(i) {
          this.extend = i;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          for (var i = this.history, l = 0, m = 0, p = 0; p < i.done.length; p++)
            i.done[p].ranges || ++l;
          for (var y = 0; y < i.undone.length; y++)
            i.undone[y].ranges || ++m;
          return { undo: l, redo: m };
        },
        clearHistory: function() {
          var i = this;
          this.history = new ni(this.history), cr(this, function(l) {
            return l.history = i.history;
          }, !0);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(!0);
        },
        changeGeneration: function(i) {
          return i && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation;
        },
        isClean: function(i) {
          return this.history.generation == (i || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: Xr(this.history.done),
            undone: Xr(this.history.undone)
          };
        },
        setHistory: function(i) {
          var l = this.history = new ni(this.history);
          l.done = Xr(i.done.slice(0), null, !0), l.undone = Xr(i.undone.slice(0), null, !0);
        },
        setGutterMarker: en(function(i, l, m) {
          return Ea(this, i, "gutter", function(p) {
            var y = p.gutterMarkers || (p.gutterMarkers = {});
            return y[l] = m, !m && We(y) && (p.gutterMarkers = null), !0;
          });
        }),
        clearGutter: en(function(i) {
          var l = this;
          this.iter(function(m) {
            m.gutterMarkers && m.gutterMarkers[i] && Ea(l, m, "gutter", function() {
              return m.gutterMarkers[i] = null, We(m.gutterMarkers) && (m.gutterMarkers = null), !0;
            });
          });
        }),
        lineInfo: function(i) {
          var l;
          if (typeof i == "number") {
            if (!ee(this, i) || (l = i, i = ut(this, i), !i))
              return null;
          } else if (l = _t(i), l == null)
            return null;
          return {
            line: l,
            handle: i,
            text: i.text,
            gutterMarkers: i.gutterMarkers,
            textClass: i.textClass,
            bgClass: i.bgClass,
            wrapClass: i.wrapClass,
            widgets: i.widgets
          };
        },
        addLineClass: en(function(i, l, m) {
          return Ea(this, i, l == "gutter" ? "gutter" : "class", function(p) {
            var y = l == "text" ? "textClass" : l == "background" ? "bgClass" : l == "gutter" ? "gutterClass" : "wrapClass";
            if (!p[y])
              p[y] = m;
            else {
              if (K(m).test(p[y]))
                return !1;
              p[y] += " " + m;
            }
            return !0;
          });
        }),
        removeLineClass: en(function(i, l, m) {
          return Ea(this, i, l == "gutter" ? "gutter" : "class", function(p) {
            var y = l == "text" ? "textClass" : l == "background" ? "bgClass" : l == "gutter" ? "gutterClass" : "wrapClass", S = p[y];
            if (S)
              if (m == null)
                p[y] = null;
              else {
                var R = S.match(K(m));
                if (!R)
                  return !1;
                var N = R.index + R[0].length;
                p[y] = S.slice(0, R.index) + (!R.index || N == S.length ? "" : " ") + S.slice(N) || null;
              }
            else return !1;
            return !0;
          });
        }),
        addLineWidget: en(function(i, l, m) {
          return Dl(this, i, l, m);
        }),
        removeLineWidget: function(i) {
          i.clear();
        },
        markText: function(i, l, m) {
          return ea(this, mt(this, i), mt(this, l), m, m && m.type || "range");
        },
        setBookmark: function(i, l) {
          var m = {
            replacedWith: l && (l.nodeType == null ? l.widget : l),
            insertLeft: l && l.insertLeft,
            clearWhenEmpty: !1,
            shared: l && l.shared,
            handleMouseEvents: l && l.handleMouseEvents
          };
          return i = mt(this, i), ea(this, i, i, m, "bookmark");
        },
        findMarksAt: function(i) {
          i = mt(this, i);
          var l = [], m = ut(this, i.line).markedSpans;
          if (m)
            for (var p = 0; p < m.length; ++p) {
              var y = m[p];
              (y.from == null || y.from <= i.ch) && (y.to == null || y.to >= i.ch) && l.push(y.marker.parent || y.marker);
            }
          return l;
        },
        findMarks: function(i, l, m) {
          i = mt(this, i), l = mt(this, l);
          var p = [], y = i.line;
          return this.iter(i.line, l.line + 1, function(S) {
            var R = S.markedSpans;
            if (R)
              for (var N = 0; N < R.length; N++) {
                var H = R[N];
                !(H.to != null && y == i.line && i.ch >= H.to || H.from == null && y != i.line || H.from != null && y == l.line && H.from >= l.ch) && (!m || m(H.marker)) && p.push(H.marker.parent || H.marker);
              }
            ++y;
          }), p;
        },
        getAllMarks: function() {
          var i = [];
          return this.iter(function(l) {
            var m = l.markedSpans;
            if (m)
              for (var p = 0; p < m.length; ++p)
                m[p].from != null && i.push(m[p].marker);
          }), i;
        },
        posFromIndex: function(i) {
          var l, m = this.first, p = this.lineSeparator().length;
          return this.iter(function(y) {
            var S = y.text.length + p;
            if (S > i)
              return l = i, !0;
            i -= S, ++m;
          }), mt(this, xe(m, l));
        },
        indexFromPos: function(i) {
          i = mt(this, i);
          var l = i.ch;
          if (i.line < this.first || i.ch < 0)
            return 0;
          var m = this.lineSeparator().length;
          return this.iter(this.first, i.line, function(p) {
            l += p.text.length + m;
          }), l;
        },
        copy: function(i) {
          var l = new xn(
            nr(this, this.first, this.first + this.size),
            this.modeOption,
            this.first,
            this.lineSep,
            this.direction
          );
          return l.scrollTop = this.scrollTop, l.scrollLeft = this.scrollLeft, l.sel = this.sel, l.extend = !1, i && (l.history.undoDepth = this.history.undoDepth, l.setHistory(this.getHistory())), l;
        },
        linkedDoc: function(i) {
          i || (i = {});
          var l = this.first, m = this.first + this.size;
          i.from != null && i.from > l && (l = i.from), i.to != null && i.to < m && (m = i.to);
          var p = new xn(nr(this, l, m), i.mode || this.modeOption, l, this.lineSep, this.direction);
          return i.sharedHist && (p.history = this.history), (this.linked || (this.linked = [])).push({ doc: p, sharedHist: i.sharedHist }), p.linked = [{ doc: this, isParent: !0, sharedHist: i.sharedHist }], Ml(p, ms(this)), p;
        },
        unlinkDoc: function(i) {
          if (i instanceof Ot && (i = i.doc), this.linked)
            for (var l = 0; l < this.linked.length; ++l) {
              var m = this.linked[l];
              if (m.doc == i) {
                this.linked.splice(l, 1), i.unlinkDoc(this), Ol(ms(this));
                break;
              }
            }
          if (i.history == this.history) {
            var p = [i.id];
            cr(i, function(y) {
              return p.push(y.id);
            }, !0), i.history = new ni(null), i.history.done = Xr(this.history.done, p), i.history.undone = Xr(this.history.undone, p);
          }
        },
        iterLinkedDocs: function(i) {
          cr(this, i);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(i) {
          return this.lineSep ? i.split(this.lineSep) : vr(i);
        },
        lineSeparator: function() {
          return this.lineSep || `
`;
        },
        setDirection: en(function(i) {
          i != "rtl" && (i = "ltr"), i != this.direction && (this.direction = i, this.iter(function(l) {
            return l.order = null;
          }), this.cm && Sl(this.cm));
        })
      }), xn.prototype.eachLine = xn.prototype.iter;
      var gs = 0;
      function Vl(i) {
        var l = this;
        if (vs(l), !(yt(l, i) || Yn(l.display, i))) {
          Ut(i), f && (gs = +/* @__PURE__ */ new Date());
          var m = Ar(l, i, !0), p = i.dataTransfer.files;
          if (!(!m || l.isReadOnly()))
            if (p && p.length && window.FileReader && window.File)
              for (var y = p.length, S = Array(y), R = 0, N = function() {
                ++R == y && Qt(l, function() {
                  m = mt(l.doc, m);
                  var Ee = {
                    from: m,
                    to: m,
                    text: l.doc.splitLines(
                      S.filter(function(Ve) {
                        return Ve != null;
                      }).join(l.doc.lineSeparator())
                    ),
                    origin: "paste"
                  };
                  Jr(l.doc, Ee), ts(l.doc, lr(mt(l.doc, m), mt(l.doc, ur(Ee))));
                })();
              }, H = function(Ee, Ve) {
                if (l.options.allowDropFileTypes && Ae(l.options.allowDropFileTypes, Ee.type) == -1) {
                  N();
                  return;
                }
                var Ke = new FileReader();
                Ke.onerror = function() {
                  return N();
                }, Ke.onload = function() {
                  var Ye = Ke.result;
                  if (/[\x00-\x08\x0e-\x1f]{2}/.test(Ye)) {
                    N();
                    return;
                  }
                  S[Ve] = Ye, N();
                }, Ke.readAsText(Ee);
              }, Y = 0; Y < p.length; Y++)
                H(p[Y], Y);
            else {
              if (l.state.draggingText && l.doc.sel.contains(m) > -1) {
                l.state.draggingText(i), setTimeout(function() {
                  return l.display.input.focus();
                }, 20);
                return;
              }
              try {
                var le = i.dataTransfer.getData("Text");
                if (le) {
                  var he;
                  if (l.state.draggingText && !l.state.draggingText.copy && (he = l.listSelections()), ii(l.doc, lr(m, m)), he)
                    for (var Pe = 0; Pe < he.length; ++Pe)
                      Qr(l.doc, "", he[Pe].anchor, he[Pe].head, "drag");
                  l.replaceSelection(le, "around", "paste"), l.display.input.focus();
                }
              } catch {
              }
            }
        }
      }
      function Nl(i, l) {
        if (f && (!i.state.draggingText || +/* @__PURE__ */ new Date() - gs < 100)) {
          Dn(l);
          return;
        }
        if (!(yt(i, l) || Yn(i.display, l)) && (l.dataTransfer.setData("Text", i.getSelection()), l.dataTransfer.effectAllowed = "copyMove", l.dataTransfer.setDragImage && !E)) {
          var m = V("img", null, null, "position: fixed; left: 0; top: 0;");
          m.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", k && (m.width = m.height = 1, i.display.wrapper.appendChild(m), m._top = m.offsetTop), l.dataTransfer.setDragImage(m, 0, 0), k && m.parentNode.removeChild(m);
        }
      }
      function Il(i, l) {
        var m = Ar(i, l);
        if (m) {
          var p = document.createDocumentFragment();
          Bi(i, m, p), i.display.dragCursor || (i.display.dragCursor = V("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), i.display.lineSpace.insertBefore(i.display.dragCursor, i.display.cursorDiv)), re(i.display.dragCursor, p);
        }
      }
      function vs(i) {
        i.display.dragCursor && (i.display.lineSpace.removeChild(i.display.dragCursor), i.display.dragCursor = null);
      }
      function ys(i) {
        if (document.getElementsByClassName) {
          for (var l = document.getElementsByClassName("CodeMirror"), m = [], p = 0; p < l.length; p++) {
            var y = l[p].CodeMirror;
            y && m.push(y);
          }
          m.length && m[0].operation(function() {
            for (var S = 0; S < m.length; S++)
              i(m[S]);
          });
        }
      }
      var bs = !1;
      function Fl() {
        bs || (zl(), bs = !0);
      }
      function zl() {
        var i;
        qe(window, "resize", function() {
          i == null && (i = setTimeout(function() {
            i = null, ys(jl);
          }, 100));
        }), qe(window, "blur", function() {
          return ys(Kr);
        });
      }
      function jl(i) {
        var l = i.display;
        l.cachedCharWidth = l.cachedTextHeight = l.cachedPaddingH = null, l.scrollbarsClipped = !1, i.setSize();
      }
      for (var fr = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      }, Da = 0; Da < 10; Da++)
        fr[Da + 48] = fr[Da + 96] = String(Da);
      for (var li = 65; li <= 90; li++)
        fr[li] = String.fromCharCode(li);
      for (var Ra = 1; Ra <= 12; Ra++)
        fr[Ra + 111] = fr[Ra + 63235] = "F" + Ra;
      var Zn = {};
      Zn.basic = {
        Left: "goCharLeft",
        Right: "goCharRight",
        Up: "goLineUp",
        Down: "goLineDown",
        End: "goLineEnd",
        Home: "goLineStartSmart",
        PageUp: "goPageUp",
        PageDown: "goPageDown",
        Delete: "delCharAfter",
        Backspace: "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        Tab: "defaultTab",
        "Shift-Tab": "indentAuto",
        Enter: "newlineAndIndent",
        Insert: "toggleOverwrite",
        Esc: "singleSelection"
      }, Zn.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        fallthrough: "basic"
      }, Zn.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      }, Zn.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        fallthrough: ["basic", "emacsy"]
      }, Zn.default = T ? Zn.macDefault : Zn.pcDefault;
      function ql(i) {
        var l = i.split(/-(?!$)/);
        i = l[l.length - 1];
        for (var m, p, y, S, R = 0; R < l.length - 1; R++) {
          var N = l[R];
          if (/^(cmd|meta|m)$/i.test(N))
            S = !0;
          else if (/^a(lt)?$/i.test(N))
            m = !0;
          else if (/^(c|ctrl|control)$/i.test(N))
            p = !0;
          else if (/^s(hift)?$/i.test(N))
            y = !0;
          else
            throw new Error("Unrecognized modifier name: " + N);
        }
        return m && (i = "Alt-" + i), p && (i = "Ctrl-" + i), S && (i = "Cmd-" + i), y && (i = "Shift-" + i), i;
      }
      function Hl(i) {
        var l = {};
        for (var m in i)
          if (i.hasOwnProperty(m)) {
            var p = i[m];
            if (/^(name|fallthrough|(de|at)tach)$/.test(m))
              continue;
            if (p == "...") {
              delete i[m];
              continue;
            }
            for (var y = pe(m.split(" "), ql), S = 0; S < y.length; S++) {
              var R = void 0, N = void 0;
              S == y.length - 1 ? (N = y.join(" "), R = p) : (N = y.slice(0, S + 1).join(" "), R = "...");
              var H = l[N];
              if (!H)
                l[N] = R;
              else if (H != R)
                throw new Error("Inconsistent bindings for " + N);
            }
            delete i[m];
          }
        for (var Y in l)
          i[Y] = l[Y];
        return i;
      }
      function ta(i, l, m, p) {
        l = ui(l);
        var y = l.call ? l.call(i, p) : l[i];
        if (y === !1)
          return "nothing";
        if (y === "...")
          return "multi";
        if (y != null && m(y))
          return "handled";
        if (l.fallthrough) {
          if (Object.prototype.toString.call(l.fallthrough) != "[object Array]")
            return ta(i, l.fallthrough, m, p);
          for (var S = 0; S < l.fallthrough.length; S++) {
            var R = ta(i, l.fallthrough[S], m, p);
            if (R)
              return R;
          }
        }
      }
      function xs(i) {
        var l = typeof i == "string" ? i : fr[i.keyCode];
        return l == "Ctrl" || l == "Alt" || l == "Shift" || l == "Mod";
      }
      function ws(i, l, m) {
        var p = i;
        return l.altKey && p != "Alt" && (i = "Alt-" + i), (F ? l.metaKey : l.ctrlKey) && p != "Ctrl" && (i = "Ctrl-" + i), (F ? l.ctrlKey : l.metaKey) && p != "Mod" && (i = "Cmd-" + i), !m && l.shiftKey && p != "Shift" && (i = "Shift-" + i), i;
      }
      function ks(i, l) {
        if (k && i.keyCode == 34 && i.char)
          return !1;
        var m = fr[i.keyCode];
        return m == null || i.altGraphKey ? !1 : (i.keyCode == 3 && i.code && (m = i.code), ws(m, i, l));
      }
      function ui(i) {
        return typeof i == "string" ? Zn[i] : i;
      }
      function na(i, l) {
        for (var m = i.doc.sel.ranges, p = [], y = 0; y < m.length; y++) {
          for (var S = l(m[y]); p.length && De(S.from, ce(p).to) <= 0; ) {
            var R = p.pop();
            if (De(R.from, S.from) < 0) {
              S.from = R.from;
              break;
            }
          }
          p.push(S);
        }
        $n(i, function() {
          for (var N = p.length - 1; N >= 0; N--)
            Qr(i.doc, "", p[N].from, p[N].to, "+delete");
          Gr(i);
        });
      }
      function Gi(i, l, m) {
        var p = me(i.text, l + m, m);
        return p < 0 || p > i.text.length ? null : p;
      }
      function Yi(i, l, m) {
        var p = Gi(i, l.ch, m);
        return p == null ? null : new xe(l.line, p, m < 0 ? "after" : "before");
      }
      function Xi(i, l, m, p, y) {
        if (i) {
          l.doc.direction == "rtl" && (y = -y);
          var S = Je(m, l.doc.direction);
          if (S) {
            var R = y < 0 ? ce(S) : S[0], N = y < 0 == (R.level == 1), H = N ? "after" : "before", Y;
            if (R.level > 0 || l.doc.direction == "rtl") {
              var le = Hr(l, m);
              Y = y < 0 ? m.text.length - 1 : 0;
              var he = Wn(l, le, Y).top;
              Y = de(function(Pe) {
                return Wn(l, le, Pe).top == he;
              }, y < 0 == (R.level == 1) ? R.from : R.to - 1, Y), H == "before" && (Y = Gi(m, Y, 1));
            } else
              Y = y < 0 ? R.to : R.from;
            return new xe(p, Y, H);
          }
        }
        return new xe(p, y < 0 ? m.text.length : 0, y < 0 ? "before" : "after");
      }
      function Ul(i, l, m, p) {
        var y = Je(l, i.doc.direction);
        if (!y)
          return Yi(l, m, p);
        m.ch >= l.text.length ? (m.ch = l.text.length, m.sticky = "before") : m.ch <= 0 && (m.ch = 0, m.sticky = "after");
        var S = $e(y, m.ch, m.sticky), R = y[S];
        if (i.doc.direction == "ltr" && R.level % 2 == 0 && (p > 0 ? R.to > m.ch : R.from < m.ch))
          return Yi(l, m, p);
        var N = function(nt, it) {
          return Gi(l, nt instanceof xe ? nt.ch : nt, it);
        }, H, Y = function(nt) {
          return i.options.lineWrapping ? (H = H || Hr(i, l), Eo(i, l, H, nt)) : { begin: 0, end: l.text.length };
        }, le = Y(m.sticky == "before" ? N(m, -1) : m.ch);
        if (i.doc.direction == "rtl" || R.level == 1) {
          var he = R.level == 1 == p < 0, Pe = N(m, he ? 1 : -1);
          if (Pe != null && (he ? Pe <= R.to && Pe <= le.end : Pe >= R.from && Pe >= le.begin)) {
            var Ee = he ? "before" : "after";
            return new xe(m.line, Pe, Ee);
          }
        }
        var Ve = function(nt, it, rt) {
          for (var st = function(Dt, tn) {
            return tn ? new xe(m.line, N(Dt, 1), "before") : new xe(m.line, Dt, "after");
          }; nt >= 0 && nt < y.length; nt += it) {
            var ft = y[nt], dt = it > 0 == (ft.level != 1), bt = dt ? rt.begin : N(rt.end, -1);
            if (ft.from <= bt && bt < ft.to || (bt = dt ? ft.from : N(ft.to, -1), rt.begin <= bt && bt < rt.end))
              return st(bt, dt);
          }
        }, Ke = Ve(S + p, p, le);
        if (Ke)
          return Ke;
        var Ye = p > 0 ? le.end : N(le.begin, -1);
        return Ye != null && !(p > 0 && Ye == l.text.length) && (Ke = Ve(p > 0 ? 0 : y.length - 1, p, Y(Ye)), Ke) ? Ke : null;
      }
      var Ma = {
        selectAll: os,
        singleSelection: function(i) {
          return i.setSelection(i.getCursor("anchor"), i.getCursor("head"), Se);
        },
        killLine: function(i) {
          return na(i, function(l) {
            if (l.empty()) {
              var m = ut(i.doc, l.head.line).text.length;
              return l.head.ch == m && l.head.line < i.lastLine() ? { from: l.head, to: xe(l.head.line + 1, 0) } : { from: l.head, to: xe(l.head.line, m) };
            } else
              return { from: l.from(), to: l.to() };
          });
        },
        deleteLine: function(i) {
          return na(i, function(l) {
            return {
              from: xe(l.from().line, 0),
              to: mt(i.doc, xe(l.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(i) {
          return na(i, function(l) {
            return {
              from: xe(l.from().line, 0),
              to: l.from()
            };
          });
        },
        delWrappedLineLeft: function(i) {
          return na(i, function(l) {
            var m = i.charCoords(l.head, "div").top + 5, p = i.coordsChar({ left: 0, top: m }, "div");
            return { from: p, to: l.from() };
          });
        },
        delWrappedLineRight: function(i) {
          return na(i, function(l) {
            var m = i.charCoords(l.head, "div").top + 5, p = i.coordsChar({ left: i.display.lineDiv.offsetWidth + 100, top: m }, "div");
            return { from: l.from(), to: p };
          });
        },
        undo: function(i) {
          return i.undo();
        },
        redo: function(i) {
          return i.redo();
        },
        undoSelection: function(i) {
          return i.undoSelection();
        },
        redoSelection: function(i) {
          return i.redoSelection();
        },
        goDocStart: function(i) {
          return i.extendSelection(xe(i.firstLine(), 0));
        },
        goDocEnd: function(i) {
          return i.extendSelection(xe(i.lastLine()));
        },
        goLineStart: function(i) {
          return i.extendSelectionsBy(
            function(l) {
              return _s(i, l.head.line);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineStartSmart: function(i) {
          return i.extendSelectionsBy(
            function(l) {
              return Ss(i, l.head);
            },
            { origin: "+move", bias: 1 }
          );
        },
        goLineEnd: function(i) {
          return i.extendSelectionsBy(
            function(l) {
              return Wl(i, l.head.line);
            },
            { origin: "+move", bias: -1 }
          );
        },
        goLineRight: function(i) {
          return i.extendSelectionsBy(function(l) {
            var m = i.cursorCoords(l.head, "div").top + 5;
            return i.coordsChar({ left: i.display.lineDiv.offsetWidth + 100, top: m }, "div");
          }, Ne);
        },
        goLineLeft: function(i) {
          return i.extendSelectionsBy(function(l) {
            var m = i.cursorCoords(l.head, "div").top + 5;
            return i.coordsChar({ left: 0, top: m }, "div");
          }, Ne);
        },
        goLineLeftSmart: function(i) {
          return i.extendSelectionsBy(function(l) {
            var m = i.cursorCoords(l.head, "div").top + 5, p = i.coordsChar({ left: 0, top: m }, "div");
            return p.ch < i.getLine(p.line).search(/\S/) ? Ss(i, l.head) : p;
          }, Ne);
        },
        goLineUp: function(i) {
          return i.moveV(-1, "line");
        },
        goLineDown: function(i) {
          return i.moveV(1, "line");
        },
        goPageUp: function(i) {
          return i.moveV(-1, "page");
        },
        goPageDown: function(i) {
          return i.moveV(1, "page");
        },
        goCharLeft: function(i) {
          return i.moveH(-1, "char");
        },
        goCharRight: function(i) {
          return i.moveH(1, "char");
        },
        goColumnLeft: function(i) {
          return i.moveH(-1, "column");
        },
        goColumnRight: function(i) {
          return i.moveH(1, "column");
        },
        goWordLeft: function(i) {
          return i.moveH(-1, "word");
        },
        goGroupRight: function(i) {
          return i.moveH(1, "group");
        },
        goGroupLeft: function(i) {
          return i.moveH(-1, "group");
        },
        goWordRight: function(i) {
          return i.moveH(1, "word");
        },
        delCharBefore: function(i) {
          return i.deleteH(-1, "codepoint");
        },
        delCharAfter: function(i) {
          return i.deleteH(1, "char");
        },
        delWordBefore: function(i) {
          return i.deleteH(-1, "word");
        },
        delWordAfter: function(i) {
          return i.deleteH(1, "word");
        },
        delGroupBefore: function(i) {
          return i.deleteH(-1, "group");
        },
        delGroupAfter: function(i) {
          return i.deleteH(1, "group");
        },
        indentAuto: function(i) {
          return i.indentSelection("smart");
        },
        indentMore: function(i) {
          return i.indentSelection("add");
        },
        indentLess: function(i) {
          return i.indentSelection("subtract");
        },
        insertTab: function(i) {
          return i.replaceSelection("	");
        },
        insertSoftTab: function(i) {
          for (var l = [], m = i.listSelections(), p = i.options.tabSize, y = 0; y < m.length; y++) {
            var S = m[y].from(), R = ve(i.getLine(S.line), S.ch, p);
            l.push(et(p - R % p));
          }
          i.replaceSelections(l);
        },
        defaultTab: function(i) {
          i.somethingSelected() ? i.indentSelection("add") : i.execCommand("insertTab");
        },
        // Swap the two chars left and right of each selection's head.
        // Move cursor behind the two swapped characters afterwards.
        //
        // Doesn't consider line feeds a character.
        // Doesn't scan more than one line above to find a character.
        // Doesn't do anything on an empty line.
        // Doesn't do anything with non-empty selections.
        transposeChars: function(i) {
          return $n(i, function() {
            for (var l = i.listSelections(), m = [], p = 0; p < l.length; p++)
              if (l[p].empty()) {
                var y = l[p].head, S = ut(i.doc, y.line).text;
                if (S) {
                  if (y.ch == S.length && (y = new xe(y.line, y.ch - 1)), y.ch > 0)
                    y = new xe(y.line, y.ch + 1), i.replaceRange(
                      S.charAt(y.ch - 1) + S.charAt(y.ch - 2),
                      xe(y.line, y.ch - 2),
                      y,
                      "+transpose"
                    );
                  else if (y.line > i.doc.first) {
                    var R = ut(i.doc, y.line - 1).text;
                    R && (y = new xe(y.line, 1), i.replaceRange(
                      S.charAt(0) + i.doc.lineSeparator() + R.charAt(R.length - 1),
                      xe(y.line - 1, R.length - 1),
                      y,
                      "+transpose"
                    ));
                  }
                }
                m.push(new At(y, y));
              }
            i.setSelections(m);
          });
        },
        newlineAndIndent: function(i) {
          return $n(i, function() {
            for (var l = i.listSelections(), m = l.length - 1; m >= 0; m--)
              i.replaceRange(i.doc.lineSeparator(), l[m].anchor, l[m].head, "+input");
            l = i.listSelections();
            for (var p = 0; p < l.length; p++)
              i.indentLine(l[p].from().line, null, !0);
            Gr(i);
          });
        },
        openLine: function(i) {
          return i.replaceSelection(`
`, "start");
        },
        toggleOverwrite: function(i) {
          return i.toggleOverwrite();
        }
      };
      function _s(i, l) {
        var m = ut(i.doc, l), p = L(m);
        return p != m && (l = _t(p)), Xi(!0, i, p, l, 1);
      }
      function Wl(i, l) {
        var m = ut(i.doc, l), p = j(m);
        return p != m && (l = _t(p)), Xi(!0, i, m, l, -1);
      }
      function Ss(i, l) {
        var m = _s(i, l.line), p = ut(i.doc, m.line), y = Je(p, i.doc.direction);
        if (!y || y[0].level == 0) {
          var S = Math.max(m.ch, p.text.search(/\S/)), R = l.line == m.line && l.ch <= S && l.ch;
          return xe(m.line, R ? 0 : S, m.sticky);
        }
        return m;
      }
      function ci(i, l, m) {
        if (typeof l == "string" && (l = Ma[l], !l))
          return !1;
        i.display.input.ensurePolled();
        var p = i.display.shift, y = !1;
        try {
          i.isReadOnly() && (i.state.suppressEdits = !0), m && (i.display.shift = !1), y = l(i) != Ie;
        } finally {
          i.display.shift = p, i.state.suppressEdits = !1;
        }
        return y;
      }
      function Kl(i, l, m) {
        for (var p = 0; p < i.state.keyMaps.length; p++) {
          var y = ta(l, i.state.keyMaps[p], m, i);
          if (y)
            return y;
        }
        return i.options.extraKeys && ta(l, i.options.extraKeys, m, i) || ta(l, i.options.keyMap, m, i);
      }
      var Gl = new ke();
      function Oa(i, l, m, p) {
        var y = i.state.keySeq;
        if (y) {
          if (xs(l))
            return "handled";
          if (/\'$/.test(l) ? i.state.keySeq = null : Gl.set(50, function() {
            i.state.keySeq == y && (i.state.keySeq = null, i.display.input.reset());
          }), Cs(i, y + " " + l, m, p))
            return !0;
        }
        return Cs(i, l, m, p);
      }
      function Cs(i, l, m, p) {
        var y = Kl(i, l, p);
        return y == "multi" && (i.state.keySeq = l), y == "handled" && Jt(i, "keyHandled", i, l, m), (y == "handled" || y == "multi") && (Ut(m), Di(i)), !!y;
      }
      function $s(i, l) {
        var m = ks(l, !0);
        return m ? l.shiftKey && !i.state.keySeq ? Oa(i, "Shift-" + m, l, function(p) {
          return ci(i, p, !0);
        }) || Oa(i, m, l, function(p) {
          if (typeof p == "string" ? /^go[A-Z]/.test(p) : p.motion)
            return ci(i, p);
        }) : Oa(i, m, l, function(p) {
          return ci(i, p);
        }) : !1;
      }
      function Yl(i, l, m) {
        return Oa(i, "'" + m + "'", l, function(p) {
          return ci(i, p, !0);
        });
      }
      var Zi = null;
      function Es(i) {
        var l = this;
        if (!(i.target && i.target != l.display.input.getField()) && (l.curOp.focus = X(G(l)), !yt(l, i))) {
          f && g < 11 && i.keyCode == 27 && (i.returnValue = !1);
          var m = i.keyCode;
          l.display.shift = m == 16 || i.shiftKey;
          var p = $s(l, i);
          k && (Zi = p ? m : null, !p && m == 88 && !gn && (T ? i.metaKey : i.ctrlKey) && l.replaceSelection("", null, "cut")), o && !T && !p && m == 46 && i.shiftKey && !i.ctrlKey && document.execCommand && document.execCommand("cut"), m == 18 && !/\bCodeMirror-crosshair\b/.test(l.display.lineDiv.className) && Xl(l);
        }
      }
      function Xl(i) {
        var l = i.display.lineDiv;
        ue(l, "CodeMirror-crosshair");
        function m(p) {
          (p.keyCode == 18 || !p.altKey) && (Z(l, "CodeMirror-crosshair"), Mt(document, "keyup", m), Mt(document, "mouseover", m));
        }
        qe(document, "keyup", m), qe(document, "mouseover", m);
      }
      function As(i) {
        i.keyCode == 16 && (this.doc.sel.shift = !1), yt(this, i);
      }
      function Ts(i) {
        var l = this;
        if (!(i.target && i.target != l.display.input.getField()) && !(Yn(l.display, i) || yt(l, i) || i.ctrlKey && !i.altKey || T && i.metaKey)) {
          var m = i.keyCode, p = i.charCode;
          if (k && m == Zi) {
            Zi = null, Ut(i);
            return;
          }
          if (!(k && (!i.which || i.which < 10) && $s(l, i))) {
            var y = String.fromCharCode(p ?? m);
            y != "\b" && (Yl(l, i, y) || l.display.input.onKeyPress(i));
          }
        }
      }
      var Zl = 400, Ji = function(i, l, m) {
        this.time = i, this.pos = l, this.button = m;
      };
      Ji.prototype.compare = function(i, l, m) {
        return this.time + Zl > i && De(l, this.pos) == 0 && m == this.button;
      };
      var La, Va;
      function Jl(i, l) {
        var m = +/* @__PURE__ */ new Date();
        return Va && Va.compare(m, i, l) ? (La = Va = null, "triple") : La && La.compare(m, i, l) ? (Va = new Ji(m, i, l), La = null, "double") : (La = new Ji(m, i, l), Va = null, "single");
      }
      function Ps(i) {
        var l = this, m = l.display;
        if (!(yt(l, i) || m.activeTouch && m.input.supportsTouch())) {
          if (m.input.ensurePolled(), m.shift = i.shiftKey, Yn(m, i)) {
            v || (m.scroller.draggable = !1, setTimeout(function() {
              return m.scroller.draggable = !0;
            }, 100));
            return;
          }
          if (!Qi(l, i)) {
            var p = Ar(l, i), y = gr(i), S = p ? Jl(p, y) : "single";
            ie(l).focus(), y == 1 && l.state.selectingText && l.state.selectingText(i), !(p && Ql(l, y, p, S, i)) && (y == 1 ? p ? tu(l, p, S, i) : on(i) == m.scroller && Ut(i) : y == 2 ? (p && ai(l.doc, p), setTimeout(function() {
              return m.input.focus();
            }, 20)) : y == 3 && (W ? l.display.input.onContextMenu(i) : Ri(l)));
          }
        }
      }
      function Ql(i, l, m, p, y) {
        var S = "Click";
        return p == "double" ? S = "Double" + S : p == "triple" && (S = "Triple" + S), S = (l == 1 ? "Left" : l == 2 ? "Middle" : "Right") + S, Oa(i, ws(S, y), y, function(R) {
          if (typeof R == "string" && (R = Ma[R]), !R)
            return !1;
          var N = !1;
          try {
            i.isReadOnly() && (i.state.suppressEdits = !0), N = R(i, m) != Ie;
          } finally {
            i.state.suppressEdits = !1;
          }
          return N;
        });
      }
      function eu(i, l, m) {
        var p = i.getOption("configureMouse"), y = p ? p(i, l, m) : {};
        if (y.unit == null) {
          var S = O ? m.shiftKey && m.metaKey : m.altKey;
          y.unit = S ? "rectangle" : l == "single" ? "char" : l == "double" ? "word" : "line";
        }
        return (y.extend == null || i.doc.extend) && (y.extend = i.doc.extend || m.shiftKey), y.addNew == null && (y.addNew = T ? m.metaKey : m.ctrlKey), y.moveOnDrag == null && (y.moveOnDrag = !(T ? m.altKey : m.ctrlKey)), y;
      }
      function tu(i, l, m, p) {
        f ? setTimeout(oe(Bo, i), 0) : i.curOp.focus = X(G(i));
        var y = eu(i, m, p), S = i.doc.sel, R;
        i.options.dragDrop && zn && !i.isReadOnly() && m == "single" && (R = S.contains(l)) > -1 && (De((R = S.ranges[R]).from(), l) < 0 || l.xRel > 0) && (De(R.to(), l) > 0 || l.xRel < 0) ? nu(i, p, l, y) : ru(i, p, l, y);
      }
      function nu(i, l, m, p) {
        var y = i.display, S = !1, R = Qt(i, function(Y) {
          v && (y.scroller.draggable = !1), i.state.draggingText = !1, i.state.delayingBlurEvent && (i.hasFocus() ? i.state.delayingBlurEvent = !1 : Ri(i)), Mt(y.wrapper.ownerDocument, "mouseup", R), Mt(y.wrapper.ownerDocument, "mousemove", N), Mt(y.scroller, "dragstart", H), Mt(y.scroller, "drop", R), S || (Ut(Y), p.addNew || ai(i.doc, m, null, null, p.extend), v && !E || f && g == 9 ? setTimeout(function() {
            y.wrapper.ownerDocument.body.focus({ preventScroll: !0 }), y.input.focus();
          }, 20) : y.input.focus());
        }), N = function(Y) {
          S = S || Math.abs(l.clientX - Y.clientX) + Math.abs(l.clientY - Y.clientY) >= 10;
        }, H = function() {
          return S = !0;
        };
        v && (y.scroller.draggable = !0), i.state.draggingText = R, R.copy = !p.moveOnDrag, qe(y.wrapper.ownerDocument, "mouseup", R), qe(y.wrapper.ownerDocument, "mousemove", N), qe(y.scroller, "dragstart", H), qe(y.scroller, "drop", R), i.state.delayingBlurEvent = !0, setTimeout(function() {
          return y.input.focus();
        }, 20), y.scroller.dragDrop && y.scroller.dragDrop();
      }
      function Bs(i, l, m) {
        if (m == "char")
          return new At(l, l);
        if (m == "word")
          return i.findWordAt(l);
        if (m == "line")
          return new At(xe(l.line, 0), mt(i.doc, xe(l.line + 1, 0)));
        var p = m(i, l);
        return new At(p.from, p.to);
      }
      function ru(i, l, m, p) {
        f && Ri(i);
        var y = i.display, S = i.doc;
        Ut(l);
        var R, N, H = S.sel, Y = H.ranges;
        if (p.addNew && !p.extend ? (N = S.sel.contains(m), N > -1 ? R = Y[N] : R = new At(m, m)) : (R = S.sel.primary(), N = S.sel.primIndex), p.unit == "rectangle")
          p.addNew || (R = new At(m, m)), m = Ar(i, l, !0, !0), N = -1;
        else {
          var le = Bs(i, m, p.unit);
          p.extend ? R = Wi(R, le.anchor, le.head, p.extend) : R = le;
        }
        p.addNew ? N == -1 ? (N = Y.length, cn(
          S,
          Nn(i, Y.concat([R]), N),
          { scroll: !1, origin: "*mouse" }
        )) : Y.length > 1 && Y[N].empty() && p.unit == "char" && !p.extend ? (cn(
          S,
          Nn(i, Y.slice(0, N).concat(Y.slice(N + 1)), 0),
          { scroll: !1, origin: "*mouse" }
        ), H = S.sel) : Ki(S, N, R, ze) : (N = 0, cn(S, new An([R], 0), ze), H = S.sel);
        var he = m;
        function Pe(rt) {
          if (De(he, rt) != 0)
            if (he = rt, p.unit == "rectangle") {
              for (var st = [], ft = i.options.tabSize, dt = ve(ut(S, m.line).text, m.ch, ft), bt = ve(ut(S, rt.line).text, rt.ch, ft), Dt = Math.min(dt, bt), tn = Math.max(dt, bt), Nt = Math.min(m.line, rt.line), En = Math.min(i.lastLine(), Math.max(m.line, rt.line)); Nt <= En; Nt++) {
                var wn = ut(S, Nt).text, qt = tt(wn, Dt, ft);
                Dt == tn ? st.push(new At(xe(Nt, qt), xe(Nt, qt))) : wn.length > qt && st.push(new At(xe(Nt, qt), xe(Nt, tt(wn, tn, ft))));
              }
              st.length || st.push(new At(m, m)), cn(
                S,
                Nn(i, H.ranges.slice(0, N).concat(st), N),
                { origin: "*mouse", scroll: !1 }
              ), i.scrollIntoView(rt);
            } else {
              var kn = R, ln = Bs(i, rt, p.unit), Gt = kn.anchor, Ht;
              De(ln.anchor, Gt) > 0 ? (Ht = ln.head, Gt = It(kn.from(), ln.anchor)) : (Ht = ln.anchor, Gt = St(kn.to(), ln.head));
              var Ft = H.ranges.slice(0);
              Ft[N] = au(i, new At(mt(S, Gt), Ht)), cn(S, Nn(i, Ft, N), ze);
            }
        }
        var Ee = y.wrapper.getBoundingClientRect(), Ve = 0;
        function Ke(rt) {
          var st = ++Ve, ft = Ar(i, rt, !0, p.unit == "rectangle");
          if (ft)
            if (De(ft, he) != 0) {
              i.curOp.focus = X(G(i)), Pe(ft);
              var dt = Ja(y, S);
              (ft.line >= dt.to || ft.line < dt.from) && setTimeout(Qt(i, function() {
                Ve == st && Ke(rt);
              }), 150);
            } else {
              var bt = rt.clientY < Ee.top ? -20 : rt.clientY > Ee.bottom ? 20 : 0;
              bt && setTimeout(Qt(i, function() {
                Ve == st && (y.scroller.scrollTop += bt, Ke(rt));
              }), 50);
            }
        }
        function Ye(rt) {
          i.state.selectingText = !1, Ve = 1 / 0, rt && (Ut(rt), y.input.focus()), Mt(y.wrapper.ownerDocument, "mousemove", nt), Mt(y.wrapper.ownerDocument, "mouseup", it), S.history.lastSelOrigin = null;
        }
        var nt = Qt(i, function(rt) {
          rt.buttons === 0 || !gr(rt) ? Ye(rt) : Ke(rt);
        }), it = Qt(i, Ye);
        i.state.selectingText = it, qe(y.wrapper.ownerDocument, "mousemove", nt), qe(y.wrapper.ownerDocument, "mouseup", it);
      }
      function au(i, l) {
        var m = l.anchor, p = l.head, y = ut(i.doc, m.line);
        if (De(m, p) == 0 && m.sticky == p.sticky)
          return l;
        var S = Je(y);
        if (!S)
          return l;
        var R = $e(S, m.ch, m.sticky), N = S[R];
        if (N.from != m.ch && N.to != m.ch)
          return l;
        var H = R + (N.from == m.ch == (N.level != 1) ? 0 : 1);
        if (H == 0 || H == S.length)
          return l;
        var Y;
        if (p.line != m.line)
          Y = (p.line - m.line) * (i.doc.direction == "ltr" ? 1 : -1) > 0;
        else {
          var le = $e(S, p.ch, p.sticky), he = le - R || (p.ch - m.ch) * (N.level == 1 ? -1 : 1);
          le == H - 1 || le == H ? Y = he < 0 : Y = he > 0;
        }
        var Pe = S[H + (Y ? -1 : 0)], Ee = Y == (Pe.level == 1), Ve = Ee ? Pe.from : Pe.to, Ke = Ee ? "after" : "before";
        return m.ch == Ve && m.sticky == Ke ? l : new At(new xe(m.line, Ve, Ke), p);
      }
      function Ds(i, l, m, p) {
        var y, S;
        if (l.touches)
          y = l.touches[0].clientX, S = l.touches[0].clientY;
        else
          try {
            y = l.clientX, S = l.clientY;
          } catch {
            return !1;
          }
        if (y >= Math.floor(i.display.gutters.getBoundingClientRect().right))
          return !1;
        p && Ut(l);
        var R = i.display, N = R.lineDiv.getBoundingClientRect();
        if (S > N.bottom || !rn(i, m))
          return mr(l);
        S -= N.top - R.viewOffset;
        for (var H = 0; H < i.display.gutterSpecs.length; ++H) {
          var Y = R.gutters.childNodes[H];
          if (Y && Y.getBoundingClientRect().right >= y) {
            var le = jt(i.doc, S), he = i.display.gutterSpecs[H];
            return Tt(i, m, i, le, he.className, l), mr(l);
          }
        }
      }
      function Qi(i, l) {
        return Ds(i, l, "gutterClick", !0);
      }
      function Rs(i, l) {
        Yn(i.display, l) || iu(i, l) || yt(i, l, "contextmenu") || W || i.display.input.onContextMenu(l);
      }
      function iu(i, l) {
        return rn(i, "gutterContextMenu") ? Ds(i, l, "gutterContextMenu", !1) : !1;
      }
      function Ms(i) {
        i.display.wrapper.className = i.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + i.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), va(i);
      }
      var ra = { toString: function() {
        return "CodeMirror.Init";
      } }, Os = {}, di = {};
      function ou(i) {
        var l = i.optionHandlers;
        function m(p, y, S, R) {
          i.defaults[p] = y, S && (l[p] = R ? function(N, H, Y) {
            Y != ra && S(N, H, Y);
          } : S);
        }
        i.defineOption = m, i.Init = ra, m("value", "", function(p, y) {
          return p.setValue(y);
        }, !0), m("mode", null, function(p, y) {
          p.doc.modeOption = y, qi(p);
        }, !0), m("indentUnit", 2, qi, !0), m("indentWithTabs", !1), m("smartIndent", !0), m("tabSize", 4, function(p) {
          Ca(p), va(p), bn(p);
        }, !0), m("lineSeparator", null, function(p, y) {
          if (p.doc.lineSep = y, !!y) {
            var S = [], R = p.doc.first;
            p.doc.iter(function(H) {
              for (var Y = 0; ; ) {
                var le = H.text.indexOf(y, Y);
                if (le == -1)
                  break;
                Y = le + y.length, S.push(xe(R, le));
              }
              R++;
            });
            for (var N = S.length - 1; N >= 0; N--)
              Qr(p.doc, y, S[N], xe(S[N].line, S[N].ch + y.length));
          }
        }), m("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\u202d\u202e\u2066\u2067\u2069\ufeff\ufff9-\ufffc]/g, function(p, y, S) {
          p.state.specialChars = new RegExp(y.source + (y.test("	") ? "" : "|	"), "g"), S != ra && p.refresh();
        }), m("specialCharPlaceholder", Ct, function(p) {
          return p.refresh();
        }, !0), m("electricChars", !0), m("inputStyle", _ ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, !0), m("spellcheck", !1, function(p, y) {
          return p.getInputField().spellcheck = y;
        }, !0), m("autocorrect", !1, function(p, y) {
          return p.getInputField().autocorrect = y;
        }, !0), m("autocapitalize", !1, function(p, y) {
          return p.getInputField().autocapitalize = y;
        }, !0), m("rtlMoveVisually", !I), m("wholeLineUpdateBefore", !0), m("theme", "default", function(p) {
          Ms(p), Sa(p);
        }, !0), m("keyMap", "default", function(p, y, S) {
          var R = ui(y), N = S != ra && ui(S);
          N && N.detach && N.detach(p, R), R.attach && R.attach(p, N || null);
        }), m("extraKeys", null), m("configureMouse", null), m("lineWrapping", !1, lu, !0), m("gutters", [], function(p, y) {
          p.display.gutterSpecs = zi(y, p.options.lineNumbers), Sa(p);
        }, !0), m("fixedGutter", !0, function(p, y) {
          p.display.gutters.style.left = y ? Ti(p.display) + "px" : "0", p.refresh();
        }, !0), m("coverGutterNextToScrollbar", !1, function(p) {
          return Yr(p);
        }, !0), m("scrollbarStyle", "native", function(p) {
          Vo(p), Yr(p), p.display.scrollbars.setScrollTop(p.doc.scrollTop), p.display.scrollbars.setScrollLeft(p.doc.scrollLeft);
        }, !0), m("lineNumbers", !1, function(p, y) {
          p.display.gutterSpecs = zi(p.options.gutters, y), Sa(p);
        }, !0), m("firstLineNumber", 1, Sa, !0), m("lineNumberFormatter", function(p) {
          return p;
        }, Sa, !0), m("showCursorWhenSelecting", !1, ya, !0), m("resetSelectionOnContextMenu", !0), m("lineWiseCopyCut", !0), m("pasteLinesPerSelection", !0), m("selectionsMayTouch", !1), m("readOnly", !1, function(p, y) {
          y == "nocursor" && (Kr(p), p.display.input.blur()), p.display.input.readOnlyChanged(y);
        }), m("screenReaderLabel", null, function(p, y) {
          y = y === "" ? null : y, p.display.input.screenReaderLabelChanged(y);
        }), m("disableInput", !1, function(p, y) {
          y || p.display.input.reset();
        }, !0), m("dragDrop", !0, su), m("allowDropFileTypes", null), m("cursorBlinkRate", 530), m("cursorScrollMargin", 0), m("cursorHeight", 1, ya, !0), m("singleCursorHeightPerLine", !0, ya, !0), m("workTime", 100), m("workDelay", 100), m("flattenSpans", !0, Ca, !0), m("addModeClass", !1, Ca, !0), m("pollInterval", 100), m("undoDepth", 200, function(p, y) {
          return p.doc.history.undoDepth = y;
        }), m("historyEventDelay", 1250), m("viewportMargin", 10, function(p) {
          return p.refresh();
        }, !0), m("maxHighlightLength", 1e4, Ca, !0), m("moveInputWithCursor", !0, function(p, y) {
          y || p.display.input.resetPosition();
        }), m("tabindex", null, function(p, y) {
          return p.display.input.getField().tabIndex = y || "";
        }), m("autofocus", null), m("direction", "ltr", function(p, y) {
          return p.doc.setDirection(y);
        }, !0), m("phrases", null);
      }
      function su(i, l, m) {
        var p = m && m != ra;
        if (!l != !p) {
          var y = i.display.dragFunctions, S = l ? qe : Mt;
          S(i.display.scroller, "dragstart", y.start), S(i.display.scroller, "dragenter", y.enter), S(i.display.scroller, "dragover", y.over), S(i.display.scroller, "dragleave", y.leave), S(i.display.scroller, "drop", y.drop);
        }
      }
      function lu(i) {
        i.options.lineWrapping ? (ue(i.display.wrapper, "CodeMirror-wrap"), i.display.sizer.style.minWidth = "", i.display.sizerWidth = null) : (Z(i.display.wrapper, "CodeMirror-wrap"), Ue(i)), Pi(i), bn(i), va(i), setTimeout(function() {
          return Yr(i);
        }, 100);
      }
      function Ot(i, l) {
        var m = this;
        if (!(this instanceof Ot))
          return new Ot(i, l);
        this.options = l = l ? ye(l) : {}, ye(Os, l, !1);
        var p = l.value;
        typeof p == "string" ? p = new xn(p, l.mode, null, l.lineSeparator, l.direction) : l.mode && (p.modeOption = l.mode), this.doc = p;
        var y = new Ot.inputStyles[l.inputStyle](this), S = this.display = new wl(i, p, y, l);
        S.wrapper.CodeMirror = this, Ms(this), l.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), Vo(this), this.state = {
          keyMaps: [],
          // stores maps added by addKeyMap
          overlays: [],
          // highlighting overlays, as added by addOverlay
          modeGen: 0,
          // bumped when mode/overlay changes, used to invalidate highlighting info
          overwrite: !1,
          delayingBlurEvent: !1,
          focused: !1,
          suppressEdits: !1,
          // used to disable editing during key handlers when in readOnly mode
          pasteIncoming: -1,
          cutIncoming: -1,
          // help recognize paste/cut edits in input.poll
          selectingText: !1,
          draggingText: !1,
          highlight: new ke(),
          // stores highlight worker timeout
          keySeq: null,
          // Unfinished key sequence
          specialChars: null
        }, l.autofocus && !_ && S.input.focus(), f && g < 11 && setTimeout(function() {
          return m.display.input.reset(!0);
        }, 20), uu(this), Fl(), Dr(this), this.curOp.forceUpdate = !0, Ko(this, p), l.autofocus && !_ || this.hasFocus() ? setTimeout(function() {
          m.hasFocus() && !m.state.focused && Mi(m);
        }, 20) : Kr(this);
        for (var R in di)
          di.hasOwnProperty(R) && di[R](this, l[R], ra);
        Fo(this), l.finishInit && l.finishInit(this);
        for (var N = 0; N < eo.length; ++N)
          eo[N](this);
        Rr(this), v && l.lineWrapping && getComputedStyle(S.lineDiv).textRendering == "optimizelegibility" && (S.lineDiv.style.textRendering = "auto");
      }
      Ot.defaults = Os, Ot.optionHandlers = di;
      function uu(i) {
        var l = i.display;
        qe(l.scroller, "mousedown", Qt(i, Ps)), f && g < 11 ? qe(l.scroller, "dblclick", Qt(i, function(H) {
          if (!yt(i, H)) {
            var Y = Ar(i, H);
            if (!(!Y || Qi(i, H) || Yn(i.display, H))) {
              Ut(H);
              var le = i.findWordAt(Y);
              ai(i.doc, le.anchor, le.head);
            }
          }
        })) : qe(l.scroller, "dblclick", function(H) {
          return yt(i, H) || Ut(H);
        }), qe(l.scroller, "contextmenu", function(H) {
          return Rs(i, H);
        }), qe(l.input.getField(), "contextmenu", function(H) {
          l.scroller.contains(H.target) || Rs(i, H);
        });
        var m, p = { end: 0 };
        function y() {
          l.activeTouch && (m = setTimeout(function() {
            return l.activeTouch = null;
          }, 1e3), p = l.activeTouch, p.end = +/* @__PURE__ */ new Date());
        }
        function S(H) {
          if (H.touches.length != 1)
            return !1;
          var Y = H.touches[0];
          return Y.radiusX <= 1 && Y.radiusY <= 1;
        }
        function R(H, Y) {
          if (Y.left == null)
            return !0;
          var le = Y.left - H.left, he = Y.top - H.top;
          return le * le + he * he > 400;
        }
        qe(l.scroller, "touchstart", function(H) {
          if (!yt(i, H) && !S(H) && !Qi(i, H)) {
            l.input.ensurePolled(), clearTimeout(m);
            var Y = +/* @__PURE__ */ new Date();
            l.activeTouch = {
              start: Y,
              moved: !1,
              prev: Y - p.end <= 300 ? p : null
            }, H.touches.length == 1 && (l.activeTouch.left = H.touches[0].pageX, l.activeTouch.top = H.touches[0].pageY);
          }
        }), qe(l.scroller, "touchmove", function() {
          l.activeTouch && (l.activeTouch.moved = !0);
        }), qe(l.scroller, "touchend", function(H) {
          var Y = l.activeTouch;
          if (Y && !Yn(l, H) && Y.left != null && !Y.moved && /* @__PURE__ */ new Date() - Y.start < 300) {
            var le = i.coordsChar(l.activeTouch, "page"), he;
            !Y.prev || R(Y, Y.prev) ? he = new At(le, le) : !Y.prev.prev || R(Y, Y.prev.prev) ? he = i.findWordAt(le) : he = new At(xe(le.line, 0), mt(i.doc, xe(le.line + 1, 0))), i.setSelection(he.anchor, he.head), i.focus(), Ut(H);
          }
          y();
        }), qe(l.scroller, "touchcancel", y), qe(l.scroller, "scroll", function() {
          l.scroller.clientHeight && (xa(i, l.scroller.scrollTop), Pr(i, l.scroller.scrollLeft, !0), Tt(i, "scroll", i));
        }), qe(l.scroller, "mousewheel", function(H) {
          return qo(i, H);
        }), qe(l.scroller, "DOMMouseScroll", function(H) {
          return qo(i, H);
        }), qe(l.wrapper, "scroll", function() {
          return l.wrapper.scrollTop = l.wrapper.scrollLeft = 0;
        }), l.dragFunctions = {
          enter: function(H) {
            yt(i, H) || Dn(H);
          },
          over: function(H) {
            yt(i, H) || (Il(i, H), Dn(H));
          },
          start: function(H) {
            return Nl(i, H);
          },
          drop: Qt(i, Vl),
          leave: function(H) {
            yt(i, H) || vs(i);
          }
        };
        var N = l.input.getField();
        qe(N, "keyup", function(H) {
          return As.call(i, H);
        }), qe(N, "keydown", Qt(i, Es)), qe(N, "keypress", Qt(i, Ts)), qe(N, "focus", function(H) {
          return Mi(i, H);
        }), qe(N, "blur", function(H) {
          return Kr(i, H);
        });
      }
      var eo = [];
      Ot.defineInitHook = function(i) {
        return eo.push(i);
      };
      function Na(i, l, m, p) {
        var y = i.doc, S;
        m == null && (m = "add"), m == "smart" && (y.mode.indent ? S = kr(i, l).state : m = "prev");
        var R = i.options.tabSize, N = ut(y, l), H = ve(N.text, null, R);
        N.stateAfter && (N.stateAfter = null);
        var Y = N.text.match(/^\s*/)[0], le;
        if (!p && !/\S/.test(N.text))
          le = 0, m = "not";
        else if (m == "smart" && (le = y.mode.indent(S, N.text.slice(Y.length), N.text), le == Ie || le > 150)) {
          if (!p)
            return;
          m = "prev";
        }
        m == "prev" ? l > y.first ? le = ve(ut(y, l - 1).text, null, R) : le = 0 : m == "add" ? le = H + i.options.indentUnit : m == "subtract" ? le = H - i.options.indentUnit : typeof m == "number" && (le = H + m), le = Math.max(0, le);
        var he = "", Pe = 0;
        if (i.options.indentWithTabs)
          for (var Ee = Math.floor(le / R); Ee; --Ee)
            Pe += R, he += "	";
        if (Pe < le && (he += et(le - Pe)), he != Y)
          return Qr(y, he, xe(l, 0), xe(l, Y.length), "+input"), N.stateAfter = null, !0;
        for (var Ve = 0; Ve < y.sel.ranges.length; Ve++) {
          var Ke = y.sel.ranges[Ve];
          if (Ke.head.line == l && Ke.head.ch < Y.length) {
            var Ye = xe(l, Y.length);
            Ki(y, Ve, new At(Ye, Ye));
            break;
          }
        }
      }
      var In = null;
      function fi(i) {
        In = i;
      }
      function to(i, l, m, p, y) {
        var S = i.doc;
        i.display.shift = !1, p || (p = S.sel);
        var R = +/* @__PURE__ */ new Date() - 200, N = y == "paste" || i.state.pasteIncoming > R, H = vr(l), Y = null;
        if (N && p.ranges.length > 1)
          if (In && In.text.join(`
`) == l) {
            if (p.ranges.length % In.text.length == 0) {
              Y = [];
              for (var le = 0; le < In.text.length; le++)
                Y.push(S.splitLines(In.text[le]));
            }
          } else H.length == p.ranges.length && i.options.pasteLinesPerSelection && (Y = pe(H, function(nt) {
            return [nt];
          }));
        for (var he = i.curOp.updateInput, Pe = p.ranges.length - 1; Pe >= 0; Pe--) {
          var Ee = p.ranges[Pe], Ve = Ee.from(), Ke = Ee.to();
          Ee.empty() && (m && m > 0 ? Ve = xe(Ve.line, Ve.ch - m) : i.state.overwrite && !N ? Ke = xe(Ke.line, Math.min(ut(S, Ke.line).text.length, Ke.ch + ce(H).length)) : N && In && In.lineWise && In.text.join(`
`) == H.join(`
`) && (Ve = Ke = xe(Ve.line, 0)));
          var Ye = {
            from: Ve,
            to: Ke,
            text: Y ? Y[Pe % Y.length] : H,
            origin: y || (N ? "paste" : i.state.cutIncoming > R ? "cut" : "+input")
          };
          Jr(i.doc, Ye), Jt(i, "inputRead", i, Ye);
        }
        l && !N && Vs(i, l), Gr(i), i.curOp.updateInput < 2 && (i.curOp.updateInput = he), i.curOp.typing = !0, i.state.pasteIncoming = i.state.cutIncoming = -1;
      }
      function Ls(i, l) {
        var m = i.clipboardData && i.clipboardData.getData("Text");
        if (m)
          return i.preventDefault(), !l.isReadOnly() && !l.options.disableInput && l.hasFocus() && $n(l, function() {
            return to(l, m, 0, null, "paste");
          }), !0;
      }
      function Vs(i, l) {
        if (!(!i.options.electricChars || !i.options.smartIndent))
          for (var m = i.doc.sel, p = m.ranges.length - 1; p >= 0; p--) {
            var y = m.ranges[p];
            if (!(y.head.ch > 100 || p && m.ranges[p - 1].head.line == y.head.line)) {
              var S = i.getModeAt(y.head), R = !1;
              if (S.electricChars) {
                for (var N = 0; N < S.electricChars.length; N++)
                  if (l.indexOf(S.electricChars.charAt(N)) > -1) {
                    R = Na(i, y.head.line, "smart");
                    break;
                  }
              } else S.electricInput && S.electricInput.test(ut(i.doc, y.head.line).text.slice(0, y.head.ch)) && (R = Na(i, y.head.line, "smart"));
              R && Jt(i, "electricInput", i, y.head.line);
            }
          }
      }
      function Ns(i) {
        for (var l = [], m = [], p = 0; p < i.doc.sel.ranges.length; p++) {
          var y = i.doc.sel.ranges[p].head.line, S = { anchor: xe(y, 0), head: xe(y + 1, 0) };
          m.push(S), l.push(i.getRange(S.anchor, S.head));
        }
        return { text: l, ranges: m };
      }
      function no(i, l, m, p) {
        i.setAttribute("autocorrect", m ? "on" : "off"), i.setAttribute("autocapitalize", p ? "on" : "off"), i.setAttribute("spellcheck", !!l);
      }
      function Is() {
        var i = V("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none"), l = V("div", [i], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        return v ? i.style.width = "1000px" : i.setAttribute("wrap", "off"), M && (i.style.border = "1px solid black"), l;
      }
      function cu(i) {
        var l = i.optionHandlers, m = i.helpers = {};
        i.prototype = {
          constructor: i,
          focus: function() {
            ie(this).focus(), this.display.input.focus();
          },
          setOption: function(p, y) {
            var S = this.options, R = S[p];
            S[p] == y && p != "mode" || (S[p] = y, l.hasOwnProperty(p) && Qt(this, l[p])(this, y, R), Tt(this, "optionChange", this, p));
          },
          getOption: function(p) {
            return this.options[p];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(p, y) {
            this.state.keyMaps[y ? "push" : "unshift"](ui(p));
          },
          removeKeyMap: function(p) {
            for (var y = this.state.keyMaps, S = 0; S < y.length; ++S)
              if (y[S] == p || y[S].name == p)
                return y.splice(S, 1), !0;
          },
          addOverlay: hn(function(p, y) {
            var S = p.token ? p : i.getMode(this.options, p);
            if (S.startState)
              throw new Error("Overlays may not be stateful.");
            je(
              this.state.overlays,
              {
                mode: S,
                modeSpec: p,
                opaque: y && y.opaque,
                priority: y && y.priority || 0
              },
              function(R) {
                return R.priority;
              }
            ), this.state.modeGen++, bn(this);
          }),
          removeOverlay: hn(function(p) {
            for (var y = this.state.overlays, S = 0; S < y.length; ++S) {
              var R = y[S].modeSpec;
              if (R == p || typeof p == "string" && R.name == p) {
                y.splice(S, 1), this.state.modeGen++, bn(this);
                return;
              }
            }
          }),
          indentLine: hn(function(p, y, S) {
            typeof y != "string" && typeof y != "number" && (y == null ? y = this.options.smartIndent ? "smart" : "prev" : y = y ? "add" : "subtract"), ee(this.doc, p) && Na(this, p, y, S);
          }),
          indentSelection: hn(function(p) {
            for (var y = this.doc.sel.ranges, S = -1, R = 0; R < y.length; R++) {
              var N = y[R];
              if (N.empty())
                N.head.line > S && (Na(this, N.head.line, p, !0), S = N.head.line, R == this.doc.sel.primIndex && Gr(this));
              else {
                var H = N.from(), Y = N.to(), le = Math.max(S, H.line);
                S = Math.min(this.lastLine(), Y.line - (Y.ch ? 0 : 1)) + 1;
                for (var he = le; he < S; ++he)
                  Na(this, he, p);
                var Pe = this.doc.sel.ranges;
                H.ch == 0 && y.length == Pe.length && Pe[R].from().ch > 0 && Ki(this.doc, R, new At(H, Pe[R].to()), Se);
              }
            }
          }),
          // Fetch the parser token for a given character. Useful for hacks
          // that want to inspect the mode state (say, for completion).
          getTokenAt: function(p, y) {
            return Ir(this, p, y);
          },
          getLineTokens: function(p, y) {
            return Ir(this, xe(p), y, !0);
          },
          getTokenTypeAt: function(p) {
            p = mt(this.doc, p);
            var y = rr(this, ut(this.doc, p.line)), S = 0, R = (y.length - 1) / 2, N = p.ch, H;
            if (N == 0)
              H = y[2];
            else
              for (; ; ) {
                var Y = S + R >> 1;
                if ((Y ? y[Y * 2 - 1] : 0) >= N)
                  R = Y;
                else if (y[Y * 2 + 1] < N)
                  S = Y + 1;
                else {
                  H = y[Y * 2 + 2];
                  break;
                }
              }
            var le = H ? H.indexOf("overlay ") : -1;
            return le < 0 ? H : le == 0 ? null : H.slice(0, le - 1);
          },
          getModeAt: function(p) {
            var y = this.doc.mode;
            return y.innerMode ? i.innerMode(y, this.getTokenAt(p).state).mode : y;
          },
          getHelper: function(p, y) {
            return this.getHelpers(p, y)[0];
          },
          getHelpers: function(p, y) {
            var S = [];
            if (!m.hasOwnProperty(y))
              return S;
            var R = m[y], N = this.getModeAt(p);
            if (typeof N[y] == "string")
              R[N[y]] && S.push(R[N[y]]);
            else if (N[y])
              for (var H = 0; H < N[y].length; H++) {
                var Y = R[N[y][H]];
                Y && S.push(Y);
              }
            else N.helperType && R[N.helperType] ? S.push(R[N.helperType]) : R[N.name] && S.push(R[N.name]);
            for (var le = 0; le < R._global.length; le++) {
              var he = R._global[le];
              he.pred(N, this) && Ae(S, he.val) == -1 && S.push(he.val);
            }
            return S;
          },
          getStateAfter: function(p, y) {
            var S = this.doc;
            return p = vn(S, p ?? S.first + S.size - 1), kr(this, p + 1, y).state;
          },
          cursorCoords: function(p, y) {
            var S, R = this.doc.sel.primary();
            return p == null ? S = R.head : typeof p == "object" ? S = mt(this.doc, p) : S = p ? R.from() : R.to(), Vn(this, S, y || "page");
          },
          charCoords: function(p, y) {
            return Ga(this, mt(this.doc, p), y || "page");
          },
          coordsChar: function(p, y) {
            return p = So(this, p, y || "page"), $i(this, p.left, p.top);
          },
          lineAtHeight: function(p, y) {
            return p = So(this, { top: p, left: 0 }, y || "page").top, jt(this.doc, p + this.display.viewOffset);
          },
          heightAtLine: function(p, y, S) {
            var R = !1, N;
            if (typeof p == "number") {
              var H = this.doc.first + this.doc.size - 1;
              p < this.doc.first ? p = this.doc.first : p > H && (p = H, R = !0), N = ut(this.doc, p);
            } else
              N = p;
            return Ka(this, N, { top: 0, left: 0 }, y || "page", S || R).top + (R ? this.doc.height - _e(N) : 0);
          },
          defaultTextHeight: function() {
            return Ur(this.display);
          },
          defaultCharWidth: function() {
            return Wr(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(p, y, S, R, N) {
            var H = this.display;
            p = Vn(this, mt(this.doc, p));
            var Y = p.bottom, le = p.left;
            if (y.style.position = "absolute", y.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(y), H.sizer.appendChild(y), R == "over")
              Y = p.top;
            else if (R == "above" || R == "near") {
              var he = Math.max(H.wrapper.clientHeight, this.doc.height), Pe = Math.max(H.sizer.clientWidth, H.lineSpace.clientWidth);
              (R == "above" || p.bottom + y.offsetHeight > he) && p.top > y.offsetHeight ? Y = p.top - y.offsetHeight : p.bottom + y.offsetHeight <= he && (Y = p.bottom), le + y.offsetWidth > Pe && (le = Pe - y.offsetWidth);
            }
            y.style.top = Y + "px", y.style.left = y.style.right = "", N == "right" ? (le = H.sizer.clientWidth - y.offsetWidth, y.style.right = "0px") : (N == "left" ? le = 0 : N == "middle" && (le = (H.sizer.clientWidth - y.offsetWidth) / 2), y.style.left = le + "px"), S && sl(this, { left: le, top: Y, right: le + y.offsetWidth, bottom: Y + y.offsetHeight });
          },
          triggerOnKeyDown: hn(Es),
          triggerOnKeyPress: hn(Ts),
          triggerOnKeyUp: As,
          triggerOnMouseDown: hn(Ps),
          execCommand: function(p) {
            if (Ma.hasOwnProperty(p))
              return Ma[p].call(null, this);
          },
          triggerElectric: hn(function(p) {
            Vs(this, p);
          }),
          findPosH: function(p, y, S, R) {
            var N = 1;
            y < 0 && (N = -1, y = -y);
            for (var H = mt(this.doc, p), Y = 0; Y < y && (H = ro(this.doc, H, N, S, R), !H.hitSide); ++Y)
              ;
            return H;
          },
          moveH: hn(function(p, y) {
            var S = this;
            this.extendSelectionsBy(function(R) {
              return S.display.shift || S.doc.extend || R.empty() ? ro(S.doc, R.head, p, y, S.options.rtlMoveVisually) : p < 0 ? R.from() : R.to();
            }, Ne);
          }),
          deleteH: hn(function(p, y) {
            var S = this.doc.sel, R = this.doc;
            S.somethingSelected() ? R.replaceSelection("", null, "+delete") : na(this, function(N) {
              var H = ro(R, N.head, p, y, !1);
              return p < 0 ? { from: H, to: N.head } : { from: N.head, to: H };
            });
          }),
          findPosV: function(p, y, S, R) {
            var N = 1, H = R;
            y < 0 && (N = -1, y = -y);
            for (var Y = mt(this.doc, p), le = 0; le < y; ++le) {
              var he = Vn(this, Y, "div");
              if (H == null ? H = he.left : he.left = H, Y = Fs(this, he, N, S), Y.hitSide)
                break;
            }
            return Y;
          },
          moveV: hn(function(p, y) {
            var S = this, R = this.doc, N = [], H = !this.display.shift && !R.extend && R.sel.somethingSelected();
            if (R.extendSelectionsBy(function(le) {
              if (H)
                return p < 0 ? le.from() : le.to();
              var he = Vn(S, le.head, "div");
              le.goalColumn != null && (he.left = le.goalColumn), N.push(he.left);
              var Pe = Fs(S, he, p, y);
              return y == "page" && le == R.sel.primary() && Li(S, Ga(S, Pe, "div").top - he.top), Pe;
            }, Ne), N.length)
              for (var Y = 0; Y < R.sel.ranges.length; Y++)
                R.sel.ranges[Y].goalColumn = N[Y];
          }),
          // Find the word at the given position (as returned by coordsChar).
          findWordAt: function(p) {
            var y = this.doc, S = ut(y, p.line).text, R = p.ch, N = p.ch;
            if (S) {
              var H = this.getHelper(p, "wordChars");
              (p.sticky == "before" || N == S.length) && R ? --R : ++N;
              for (var Y = S.charAt(R), le = ot(Y, H) ? function(he) {
                return ot(he, H);
              } : /\s/.test(Y) ? function(he) {
                return /\s/.test(he);
              } : function(he) {
                return !/\s/.test(he) && !ot(he);
              }; R > 0 && le(S.charAt(R - 1)); )
                --R;
              for (; N < S.length && le(S.charAt(N)); )
                ++N;
            }
            return new At(xe(p.line, R), xe(p.line, N));
          },
          toggleOverwrite: function(p) {
            p != null && p == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? ue(this.display.cursorDiv, "CodeMirror-overwrite") : Z(this.display.cursorDiv, "CodeMirror-overwrite"), Tt(this, "overwriteToggle", this, this.state.overwrite));
          },
          hasFocus: function() {
            return this.display.input.getField() == X(G(this));
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: hn(function(p, y) {
            ba(this, p, y);
          }),
          getScrollInfo: function() {
            var p = this.display.scroller;
            return {
              left: p.scrollLeft,
              top: p.scrollTop,
              height: p.scrollHeight - Un(this) - this.display.barHeight,
              width: p.scrollWidth - Un(this) - this.display.barWidth,
              clientHeight: ki(this),
              clientWidth: $r(this)
            };
          },
          scrollIntoView: hn(function(p, y) {
            p == null ? (p = { from: this.doc.sel.primary().head, to: null }, y == null && (y = this.options.cursorScrollMargin)) : typeof p == "number" ? p = { from: xe(p, 0), to: null } : p.from == null && (p = { from: p, to: null }), p.to || (p.to = p.from), p.margin = y || 0, p.from.line != null ? ll(this, p) : Ro(this, p.from, p.to, p.margin);
          }),
          setSize: hn(function(p, y) {
            var S = this, R = function(H) {
              return typeof H == "number" || /^\d+$/.test(String(H)) ? H + "px" : H;
            };
            p != null && (this.display.wrapper.style.width = R(p)), y != null && (this.display.wrapper.style.height = R(y)), this.options.lineWrapping && wo(this);
            var N = this.display.viewFrom;
            this.doc.iter(N, this.display.viewTo, function(H) {
              if (H.widgets) {
                for (var Y = 0; Y < H.widgets.length; Y++)
                  if (H.widgets[Y].noHScroll) {
                    or(S, N, "widget");
                    break;
                  }
              }
              ++N;
            }), this.curOp.forceUpdate = !0, Tt(this, "refresh", this);
          }),
          operation: function(p) {
            return $n(this, p);
          },
          startOperation: function() {
            return Dr(this);
          },
          endOperation: function() {
            return Rr(this);
          },
          refresh: hn(function() {
            var p = this.display.cachedTextHeight;
            bn(this), this.curOp.forceUpdate = !0, va(this), ba(this, this.doc.scrollLeft, this.doc.scrollTop), Ii(this.display), (p == null || Math.abs(p - Ur(this.display)) > 0.5 || this.options.lineWrapping) && Pi(this), Tt(this, "refresh", this);
          }),
          swapDoc: hn(function(p) {
            var y = this.doc;
            return y.cm = null, this.state.selectingText && this.state.selectingText(), Ko(this, p), va(this), this.display.input.reset(), ba(this, p.scrollLeft, p.scrollTop), this.curOp.forceScroll = !0, Jt(this, "swapDoc", this, y), y;
          }),
          phrase: function(p) {
            var y = this.options.phrases;
            return y && Object.prototype.hasOwnProperty.call(y, p) ? y[p] : p;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        }, an(i), i.registerHelper = function(p, y, S) {
          m.hasOwnProperty(p) || (m[p] = i[p] = { _global: [] }), m[p][y] = S;
        }, i.registerGlobalHelper = function(p, y, S, R) {
          i.registerHelper(p, y, R), m[p]._global.push({ pred: S, val: R });
        };
      }
      function ro(i, l, m, p, y) {
        var S = l, R = m, N = ut(i, l.line), H = y && i.direction == "rtl" ? -m : m;
        function Y() {
          var it = l.line + H;
          return it < i.first || it >= i.first + i.size ? !1 : (l = new xe(it, l.ch, l.sticky), N = ut(i, it));
        }
        function le(it) {
          var rt;
          if (p == "codepoint") {
            var st = N.text.charCodeAt(l.ch + (m > 0 ? 0 : -1));
            if (isNaN(st))
              rt = null;
            else {
              var ft = m > 0 ? st >= 55296 && st < 56320 : st >= 56320 && st < 57343;
              rt = new xe(l.line, Math.max(0, Math.min(N.text.length, l.ch + m * (ft ? 2 : 1))), -m);
            }
          } else y ? rt = Ul(i.cm, N, l, m) : rt = Yi(N, l, m);
          if (rt == null)
            if (!it && Y())
              l = Xi(y, i.cm, N, l.line, H);
            else
              return !1;
          else
            l = rt;
          return !0;
        }
        if (p == "char" || p == "codepoint")
          le();
        else if (p == "column")
          le(!0);
        else if (p == "word" || p == "group")
          for (var he = null, Pe = p == "group", Ee = i.cm && i.cm.getHelper(l, "wordChars"), Ve = !0; !(m < 0 && !le(!Ve)); Ve = !1) {
            var Ke = N.text.charAt(l.ch) || `
`, Ye = ot(Ke, Ee) ? "w" : Pe && Ke == `
` ? "n" : !Pe || /\s/.test(Ke) ? null : "p";
            if (Pe && !Ve && !Ye && (Ye = "s"), he && he != Ye) {
              m < 0 && (m = 1, le(), l.sticky = "after");
              break;
            }
            if (Ye && (he = Ye), m > 0 && !le(!Ve))
              break;
          }
        var nt = oi(i, l, S, R, !0);
        return ht(S, nt) && (nt.hitSide = !0), nt;
      }
      function Fs(i, l, m, p) {
        var y = i.doc, S = l.left, R;
        if (p == "page") {
          var N = Math.min(i.display.wrapper.clientHeight, ie(i).innerHeight || y(i).documentElement.clientHeight), H = Math.max(N - 0.5 * Ur(i.display), 3);
          R = (m > 0 ? l.bottom : l.top) + m * H;
        } else p == "line" && (R = m > 0 ? l.bottom + 3 : l.top - 3);
        for (var Y; Y = $i(i, S, R), !!Y.outside; ) {
          if (m < 0 ? R <= 0 : R >= y.height) {
            Y.hitSide = !0;
            break;
          }
          R += m * 5;
        }
        return Y;
      }
      var Pt = function(i) {
        this.cm = i, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new ke(), this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null;
      };
      Pt.prototype.init = function(i) {
        var l = this, m = this, p = m.cm, y = m.div = i.lineDiv;
        y.contentEditable = !0, no(y, p.options.spellcheck, p.options.autocorrect, p.options.autocapitalize);
        function S(N) {
          for (var H = N.target; H; H = H.parentNode) {
            if (H == y)
              return !0;
            if (/\bCodeMirror-(?:line)?widget\b/.test(H.className))
              break;
          }
          return !1;
        }
        qe(y, "paste", function(N) {
          !S(N) || yt(p, N) || Ls(N, p) || g <= 11 && setTimeout(Qt(p, function() {
            return l.updateFromDOM();
          }), 20);
        }), qe(y, "compositionstart", function(N) {
          l.composing = { data: N.data, done: !1 };
        }), qe(y, "compositionupdate", function(N) {
          l.composing || (l.composing = { data: N.data, done: !1 });
        }), qe(y, "compositionend", function(N) {
          l.composing && (N.data != l.composing.data && l.readFromDOMSoon(), l.composing.done = !0);
        }), qe(y, "touchstart", function() {
          return m.forceCompositionEnd();
        }), qe(y, "input", function() {
          l.composing || l.readFromDOMSoon();
        });
        function R(N) {
          if (!(!S(N) || yt(p, N))) {
            if (p.somethingSelected())
              fi({ lineWise: !1, text: p.getSelections() }), N.type == "cut" && p.replaceSelection("", null, "cut");
            else if (p.options.lineWiseCopyCut) {
              var H = Ns(p);
              fi({ lineWise: !0, text: H.text }), N.type == "cut" && p.operation(function() {
                p.setSelections(H.ranges, 0, Se), p.replaceSelection("", null, "cut");
              });
            } else
              return;
            if (N.clipboardData) {
              N.clipboardData.clearData();
              var Y = In.text.join(`
`);
              if (N.clipboardData.setData("Text", Y), N.clipboardData.getData("Text") == Y) {
                N.preventDefault();
                return;
              }
            }
            var le = Is(), he = le.firstChild;
            no(he), p.display.lineSpace.insertBefore(le, p.display.lineSpace.firstChild), he.value = In.text.join(`
`);
            var Pe = X(y.ownerDocument);
            te(he), setTimeout(function() {
              p.display.lineSpace.removeChild(le), Pe.focus(), Pe == y && m.showPrimarySelection();
            }, 50);
          }
        }
        qe(y, "copy", R), qe(y, "cut", R);
      }, Pt.prototype.screenReaderLabelChanged = function(i) {
        i ? this.div.setAttribute("aria-label", i) : this.div.removeAttribute("aria-label");
      }, Pt.prototype.prepareSelection = function() {
        var i = Po(this.cm, !1);
        return i.focus = X(this.div.ownerDocument) == this.div, i;
      }, Pt.prototype.showSelection = function(i, l) {
        !i || !this.cm.display.view.length || ((i.focus || l) && this.showPrimarySelection(), this.showMultipleSelections(i));
      }, Pt.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      }, Pt.prototype.showPrimarySelection = function() {
        var i = this.getSelection(), l = this.cm, m = l.doc.sel.primary(), p = m.from(), y = m.to();
        if (l.display.viewTo == l.display.viewFrom || p.line >= l.display.viewTo || y.line < l.display.viewFrom) {
          i.removeAllRanges();
          return;
        }
        var S = pi(l, i.anchorNode, i.anchorOffset), R = pi(l, i.focusNode, i.focusOffset);
        if (!(S && !S.bad && R && !R.bad && De(It(S, R), p) == 0 && De(St(S, R), y) == 0)) {
          var N = l.display.view, H = p.line >= l.display.viewFrom && zs(l, p) || { node: N[0].measure.map[2], offset: 0 }, Y = y.line < l.display.viewTo && zs(l, y);
          if (!Y) {
            var le = N[N.length - 1].measure, he = le.maps ? le.maps[le.maps.length - 1] : le.map;
            Y = { node: he[he.length - 1], offset: he[he.length - 2] - he[he.length - 3] };
          }
          if (!H || !Y) {
            i.removeAllRanges();
            return;
          }
          var Pe = i.rangeCount && i.getRangeAt(0), Ee;
          try {
            Ee = Q(H.node, H.offset, Y.offset, Y.node);
          } catch {
          }
          Ee && (!o && l.state.focused ? (i.collapse(H.node, H.offset), Ee.collapsed || (i.removeAllRanges(), i.addRange(Ee))) : (i.removeAllRanges(), i.addRange(Ee)), Pe && i.anchorNode == null ? i.addRange(Pe) : o && this.startGracePeriod()), this.rememberSelection();
        }
      }, Pt.prototype.startGracePeriod = function() {
        var i = this;
        clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
          i.gracePeriod = !1, i.selectionChanged() && i.cm.operation(function() {
            return i.cm.curOp.selectionChanged = !0;
          });
        }, 20);
      }, Pt.prototype.showMultipleSelections = function(i) {
        re(this.cm.display.cursorDiv, i.cursors), re(this.cm.display.selectionDiv, i.selection);
      }, Pt.prototype.rememberSelection = function() {
        var i = this.getSelection();
        this.lastAnchorNode = i.anchorNode, this.lastAnchorOffset = i.anchorOffset, this.lastFocusNode = i.focusNode, this.lastFocusOffset = i.focusOffset;
      }, Pt.prototype.selectionInEditor = function() {
        var i = this.getSelection();
        if (!i.rangeCount)
          return !1;
        var l = i.getRangeAt(0).commonAncestorContainer;
        return z(this.div, l);
      }, Pt.prototype.focus = function() {
        this.cm.options.readOnly != "nocursor" && ((!this.selectionInEditor() || X(this.div.ownerDocument) != this.div) && this.showSelection(this.prepareSelection(), !0), this.div.focus());
      }, Pt.prototype.blur = function() {
        this.div.blur();
      }, Pt.prototype.getField = function() {
        return this.div;
      }, Pt.prototype.supportsTouch = function() {
        return !0;
      }, Pt.prototype.receivedFocus = function() {
        var i = this, l = this;
        this.selectionInEditor() ? setTimeout(function() {
          return i.pollSelection();
        }, 20) : $n(this.cm, function() {
          return l.cm.curOp.selectionChanged = !0;
        });
        function m() {
          l.cm.state.focused && (l.pollSelection(), l.polling.set(l.cm.options.pollInterval, m));
        }
        this.polling.set(this.cm.options.pollInterval, m);
      }, Pt.prototype.selectionChanged = function() {
        var i = this.getSelection();
        return i.anchorNode != this.lastAnchorNode || i.anchorOffset != this.lastAnchorOffset || i.focusNode != this.lastFocusNode || i.focusOffset != this.lastFocusOffset;
      }, Pt.prototype.pollSelection = function() {
        if (!(this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged())) {
          var i = this.getSelection(), l = this.cm;
          if (B && w && this.cm.display.gutterSpecs.length && du(i.anchorNode)) {
            this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs }), this.blur(), this.focus();
            return;
          }
          if (!this.composing) {
            this.rememberSelection();
            var m = pi(l, i.anchorNode, i.anchorOffset), p = pi(l, i.focusNode, i.focusOffset);
            m && p && $n(l, function() {
              cn(l.doc, lr(m, p), Se), (m.bad || p.bad) && (l.curOp.selectionChanged = !0);
            });
          }
        }
      }, Pt.prototype.pollContent = function() {
        this.readDOMTimeout != null && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
        var i = this.cm, l = i.display, m = i.doc.sel.primary(), p = m.from(), y = m.to();
        if (p.ch == 0 && p.line > i.firstLine() && (p = xe(p.line - 1, ut(i.doc, p.line - 1).length)), y.ch == ut(i.doc, y.line).text.length && y.line < i.lastLine() && (y = xe(y.line + 1, 0)), p.line < l.viewFrom || y.line > l.viewTo - 1)
          return !1;
        var S, R, N;
        p.line == l.viewFrom || (S = Tr(i, p.line)) == 0 ? (R = _t(l.view[0].line), N = l.view[0].node) : (R = _t(l.view[S].line), N = l.view[S - 1].node.nextSibling);
        var H = Tr(i, y.line), Y, le;
        if (H == l.view.length - 1 ? (Y = l.viewTo - 1, le = l.lineDiv.lastChild) : (Y = _t(l.view[H + 1].line) - 1, le = l.view[H + 1].node.previousSibling), !N)
          return !1;
        for (var he = i.doc.splitLines(fu(i, N, le, R, Y)), Pe = Ln(i.doc, xe(R, 0), xe(Y, ut(i.doc, Y).text.length)); he.length > 1 && Pe.length > 1; )
          if (ce(he) == ce(Pe))
            he.pop(), Pe.pop(), Y--;
          else if (he[0] == Pe[0])
            he.shift(), Pe.shift(), R++;
          else
            break;
        for (var Ee = 0, Ve = 0, Ke = he[0], Ye = Pe[0], nt = Math.min(Ke.length, Ye.length); Ee < nt && Ke.charCodeAt(Ee) == Ye.charCodeAt(Ee); )
          ++Ee;
        for (var it = ce(he), rt = ce(Pe), st = Math.min(
          it.length - (he.length == 1 ? Ee : 0),
          rt.length - (Pe.length == 1 ? Ee : 0)
        ); Ve < st && it.charCodeAt(it.length - Ve - 1) == rt.charCodeAt(rt.length - Ve - 1); )
          ++Ve;
        if (he.length == 1 && Pe.length == 1 && R == p.line)
          for (; Ee && Ee > p.ch && it.charCodeAt(it.length - Ve - 1) == rt.charCodeAt(rt.length - Ve - 1); )
            Ee--, Ve++;
        he[he.length - 1] = it.slice(0, it.length - Ve).replace(/^\u200b+/, ""), he[0] = he[0].slice(Ee).replace(/\u200b+$/, "");
        var ft = xe(R, Ee), dt = xe(Y, Pe.length ? ce(Pe).length - Ve : 0);
        if (he.length > 1 || he[0] || De(ft, dt))
          return Qr(i.doc, he, ft, dt, "+input"), !0;
      }, Pt.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      }, Pt.prototype.reset = function() {
        this.forceCompositionEnd();
      }, Pt.prototype.forceCompositionEnd = function() {
        this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus());
      }, Pt.prototype.readFromDOMSoon = function() {
        var i = this;
        this.readDOMTimeout == null && (this.readDOMTimeout = setTimeout(function() {
          if (i.readDOMTimeout = null, i.composing)
            if (i.composing.done)
              i.composing = null;
            else
              return;
          i.updateFromDOM();
        }, 80));
      }, Pt.prototype.updateFromDOM = function() {
        var i = this;
        (this.cm.isReadOnly() || !this.pollContent()) && $n(this.cm, function() {
          return bn(i.cm);
        });
      }, Pt.prototype.setUneditable = function(i) {
        i.contentEditable = "false";
      }, Pt.prototype.onKeyPress = function(i) {
        i.charCode == 0 || this.composing || (i.preventDefault(), this.cm.isReadOnly() || Qt(this.cm, to)(this.cm, String.fromCharCode(i.charCode == null ? i.keyCode : i.charCode), 0));
      }, Pt.prototype.readOnlyChanged = function(i) {
        this.div.contentEditable = String(i != "nocursor");
      }, Pt.prototype.onContextMenu = function() {
      }, Pt.prototype.resetPosition = function() {
      }, Pt.prototype.needsContentAttribute = !0;
      function zs(i, l) {
        var m = _i(i, l.line);
        if (!m || m.hidden)
          return null;
        var p = ut(i.doc, l.line), y = mo(m, p, l.line), S = Je(p, i.doc.direction), R = "left";
        if (S) {
          var N = $e(S, l.ch);
          R = N % 2 ? "right" : "left";
        }
        var H = bo(y.map, l.ch, R);
        return H.offset = H.collapse == "right" ? H.end : H.start, H;
      }
      function du(i) {
        for (var l = i; l; l = l.parentNode)
          if (/CodeMirror-gutter-wrapper/.test(l.className))
            return !0;
        return !1;
      }
      function aa(i, l) {
        return l && (i.bad = !0), i;
      }
      function fu(i, l, m, p, y) {
        var S = "", R = !1, N = i.doc.lineSeparator(), H = !1;
        function Y(Ee) {
          return function(Ve) {
            return Ve.id == Ee;
          };
        }
        function le() {
          R && (S += N, H && (S += N), R = H = !1);
        }
        function he(Ee) {
          Ee && (le(), S += Ee);
        }
        function Pe(Ee) {
          if (Ee.nodeType == 1) {
            var Ve = Ee.getAttribute("cm-text");
            if (Ve) {
              he(Ve);
              return;
            }
            var Ke = Ee.getAttribute("cm-marker"), Ye;
            if (Ke) {
              var nt = i.findMarks(xe(p, 0), xe(y + 1, 0), Y(+Ke));
              nt.length && (Ye = nt[0].find(0)) && he(Ln(i.doc, Ye.from, Ye.to).join(N));
              return;
            }
            if (Ee.getAttribute("contenteditable") == "false")
              return;
            var it = /^(pre|div|p|li|table|br)$/i.test(Ee.nodeName);
            if (!/^br$/i.test(Ee.nodeName) && Ee.textContent.length == 0)
              return;
            it && le();
            for (var rt = 0; rt < Ee.childNodes.length; rt++)
              Pe(Ee.childNodes[rt]);
            /^(pre|p)$/i.test(Ee.nodeName) && (H = !0), it && (R = !0);
          } else Ee.nodeType == 3 && he(Ee.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
        }
        for (; Pe(l), l != m; )
          l = l.nextSibling, H = !1;
        return S;
      }
      function pi(i, l, m) {
        var p;
        if (l == i.display.lineDiv) {
          if (p = i.display.lineDiv.childNodes[m], !p)
            return aa(i.clipPos(xe(i.display.viewTo - 1)), !0);
          l = null, m = 0;
        } else
          for (p = l; ; p = p.parentNode) {
            if (!p || p == i.display.lineDiv)
              return null;
            if (p.parentNode && p.parentNode == i.display.lineDiv)
              break;
          }
        for (var y = 0; y < i.display.view.length; y++) {
          var S = i.display.view[y];
          if (S.node == p)
            return pu(S, l, m);
        }
      }
      function pu(i, l, m) {
        var p = i.text.firstChild, y = !1;
        if (!l || !z(p, l))
          return aa(xe(_t(i.line), 0), !0);
        if (l == p && (y = !0, l = p.childNodes[m], m = 0, !l)) {
          var S = i.rest ? ce(i.rest) : i.line;
          return aa(xe(_t(S), S.text.length), y);
        }
        var R = l.nodeType == 3 ? l : null, N = l;
        for (!R && l.childNodes.length == 1 && l.firstChild.nodeType == 3 && (R = l.firstChild, m && (m = R.nodeValue.length)); N.parentNode != p; )
          N = N.parentNode;
        var H = i.measure, Y = H.maps;
        function le(Ye, nt, it) {
          for (var rt = -1; rt < (Y ? Y.length : 0); rt++)
            for (var st = rt < 0 ? H.map : Y[rt], ft = 0; ft < st.length; ft += 3) {
              var dt = st[ft + 2];
              if (dt == Ye || dt == nt) {
                var bt = _t(rt < 0 ? i.line : i.rest[rt]), Dt = st[ft] + it;
                return (it < 0 || dt != Ye) && (Dt = st[ft + (it ? 1 : 0)]), xe(bt, Dt);
              }
            }
        }
        var he = le(R, N, m);
        if (he)
          return aa(he, y);
        for (var Pe = N.nextSibling, Ee = R ? R.nodeValue.length - m : 0; Pe; Pe = Pe.nextSibling) {
          if (he = le(Pe, Pe.firstChild, 0), he)
            return aa(xe(he.line, he.ch - Ee), y);
          Ee += Pe.textContent.length;
        }
        for (var Ve = N.previousSibling, Ke = m; Ve; Ve = Ve.previousSibling) {
          if (he = le(Ve, Ve.firstChild, -1), he)
            return aa(xe(he.line, he.ch + Ke), y);
          Ke += Ve.textContent.length;
        }
      }
      var zt = function(i) {
        this.cm = i, this.prevInput = "", this.pollingFast = !1, this.polling = new ke(), this.hasSelection = !1, this.composing = null, this.resetting = !1;
      };
      zt.prototype.init = function(i) {
        var l = this, m = this, p = this.cm;
        this.createField(i);
        var y = this.textarea;
        i.wrapper.insertBefore(this.wrapper, i.wrapper.firstChild), M && (y.style.width = "0px"), qe(y, "input", function() {
          f && g >= 9 && l.hasSelection && (l.hasSelection = null), m.poll();
        }), qe(y, "paste", function(R) {
          yt(p, R) || Ls(R, p) || (p.state.pasteIncoming = +/* @__PURE__ */ new Date(), m.fastPoll());
        });
        function S(R) {
          if (!yt(p, R)) {
            if (p.somethingSelected())
              fi({ lineWise: !1, text: p.getSelections() });
            else if (p.options.lineWiseCopyCut) {
              var N = Ns(p);
              fi({ lineWise: !0, text: N.text }), R.type == "cut" ? p.setSelections(N.ranges, null, Se) : (m.prevInput = "", y.value = N.text.join(`
`), te(y));
            } else
              return;
            R.type == "cut" && (p.state.cutIncoming = +/* @__PURE__ */ new Date());
          }
        }
        qe(y, "cut", S), qe(y, "copy", S), qe(i.scroller, "paste", function(R) {
          if (!(Yn(i, R) || yt(p, R))) {
            if (!y.dispatchEvent) {
              p.state.pasteIncoming = +/* @__PURE__ */ new Date(), m.focus();
              return;
            }
            var N = new Event("paste");
            N.clipboardData = R.clipboardData, y.dispatchEvent(N);
          }
        }), qe(i.lineSpace, "selectstart", function(R) {
          Yn(i, R) || Ut(R);
        }), qe(y, "compositionstart", function() {
          var R = p.getCursor("from");
          m.composing && m.composing.range.clear(), m.composing = {
            start: R,
            range: p.markText(R, p.getCursor("to"), { className: "CodeMirror-composing" })
          };
        }), qe(y, "compositionend", function() {
          m.composing && (m.poll(), m.composing.range.clear(), m.composing = null);
        });
      }, zt.prototype.createField = function(i) {
        this.wrapper = Is(), this.textarea = this.wrapper.firstChild;
        var l = this.cm.options;
        no(this.textarea, l.spellcheck, l.autocorrect, l.autocapitalize);
      }, zt.prototype.screenReaderLabelChanged = function(i) {
        i ? this.textarea.setAttribute("aria-label", i) : this.textarea.removeAttribute("aria-label");
      }, zt.prototype.prepareSelection = function() {
        var i = this.cm, l = i.display, m = i.doc, p = Po(i);
        if (i.options.moveInputWithCursor) {
          var y = Vn(i, m.sel.primary().head, "div"), S = l.wrapper.getBoundingClientRect(), R = l.lineDiv.getBoundingClientRect();
          p.teTop = Math.max(0, Math.min(
            l.wrapper.clientHeight - 10,
            y.top + R.top - S.top
          )), p.teLeft = Math.max(0, Math.min(
            l.wrapper.clientWidth - 10,
            y.left + R.left - S.left
          ));
        }
        return p;
      }, zt.prototype.showSelection = function(i) {
        var l = this.cm, m = l.display;
        re(m.cursorDiv, i.cursors), re(m.selectionDiv, i.selection), i.teTop != null && (this.wrapper.style.top = i.teTop + "px", this.wrapper.style.left = i.teLeft + "px");
      }, zt.prototype.reset = function(i) {
        if (!(this.contextMenuPending || this.composing && i)) {
          var l = this.cm;
          if (this.resetting = !0, l.somethingSelected()) {
            this.prevInput = "";
            var m = l.getSelection();
            this.textarea.value = m, l.state.focused && te(this.textarea), f && g >= 9 && (this.hasSelection = m);
          } else i || (this.prevInput = this.textarea.value = "", f && g >= 9 && (this.hasSelection = null));
          this.resetting = !1;
        }
      }, zt.prototype.getField = function() {
        return this.textarea;
      }, zt.prototype.supportsTouch = function() {
        return !1;
      }, zt.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!_ || X(this.textarea.ownerDocument) != this.textarea))
          try {
            this.textarea.focus();
          } catch {
          }
      }, zt.prototype.blur = function() {
        this.textarea.blur();
      }, zt.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      }, zt.prototype.receivedFocus = function() {
        this.slowPoll();
      }, zt.prototype.slowPoll = function() {
        var i = this;
        this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
          i.poll(), i.cm.state.focused && i.slowPoll();
        });
      }, zt.prototype.fastPoll = function() {
        var i = !1, l = this;
        l.pollingFast = !0;
        function m() {
          var p = l.poll();
          !p && !i ? (i = !0, l.polling.set(60, m)) : (l.pollingFast = !1, l.slowPoll());
        }
        l.polling.set(20, m);
      }, zt.prototype.poll = function() {
        var i = this, l = this.cm, m = this.textarea, p = this.prevInput;
        if (this.contextMenuPending || this.resetting || !l.state.focused || Yt(m) && !p && !this.composing || l.isReadOnly() || l.options.disableInput || l.state.keySeq)
          return !1;
        var y = m.value;
        if (y == p && !l.somethingSelected())
          return !1;
        if (f && g >= 9 && this.hasSelection === y || T && /[\uf700-\uf7ff]/.test(y))
          return l.display.input.reset(), !1;
        if (l.doc.sel == l.display.selForContextMenu) {
          var S = y.charCodeAt(0);
          if (S == 8203 && !p && (p = ""), S == 8666)
            return this.reset(), this.cm.execCommand("undo");
        }
        for (var R = 0, N = Math.min(p.length, y.length); R < N && p.charCodeAt(R) == y.charCodeAt(R); )
          ++R;
        return $n(l, function() {
          to(
            l,
            y.slice(R),
            p.length - R,
            null,
            i.composing ? "*compose" : null
          ), y.length > 1e3 || y.indexOf(`
`) > -1 ? m.value = i.prevInput = "" : i.prevInput = y, i.composing && (i.composing.range.clear(), i.composing.range = l.markText(
            i.composing.start,
            l.getCursor("to"),
            { className: "CodeMirror-composing" }
          ));
        }), !0;
      }, zt.prototype.ensurePolled = function() {
        this.pollingFast && this.poll() && (this.pollingFast = !1);
      }, zt.prototype.onKeyPress = function() {
        f && g >= 9 && (this.hasSelection = null), this.fastPoll();
      }, zt.prototype.onContextMenu = function(i) {
        var l = this, m = l.cm, p = m.display, y = l.textarea;
        l.contextMenuPending && l.contextMenuPending();
        var S = Ar(m, i), R = p.scroller.scrollTop;
        if (!S || k)
          return;
        var N = m.options.resetSelectionOnContextMenu;
        N && m.doc.sel.contains(S) == -1 && Qt(m, cn)(m.doc, lr(S), Se);
        var H = y.style.cssText, Y = l.wrapper.style.cssText, le = l.wrapper.offsetParent.getBoundingClientRect();
        l.wrapper.style.cssText = "position: static", y.style.cssText = `position: absolute; width: 30px; height: 30px;
      top: ` + (i.clientY - le.top - 5) + "px; left: " + (i.clientX - le.left - 5) + `px;
      z-index: 1000; background: ` + (f ? "rgba(255, 255, 255, .05)" : "transparent") + `;
      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);`;
        var he;
        v && (he = y.ownerDocument.defaultView.scrollY), p.input.focus(), v && y.ownerDocument.defaultView.scrollTo(null, he), p.input.reset(), m.somethingSelected() || (y.value = l.prevInput = " "), l.contextMenuPending = Ee, p.selForContextMenu = m.doc.sel, clearTimeout(p.detectingSelectAll);
        function Pe() {
          if (y.selectionStart != null) {
            var Ke = m.somethingSelected(), Ye = "" + (Ke ? y.value : "");
            y.value = "", y.value = Ye, l.prevInput = Ke ? "" : "", y.selectionStart = 1, y.selectionEnd = Ye.length, p.selForContextMenu = m.doc.sel;
          }
        }
        function Ee() {
          if (l.contextMenuPending == Ee && (l.contextMenuPending = !1, l.wrapper.style.cssText = Y, y.style.cssText = H, f && g < 9 && p.scrollbars.setScrollTop(p.scroller.scrollTop = R), y.selectionStart != null)) {
            (!f || f && g < 9) && Pe();
            var Ke = 0, Ye = function() {
              p.selForContextMenu == m.doc.sel && y.selectionStart == 0 && y.selectionEnd > 0 && l.prevInput == "" ? Qt(m, os)(m) : Ke++ < 10 ? p.detectingSelectAll = setTimeout(Ye, 500) : (p.selForContextMenu = null, p.input.reset());
            };
            p.detectingSelectAll = setTimeout(Ye, 200);
          }
        }
        if (f && g >= 9 && Pe(), W) {
          Dn(i);
          var Ve = function() {
            Mt(window, "mouseup", Ve), setTimeout(Ee, 20);
          };
          qe(window, "mouseup", Ve);
        } else
          setTimeout(Ee, 50);
      }, zt.prototype.readOnlyChanged = function(i) {
        i || this.reset(), this.textarea.disabled = i == "nocursor", this.textarea.readOnly = !!i;
      }, zt.prototype.setUneditable = function() {
      }, zt.prototype.needsContentAttribute = !1;
      function hu(i, l) {
        if (l = l ? ye(l) : {}, l.value = i.value, !l.tabindex && i.tabIndex && (l.tabindex = i.tabIndex), !l.placeholder && i.placeholder && (l.placeholder = i.placeholder), l.autofocus == null) {
          var m = X(i.ownerDocument);
          l.autofocus = m == i || i.getAttribute("autofocus") != null && m == document.body;
        }
        function p() {
          i.value = N.getValue();
        }
        var y;
        if (i.form && (qe(i.form, "submit", p), !l.leaveSubmitMethodAlone)) {
          var S = i.form;
          y = S.submit;
          try {
            var R = S.submit = function() {
              p(), S.submit = y, S.submit(), S.submit = R;
            };
          } catch {
          }
        }
        l.finishInit = function(H) {
          H.save = p, H.getTextArea = function() {
            return i;
          }, H.toTextArea = function() {
            H.toTextArea = isNaN, p(), i.parentNode.removeChild(H.getWrapperElement()), i.style.display = "", i.form && (Mt(i.form, "submit", p), !l.leaveSubmitMethodAlone && typeof i.form.submit == "function" && (i.form.submit = y));
          };
        }, i.style.display = "none";
        var N = Ot(
          function(H) {
            return i.parentNode.insertBefore(H, i.nextSibling);
          },
          l
        );
        return N;
      }
      function mu(i) {
        i.off = Mt, i.on = qe, i.wheelEventPixels = kl, i.Doc = xn, i.splitLines = vr, i.countColumn = ve, i.findColumn = tt, i.isWordChar = Te, i.Pass = Ie, i.signal = Tt, i.Line = Me, i.changeEnd = ur, i.scrollbarModel = Lo, i.Pos = xe, i.cmpPos = De, i.modes = Sn, i.mimeModes = jn, i.resolveMode = pn, i.getMode = Rn, i.modeExtensions = Mn, i.extendMode = tr, i.copyState = On, i.startState = wr, i.innerMode = sn, i.commands = Ma, i.keyMap = Zn, i.keyName = ks, i.isModifierKey = xs, i.lookupKey = ta, i.normalizeKeyMap = Hl, i.StringStream = Rt, i.SharedTextMarker = Ba, i.TextMarker = dr, i.LineWidget = Pa, i.e_preventDefault = Ut, i.e_stopPropagation = Fn, i.e_stop = Dn, i.addClass = ue, i.contains = z, i.rmClass = Z, i.keyNames = fr;
      }
      ou(Ot), cu(Ot);
      var gu = "iter insert remove copy getEditor constructor".split(" ");
      for (var hi in xn.prototype)
        xn.prototype.hasOwnProperty(hi) && Ae(gu, hi) < 0 && (Ot.prototype[hi] = /* @__PURE__ */ (function(i) {
          return function() {
            return i.apply(this.doc, arguments);
          };
        })(xn.prototype[hi]));
      return an(xn), Ot.inputStyles = { textarea: zt, contenteditable: Pt }, Ot.defineMode = function(i) {
        !Ot.defaults.mode && i != "null" && (Ot.defaults.mode = i), xr.apply(this, arguments);
      }, Ot.defineMIME = er, Ot.defineMode("null", function() {
        return { token: function(i) {
          return i.skipToEnd();
        } };
      }), Ot.defineMIME("text/plain", "null"), Ot.defineExtension = function(i, l) {
        Ot.prototype[i] = l;
      }, Ot.defineDocExtension = function(i, l) {
        xn.prototype[i] = l;
      }, Ot.fromTextArea = hu, mu(Ot), Ot.version = "5.65.12", Ot;
    }));
  })(codemirror$1)), codemirror$1.exports;
}
var codemirrorExports = requireCodemirror();
const CodeMirror = /* @__PURE__ */ getDefaultExportFromCjs(codemirrorExports);
var MapShim = (function() {
  if (typeof Map < "u")
    return Map;
  function e(t, n) {
    var a = -1;
    return t.some(function(o, s) {
      return o[0] === n ? (a = s, !0) : !1;
    }), a;
  }
  return (
    /** @class */
    (function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var a = e(this.__entries__, n), o = this.__entries__[a];
        return o && o[1];
      }, t.prototype.set = function(n, a) {
        var o = e(this.__entries__, n);
        ~o ? this.__entries__[o][1] = a : this.__entries__.push([n, a]);
      }, t.prototype.delete = function(n) {
        var a = this.__entries__, o = e(a, n);
        ~o && a.splice(o, 1);
      }, t.prototype.has = function(n) {
        return !!~e(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, a) {
        a === void 0 && (a = null);
        for (var o = 0, s = this.__entries__; o < s.length; o++) {
          var u = s[o];
          n.call(a, u[1], u[0]);
        }
      }, t;
    })()
  );
})(), isBrowser$1 = typeof window < "u" && typeof document < "u" && window.document === document, global$1 = (function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
})(), requestAnimationFrame$1 = (function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(global$1) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
})(), trailingTimeout = 2;
function throttle$2(e, t) {
  var n = !1, a = !1, o = 0;
  function s() {
    n && (n = !1, e()), a && d();
  }
  function u() {
    requestAnimationFrame$1(s);
  }
  function d() {
    var f = Date.now();
    if (n) {
      if (f - o < trailingTimeout)
        return;
      a = !0;
    } else
      n = !0, a = !1, setTimeout(u, t);
    o = f;
  }
  return d;
}
var REFRESH_DELAY = 20, transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], mutationObserverSupported = typeof MutationObserver < "u", ResizeObserverController = (
  /** @class */
  (function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = throttle$2(this.refresh.bind(this), REFRESH_DELAY);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var n = this.observers_, a = n.indexOf(t);
      ~a && n.splice(a, 1), !n.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !isBrowser$1 || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), mutationObserverSupported ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !isBrowser$1 || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, a = n === void 0 ? "" : n, o = transitionKeys.some(function(s) {
        return !!~a.indexOf(s);
      });
      o && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  })()
), defineConfigurable = (function(e, t) {
  for (var n = 0, a = Object.keys(t); n < a.length; n++) {
    var o = a[n];
    Object.defineProperty(e, o, {
      value: t[o],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}), getWindowOf = (function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || global$1;
}), emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(e) {
  return parseFloat(e) || 0;
}
function getBordersSize(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(a, o) {
    var s = e["border-" + o + "-width"];
    return a + toFloat(s);
  }, 0);
}
function getPaddings(e) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, a = 0, o = t; a < o.length; a++) {
    var s = o[a], u = e["padding-" + s];
    n[s] = toFloat(u);
  }
  return n;
}
function getSVGContentRect(e) {
  var t = e.getBBox();
  return createRectInit(0, 0, t.width, t.height);
}
function getHTMLElementContentRect(e) {
  var t = e.clientWidth, n = e.clientHeight;
  if (!t && !n)
    return emptyRect;
  var a = getWindowOf(e).getComputedStyle(e), o = getPaddings(a), s = o.left + o.right, u = o.top + o.bottom, d = toFloat(a.width), f = toFloat(a.height);
  if (a.boxSizing === "border-box" && (Math.round(d + s) !== t && (d -= getBordersSize(a, "left", "right") + s), Math.round(f + u) !== n && (f -= getBordersSize(a, "top", "bottom") + u)), !isDocumentElement(e)) {
    var g = Math.round(d + s) - t, v = Math.round(f + u) - n;
    Math.abs(g) !== 1 && (d -= g), Math.abs(v) !== 1 && (f -= v);
  }
  return createRectInit(o.left, o.top, d, f);
}
var isSVGGraphicsElement = /* @__PURE__ */ (function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof getWindowOf(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof getWindowOf(e).SVGElement && typeof e.getBBox == "function";
  };
})();
function isDocumentElement(e) {
  return e === getWindowOf(e).document.documentElement;
}
function getContentRect(e) {
  return isBrowser$1 ? isSVGGraphicsElement(e) ? getSVGContentRect(e) : getHTMLElementContentRect(e) : emptyRect;
}
function createReadOnlyRect(e) {
  var t = e.x, n = e.y, a = e.width, o = e.height, s = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, u = Object.create(s.prototype);
  return defineConfigurable(u, {
    x: t,
    y: n,
    width: a,
    height: o,
    top: n,
    right: t + a,
    bottom: o + n,
    left: t
  }), u;
}
function createRectInit(e, t, n, a) {
  return { x: e, y: t, width: n, height: a };
}
var ResizeObservation = (
  /** @class */
  (function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = createRectInit(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = getContentRect(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  })()
), ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t, n) {
      var a = createReadOnlyRect(n);
      defineConfigurable(this, { target: t, contentRect: a });
    }
    return e;
  })()
), ResizeObserverSPI = (
  /** @class */
  (function() {
    function e(t, n, a) {
      if (this.activeObservations_ = [], this.observations_ = new MapShim(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = a;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof getWindowOf(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new ResizeObservation(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof getWindowOf(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(a) {
          return new ResizeObserverEntry(a.target, a.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  })()
), observers = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new MapShim(), ResizeObserver$1 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = ResizeObserverController.getInstance(), a = new ResizeObserverSPI(t, n, this);
      observers.set(this, a);
    }
    return e;
  })()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  ResizeObserver$1.prototype[e] = function() {
    var t;
    return (t = observers.get(this))[e].apply(t, arguments);
  };
});
var index$1 = (function() {
  return typeof global$1.ResizeObserver < "u" ? global$1.ResizeObserver : ResizeObserver$1;
})();
function throttle$1(e, t) {
  let n = 0;
  return function(...a) {
    const o = /* @__PURE__ */ new Date();
    o - n >= t && (e(...a), n = o);
  };
}
const _sfc_main$1C = {
  emits: ["resized"],
  data() {
    return {
      width: null
    };
  },
  render() {
    return this.$slots.default({})[0];
  },
  mounted() {
    new index$1(
      throttle$1((t) => {
        this.width = t[0].contentRect.width;
      }, 200)
    ).observe(this.$el);
  },
  watch: {
    width(e) {
      this.$emit("resized", { width: e });
    }
  }
};
var matchbrackets = { exports: {} }, hasRequiredMatchbrackets;
function requireMatchbrackets() {
  return hasRequiredMatchbrackets || (hasRequiredMatchbrackets = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      var a = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8), o = n.Pos, s = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
      function u(w) {
        return w && w.bracketRegex || /[(){}[\]]/;
      }
      function d(w, C, k) {
        var E = w.getLineHandle(C.line), A = C.ch - 1, P = k && k.afterCursor;
        P == null && (P = /(^| )cm-fat-cursor($| )/.test(w.getWrapperElement().className));
        var M = u(k), B = !P && A >= 0 && M.test(E.text.charAt(A)) && s[E.text.charAt(A)] || M.test(E.text.charAt(A + 1)) && s[E.text.charAt(++A)];
        if (!B) return null;
        var _ = B.charAt(1) == ">" ? 1 : -1;
        if (k && k.strict && _ > 0 != (A == C.ch)) return null;
        var T = w.getTokenTypeAt(o(C.line, A + 1)), O = f(w, o(C.line, A + (_ > 0 ? 1 : 0)), _, T, k);
        return O == null ? null : {
          from: o(C.line, A),
          to: O && O.pos,
          match: O && O.ch == B.charAt(0),
          forward: _ > 0
        };
      }
      function f(w, C, k, E, A) {
        for (var P = A && A.maxScanLineLength || 1e4, M = A && A.maxScanLines || 1e3, B = [], _ = u(A), T = k > 0 ? Math.min(C.line + M, w.lastLine() + 1) : Math.max(w.firstLine() - 1, C.line - M), O = C.line; O != T; O += k) {
          var I = w.getLine(O);
          if (I) {
            var q = k > 0 ? 0 : I.length - 1, F = k > 0 ? I.length : -1;
            if (!(I.length > P))
              for (O == C.line && (q = C.ch - (k < 0 ? 1 : 0)); q != F; q += k) {
                var W = I.charAt(q);
                if (_.test(W) && (E === void 0 || (w.getTokenTypeAt(o(O, q + 1)) || "") == (E || ""))) {
                  var K = s[W];
                  if (K && K.charAt(1) == ">" == k > 0) B.push(W);
                  else if (B.length) B.pop();
                  else return { pos: o(O, q), ch: W };
                }
              }
          }
        }
        return O - k == (k > 0 ? w.lastLine() : w.firstLine()) ? !1 : null;
      }
      function g(w, C, k) {
        for (var E = w.state.matchBrackets.maxHighlightLineLength || 1e3, A = k && k.highlightNonMatching, P = [], M = w.listSelections(), B = 0; B < M.length; B++) {
          var _ = M[B].empty() && d(w, M[B].head, k);
          if (_ && (_.match || A !== !1) && w.getLine(_.from.line).length <= E) {
            var T = _.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
            P.push(w.markText(_.from, o(_.from.line, _.from.ch + 1), { className: T })), _.to && w.getLine(_.to.line).length <= E && P.push(w.markText(_.to, o(_.to.line, _.to.ch + 1), { className: T }));
          }
        }
        if (P.length) {
          a && w.state.focused && w.focus();
          var O = function() {
            w.operation(function() {
              for (var I = 0; I < P.length; I++) P[I].clear();
            });
          };
          if (C) setTimeout(O, 800);
          else return O;
        }
      }
      function v(w) {
        w.operation(function() {
          w.state.matchBrackets.currentlyHighlighted && (w.state.matchBrackets.currentlyHighlighted(), w.state.matchBrackets.currentlyHighlighted = null), w.state.matchBrackets.currentlyHighlighted = g(w, !1, w.state.matchBrackets);
        });
      }
      function b(w) {
        w.state.matchBrackets && w.state.matchBrackets.currentlyHighlighted && (w.state.matchBrackets.currentlyHighlighted(), w.state.matchBrackets.currentlyHighlighted = null);
      }
      n.defineOption("matchBrackets", !1, function(w, C, k) {
        k && k != n.Init && (w.off("cursorActivity", v), w.off("focus", v), w.off("blur", b), b(w)), C && (w.state.matchBrackets = typeof C == "object" ? C : {}, w.on("cursorActivity", v), w.on("focus", v), w.on("blur", b));
      }), n.defineExtension("matchBrackets", function() {
        g(this, !0);
      }), n.defineExtension("findMatchingBracket", function(w, C, k) {
        return (k || typeof C == "boolean") && (k ? (k.strict = C, C = k) : C = C ? { strict: !0 } : null), d(this, w, C);
      }), n.defineExtension("scanForBracket", function(w, C, k, E) {
        return f(this, w, C, k, E);
      });
    });
  })()), matchbrackets.exports;
}
requireMatchbrackets();
var fullscreen = { exports: {} }, hasRequiredFullscreen;
function requireFullscreen() {
  return hasRequiredFullscreen || (hasRequiredFullscreen = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineOption("fullScreen", !1, function(s, u, d) {
        d == n.Init && (d = !1), !d != !u && (u ? a(s) : o(s));
      });
      function a(s) {
        var u = s.getWrapperElement();
        s.state.fullScreenRestore = {
          scrollTop: window.pageYOffset,
          scrollLeft: window.pageXOffset,
          width: u.style.width,
          height: u.style.height
        }, u.style.width = "", u.style.height = "auto", u.className += " CodeMirror-fullscreen", document.documentElement.style.overflow = "hidden", s.refresh();
      }
      function o(s) {
        var u = s.getWrapperElement();
        u.className = u.className.replace(/\s*CodeMirror-fullscreen\b/, ""), document.documentElement.style.overflow = "";
        var d = s.state.fullScreenRestore;
        u.style.width = d.width, u.style.height = d.height, window.scrollTo(d.scrollLeft, d.scrollTop), s.refresh();
      }
    });
  })()), fullscreen.exports;
}
requireFullscreen();
var rulers = { exports: {} }, hasRequiredRulers;
function requireRulers() {
  return hasRequiredRulers || (hasRequiredRulers = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineOption("rulers", !1, function(o, s) {
        o.state.rulerDiv && (o.state.rulerDiv.parentElement.removeChild(o.state.rulerDiv), o.state.rulerDiv = null, o.off("refresh", a)), s && s.length && (o.state.rulerDiv = o.display.lineSpace.parentElement.insertBefore(document.createElement("div"), o.display.lineSpace), o.state.rulerDiv.className = "CodeMirror-rulers", a(o), o.on("refresh", a));
      });
      function a(o) {
        o.state.rulerDiv.textContent = "";
        var s = o.getOption("rulers"), u = o.defaultCharWidth(), d = o.charCoords(n.Pos(o.firstLine(), 0), "div").left;
        o.state.rulerDiv.style.minHeight = o.display.scroller.offsetHeight + 30 + "px";
        for (var f = 0; f < s.length; f++) {
          var g = document.createElement("div");
          g.className = "CodeMirror-ruler";
          var v, b = s[f];
          typeof b == "number" ? v = b : (v = b.column, b.className && (g.className += " " + b.className), b.color && (g.style.borderColor = b.color), b.lineStyle && (g.style.borderLeftStyle = b.lineStyle), b.width && (g.style.borderLeftWidth = b.width)), g.style.left = d + v * u + "px", o.state.rulerDiv.appendChild(g);
        }
      }
    });
  })()), rulers.exports;
}
requireRulers();
var sublime = { exports: {} }, searchcursor = { exports: {} }, hasRequiredSearchcursor;
function requireSearchcursor() {
  return hasRequiredSearchcursor || (hasRequiredSearchcursor = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      var a = n.Pos;
      function o(M) {
        var B = M.flags;
        return B ?? (M.ignoreCase ? "i" : "") + (M.global ? "g" : "") + (M.multiline ? "m" : "");
      }
      function s(M, B) {
        for (var _ = o(M), T = _, O = 0; O < B.length; O++) T.indexOf(B.charAt(O)) == -1 && (T += B.charAt(O));
        return _ == T ? M : new RegExp(M.source, T);
      }
      function u(M) {
        return /\\s|\\n|\n|\\W|\\D|\[\^/.test(M.source);
      }
      function d(M, B, _) {
        B = s(B, "g");
        for (var T = _.line, O = _.ch, I = M.lastLine(); T <= I; T++, O = 0) {
          B.lastIndex = O;
          var q = M.getLine(T), F = B.exec(q);
          if (F)
            return {
              from: a(T, F.index),
              to: a(T, F.index + F[0].length),
              match: F
            };
        }
      }
      function f(M, B, _) {
        if (!u(B)) return d(M, B, _);
        B = s(B, "gm");
        for (var T, O = 1, I = _.line, q = M.lastLine(); I <= q; ) {
          for (var F = 0; F < O && !(I > q); F++) {
            var W = M.getLine(I++);
            T = T == null ? W : T + `
` + W;
          }
          O = O * 2, B.lastIndex = _.ch;
          var K = B.exec(T);
          if (K) {
            var Z = T.slice(0, K.index).split(`
`), J = K[0].split(`
`), re = _.line + Z.length - 1, V = Z[Z.length - 1].length;
            return {
              from: a(re, V),
              to: a(
                re + J.length - 1,
                J.length == 1 ? V + J[0].length : J[J.length - 1].length
              ),
              match: K
            };
          }
        }
      }
      function g(M, B, _) {
        for (var T, O = 0; O <= M.length; ) {
          B.lastIndex = O;
          var I = B.exec(M);
          if (!I) break;
          var q = I.index + I[0].length;
          if (q > M.length - _) break;
          (!T || q > T.index + T[0].length) && (T = I), O = I.index + 1;
        }
        return T;
      }
      function v(M, B, _) {
        B = s(B, "g");
        for (var T = _.line, O = _.ch, I = M.firstLine(); T >= I; T--, O = -1) {
          var q = M.getLine(T), F = g(q, B, O < 0 ? 0 : q.length - O);
          if (F)
            return {
              from: a(T, F.index),
              to: a(T, F.index + F[0].length),
              match: F
            };
        }
      }
      function b(M, B, _) {
        if (!u(B)) return v(M, B, _);
        B = s(B, "gm");
        for (var T, O = 1, I = M.getLine(_.line).length - _.ch, q = _.line, F = M.firstLine(); q >= F; ) {
          for (var W = 0; W < O && q >= F; W++) {
            var K = M.getLine(q--);
            T = T == null ? K : K + `
` + T;
          }
          O *= 2;
          var Z = g(T, B, I);
          if (Z) {
            var J = T.slice(0, Z.index).split(`
`), re = Z[0].split(`
`), V = q + J.length, ne = J[J.length - 1].length;
            return {
              from: a(V, ne),
              to: a(
                V + re.length - 1,
                re.length == 1 ? ne + re[0].length : re[re.length - 1].length
              ),
              match: Z
            };
          }
        }
      }
      var w, C;
      String.prototype.normalize ? (w = function(M) {
        return M.normalize("NFD").toLowerCase();
      }, C = function(M) {
        return M.normalize("NFD");
      }) : (w = function(M) {
        return M.toLowerCase();
      }, C = function(M) {
        return M;
      });
      function k(M, B, _, T) {
        if (M.length == B.length) return _;
        for (var O = 0, I = _ + Math.max(0, M.length - B.length); ; ) {
          if (O == I) return O;
          var q = O + I >> 1, F = T(M.slice(0, q)).length;
          if (F == _) return q;
          F > _ ? I = q : O = q + 1;
        }
      }
      function E(M, B, _, T) {
        if (!B.length) return null;
        var O = T ? w : C, I = O(B).split(/\r|\n\r?/);
        e: for (var q = _.line, F = _.ch, W = M.lastLine() + 1 - I.length; q <= W; q++, F = 0) {
          var K = M.getLine(q).slice(F), Z = O(K);
          if (I.length == 1) {
            var J = Z.indexOf(I[0]);
            if (J == -1) continue e;
            var _ = k(K, Z, J, O) + F;
            return {
              from: a(q, k(K, Z, J, O) + F),
              to: a(q, k(K, Z, J + I[0].length, O) + F)
            };
          } else {
            var re = Z.length - I[0].length;
            if (Z.slice(re) != I[0]) continue e;
            for (var V = 1; V < I.length - 1; V++)
              if (O(M.getLine(q + V)) != I[V]) continue e;
            var ne = M.getLine(q + I.length - 1), Q = O(ne), z = I[I.length - 1];
            if (Q.slice(0, z.length) != z) continue e;
            return {
              from: a(q, k(K, Z, re, O) + F),
              to: a(q + I.length - 1, k(ne, Q, z.length, O))
            };
          }
        }
      }
      function A(M, B, _, T) {
        if (!B.length) return null;
        var O = T ? w : C, I = O(B).split(/\r|\n\r?/);
        e: for (var q = _.line, F = _.ch, W = M.firstLine() - 1 + I.length; q >= W; q--, F = -1) {
          var K = M.getLine(q);
          F > -1 && (K = K.slice(0, F));
          var Z = O(K);
          if (I.length == 1) {
            var J = Z.lastIndexOf(I[0]);
            if (J == -1) continue e;
            return {
              from: a(q, k(K, Z, J, O)),
              to: a(q, k(K, Z, J + I[0].length, O))
            };
          } else {
            var re = I[I.length - 1];
            if (Z.slice(0, re.length) != re) continue e;
            for (var V = 1, _ = q - I.length + 1; V < I.length - 1; V++)
              if (O(M.getLine(_ + V)) != I[V]) continue e;
            var ne = M.getLine(q + 1 - I.length), Q = O(ne);
            if (Q.slice(Q.length - I[0].length) != I[0]) continue e;
            return {
              from: a(q + 1 - I.length, k(ne, Q, ne.length - I[0].length, O)),
              to: a(q, k(K, Z, re.length, O))
            };
          }
        }
      }
      function P(M, B, _, T) {
        this.atOccurrence = !1, this.afterEmptyMatch = !1, this.doc = M, _ = _ ? M.clipPos(_) : a(0, 0), this.pos = { from: _, to: _ };
        var O;
        typeof T == "object" ? O = T.caseFold : (O = T, T = null), typeof B == "string" ? (O == null && (O = !1), this.matches = function(I, q) {
          return (I ? A : E)(M, B, q, O);
        }) : (B = s(B, "gm"), !T || T.multiline !== !1 ? this.matches = function(I, q) {
          return (I ? b : f)(M, B, q);
        } : this.matches = function(I, q) {
          return (I ? v : d)(M, B, q);
        });
      }
      P.prototype = {
        findNext: function() {
          return this.find(!1);
        },
        findPrevious: function() {
          return this.find(!0);
        },
        find: function(M) {
          var B = this.doc.clipPos(M ? this.pos.from : this.pos.to);
          if (this.afterEmptyMatch && this.atOccurrence && (B = a(B.line, B.ch), M ? (B.ch--, B.ch < 0 && (B.line--, B.ch = (this.doc.getLine(B.line) || "").length)) : (B.ch++, B.ch > (this.doc.getLine(B.line) || "").length && (B.ch = 0, B.line++)), n.cmpPos(B, this.doc.clipPos(B)) != 0))
            return this.atOccurrence = !1;
          var _ = this.matches(M, B);
          if (this.afterEmptyMatch = _ && n.cmpPos(_.from, _.to) == 0, _)
            return this.pos = _, this.atOccurrence = !0, this.pos.match || !0;
          var T = a(M ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
          return this.pos = { from: T, to: T }, this.atOccurrence = !1;
        },
        from: function() {
          if (this.atOccurrence) return this.pos.from;
        },
        to: function() {
          if (this.atOccurrence) return this.pos.to;
        },
        replace: function(M, B) {
          if (this.atOccurrence) {
            var _ = n.splitLines(M);
            this.doc.replaceRange(_, this.pos.from, this.pos.to, B), this.pos.to = a(
              this.pos.from.line + _.length - 1,
              _[_.length - 1].length + (_.length == 1 ? this.pos.from.ch : 0)
            );
          }
        }
      }, n.defineExtension("getSearchCursor", function(M, B, _) {
        return new P(this.doc, M, B, _);
      }), n.defineDocExtension("getSearchCursor", function(M, B, _) {
        return new P(this, M, B, _);
      }), n.defineExtension("selectMatches", function(M, B) {
        for (var _ = [], T = this.getSearchCursor(M, this.getCursor("from"), B); T.findNext() && !(n.cmpPos(T.to(), this.getCursor("to")) > 0); )
          _.push({ anchor: T.from(), head: T.to() });
        _.length && this.setSelections(_, 0);
      });
    });
  })()), searchcursor.exports;
}
var hasRequiredSublime;
function requireSublime() {
  return hasRequiredSublime || (hasRequiredSublime = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireSearchcursor(), requireMatchbrackets());
    })(function(n) {
      var a = n.commands, o = n.Pos;
      function s(_, T, O) {
        if (O < 0 && T.ch == 0) return _.clipPos(o(T.line - 1));
        var I = _.getLine(T.line);
        if (O > 0 && T.ch >= I.length) return _.clipPos(o(T.line + 1, 0));
        for (var q = "start", F, W = T.ch, K = W, Z = O < 0 ? 0 : I.length, J = 0; K != Z; K += O, J++) {
          var re = I.charAt(O < 0 ? K - 1 : K), V = re != "_" && n.isWordChar(re) ? "w" : "o";
          if (V == "w" && re.toUpperCase() == re && (V = "W"), q == "start")
            V != "o" ? (q = "in", F = V) : W = K + O;
          else if (q == "in" && F != V) {
            if (F == "w" && V == "W" && O < 0 && K--, F == "W" && V == "w" && O > 0)
              if (K == W + 1) {
                F = "w";
                continue;
              } else K--;
            break;
          }
        }
        return o(T.line, K);
      }
      function u(_, T) {
        _.extendSelectionsBy(function(O) {
          return _.display.shift || _.doc.extend || O.empty() ? s(_.doc, O.head, T) : T < 0 ? O.from() : O.to();
        });
      }
      a.goSubwordLeft = function(_) {
        u(_, -1);
      }, a.goSubwordRight = function(_) {
        u(_, 1);
      }, a.scrollLineUp = function(_) {
        var T = _.getScrollInfo();
        if (!_.somethingSelected()) {
          var O = _.lineAtHeight(T.top + T.clientHeight, "local");
          _.getCursor().line >= O && _.execCommand("goLineUp");
        }
        _.scrollTo(null, T.top - _.defaultTextHeight());
      }, a.scrollLineDown = function(_) {
        var T = _.getScrollInfo();
        if (!_.somethingSelected()) {
          var O = _.lineAtHeight(T.top, "local") + 1;
          _.getCursor().line <= O && _.execCommand("goLineDown");
        }
        _.scrollTo(null, T.top + _.defaultTextHeight());
      }, a.splitSelectionByLine = function(_) {
        for (var T = _.listSelections(), O = [], I = 0; I < T.length; I++)
          for (var q = T[I].from(), F = T[I].to(), W = q.line; W <= F.line; ++W)
            F.line > q.line && W == F.line && F.ch == 0 || O.push({
              anchor: W == q.line ? q : o(W, 0),
              head: W == F.line ? F : o(W)
            });
        _.setSelections(O, 0);
      }, a.singleSelectionTop = function(_) {
        var T = _.listSelections()[0];
        _.setSelection(T.anchor, T.head, { scroll: !1 });
      }, a.selectLine = function(_) {
        for (var T = _.listSelections(), O = [], I = 0; I < T.length; I++) {
          var q = T[I];
          O.push({
            anchor: o(q.from().line, 0),
            head: o(q.to().line + 1, 0)
          });
        }
        _.setSelections(O);
      };
      function d(_, T) {
        if (_.isReadOnly()) return n.Pass;
        _.operation(function() {
          for (var O = _.listSelections().length, I = [], q = -1, F = 0; F < O; F++) {
            var W = _.listSelections()[F].head;
            if (!(W.line <= q)) {
              var K = o(W.line + (T ? 0 : 1), 0);
              _.replaceRange(`
`, K, null, "+insertLine"), _.indentLine(K.line, null, !0), I.push({ head: K, anchor: K }), q = W.line + 1;
            }
          }
          _.setSelections(I);
        }), _.execCommand("indentAuto");
      }
      a.insertLineAfter = function(_) {
        return d(_, !1);
      }, a.insertLineBefore = function(_) {
        return d(_, !0);
      };
      function f(_, T) {
        for (var O = T.ch, I = O, q = _.getLine(T.line); O && n.isWordChar(q.charAt(O - 1)); ) --O;
        for (; I < q.length && n.isWordChar(q.charAt(I)); ) ++I;
        return { from: o(T.line, O), to: o(T.line, I), word: q.slice(O, I) };
      }
      a.selectNextOccurrence = function(_) {
        var T = _.getCursor("from"), O = _.getCursor("to"), I = _.state.sublimeFindFullWord == _.doc.sel;
        if (n.cmpPos(T, O) == 0) {
          var q = f(_, T);
          if (!q.word) return;
          _.setSelection(q.from, q.to), I = !0;
        } else {
          var F = _.getRange(T, O), W = I ? new RegExp("\\b" + F + "\\b") : F, K = _.getSearchCursor(W, O), Z = K.findNext();
          if (Z || (K = _.getSearchCursor(W, o(_.firstLine(), 0)), Z = K.findNext()), !Z || v(_.listSelections(), K.from(), K.to())) return;
          _.addSelection(K.from(), K.to());
        }
        I && (_.state.sublimeFindFullWord = _.doc.sel);
      }, a.skipAndSelectNextOccurrence = function(_) {
        var T = _.getCursor("anchor"), O = _.getCursor("head");
        a.selectNextOccurrence(_), n.cmpPos(T, O) != 0 && _.doc.setSelections(_.doc.listSelections().filter(function(I) {
          return I.anchor != T || I.head != O;
        }));
      };
      function g(_, T) {
        for (var O = _.listSelections(), I = [], q = 0; q < O.length; q++) {
          var F = O[q], W = _.findPosV(
            F.anchor,
            T,
            "line",
            F.anchor.goalColumn
          ), K = _.findPosV(
            F.head,
            T,
            "line",
            F.head.goalColumn
          );
          W.goalColumn = F.anchor.goalColumn != null ? F.anchor.goalColumn : _.cursorCoords(F.anchor, "div").left, K.goalColumn = F.head.goalColumn != null ? F.head.goalColumn : _.cursorCoords(F.head, "div").left;
          var Z = { anchor: W, head: K };
          I.push(F), I.push(Z);
        }
        _.setSelections(I);
      }
      a.addCursorToPrevLine = function(_) {
        g(_, -1);
      }, a.addCursorToNextLine = function(_) {
        g(_, 1);
      };
      function v(_, T, O) {
        for (var I = 0; I < _.length; I++)
          if (n.cmpPos(_[I].from(), T) == 0 && n.cmpPos(_[I].to(), O) == 0) return !0;
        return !1;
      }
      var b = "(){}[]";
      function w(_) {
        for (var T = _.listSelections(), O = [], I = 0; I < T.length; I++) {
          var q = T[I], F = q.head, W = _.scanForBracket(F, -1);
          if (!W) return !1;
          for (; ; ) {
            var K = _.scanForBracket(F, 1);
            if (!K) return !1;
            if (K.ch == b.charAt(b.indexOf(W.ch) + 1)) {
              var Z = o(W.pos.line, W.pos.ch + 1);
              if (n.cmpPos(Z, q.from()) == 0 && n.cmpPos(K.pos, q.to()) == 0) {
                if (W = _.scanForBracket(W.pos, -1), !W) return !1;
              } else {
                O.push({ anchor: Z, head: K.pos });
                break;
              }
            }
            F = o(K.pos.line, K.pos.ch + 1);
          }
        }
        return _.setSelections(O), !0;
      }
      a.selectScope = function(_) {
        w(_) || _.execCommand("selectAll");
      }, a.selectBetweenBrackets = function(_) {
        if (!w(_)) return n.Pass;
      };
      function C(_) {
        return _ ? /\bpunctuation\b/.test(_) ? _ : void 0 : null;
      }
      a.goToBracket = function(_) {
        _.extendSelectionsBy(function(T) {
          var O = _.scanForBracket(T.head, 1, C(_.getTokenTypeAt(T.head)));
          if (O && n.cmpPos(O.pos, T.head) != 0) return O.pos;
          var I = _.scanForBracket(T.head, -1, C(_.getTokenTypeAt(o(T.head.line, T.head.ch + 1))));
          return I && o(I.pos.line, I.pos.ch + 1) || T.head;
        });
      }, a.swapLineUp = function(_) {
        if (_.isReadOnly()) return n.Pass;
        for (var T = _.listSelections(), O = [], I = _.firstLine() - 1, q = [], F = 0; F < T.length; F++) {
          var W = T[F], K = W.from().line - 1, Z = W.to().line;
          q.push({
            anchor: o(W.anchor.line - 1, W.anchor.ch),
            head: o(W.head.line - 1, W.head.ch)
          }), W.to().ch == 0 && !W.empty() && --Z, K > I ? O.push(K, Z) : O.length && (O[O.length - 1] = Z), I = Z;
        }
        _.operation(function() {
          for (var J = 0; J < O.length; J += 2) {
            var re = O[J], V = O[J + 1], ne = _.getLine(re);
            _.replaceRange("", o(re, 0), o(re + 1, 0), "+swapLine"), V > _.lastLine() ? _.replaceRange(`
` + ne, o(_.lastLine()), null, "+swapLine") : _.replaceRange(ne + `
`, o(V, 0), null, "+swapLine");
          }
          _.setSelections(q), _.scrollIntoView();
        });
      }, a.swapLineDown = function(_) {
        if (_.isReadOnly()) return n.Pass;
        for (var T = _.listSelections(), O = [], I = _.lastLine() + 1, q = T.length - 1; q >= 0; q--) {
          var F = T[q], W = F.to().line + 1, K = F.from().line;
          F.to().ch == 0 && !F.empty() && W--, W < I ? O.push(W, K) : O.length && (O[O.length - 1] = K), I = K;
        }
        _.operation(function() {
          for (var Z = O.length - 2; Z >= 0; Z -= 2) {
            var J = O[Z], re = O[Z + 1], V = _.getLine(J);
            J == _.lastLine() ? _.replaceRange("", o(J - 1), o(J), "+swapLine") : _.replaceRange("", o(J, 0), o(J + 1, 0), "+swapLine"), _.replaceRange(V + `
`, o(re, 0), null, "+swapLine");
          }
          _.scrollIntoView();
        });
      }, a.toggleCommentIndented = function(_) {
        _.toggleComment({ indent: !0 });
      }, a.joinLines = function(_) {
        for (var T = _.listSelections(), O = [], I = 0; I < T.length; I++) {
          for (var q = T[I], F = q.from(), W = F.line, K = q.to().line; I < T.length - 1 && T[I + 1].from().line == K; )
            K = T[++I].to().line;
          O.push({ start: W, end: K, anchor: !q.empty() && F });
        }
        _.operation(function() {
          for (var Z = 0, J = [], re = 0; re < O.length; re++) {
            for (var V = O[re], ne = V.anchor && o(V.anchor.line - Z, V.anchor.ch), Q, z = V.start; z <= V.end; z++) {
              var X = z - Z;
              z == V.end && (Q = o(X, _.getLine(X).length + 1)), X < _.lastLine() && (_.replaceRange(" ", o(X), o(X + 1, /^\s*/.exec(_.getLine(X + 1))[0].length)), ++Z);
            }
            J.push({ anchor: ne || Q, head: Q });
          }
          _.setSelections(J, 0);
        });
      }, a.duplicateLine = function(_) {
        _.operation(function() {
          for (var T = _.listSelections().length, O = 0; O < T; O++) {
            var I = _.listSelections()[O];
            I.empty() ? _.replaceRange(_.getLine(I.head.line) + `
`, o(I.head.line, 0)) : _.replaceRange(_.getRange(I.from(), I.to()), I.from());
          }
          _.scrollIntoView();
        });
      };
      function k(_, T, O) {
        if (_.isReadOnly()) return n.Pass;
        for (var I = _.listSelections(), q = [], F, W = 0; W < I.length; W++) {
          var K = I[W];
          if (!K.empty()) {
            for (var Z = K.from().line, J = K.to().line; W < I.length - 1 && I[W + 1].from().line == J; )
              J = I[++W].to().line;
            I[W].to().ch || J--, q.push(Z, J);
          }
        }
        q.length ? F = !0 : q.push(_.firstLine(), _.lastLine()), _.operation(function() {
          for (var re = [], V = 0; V < q.length; V += 2) {
            var ne = q[V], Q = q[V + 1], z = o(ne, 0), X = o(Q), ue = _.getRange(z, X, !1);
            T ? ue.sort(function(Be, te) {
              return Be < te ? -O : Be == te ? 0 : O;
            }) : ue.sort(function(Be, te) {
              var G = Be.toUpperCase(), ie = te.toUpperCase();
              return G != ie && (Be = G, te = ie), Be < te ? -O : Be == te ? 0 : O;
            }), _.replaceRange(ue, z, X), F && re.push({ anchor: z, head: o(Q + 1, 0) });
          }
          F && _.setSelections(re, 0);
        });
      }
      a.sortLines = function(_) {
        k(_, !0, 1);
      }, a.reverseSortLines = function(_) {
        k(_, !0, -1);
      }, a.sortLinesInsensitive = function(_) {
        k(_, !1, 1);
      }, a.reverseSortLinesInsensitive = function(_) {
        k(_, !1, -1);
      }, a.nextBookmark = function(_) {
        var T = _.state.sublimeBookmarks;
        if (T) for (; T.length; ) {
          var O = T.shift(), I = O.find();
          if (I)
            return T.push(O), _.setSelection(I.from, I.to);
        }
      }, a.prevBookmark = function(_) {
        var T = _.state.sublimeBookmarks;
        if (T) for (; T.length; ) {
          T.unshift(T.pop());
          var O = T[T.length - 1].find();
          if (!O)
            T.pop();
          else
            return _.setSelection(O.from, O.to);
        }
      }, a.toggleBookmark = function(_) {
        for (var T = _.listSelections(), O = _.state.sublimeBookmarks || (_.state.sublimeBookmarks = []), I = 0; I < T.length; I++) {
          for (var q = T[I].from(), F = T[I].to(), W = T[I].empty() ? _.findMarksAt(q) : _.findMarks(q, F), K = 0; K < W.length; K++)
            if (W[K].sublimeBookmark) {
              W[K].clear();
              for (var Z = 0; Z < O.length; Z++)
                O[Z] == W[K] && O.splice(Z--, 1);
              break;
            }
          K == W.length && O.push(_.markText(q, F, { sublimeBookmark: !0, clearWhenEmpty: !1 }));
        }
      }, a.clearBookmarks = function(_) {
        var T = _.state.sublimeBookmarks;
        if (T) for (var O = 0; O < T.length; O++) T[O].clear();
        T.length = 0;
      }, a.selectBookmarks = function(_) {
        var T = _.state.sublimeBookmarks, O = [];
        if (T) for (var I = 0; I < T.length; I++) {
          var q = T[I].find();
          q ? O.push({ anchor: q.from, head: q.to }) : T.splice(I--, 0);
        }
        O.length && _.setSelections(O, 0);
      };
      function E(_, T) {
        _.operation(function() {
          for (var O = _.listSelections(), I = [], q = [], F = 0; F < O.length; F++) {
            var W = O[F];
            W.empty() ? (I.push(F), q.push("")) : q.push(T(_.getRange(W.from(), W.to())));
          }
          _.replaceSelections(q, "around", "case");
          for (var F = I.length - 1, K; F >= 0; F--) {
            var W = O[I[F]];
            if (!(K && n.cmpPos(W.head, K) > 0)) {
              var Z = f(_, W.head);
              K = Z.from, _.replaceRange(T(Z.word), Z.from, Z.to);
            }
          }
        });
      }
      a.smartBackspace = function(_) {
        if (_.somethingSelected()) return n.Pass;
        _.operation(function() {
          for (var T = _.listSelections(), O = _.getOption("indentUnit"), I = T.length - 1; I >= 0; I--) {
            var q = T[I].head, F = _.getRange({ line: q.line, ch: 0 }, q), W = n.countColumn(F, null, _.getOption("tabSize")), K = _.findPosH(q, -1, "char", !1);
            if (F && !/\S/.test(F) && W % O == 0) {
              var Z = new o(
                q.line,
                n.findColumn(F, W - O, O)
              );
              Z.ch != q.ch && (K = Z);
            }
            _.replaceRange("", K, q, "+delete");
          }
        });
      }, a.delLineRight = function(_) {
        _.operation(function() {
          for (var T = _.listSelections(), O = T.length - 1; O >= 0; O--)
            _.replaceRange("", T[O].anchor, o(T[O].to().line), "+delete");
          _.scrollIntoView();
        });
      }, a.upcaseAtCursor = function(_) {
        E(_, function(T) {
          return T.toUpperCase();
        });
      }, a.downcaseAtCursor = function(_) {
        E(_, function(T) {
          return T.toLowerCase();
        });
      }, a.setSublimeMark = function(_) {
        _.state.sublimeMark && _.state.sublimeMark.clear(), _.state.sublimeMark = _.setBookmark(_.getCursor());
      }, a.selectToSublimeMark = function(_) {
        var T = _.state.sublimeMark && _.state.sublimeMark.find();
        T && _.setSelection(_.getCursor(), T);
      }, a.deleteToSublimeMark = function(_) {
        var T = _.state.sublimeMark && _.state.sublimeMark.find();
        if (T) {
          var O = _.getCursor(), I = T;
          if (n.cmpPos(O, I) > 0) {
            var q = I;
            I = O, O = q;
          }
          _.state.sublimeKilled = _.getRange(O, I), _.replaceRange("", O, I);
        }
      }, a.swapWithSublimeMark = function(_) {
        var T = _.state.sublimeMark && _.state.sublimeMark.find();
        T && (_.state.sublimeMark.clear(), _.state.sublimeMark = _.setBookmark(_.getCursor()), _.setCursor(T));
      }, a.sublimeYank = function(_) {
        _.state.sublimeKilled != null && _.replaceSelection(_.state.sublimeKilled, null, "paste");
      }, a.showInCenter = function(_) {
        var T = _.cursorCoords(null, "local");
        _.scrollTo(null, (T.top + T.bottom) / 2 - _.getScrollInfo().clientHeight / 2);
      };
      function A(_) {
        var T = _.getCursor("from"), O = _.getCursor("to");
        if (n.cmpPos(T, O) == 0) {
          var I = f(_, T);
          if (!I.word) return;
          T = I.from, O = I.to;
        }
        return { from: T, to: O, query: _.getRange(T, O), word: I };
      }
      function P(_, T) {
        var O = A(_);
        if (O) {
          var I = O.query, q = _.getSearchCursor(I, T ? O.to : O.from);
          (T ? q.findNext() : q.findPrevious()) ? _.setSelection(q.from(), q.to()) : (q = _.getSearchCursor(I, T ? o(_.firstLine(), 0) : _.clipPos(o(_.lastLine()))), (T ? q.findNext() : q.findPrevious()) ? _.setSelection(q.from(), q.to()) : O.word && _.setSelection(O.from, O.to));
        }
      }
      a.findUnder = function(_) {
        P(_, !0);
      }, a.findUnderPrevious = function(_) {
        P(_, !1);
      }, a.findAllUnder = function(_) {
        var T = A(_);
        if (T) {
          for (var O = _.getSearchCursor(T.query), I = [], q = -1; O.findNext(); )
            I.push({ anchor: O.from(), head: O.to() }), O.from().line <= T.from.line && O.from().ch <= T.from.ch && q++;
          _.setSelections(I, q);
        }
      };
      var M = n.keyMap;
      M.macSublime = {
        "Cmd-Left": "goLineStartSmart",
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-Left": "goSubwordLeft",
        "Ctrl-Right": "goSubwordRight",
        "Ctrl-Alt-Up": "scrollLineUp",
        "Ctrl-Alt-Down": "scrollLineDown",
        "Cmd-L": "selectLine",
        "Shift-Cmd-L": "splitSelectionByLine",
        Esc: "singleSelectionTop",
        "Cmd-Enter": "insertLineAfter",
        "Shift-Cmd-Enter": "insertLineBefore",
        "Cmd-D": "selectNextOccurrence",
        "Shift-Cmd-Space": "selectScope",
        "Shift-Cmd-M": "selectBetweenBrackets",
        "Cmd-M": "goToBracket",
        "Cmd-Ctrl-Up": "swapLineUp",
        "Cmd-Ctrl-Down": "swapLineDown",
        "Cmd-/": "toggleCommentIndented",
        "Cmd-J": "joinLines",
        "Shift-Cmd-D": "duplicateLine",
        F5: "sortLines",
        "Shift-F5": "reverseSortLines",
        "Cmd-F5": "sortLinesInsensitive",
        "Shift-Cmd-F5": "reverseSortLinesInsensitive",
        F2: "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Cmd-F2": "toggleBookmark",
        "Shift-Cmd-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        Backspace: "smartBackspace",
        "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",
        "Cmd-K Cmd-K": "delLineRight",
        "Cmd-K Cmd-U": "upcaseAtCursor",
        "Cmd-K Cmd-L": "downcaseAtCursor",
        "Cmd-K Cmd-Space": "setSublimeMark",
        "Cmd-K Cmd-A": "selectToSublimeMark",
        "Cmd-K Cmd-W": "deleteToSublimeMark",
        "Cmd-K Cmd-X": "swapWithSublimeMark",
        "Cmd-K Cmd-Y": "sublimeYank",
        "Cmd-K Cmd-C": "showInCenter",
        "Cmd-K Cmd-G": "clearBookmarks",
        "Cmd-K Cmd-Backspace": "delLineLeft",
        "Cmd-K Cmd-1": "foldAll",
        "Cmd-K Cmd-0": "unfoldAll",
        "Cmd-K Cmd-J": "unfoldAll",
        "Ctrl-Shift-Up": "addCursorToPrevLine",
        "Ctrl-Shift-Down": "addCursorToNextLine",
        "Cmd-F3": "findUnder",
        "Shift-Cmd-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Cmd-[": "fold",
        "Shift-Cmd-]": "unfold",
        "Cmd-I": "findIncremental",
        "Shift-Cmd-I": "findIncrementalReverse",
        "Cmd-H": "replace",
        F3: "findNext",
        "Shift-F3": "findPrev",
        fallthrough: "macDefault"
      }, n.normalizeKeyMap(M.macSublime), M.pcSublime = {
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-T": "transposeChars",
        "Alt-Left": "goSubwordLeft",
        "Alt-Right": "goSubwordRight",
        "Ctrl-Up": "scrollLineUp",
        "Ctrl-Down": "scrollLineDown",
        "Ctrl-L": "selectLine",
        "Shift-Ctrl-L": "splitSelectionByLine",
        Esc: "singleSelectionTop",
        "Ctrl-Enter": "insertLineAfter",
        "Shift-Ctrl-Enter": "insertLineBefore",
        "Ctrl-D": "selectNextOccurrence",
        "Shift-Ctrl-Space": "selectScope",
        "Shift-Ctrl-M": "selectBetweenBrackets",
        "Ctrl-M": "goToBracket",
        "Shift-Ctrl-Up": "swapLineUp",
        "Shift-Ctrl-Down": "swapLineDown",
        "Ctrl-/": "toggleCommentIndented",
        "Ctrl-J": "joinLines",
        "Shift-Ctrl-D": "duplicateLine",
        F9: "sortLines",
        "Shift-F9": "reverseSortLines",
        "Ctrl-F9": "sortLinesInsensitive",
        "Shift-Ctrl-F9": "reverseSortLinesInsensitive",
        F2: "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Ctrl-F2": "toggleBookmark",
        "Shift-Ctrl-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        Backspace: "smartBackspace",
        "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",
        "Ctrl-K Ctrl-K": "delLineRight",
        "Ctrl-K Ctrl-U": "upcaseAtCursor",
        "Ctrl-K Ctrl-L": "downcaseAtCursor",
        "Ctrl-K Ctrl-Space": "setSublimeMark",
        "Ctrl-K Ctrl-A": "selectToSublimeMark",
        "Ctrl-K Ctrl-W": "deleteToSublimeMark",
        "Ctrl-K Ctrl-X": "swapWithSublimeMark",
        "Ctrl-K Ctrl-Y": "sublimeYank",
        "Ctrl-K Ctrl-C": "showInCenter",
        "Ctrl-K Ctrl-G": "clearBookmarks",
        "Ctrl-K Ctrl-Backspace": "delLineLeft",
        "Ctrl-K Ctrl-1": "foldAll",
        "Ctrl-K Ctrl-0": "unfoldAll",
        "Ctrl-K Ctrl-J": "unfoldAll",
        "Ctrl-Alt-Up": "addCursorToPrevLine",
        "Ctrl-Alt-Down": "addCursorToNextLine",
        "Ctrl-F3": "findUnder",
        "Shift-Ctrl-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Ctrl-[": "fold",
        "Shift-Ctrl-]": "unfold",
        "Ctrl-I": "findIncremental",
        "Shift-Ctrl-I": "findIncrementalReverse",
        "Ctrl-H": "replace",
        F3: "findNext",
        "Shift-F3": "findPrev",
        fallthrough: "pcDefault"
      }, n.normalizeKeyMap(M.pcSublime);
      var B = M.default == M.macDefault;
      M.sublime = B ? M.macSublime : M.pcSublime;
    });
  })()), sublime.exports;
}
requireSublime();
var vim = { exports: {} }, dialog = { exports: {} }, hasRequiredDialog;
function requireDialog() {
  return hasRequiredDialog || (hasRequiredDialog = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      function a(s, u, d) {
        var f = s.getWrapperElement(), g;
        return g = f.appendChild(document.createElement("div")), d ? g.className = "CodeMirror-dialog CodeMirror-dialog-bottom" : g.className = "CodeMirror-dialog CodeMirror-dialog-top", typeof u == "string" ? g.innerHTML = u : g.appendChild(u), n.addClass(f, "dialog-opened"), g;
      }
      function o(s, u) {
        s.state.currentNotificationClose && s.state.currentNotificationClose(), s.state.currentNotificationClose = u;
      }
      n.defineExtension("openDialog", function(s, u, d) {
        d || (d = {}), o(this, null);
        var f = a(this, s, d.bottom), g = !1, v = this;
        function b(k) {
          if (typeof k == "string")
            w.value = k;
          else {
            if (g) return;
            g = !0, n.rmClass(f.parentNode, "dialog-opened"), f.parentNode.removeChild(f), v.focus(), d.onClose && d.onClose(f);
          }
        }
        var w = f.getElementsByTagName("input")[0], C;
        return w ? (w.focus(), d.value && (w.value = d.value, d.selectValueOnOpen !== !1 && w.select()), d.onInput && n.on(w, "input", function(k) {
          d.onInput(k, w.value, b);
        }), d.onKeyUp && n.on(w, "keyup", function(k) {
          d.onKeyUp(k, w.value, b);
        }), n.on(w, "keydown", function(k) {
          d && d.onKeyDown && d.onKeyDown(k, w.value, b) || ((k.keyCode == 27 || d.closeOnEnter !== !1 && k.keyCode == 13) && (w.blur(), n.e_stop(k), b()), k.keyCode == 13 && u(w.value, k));
        }), d.closeOnBlur !== !1 && n.on(f, "focusout", function(k) {
          k.relatedTarget !== null && b();
        })) : (C = f.getElementsByTagName("button")[0]) && (n.on(C, "click", function() {
          b(), v.focus();
        }), d.closeOnBlur !== !1 && n.on(C, "blur", b), C.focus()), b;
      }), n.defineExtension("openConfirm", function(s, u, d) {
        o(this, null);
        var f = a(this, s, d && d.bottom), g = f.getElementsByTagName("button"), v = !1, b = this, w = 1;
        function C() {
          v || (v = !0, n.rmClass(f.parentNode, "dialog-opened"), f.parentNode.removeChild(f), b.focus());
        }
        g[0].focus();
        for (var k = 0; k < g.length; ++k) {
          var E = g[k];
          (function(A) {
            n.on(E, "click", function(P) {
              n.e_preventDefault(P), C(), A && A(b);
            });
          })(u[k]), n.on(E, "blur", function() {
            --w, setTimeout(function() {
              w <= 0 && C();
            }, 200);
          }), n.on(E, "focus", function() {
            ++w;
          });
        }
      }), n.defineExtension("openNotification", function(s, u) {
        o(this, b);
        var d = a(this, s, u && u.bottom), f = !1, g, v = u && typeof u.duration < "u" ? u.duration : 5e3;
        function b() {
          f || (f = !0, clearTimeout(g), n.rmClass(d.parentNode, "dialog-opened"), d.parentNode.removeChild(d));
        }
        return n.on(d, "click", function(w) {
          n.e_preventDefault(w), b();
        }), v && (g = setTimeout(b, v)), b;
      });
    });
  })()), dialog.exports;
}
var hasRequiredVim;
function requireVim() {
  return hasRequiredVim || (hasRequiredVim = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireSearchcursor(), requireDialog(), requireMatchbrackets());
    })(function(n) {
      function a(s) {
        var u = s.Pos;
        function d(x, $) {
          var D = x.state.vim;
          if (!D || D.insertMode) return $.head;
          var L = D.sel.head;
          if (!L) return $.head;
          if (!(D.visualBlock && $.head.line != L.line))
            return $.from() == $.anchor && !$.empty() && $.head.line == L.line && $.head.ch != L.ch ? new u($.head.line, $.head.ch - 1) : $.head;
        }
        var f = [
          // Key to key mapping. This goes first to make it possible to override
          // existing mappings.
          { keys: "<Left>", type: "keyToKey", toKeys: "h" },
          { keys: "<Right>", type: "keyToKey", toKeys: "l" },
          { keys: "<Up>", type: "keyToKey", toKeys: "k" },
          { keys: "<Down>", type: "keyToKey", toKeys: "j" },
          { keys: "g<Up>", type: "keyToKey", toKeys: "gk" },
          { keys: "g<Down>", type: "keyToKey", toKeys: "gj" },
          { keys: "<Space>", type: "keyToKey", toKeys: "l" },
          { keys: "<BS>", type: "keyToKey", toKeys: "h", context: "normal" },
          { keys: "<Del>", type: "keyToKey", toKeys: "x", context: "normal" },
          { keys: "<C-Space>", type: "keyToKey", toKeys: "W" },
          { keys: "<C-BS>", type: "keyToKey", toKeys: "B", context: "normal" },
          { keys: "<S-Space>", type: "keyToKey", toKeys: "w" },
          { keys: "<S-BS>", type: "keyToKey", toKeys: "b", context: "normal" },
          { keys: "<C-n>", type: "keyToKey", toKeys: "j" },
          { keys: "<C-p>", type: "keyToKey", toKeys: "k" },
          { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>" },
          { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>" },
          { keys: "<C-[>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
          { keys: "<C-c>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
          { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>" },
          // ipad keyboard sends C-Esc instead of C-[
          { keys: "<C-Esc>", type: "keyToKey", toKeys: "<Esc>", context: "insert" },
          { keys: "s", type: "keyToKey", toKeys: "cl", context: "normal" },
          { keys: "s", type: "keyToKey", toKeys: "c", context: "visual" },
          { keys: "S", type: "keyToKey", toKeys: "cc", context: "normal" },
          { keys: "S", type: "keyToKey", toKeys: "VdO", context: "visual" },
          { keys: "<Home>", type: "keyToKey", toKeys: "0" },
          { keys: "<End>", type: "keyToKey", toKeys: "$" },
          { keys: "<PageUp>", type: "keyToKey", toKeys: "<C-b>" },
          { keys: "<PageDown>", type: "keyToKey", toKeys: "<C-f>" },
          { keys: "<CR>", type: "keyToKey", toKeys: "j^", context: "normal" },
          { keys: "<Ins>", type: "keyToKey", toKeys: "i", context: "normal" },
          { keys: "<Ins>", type: "action", action: "toggleOverwrite", context: "insert" },
          // Motions
          { keys: "H", type: "motion", motion: "moveToTopLine", motionArgs: { linewise: !0, toJumplist: !0 } },
          { keys: "M", type: "motion", motion: "moveToMiddleLine", motionArgs: { linewise: !0, toJumplist: !0 } },
          { keys: "L", type: "motion", motion: "moveToBottomLine", motionArgs: { linewise: !0, toJumplist: !0 } },
          { keys: "h", type: "motion", motion: "moveByCharacters", motionArgs: { forward: !1 } },
          { keys: "l", type: "motion", motion: "moveByCharacters", motionArgs: { forward: !0 } },
          { keys: "j", type: "motion", motion: "moveByLines", motionArgs: { forward: !0, linewise: !0 } },
          { keys: "k", type: "motion", motion: "moveByLines", motionArgs: { forward: !1, linewise: !0 } },
          { keys: "gj", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: !0 } },
          { keys: "gk", type: "motion", motion: "moveByDisplayLines", motionArgs: { forward: !1 } },
          { keys: "w", type: "motion", motion: "moveByWords", motionArgs: { forward: !0, wordEnd: !1 } },
          { keys: "W", type: "motion", motion: "moveByWords", motionArgs: { forward: !0, wordEnd: !1, bigWord: !0 } },
          { keys: "e", type: "motion", motion: "moveByWords", motionArgs: { forward: !0, wordEnd: !0, inclusive: !0 } },
          { keys: "E", type: "motion", motion: "moveByWords", motionArgs: { forward: !0, wordEnd: !0, bigWord: !0, inclusive: !0 } },
          { keys: "b", type: "motion", motion: "moveByWords", motionArgs: { forward: !1, wordEnd: !1 } },
          { keys: "B", type: "motion", motion: "moveByWords", motionArgs: { forward: !1, wordEnd: !1, bigWord: !0 } },
          { keys: "ge", type: "motion", motion: "moveByWords", motionArgs: { forward: !1, wordEnd: !0, inclusive: !0 } },
          { keys: "gE", type: "motion", motion: "moveByWords", motionArgs: { forward: !1, wordEnd: !0, bigWord: !0, inclusive: !0 } },
          { keys: "{", type: "motion", motion: "moveByParagraph", motionArgs: { forward: !1, toJumplist: !0 } },
          { keys: "}", type: "motion", motion: "moveByParagraph", motionArgs: { forward: !0, toJumplist: !0 } },
          { keys: "(", type: "motion", motion: "moveBySentence", motionArgs: { forward: !1 } },
          { keys: ")", type: "motion", motion: "moveBySentence", motionArgs: { forward: !0 } },
          { keys: "<C-f>", type: "motion", motion: "moveByPage", motionArgs: { forward: !0 } },
          { keys: "<C-b>", type: "motion", motion: "moveByPage", motionArgs: { forward: !1 } },
          { keys: "<C-d>", type: "motion", motion: "moveByScroll", motionArgs: { forward: !0, explicitRepeat: !0 } },
          { keys: "<C-u>", type: "motion", motion: "moveByScroll", motionArgs: { forward: !1, explicitRepeat: !0 } },
          { keys: "gg", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: !1, explicitRepeat: !0, linewise: !0, toJumplist: !0 } },
          { keys: "G", type: "motion", motion: "moveToLineOrEdgeOfDocument", motionArgs: { forward: !0, explicitRepeat: !0, linewise: !0, toJumplist: !0 } },
          { keys: "g$", type: "motion", motion: "moveToEndOfDisplayLine" },
          { keys: "g^", type: "motion", motion: "moveToStartOfDisplayLine" },
          { keys: "g0", type: "motion", motion: "moveToStartOfDisplayLine" },
          { keys: "0", type: "motion", motion: "moveToStartOfLine" },
          { keys: "^", type: "motion", motion: "moveToFirstNonWhiteSpaceCharacter" },
          { keys: "+", type: "motion", motion: "moveByLines", motionArgs: { forward: !0, toFirstChar: !0 } },
          { keys: "-", type: "motion", motion: "moveByLines", motionArgs: { forward: !1, toFirstChar: !0 } },
          { keys: "_", type: "motion", motion: "moveByLines", motionArgs: { forward: !0, toFirstChar: !0, repeatOffset: -1 } },
          { keys: "$", type: "motion", motion: "moveToEol", motionArgs: { inclusive: !0 } },
          { keys: "%", type: "motion", motion: "moveToMatchedSymbol", motionArgs: { inclusive: !0, toJumplist: !0 } },
          { keys: "f<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: !0, inclusive: !0 } },
          { keys: "F<character>", type: "motion", motion: "moveToCharacter", motionArgs: { forward: !1 } },
          { keys: "t<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: !0, inclusive: !0 } },
          { keys: "T<character>", type: "motion", motion: "moveTillCharacter", motionArgs: { forward: !1 } },
          { keys: ";", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: !0 } },
          { keys: ",", type: "motion", motion: "repeatLastCharacterSearch", motionArgs: { forward: !1 } },
          { keys: "'<character>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: !0, linewise: !0 } },
          { keys: "`<character>", type: "motion", motion: "goToMark", motionArgs: { toJumplist: !0 } },
          { keys: "]`", type: "motion", motion: "jumpToMark", motionArgs: { forward: !0 } },
          { keys: "[`", type: "motion", motion: "jumpToMark", motionArgs: { forward: !1 } },
          { keys: "]'", type: "motion", motion: "jumpToMark", motionArgs: { forward: !0, linewise: !0 } },
          { keys: "['", type: "motion", motion: "jumpToMark", motionArgs: { forward: !1, linewise: !0 } },
          // the next two aren't motions but must come before more general motion declarations
          { keys: "]p", type: "action", action: "paste", isEdit: !0, actionArgs: { after: !0, isEdit: !0, matchIndent: !0 } },
          { keys: "[p", type: "action", action: "paste", isEdit: !0, actionArgs: { after: !1, isEdit: !0, matchIndent: !0 } },
          { keys: "]<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: !0, toJumplist: !0 } },
          { keys: "[<character>", type: "motion", motion: "moveToSymbol", motionArgs: { forward: !1, toJumplist: !0 } },
          { keys: "|", type: "motion", motion: "moveToColumn" },
          { keys: "o", type: "motion", motion: "moveToOtherHighlightedEnd", context: "visual" },
          { keys: "O", type: "motion", motion: "moveToOtherHighlightedEnd", motionArgs: { sameLine: !0 }, context: "visual" },
          // Operators
          { keys: "d", type: "operator", operator: "delete" },
          { keys: "y", type: "operator", operator: "yank" },
          { keys: "c", type: "operator", operator: "change" },
          { keys: "=", type: "operator", operator: "indentAuto" },
          { keys: ">", type: "operator", operator: "indent", operatorArgs: { indentRight: !0 } },
          { keys: "<", type: "operator", operator: "indent", operatorArgs: { indentRight: !1 } },
          { keys: "g~", type: "operator", operator: "changeCase" },
          { keys: "gu", type: "operator", operator: "changeCase", operatorArgs: { toLower: !0 }, isEdit: !0 },
          { keys: "gU", type: "operator", operator: "changeCase", operatorArgs: { toLower: !1 }, isEdit: !0 },
          { keys: "n", type: "motion", motion: "findNext", motionArgs: { forward: !0, toJumplist: !0 } },
          { keys: "N", type: "motion", motion: "findNext", motionArgs: { forward: !1, toJumplist: !0 } },
          { keys: "gn", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: !0 } },
          { keys: "gN", type: "motion", motion: "findAndSelectNextInclusive", motionArgs: { forward: !1 } },
          // Operator-Motion dual commands
          { keys: "x", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: !0 }, operatorMotionArgs: { visualLine: !1 } },
          { keys: "X", type: "operatorMotion", operator: "delete", motion: "moveByCharacters", motionArgs: { forward: !1 }, operatorMotionArgs: { visualLine: !0 } },
          { keys: "D", type: "operatorMotion", operator: "delete", motion: "moveToEol", motionArgs: { inclusive: !0 }, context: "normal" },
          { keys: "D", type: "operator", operator: "delete", operatorArgs: { linewise: !0 }, context: "visual" },
          { keys: "Y", type: "operatorMotion", operator: "yank", motion: "expandToLine", motionArgs: { linewise: !0 }, context: "normal" },
          { keys: "Y", type: "operator", operator: "yank", operatorArgs: { linewise: !0 }, context: "visual" },
          { keys: "C", type: "operatorMotion", operator: "change", motion: "moveToEol", motionArgs: { inclusive: !0 }, context: "normal" },
          { keys: "C", type: "operator", operator: "change", operatorArgs: { linewise: !0 }, context: "visual" },
          { keys: "~", type: "operatorMotion", operator: "changeCase", motion: "moveByCharacters", motionArgs: { forward: !0 }, operatorArgs: { shouldMoveCursor: !0 }, context: "normal" },
          { keys: "~", type: "operator", operator: "changeCase", context: "visual" },
          { keys: "<C-u>", type: "operatorMotion", operator: "delete", motion: "moveToStartOfLine", context: "insert" },
          { keys: "<C-w>", type: "operatorMotion", operator: "delete", motion: "moveByWords", motionArgs: { forward: !1, wordEnd: !1 }, context: "insert" },
          //ignore C-w in normal mode
          { keys: "<C-w>", type: "idle", context: "normal" },
          // Actions
          { keys: "<C-i>", type: "action", action: "jumpListWalk", actionArgs: { forward: !0 } },
          { keys: "<C-o>", type: "action", action: "jumpListWalk", actionArgs: { forward: !1 } },
          { keys: "<C-e>", type: "action", action: "scroll", actionArgs: { forward: !0, linewise: !0 } },
          { keys: "<C-y>", type: "action", action: "scroll", actionArgs: { forward: !1, linewise: !0 } },
          { keys: "a", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "charAfter" }, context: "normal" },
          { keys: "A", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "eol" }, context: "normal" },
          { keys: "A", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "endOfSelectedArea" }, context: "visual" },
          { keys: "i", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "inplace" }, context: "normal" },
          { keys: "gi", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "lastEdit" }, context: "normal" },
          { keys: "I", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "firstNonBlank" }, context: "normal" },
          { keys: "gI", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "bol" }, context: "normal" },
          { keys: "I", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { insertAt: "startOfSelectedArea" }, context: "visual" },
          { keys: "o", type: "action", action: "newLineAndEnterInsertMode", isEdit: !0, interlaceInsertRepeat: !0, actionArgs: { after: !0 }, context: "normal" },
          { keys: "O", type: "action", action: "newLineAndEnterInsertMode", isEdit: !0, interlaceInsertRepeat: !0, actionArgs: { after: !1 }, context: "normal" },
          { keys: "v", type: "action", action: "toggleVisualMode" },
          { keys: "V", type: "action", action: "toggleVisualMode", actionArgs: { linewise: !0 } },
          { keys: "<C-v>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: !0 } },
          { keys: "<C-q>", type: "action", action: "toggleVisualMode", actionArgs: { blockwise: !0 } },
          { keys: "gv", type: "action", action: "reselectLastSelection" },
          { keys: "J", type: "action", action: "joinLines", isEdit: !0 },
          { keys: "gJ", type: "action", action: "joinLines", actionArgs: { keepSpaces: !0 }, isEdit: !0 },
          { keys: "p", type: "action", action: "paste", isEdit: !0, actionArgs: { after: !0, isEdit: !0 } },
          { keys: "P", type: "action", action: "paste", isEdit: !0, actionArgs: { after: !1, isEdit: !0 } },
          { keys: "r<character>", type: "action", action: "replace", isEdit: !0 },
          { keys: "@<character>", type: "action", action: "replayMacro" },
          { keys: "q<character>", type: "action", action: "enterMacroRecordMode" },
          // Handle Replace-mode as a special case of insert mode.
          { keys: "R", type: "action", action: "enterInsertMode", isEdit: !0, actionArgs: { replace: !0 }, context: "normal" },
          { keys: "R", type: "operator", operator: "change", operatorArgs: { linewise: !0, fullLine: !0 }, context: "visual", exitVisualBlock: !0 },
          { keys: "u", type: "action", action: "undo", context: "normal" },
          { keys: "u", type: "operator", operator: "changeCase", operatorArgs: { toLower: !0 }, context: "visual", isEdit: !0 },
          { keys: "U", type: "operator", operator: "changeCase", operatorArgs: { toLower: !1 }, context: "visual", isEdit: !0 },
          { keys: "<C-r>", type: "action", action: "redo" },
          { keys: "m<character>", type: "action", action: "setMark" },
          { keys: '"<character>', type: "action", action: "setRegister" },
          { keys: "zz", type: "action", action: "scrollToCursor", actionArgs: { position: "center" } },
          { keys: "z.", type: "action", action: "scrollToCursor", actionArgs: { position: "center" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
          { keys: "zt", type: "action", action: "scrollToCursor", actionArgs: { position: "top" } },
          { keys: "z<CR>", type: "action", action: "scrollToCursor", actionArgs: { position: "top" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
          { keys: "zb", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" } },
          { keys: "z-", type: "action", action: "scrollToCursor", actionArgs: { position: "bottom" }, motion: "moveToFirstNonWhiteSpaceCharacter" },
          { keys: ".", type: "action", action: "repeatLastEdit" },
          { keys: "<C-a>", type: "action", action: "incrementNumberToken", isEdit: !0, actionArgs: { increase: !0, backtrack: !1 } },
          { keys: "<C-x>", type: "action", action: "incrementNumberToken", isEdit: !0, actionArgs: { increase: !1, backtrack: !1 } },
          { keys: "<C-t>", type: "action", action: "indent", actionArgs: { indentRight: !0 }, context: "insert" },
          { keys: "<C-d>", type: "action", action: "indent", actionArgs: { indentRight: !1 }, context: "insert" },
          // Text object motions
          { keys: "a<character>", type: "motion", motion: "textObjectManipulation" },
          { keys: "i<character>", type: "motion", motion: "textObjectManipulation", motionArgs: { textObjectInner: !0 } },
          // Search
          { keys: "/", type: "search", searchArgs: { forward: !0, querySrc: "prompt", toJumplist: !0 } },
          { keys: "?", type: "search", searchArgs: { forward: !1, querySrc: "prompt", toJumplist: !0 } },
          { keys: "*", type: "search", searchArgs: { forward: !0, querySrc: "wordUnderCursor", wholeWordOnly: !0, toJumplist: !0 } },
          { keys: "#", type: "search", searchArgs: { forward: !1, querySrc: "wordUnderCursor", wholeWordOnly: !0, toJumplist: !0 } },
          { keys: "g*", type: "search", searchArgs: { forward: !0, querySrc: "wordUnderCursor", toJumplist: !0 } },
          { keys: "g#", type: "search", searchArgs: { forward: !1, querySrc: "wordUnderCursor", toJumplist: !0 } },
          // Ex command
          { keys: ":", type: "ex" }
        ], g = f.length, v = [
          { name: "colorscheme", shortName: "colo" },
          { name: "map" },
          { name: "imap", shortName: "im" },
          { name: "nmap", shortName: "nm" },
          { name: "vmap", shortName: "vm" },
          { name: "unmap" },
          { name: "write", shortName: "w" },
          { name: "undo", shortName: "u" },
          { name: "redo", shortName: "red" },
          { name: "set", shortName: "se" },
          { name: "setlocal", shortName: "setl" },
          { name: "setglobal", shortName: "setg" },
          { name: "sort", shortName: "sor" },
          { name: "substitute", shortName: "s", possiblyAsync: !0 },
          { name: "nohlsearch", shortName: "noh" },
          { name: "yank", shortName: "y" },
          { name: "delmarks", shortName: "delm" },
          { name: "registers", shortName: "reg", excludeFromCommandHistory: !0 },
          { name: "vglobal", shortName: "v" },
          { name: "global", shortName: "g" }
        ];
        function b(x) {
          x.setOption("disableInput", !0), x.setOption("showCursorWhenSelecting", !1), s.signal(x, "vim-mode-change", { mode: "normal" }), x.on("cursorActivity", Ha), Ae(x), s.on(x.getInputField(), "paste", B(x));
        }
        function w(x) {
          x.setOption("disableInput", !1), x.off("cursorActivity", Ha), s.off(x.getInputField(), "paste", B(x)), x.state.vim = null, ar && clearTimeout(ar);
        }
        function C(x, $) {
          this == s.keyMap.vim && (x.options.$customCursor = null, s.rmClass(x.getWrapperElement(), "cm-fat-cursor")), (!$ || $.attach != k) && w(x);
        }
        function k(x, $) {
          this == s.keyMap.vim && (x.curOp && (x.curOp.selectionChanged = !0), x.options.$customCursor = d, s.addClass(x.getWrapperElement(), "cm-fat-cursor")), (!$ || $.attach != k) && b(x);
        }
        s.defineOption("vimMode", !1, function(x, $, D) {
          $ && x.getOption("keyMap") != "vim" ? x.setOption("keyMap", "vim") : !$ && D != s.Init && /^vim/.test(x.getOption("keyMap")) && x.setOption("keyMap", "default");
        });
        function E(x, $) {
          if ($) {
            if (this[x])
              return this[x];
            var D = M(x);
            if (!D)
              return !1;
            var L = ze.findKey($, D);
            return typeof L == "function" && s.signal($, "vim-keypress", D), L;
          }
        }
        var A = { Shift: "S", Ctrl: "C", Alt: "A", Cmd: "D", Mod: "A", CapsLock: "" }, P = { Enter: "CR", Backspace: "BS", Delete: "Del", Insert: "Ins" };
        function M(x) {
          if (x.charAt(0) == "'")
            return x.charAt(1);
          var $ = x.split(/-(?!$)/), D = $[$.length - 1];
          if ($.length == 1 && $[0].length == 1)
            return !1;
          if ($.length == 2 && $[0] == "Shift" && D.length == 1)
            return !1;
          for (var L = !1, j = 0; j < $.length; j++) {
            var U = $[j];
            U in A ? $[j] = A[U] : L = !0, U in P && ($[j] = P[U]);
          }
          return L ? (z(D) && ($[$.length - 1] = D.toLowerCase()), "<" + $.join("-") + ">") : !1;
        }
        function B(x) {
          var $ = x.state.vim;
          return $.onPasteFn || ($.onPasteFn = function() {
            $.insertMode || (x.setCursor(de(x.getCursor(), 0, 1)), We.enterInsertMode(x, {}, $));
          }), $.onPasteFn;
        }
        var _ = /[\d]/, T = [s.isWordChar, function(x) {
          return x && !s.isWordChar(x) && !/\s/.test(x);
        }], O = [function(x) {
          return /\S/.test(x);
        }];
        function I(x, $) {
          for (var D = [], L = x; L < x + $; L++)
            D.push(String.fromCharCode(L));
          return D;
        }
        var q = I(65, 26), F = I(97, 26), W = I(48, 10), K = [].concat(q, F, W, ["<", ">"]), Z = [].concat(q, F, W, ["-", '"', ".", ":", "_", "/"]), J;
        try {
          J = new RegExp("^[\\p{Lu}]$", "u");
        } catch {
          J = /^[A-Z]$/;
        }
        function re(x, $) {
          return $ >= x.firstLine() && $ <= x.lastLine();
        }
        function V(x) {
          return /^[a-z]$/.test(x);
        }
        function ne(x) {
          return "()[]{}".indexOf(x) != -1;
        }
        function Q(x) {
          return _.test(x);
        }
        function z(x) {
          return J.test(x);
        }
        function X(x) {
          return /^\s*$/.test(x);
        }
        function ue(x) {
          return ".?!".indexOf(x) != -1;
        }
        function Be(x, $) {
          for (var D = 0; D < $.length; D++)
            if ($[D] == x)
              return !0;
          return !1;
        }
        var te = {};
        function G(x, $, D, L, j) {
          if ($ === void 0 && !j)
            throw Error("defaultValue is required unless callback is provided");
          if (D || (D = "string"), te[x] = {
            type: D,
            defaultValue: $,
            callback: j
          }, L)
            for (var U = 0; U < L.length; U++)
              te[L[U]] = te[x];
          $ && ie(x, $);
        }
        function ie(x, $, D, L) {
          var j = te[x];
          L = L || {};
          var U = L.scope;
          if (!j)
            return new Error("Unknown option: " + x);
          if (j.type == "boolean") {
            if ($ && $ !== !0)
              return new Error("Invalid argument: " + x + "=" + $);
            $ !== !1 && ($ = !0);
          }
          j.callback ? (U !== "local" && j.callback($, void 0), U !== "global" && D && j.callback($, D)) : (U !== "local" && (j.value = j.type == "boolean" ? !!$ : $), U !== "global" && D && (D.state.vim.options[x] = { value: $ }));
        }
        function oe(x, $, D) {
          var L = te[x];
          D = D || {};
          var j = D.scope;
          if (!L)
            return new Error("Unknown option: " + x);
          if (L.callback) {
            var U = $ && L.callback(void 0, $);
            return j !== "global" && U !== void 0 ? U : j !== "local" ? L.callback() : void 0;
          } else {
            var U = j !== "global" && $ && $.state.vim.options[x];
            return (U || j !== "local" && L || {}).value;
          }
        }
        G("filetype", void 0, "string", ["ft"], function(x, $) {
          if ($ !== void 0)
            if (x === void 0) {
              var D = $.getOption("mode");
              return D == "null" ? "" : D;
            } else {
              var D = x == "" ? "null" : x;
              $.setOption("mode", D);
            }
        });
        var ye = function() {
          var x = 100, $ = -1, D = 0, L = 0, j = new Array(x);
          function U(se, we, _e) {
            var Le = $ % x, Ue = j[Le];
            function Me(at) {
              var Xe = ++$ % x, pt = j[Xe];
              pt && pt.clear(), j[Xe] = se.setBookmark(at);
            }
            if (Ue) {
              var Re = Ue.find();
              Re && !wt(Re, we) && Me(we);
            } else
              Me(we);
            Me(_e), D = $, L = $ - x + 1, L < 0 && (L = 0);
          }
          function ae(se, we) {
            $ += we, $ > D ? $ = D : $ < L && ($ = L);
            var _e = j[(x + $) % x];
            if (_e && !_e.find()) {
              var Le = we > 0 ? 1 : -1, Ue, Me = se.getCursor();
              do
                if ($ += Le, _e = j[(x + $) % x], _e && (Ue = _e.find()) && !wt(Me, Ue))
                  break;
              while ($ < D && $ > L);
            }
            return _e;
          }
          function fe(se, we) {
            var _e = $, Le = ae(se, we);
            return $ = _e, Le && Le.find();
          }
          return {
            cachedCursor: void 0,
            //used for # and * jumps
            add: U,
            find: fe,
            move: ae
          };
        }, ve = function(x) {
          return x ? {
            changes: x.changes,
            expectCursorActivityForChange: x.expectCursorActivityForChange
          } : {
            // Change list
            changes: [],
            // Set to true on change, false on cursorActivity.
            expectCursorActivityForChange: !1
          };
        };
        function ke() {
          this.latestRegister = void 0, this.isPlaying = !1, this.isRecording = !1, this.replaySearchQueries = [], this.onRecordingDone = void 0, this.lastInsertModeChanges = ve();
        }
        ke.prototype = {
          exitMacroRecordMode: function() {
            var x = be.macroModeState;
            x.onRecordingDone && x.onRecordingDone(), x.onRecordingDone = void 0, x.isRecording = !1;
          },
          enterMacroRecordMode: function(x, $) {
            var D = be.registerController.getRegister($);
            if (D) {
              if (D.clear(), this.latestRegister = $, x.openDialog) {
                var L = qn("span", { class: "cm-vim-message" }, "recording @" + $);
                this.onRecordingDone = x.openDialog(L, null, { bottom: !0 });
              }
              this.isRecording = !0;
            }
          }
        };
        function Ae(x) {
          return x.state.vim || (x.state.vim = {
            inputState: new Ne(),
            // Vim's input state that triggered the last edit, used to repeat
            // motions and operators with '.'.
            lastEditInputState: void 0,
            // Vim's action command before the last edit, used to repeat actions
            // with '.' and insert mode repeat.
            lastEditActionCommand: void 0,
            // When using jk for navigation, if you move from a longer line to a
            // shorter line, the cursor may clip to the end of the shorter line.
            // If j is pressed again and cursor goes to the next line, the
            // cursor should go back to its horizontal position on the longer
            // line if it can. This is to keep track of the horizontal position.
            lastHPos: -1,
            // Doing the same with screen-position for gj/gk
            lastHSPos: -1,
            // The last motion command run. Cleared if a non-motion command gets
            // executed in between.
            lastMotion: null,
            marks: {},
            insertMode: !1,
            // Repeat count for changes made in insert mode, triggered by key
            // sequences like 3,i. Only exists when insertMode is true.
            insertModeRepeat: void 0,
            visualMode: !1,
            // If we are in visual line mode. No effect if visualMode is false.
            visualLine: !1,
            visualBlock: !1,
            lastSelection: null,
            lastPastedText: null,
            sel: {},
            // Buffer-local/window-local values of vim options.
            options: {}
          }), x.state.vim;
        }
        var be;
        function Ie() {
          be = {
            // The current search query.
            searchQuery: null,
            // Whether we are searching backwards.
            searchIsReversed: !1,
            // Replace part of the last substituted pattern
            lastSubstituteReplacePart: void 0,
            jumpList: ye(),
            macroModeState: new ke(),
            // Recording latest f, t, F or T motion command.
            lastCharacterSearch: { increment: 0, forward: !0, selectedCharacter: "" },
            registerController: new ce({}),
            // search history buffer
            searchHistoryController: new pe(),
            // ex Command history buffer
            exCommandHistoryController: new pe()
          };
          for (var x in te) {
            var $ = te[x];
            $.value = $.defaultValue;
          }
        }
        var Se, ze = {
          enterVimMode: b,
          buildKeyMap: function() {
          },
          // Testing hook, though it might be useful to expose the register
          // controller anyway.
          getRegisterController: function() {
            return be.registerController;
          },
          // Testing hook.
          resetVimGlobalState_: Ie,
          // Testing hook.
          getVimGlobalState_: function() {
            return be;
          },
          // Testing hook.
          maybeInitVimState_: Ae,
          suppressErrorLogging: !1,
          InsertModeKey: zr,
          map: function(x, $, D) {
            Bn.map(x, $, D);
          },
          unmap: function(x, $) {
            return Bn.unmap(x, $);
          },
          // Non-recursive map function.
          // NOTE: This will not create mappings to key maps that aren't present
          // in the default key map. See TODO at bottom of function.
          noremap: function(x, $, D) {
            function L(Ue) {
              return Ue ? [Ue] : ["normal", "insert", "visual"];
            }
            for (var j = L(D), U = f.length, ae = g, fe = U - ae; fe < U && j.length; fe++) {
              var se = f[fe];
              if (se.keys == $ && (!D || !se.context || se.context === D) && se.type.substr(0, 2) !== "ex" && se.type.substr(0, 3) !== "key") {
                var we = {};
                for (var _e in se)
                  we[_e] = se[_e];
                we.keys = x, D && !we.context && (we.context = D), this._mapCommand(we);
                var Le = L(se.context);
                j = j.filter(function(Ue) {
                  return Le.indexOf(Ue) === -1;
                });
              }
            }
          },
          // Remove all user-defined mappings for the provided context.
          mapclear: function(x) {
            var $ = f.length, D = g, L = f.slice(0, $ - D);
            if (f = f.slice($ - D), x)
              for (var j = L.length - 1; j >= 0; j--) {
                var U = L[j];
                if (x !== U.context)
                  if (U.context)
                    this._mapCommand(U);
                  else {
                    var ae = ["normal", "insert", "visual"];
                    for (var fe in ae)
                      if (ae[fe] !== x) {
                        var se = {};
                        for (var we in U)
                          se[we] = U[we];
                        se.context = ae[fe], this._mapCommand(se);
                      }
                  }
              }
          },
          // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace
          // them, or somehow make them work with the existing CodeMirror setOption/getOption API.
          setOption: ie,
          getOption: oe,
          defineOption: G,
          defineEx: function(x, $, D) {
            if (!$)
              $ = x;
            else if (x.indexOf($) !== 0)
              throw new Error('(Vim.defineEx) "' + $ + '" is not a prefix of "' + x + '", command not registered');
            Pn[x] = D, Bn.commandMap_[$] = { name: x, shortName: $, type: "api" };
          },
          handleKey: function(x, $, D) {
            var L = this.findKey(x, $, D);
            if (typeof L == "function")
              return L();
          },
          multiSelectHandleKey: Ua,
          /**
           * This is the outermost function called by CodeMirror, after keys have
           * been mapped to their Vim equivalents.
           *
           * Finds a command based on the key (and cached keys if there is a
           * multi-key sequence). Returns `undefined` if no key is matched, a noop
           * function if a partial match is found (multi-key), and a function to
           * execute the bound command if a a key is matched. The function always
           * returns true.
           */
          findKey: function(x, $, D) {
            var L = Ae(x);
            function j() {
              var _e = be.macroModeState;
              if (_e.isRecording) {
                if ($ == "q")
                  return _e.exitMacroRecordMode(), tt(x), !0;
                D != "mapping" && yi(_e, $);
              }
            }
            function U() {
              if ($ == "<Esc>") {
                if (L.visualMode)
                  un(x);
                else if (L.insertMode)
                  Hn(x);
                else
                  return;
                return tt(x), !0;
              }
            }
            function ae(_e) {
              for (var Le; _e; )
                Le = /<\w+-.+?>|<\w+>|./.exec(_e), $ = Le[0], _e = _e.substring(Le.index + $.length), ze.handleKey(x, $, "mapping");
            }
            function fe() {
              if (U())
                return !0;
              for (var _e = L.inputState.keyBuffer = L.inputState.keyBuffer + $, Le = $.length == 1, Ue = je.matchCommand(_e, f, L.inputState, "insert"); _e.length > 1 && Ue.type != "full"; ) {
                var _e = L.inputState.keyBuffer = _e.slice(1), Me = je.matchCommand(_e, f, L.inputState, "insert");
                Me.type != "none" && (Ue = Me);
              }
              if (Ue.type == "none")
                return tt(x), !1;
              if (Ue.type == "partial")
                return Se && window.clearTimeout(Se), Se = window.setTimeout(
                  function() {
                    L.insertMode && L.inputState.keyBuffer && tt(x);
                  },
                  oe("insertModeEscKeysTimeout")
                ), !Le;
              if (Se && window.clearTimeout(Se), Le) {
                for (var Re = x.listSelections(), at = 0; at < Re.length; at++) {
                  var Xe = Re[at].head;
                  x.replaceRange("", de(Xe, 0, -(_e.length - 1)), Xe, "+input");
                }
                be.macroModeState.lastInsertModeChanges.changes.pop();
              }
              return tt(x), Ue.command;
            }
            function se() {
              if (j() || U())
                return !0;
              var _e = L.inputState.keyBuffer = L.inputState.keyBuffer + $;
              if (/^[1-9]\d*$/.test(_e))
                return !0;
              var Le = /^(\d*)(.*)$/.exec(_e);
              if (!Le)
                return tt(x), !1;
              var Ue = L.visualMode ? "visual" : "normal", Me = Le[2] || Le[1];
              L.inputState.operatorShortcut && L.inputState.operatorShortcut.slice(-1) == Me && (Me = L.inputState.operatorShortcut);
              var Re = je.matchCommand(Me, f, L.inputState, Ue);
              return Re.type == "none" ? (tt(x), !1) : Re.type == "partial" ? !0 : Re.type == "clear" ? (tt(x), !0) : (L.inputState.keyBuffer = "", Le = /^(\d*)(.*)$/.exec(_e), Le[1] && Le[1] != "0" && L.inputState.pushRepeatDigit(Le[1]), Re.command);
            }
            var we;
            return L.insertMode ? we = fe() : we = se(), we === !1 ? !L.insertMode && $.length === 1 ? function() {
              return !0;
            } : void 0 : we === !0 ? function() {
              return !0;
            } : function() {
              return x.operation(function() {
                x.curOp.isVimOp = !0;
                try {
                  we.type == "keyToKey" ? ae(we.toKeys) : je.processCommand(x, L, we);
                } catch (_e) {
                  throw x.state.vim = void 0, Ae(x), ze.suppressErrorLogging || console.log(_e), _e;
                }
                return !0;
              });
            };
          },
          handleEx: function(x, $) {
            Bn.processCommand(x, $);
          },
          defineMotion: Ce,
          defineAction: Ge,
          defineOperator: ot,
          mapCommand: gi,
          _mapCommand: ir,
          defineRegister: et,
          exitVisualMode: un,
          exitInsertMode: Hn
        };
        function Ne() {
          this.prefixRepeat = [], this.motionRepeat = [], this.operator = null, this.operatorArgs = null, this.motion = null, this.motionArgs = null, this.keyBuffer = [], this.registerName = null;
        }
        Ne.prototype.pushRepeatDigit = function(x) {
          this.operator ? this.motionRepeat = this.motionRepeat.concat(x) : this.prefixRepeat = this.prefixRepeat.concat(x);
        }, Ne.prototype.getRepeat = function() {
          var x = 0;
          return (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) && (x = 1, this.prefixRepeat.length > 0 && (x *= parseInt(this.prefixRepeat.join(""), 10)), this.motionRepeat.length > 0 && (x *= parseInt(this.motionRepeat.join(""), 10))), x;
        };
        function tt(x, $) {
          x.state.vim.inputState = new Ne(), s.signal(x, "vim-command-done", $);
        }
        function Qe(x, $, D) {
          this.clear(), this.keyBuffer = [x || ""], this.insertModeChanges = [], this.searchQueries = [], this.linewise = !!$, this.blockwise = !!D;
        }
        Qe.prototype = {
          setText: function(x, $, D) {
            this.keyBuffer = [x || ""], this.linewise = !!$, this.blockwise = !!D;
          },
          pushText: function(x, $) {
            $ && (this.linewise || this.keyBuffer.push(`
`), this.linewise = !0), this.keyBuffer.push(x);
          },
          pushInsertModeChanges: function(x) {
            this.insertModeChanges.push(ve(x));
          },
          pushSearchQuery: function(x) {
            this.searchQueries.push(x);
          },
          clear: function() {
            this.keyBuffer = [], this.insertModeChanges = [], this.searchQueries = [], this.linewise = !1;
          },
          toString: function() {
            return this.keyBuffer.join("");
          }
        };
        function et(x, $) {
          var D = be.registerController.registers;
          if (!x || x.length != 1)
            throw Error("Register name must be 1 character");
          if (D[x])
            throw Error("Register already defined " + x);
          D[x] = $, Z.push(x);
        }
        function ce(x) {
          this.registers = x, this.unnamedRegister = x['"'] = new Qe(), x["."] = new Qe(), x[":"] = new Qe(), x["/"] = new Qe();
        }
        ce.prototype = {
          pushText: function(x, $, D, L, j) {
            if (x !== "_") {
              L && D.charAt(D.length - 1) !== `
` && (D += `
`);
              var U = this.isValidRegister(x) ? this.getRegister(x) : null;
              if (!U) {
                switch ($) {
                  case "yank":
                    this.registers[0] = new Qe(D, L, j);
                    break;
                  case "delete":
                  case "change":
                    D.indexOf(`
`) == -1 ? this.registers["-"] = new Qe(D, L) : (this.shiftNumericRegisters_(), this.registers[1] = new Qe(D, L));
                    break;
                }
                this.unnamedRegister.setText(D, L, j);
                return;
              }
              var ae = z(x);
              ae ? U.pushText(D, L) : U.setText(D, L, j), this.unnamedRegister.setText(U.toString(), L);
            }
          },
          // Gets the register named @name.  If one of @name doesn't already exist,
          // create it.  If @name is invalid, return the unnamedRegister.
          getRegister: function(x) {
            return this.isValidRegister(x) ? (x = x.toLowerCase(), this.registers[x] || (this.registers[x] = new Qe()), this.registers[x]) : this.unnamedRegister;
          },
          isValidRegister: function(x) {
            return x && Be(x, Z);
          },
          shiftNumericRegisters_: function() {
            for (var x = 9; x >= 2; x--)
              this.registers[x] = this.getRegister("" + (x - 1));
          }
        };
        function pe() {
          this.historyBuffer = [], this.iterator = 0, this.initialPrefix = null;
        }
        pe.prototype = {
          // the input argument here acts a user entered prefix for a small time
          // until we start autocompletion in which case it is the autocompleted.
          nextMatch: function(x, $) {
            var D = this.historyBuffer, L = $ ? -1 : 1;
            this.initialPrefix === null && (this.initialPrefix = x);
            for (var j = this.iterator + L; $ ? j >= 0 : j < D.length; j += L)
              for (var U = D[j], ae = 0; ae <= U.length; ae++)
                if (this.initialPrefix == U.substring(0, ae))
                  return this.iterator = j, U;
            if (j >= D.length)
              return this.iterator = D.length, this.initialPrefix;
            if (j < 0) return x;
          },
          pushInput: function(x) {
            var $ = this.historyBuffer.indexOf(x);
            $ > -1 && this.historyBuffer.splice($, 1), x.length && this.historyBuffer.push(x);
          },
          reset: function() {
            this.initialPrefix = null, this.iterator = this.historyBuffer.length;
          }
        };
        var je = {
          matchCommand: function(x, $, D, L) {
            var j = Fe(x, $, L, D);
            if (!j.full && !j.partial)
              return { type: "none" };
            if (!j.full && j.partial)
              return { type: "partial" };
            for (var U, ae = 0; ae < j.full.length; ae++) {
              var fe = j.full[ae];
              U || (U = fe);
            }
            if (U.keys.slice(-11) == "<character>") {
              var se = $e(x);
              if (!se || se.length > 1) return { type: "clear" };
              D.selectedCharacter = se;
            }
            return { type: "full", command: U };
          },
          processCommand: function(x, $, D) {
            switch ($.inputState.repeatOverride = D.repeatOverride, D.type) {
              case "motion":
                this.processMotion(x, $, D);
                break;
              case "operator":
                this.processOperator(x, $, D);
                break;
              case "operatorMotion":
                this.processOperatorMotion(x, $, D);
                break;
              case "action":
                this.processAction(x, $, D);
                break;
              case "search":
                this.processSearch(x, $, D);
                break;
              case "ex":
              case "keyToEx":
                this.processEx(x, $, D);
                break;
            }
          },
          processMotion: function(x, $, D) {
            $.inputState.motion = D.motion, $.inputState.motionArgs = me(D.motionArgs), this.evalInput(x, $);
          },
          processOperator: function(x, $, D) {
            var L = $.inputState;
            if (L.operator)
              if (L.operator == D.operator) {
                L.motion = "expandToLine", L.motionArgs = { linewise: !0 }, this.evalInput(x, $);
                return;
              } else
                tt(x);
            L.operator = D.operator, L.operatorArgs = me(D.operatorArgs), D.keys.length > 1 && (L.operatorShortcut = D.keys), D.exitVisualBlock && ($.visualBlock = !1, zn(x)), $.visualMode && this.evalInput(x, $);
          },
          processOperatorMotion: function(x, $, D) {
            var L = $.visualMode, j = me(D.operatorMotionArgs);
            j && L && j.visualLine && ($.visualLine = !0), this.processOperator(x, $, D), L || this.processMotion(x, $, D);
          },
          processAction: function(x, $, D) {
            var L = $.inputState, j = L.getRepeat(), U = !!j, ae = me(D.actionArgs) || {};
            L.selectedCharacter && (ae.selectedCharacter = L.selectedCharacter), D.operator && this.processOperator(x, $, D), D.motion && this.processMotion(x, $, D), (D.motion || D.operator) && this.evalInput(x, $), ae.repeat = j || 1, ae.repeatIsExplicit = U, ae.registerName = L.registerName, tt(x), $.lastMotion = null, D.isEdit && this.recordLastEdit($, L, D), We[D.action](x, ae, $);
          },
          processSearch: function(x, $, D) {
            if (!x.getSearchCursor)
              return;
            var L = D.searchArgs.forward, j = D.searchArgs.wholeWordOnly;
            jt(x).setReversed(!L);
            var U = L ? "/" : "?", ae = jt(x).getQuery(), fe = x.getScrollInfo();
            function se(Xe, pt, vt) {
              be.searchHistoryController.pushInput(Xe), be.searchHistoryController.reset();
              try {
                rr(x, Xe, pt, vt);
              } catch {
                Bt(x, "Invalid regex: " + Xe), tt(x);
                return;
              }
              je.processMotion(x, $, {
                type: "motion",
                motion: "findNext",
                motionArgs: { forward: !0, toJumplist: D.searchArgs.toJumplist }
              });
            }
            function we(Xe) {
              x.scrollTo(fe.left, fe.top), se(
                Xe,
                !0,
                !0
                /** smartCase */
              );
              var pt = be.macroModeState;
              pt.isRecording && ca(pt, Xe);
            }
            function _e(Xe, pt, vt) {
              var gt = s.keyName(Xe), Ct, Wt;
              gt == "Up" || gt == "Down" ? (Ct = gt == "Up", Wt = Xe.target ? Xe.target.selectionEnd : 0, pt = be.searchHistoryController.nextMatch(pt, Ct) || "", vt(pt), Wt && Xe.target && (Xe.target.selectionEnd = Xe.target.selectionStart = Math.min(Wt, Xe.target.value.length))) : gt != "Left" && gt != "Right" && gt != "Ctrl" && gt != "Alt" && gt != "Shift" && be.searchHistoryController.reset();
              var Lt;
              try {
                Lt = rr(
                  x,
                  pt,
                  !0,
                  !0
                  /** smartCase */
                );
              } catch {
              }
              Lt ? x.scrollIntoView(Nr(x, !L, Lt), 30) : (Ir(x), x.scrollTo(fe.left, fe.top));
            }
            function Le(Xe, pt, vt) {
              var gt = s.keyName(Xe);
              gt == "Esc" || gt == "Ctrl-C" || gt == "Ctrl-[" || gt == "Backspace" && pt == "" ? (be.searchHistoryController.pushInput(pt), be.searchHistoryController.reset(), rr(x, ae), Ir(x), x.scrollTo(fe.left, fe.top), s.e_stop(Xe), tt(x), vt(), x.focus()) : gt == "Up" || gt == "Down" ? s.e_stop(Xe) : gt == "Ctrl-U" && (s.e_stop(Xe), vt(""));
            }
            switch (D.searchArgs.querySrc) {
              case "prompt":
                var Ue = be.macroModeState;
                if (Ue.isPlaying) {
                  var at = Ue.replaySearchQueries.shift();
                  se(
                    at,
                    !0,
                    !1
                    /** smartCase */
                  );
                } else
                  yn(x, {
                    onClose: we,
                    prefix: U,
                    desc: "(JavaScript regexp)",
                    onKeyUp: _e,
                    onKeyDown: Le
                  });
                break;
              case "wordUnderCursor":
                var Me = gn(
                  x,
                  !1,
                  !0,
                  !1,
                  !0
                  /** noSymbol */
                ), Re = !0;
                if (Me || (Me = gn(
                  x,
                  !1,
                  !0,
                  !1,
                  !1
                  /** noSymbol */
                ), Re = !1), !Me)
                  return;
                var at = x.getLine(Me.start.line).substring(
                  Me.start.ch,
                  Me.end.ch
                );
                Re && j ? at = "\\b" + at + "\\b" : at = rn(at), be.jumpList.cachedCursor = x.getCursor(), x.setCursor(Me.start), se(
                  at,
                  !0,
                  !1
                  /** smartCase */
                );
                break;
            }
          },
          processEx: function(x, $, D) {
            function L(U) {
              be.exCommandHistoryController.pushInput(U), be.exCommandHistoryController.reset(), Bn.processCommand(x, U), tt(x);
            }
            function j(U, ae, fe) {
              var se = s.keyName(U), we, _e;
              (se == "Esc" || se == "Ctrl-C" || se == "Ctrl-[" || se == "Backspace" && ae == "") && (be.exCommandHistoryController.pushInput(ae), be.exCommandHistoryController.reset(), s.e_stop(U), tt(x), fe(), x.focus()), se == "Up" || se == "Down" ? (s.e_stop(U), we = se == "Up", _e = U.target ? U.target.selectionEnd : 0, ae = be.exCommandHistoryController.nextMatch(ae, we) || "", fe(ae), _e && U.target && (U.target.selectionEnd = U.target.selectionStart = Math.min(_e, U.target.value.length))) : se == "Ctrl-U" ? (s.e_stop(U), fe("")) : se != "Left" && se != "Right" && se != "Ctrl" && se != "Alt" && se != "Shift" && be.exCommandHistoryController.reset();
            }
            D.type == "keyToEx" ? Bn.processCommand(x, D.exArgs.input) : $.visualMode ? yn(x, {
              onClose: L,
              prefix: ":",
              value: "'<,'>",
              onKeyDown: j,
              selectValueOnOpen: !1
            }) : yn(x, {
              onClose: L,
              prefix: ":",
              onKeyDown: j
            });
          },
          evalInput: function(x, $) {
            var D = $.inputState, L = D.motion, j = D.motionArgs || {}, U = D.operator, ae = D.operatorArgs || {}, fe = D.registerName, se = $.sel, we = Je($.visualMode ? He(x, se.head) : x.getCursor("head")), _e = Je($.visualMode ? He(x, se.anchor) : x.getCursor("anchor")), Le = Je(we), Ue = Je(_e), Me, Re, at;
            if (U && this.recordLastEdit($, D), D.repeatOverride !== void 0 ? at = D.repeatOverride : at = D.getRepeat(), at > 0 && j.explicitRepeat ? j.repeatIsExplicit = !0 : (j.noRepeat || !j.explicitRepeat && at === 0) && (at = 1, j.repeatIsExplicit = !1), D.selectedCharacter && (j.selectedCharacter = ae.selectedCharacter = D.selectedCharacter), j.repeat = at, tt(x), L) {
              var Xe = lt[L](x, we, j, $, D);
              if ($.lastMotion = lt[L], !Xe)
                return;
              if (j.toJumplist) {
                var pt = be.jumpList, vt = pt.cachedCursor;
                vt ? (yr(x, vt, Xe), delete pt.cachedCursor) : yr(x, we, Xe);
              }
              Xe instanceof Array ? (Re = Xe[0], Me = Xe[1]) : Me = Xe, Me || (Me = Je(we)), $.visualMode ? ($.visualBlock && Me.ch === 1 / 0 || (Me = He(x, Me)), Re && (Re = He(x, Re)), Re = Re || Ue, se.anchor = Re, se.head = Me, zn(x), sn(
                x,
                $,
                "<",
                qe(Re, Me) ? Re : Me
              ), sn(
                x,
                $,
                ">",
                qe(Re, Me) ? Me : Re
              )) : U || (Me = He(x, Me), x.setCursor(Me.line, Me.ch));
            }
            if (U) {
              if (ae.lastSel) {
                Re = Ue;
                var gt = ae.lastSel, Ct = Math.abs(gt.head.line - gt.anchor.line), Wt = Math.abs(gt.head.ch - gt.anchor.ch);
                gt.visualLine ? Me = new u(Ue.line + Ct, Ue.ch) : gt.visualBlock ? Me = new u(Ue.line + Ct, Ue.ch + Wt) : gt.head.line == gt.anchor.line ? Me = new u(Ue.line, Ue.ch + Wt) : Me = new u(Ue.line + Ct, Ue.ch), $.visualMode = !0, $.visualLine = gt.visualLine, $.visualBlock = gt.visualBlock, se = $.sel = {
                  anchor: Re,
                  head: Me
                }, zn(x);
              } else $.visualMode && (ae.lastSel = {
                anchor: Je(se.anchor),
                head: Je(se.head),
                visualBlock: $.visualBlock,
                visualLine: $.visualLine
              });
              var Lt, Xt, Et, kt, Kt;
              if ($.visualMode) {
                if (Lt = $t(se.head, se.anchor), Xt = Mt(se.head, se.anchor), Et = $.visualLine || ae.linewise, kt = $.visualBlock ? "block" : Et ? "line" : "char", Kt = fn(x, {
                  anchor: Lt,
                  head: Xt
                }, kt), Et) {
                  var Zt = Kt.ranges;
                  if (kt == "block")
                    for (var Vt = 0; Vt < Zt.length; Vt++)
                      Zt[Vt].head.ch = yt(x, Zt[Vt].head.line);
                  else kt == "line" && (Zt[0].head = new u(Zt[0].head.line + 1, 0));
                }
              } else {
                if (Lt = Je(Re || Ue), Xt = Je(Me || Le), qe(Xt, Lt)) {
                  var Gn = Lt;
                  Lt = Xt, Xt = Gn;
                }
                Et = j.linewise || ae.linewise, Et ? vr(x, Lt, Xt) : j.forward && Lr(x, Lt, Xt), kt = "char";
                var Cr = !j.inclusive || Et;
                Kt = fn(x, {
                  anchor: Lt,
                  head: Xt
                }, kt, Cr);
              }
              x.setSelections(Kt.ranges, Kt.primary), $.lastMotion = null, ae.repeat = at, ae.registerName = fe, ae.linewise = Et;
              var pa = Te[U](
                x,
                ae,
                Kt.ranges,
                Ue,
                Me
              );
              $.visualMode && un(x, pa != null), pa && x.setCursor(pa);
            }
          },
          recordLastEdit: function(x, $, D) {
            var L = be.macroModeState;
            L.isPlaying || (x.lastEditInputState = $, x.lastEditActionCommand = D, L.lastInsertModeChanges.changes = [], L.lastInsertModeChanges.expectCursorActivityForChange = !1, L.lastInsertModeChanges.visualBlock = x.visualBlock ? x.sel.head.line - x.sel.anchor.line : 0);
          }
        }, lt = {
          moveToTopLine: function(x, $, D) {
            var L = Fr(x).top + D.repeat - 1;
            return new u(L, Yt(x.getLine(L)));
          },
          moveToMiddleLine: function(x) {
            var $ = Fr(x), D = Math.floor(($.top + $.bottom) * 0.5);
            return new u(D, Yt(x.getLine(D)));
          },
          moveToBottomLine: function(x, $, D) {
            var L = Fr(x).bottom - D.repeat + 1;
            return new u(L, Yt(x.getLine(L)));
          },
          expandToLine: function(x, $, D) {
            var L = $;
            return new u(L.line + D.repeat - 1, 1 / 0);
          },
          findNext: function(x, $, D) {
            var L = jt(x), j = L.getQuery();
            if (j) {
              var U = !D.forward;
              return U = L.isReversed() ? !U : U, la(x, j), Nr(x, U, j, D.repeat);
            }
          },
          /**
           * Find and select the next occurrence of the search query. If the cursor is currently
           * within a match, then find and select the current match. Otherwise, find the next occurrence in the
           * appropriate direction.
           *
           * This differs from `findNext` in the following ways:
           *
           * 1. Instead of only returning the "from", this returns a "from", "to" range.
           * 2. If the cursor is currently inside a search match, this selects the current match
           *    instead of the next match.
           * 3. If there is no associated operator, this will turn on visual mode.
           */
          findAndSelectNextInclusive: function(x, $, D, L, j) {
            var U = jt(x), ae = U.getQuery();
            if (ae) {
              var fe = !D.forward;
              fe = U.isReversed() ? !fe : fe;
              var se = Fa(x, fe, ae, D.repeat, L);
              if (se) {
                if (j.operator)
                  return se;
                var we = se[0], _e = new u(se[1].line, se[1].ch - 1);
                if (L.visualMode) {
                  (L.visualLine || L.visualBlock) && (L.visualLine = !1, L.visualBlock = !1, s.signal(x, "vim-mode-change", { mode: "visual", subMode: "" }));
                  var Le = L.sel.anchor;
                  if (Le)
                    return U.isReversed() ? D.forward ? [Le, we] : [Le, _e] : D.forward ? [Le, _e] : [Le, we];
                } else
                  L.visualMode = !0, L.visualLine = !1, L.visualBlock = !1, s.signal(x, "vim-mode-change", { mode: "visual", subMode: "" });
                return fe ? [_e, we] : [we, _e];
              }
            }
          },
          goToMark: function(x, $, D, L) {
            var j = ja(x, L, D.selectedCharacter);
            return j ? D.linewise ? { line: j.line, ch: Yt(x.getLine(j.line)) } : j : null;
          },
          moveToOtherHighlightedEnd: function(x, $, D, L) {
            if (L.visualBlock && D.sameLine) {
              var j = L.sel;
              return [
                He(x, new u(j.anchor.line, j.head.ch)),
                He(x, new u(j.head.line, j.anchor.ch))
              ];
            } else
              return [L.sel.head, L.sel.anchor];
          },
          jumpToMark: function(x, $, D, L) {
            for (var j = $, U = 0; U < D.repeat; U++) {
              var ae = j;
              for (var fe in L.marks)
                if (V(fe)) {
                  var se = L.marks[fe].find(), we = D.forward ? qe(se, ae) : qe(ae, se);
                  if (!we && !(D.linewise && se.line == ae.line)) {
                    var _e = wt(ae, j), Le = D.forward ? Tt(ae, se, j) : Tt(j, se, ae);
                    (_e || Le) && (j = se);
                  }
                }
            }
            return D.linewise && (j = new u(j.line, Yt(x.getLine(j.line)))), j;
          },
          moveByCharacters: function(x, $, D) {
            var L = $, j = D.repeat, U = D.forward ? L.ch + j : L.ch - j;
            return new u(L.line, U);
          },
          moveByLines: function(x, $, D, L) {
            var j = $, U = j.ch;
            switch (L.lastMotion) {
              case this.moveByLines:
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveToColumn:
              case this.moveToEol:
                U = L.lastHPos;
                break;
              default:
                L.lastHPos = U;
            }
            var ae = D.repeat + (D.repeatOffset || 0), fe = D.forward ? j.line + ae : j.line - ae, se = x.firstLine(), we = x.lastLine(), _e = x.findPosV(j, D.forward ? ae : -ae, "line", L.lastHSPos), Le = D.forward ? _e.line > fe : _e.line < fe;
            return Le && (fe = _e.line, U = _e.ch), fe < se && j.line == se ? this.moveToStartOfLine(x, $, D, L) : fe > we && j.line == we ? Mn(x, $, D, L, !0) : (D.toFirstChar && (U = Yt(x.getLine(fe)), L.lastHPos = U), L.lastHSPos = x.charCoords(new u(fe, U), "div").left, new u(fe, U));
          },
          moveByDisplayLines: function(x, $, D, L) {
            var j = $;
            switch (L.lastMotion) {
              case this.moveByDisplayLines:
              case this.moveByScroll:
              case this.moveByLines:
              case this.moveToColumn:
              case this.moveToEol:
                break;
              default:
                L.lastHSPos = x.charCoords(j, "div").left;
            }
            var U = D.repeat, ae = x.findPosV(j, D.forward ? U : -U, "line", L.lastHSPos);
            if (ae.hitSide)
              if (D.forward)
                var fe = x.charCoords(ae, "div"), se = { top: fe.top + 8, left: L.lastHSPos }, ae = x.coordsChar(se, "div");
              else {
                var we = x.charCoords(new u(x.firstLine(), 0), "div");
                we.left = L.lastHSPos, ae = x.coordsChar(we, "div");
              }
            return L.lastHPos = ae.ch, ae;
          },
          moveByPage: function(x, $, D) {
            var L = $, j = D.repeat;
            return x.findPosV(L, D.forward ? j : -j, "page");
          },
          moveByParagraph: function(x, $, D) {
            var L = D.forward ? 1 : -1;
            return Rt(x, $, D.repeat, L);
          },
          moveBySentence: function(x, $, D) {
            var L = D.forward ? 1 : -1;
            return Ln(x, $, D.repeat, L);
          },
          moveByScroll: function(x, $, D, L) {
            var j = x.getScrollInfo(), U = null, ae = D.repeat;
            ae || (ae = j.clientHeight / (2 * x.defaultTextHeight()));
            var fe = x.charCoords($, "local");
            if (D.repeat = ae, U = lt.moveByDisplayLines(x, $, D, L), !U)
              return null;
            var se = x.charCoords(U, "local");
            return x.scrollTo(null, j.top + se.top - fe.top), U;
          },
          moveByWords: function(x, $, D) {
            return Rn(
              x,
              $,
              D.repeat,
              !!D.forward,
              !!D.wordEnd,
              !!D.bigWord
            );
          },
          moveTillCharacter: function(x, $, D) {
            var L = D.repeat, j = tr(
              x,
              L,
              D.forward,
              D.selectedCharacter
            ), U = D.forward ? -1 : 1;
            return Sn(U, D), j ? (j.ch += U, j) : null;
          },
          moveToCharacter: function(x, $, D) {
            var L = D.repeat;
            return Sn(0, D), tr(
              x,
              L,
              D.forward,
              D.selectedCharacter
            ) || $;
          },
          moveToSymbol: function(x, $, D) {
            var L = D.repeat;
            return er(
              x,
              L,
              D.forward,
              D.selectedCharacter
            ) || $;
          },
          moveToColumn: function(x, $, D, L) {
            var j = D.repeat;
            return L.lastHPos = j - 1, L.lastHSPos = x.charCoords($, "div").left, On(x, j);
          },
          moveToEol: function(x, $, D, L) {
            return Mn(x, $, D, L, !1);
          },
          moveToFirstNonWhiteSpaceCharacter: function(x, $) {
            var D = $;
            return new u(
              D.line,
              Yt(x.getLine(D.line))
            );
          },
          moveToMatchedSymbol: function(x, $) {
            for (var D = $, L = D.line, j = D.ch, U = x.getLine(L), ae; j < U.length; j++)
              if (ae = U.charAt(j), ae && ne(ae)) {
                var fe = x.getTokenTypeAt(new u(L, j + 1));
                if (fe !== "string" && fe !== "comment")
                  break;
              }
            if (j < U.length) {
              var se = j === "<" || j === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/, we = x.findMatchingBracket(new u(L, j), { bracketRegex: se });
              return we.to;
            } else
              return D;
          },
          moveToStartOfLine: function(x, $) {
            return new u($.line, 0);
          },
          moveToLineOrEdgeOfDocument: function(x, $, D) {
            var L = D.forward ? x.lastLine() : x.firstLine();
            return D.repeatIsExplicit && (L = D.repeat - x.getOption("firstLineNumber")), new u(
              L,
              Yt(x.getLine(L))
            );
          },
          moveToStartOfDisplayLine: function(x) {
            return x.execCommand("goLineLeft"), x.getCursor();
          },
          moveToEndOfDisplayLine: function(x) {
            x.execCommand("goLineRight");
            var $ = x.getCursor();
            return $.sticky == "before" && $.ch--, $;
          },
          textObjectManipulation: function(x, $, D, L) {
            var j = {
              "(": ")",
              ")": "(",
              "{": "}",
              "}": "{",
              "[": "]",
              "]": "[",
              "<": ">",
              ">": "<"
            }, U = { "'": !0, '"': !0, "`": !0 }, ae = D.selectedCharacter;
            ae == "b" ? ae = "(" : ae == "B" && (ae = "{");
            var fe = !D.textObjectInner, se;
            if (j[ae])
              se = nr(x, $, ae, fe);
            else if (U[ae])
              se = Cn(x, $, ae, fe);
            else if (ae === "W")
              se = gn(
                x,
                fe,
                !0,
                !0
                /** bigWord */
              );
            else if (ae === "w")
              se = gn(
                x,
                fe,
                !0,
                !1
                /** bigWord */
              );
            else if (ae === "p")
              if (se = Rt(x, $, D.repeat, 0, fe), D.linewise = !0, L.visualMode)
                L.visualLine || (L.visualLine = !0);
              else {
                var we = L.inputState.operatorArgs;
                we && (we.linewise = !0), se.end.line--;
              }
            else if (ae === "t")
              se = Tn(x, $, fe);
            else if (ae === "s") {
              var _e = x.getLine($.line);
              $.ch > 0 && ue(_e[$.ch]) && ($.ch -= 1);
              var Le = ut(x, $, D.repeat, 1, fe), Ue = ut(x, $, D.repeat, -1, fe);
              X(x.getLine(Ue.line)[Ue.ch]) && X(x.getLine(Le.line)[Le.ch - 1]) && (Ue = { line: Ue.line, ch: Ue.ch + 1 }), se = { start: Ue, end: Le };
            } else
              return null;
            return x.state.vim.visualMode ? gr(x, se.start, se.end) : [se.start, se.end];
          },
          repeatLastCharacterSearch: function(x, $, D) {
            var L = be.lastCharacterSearch, j = D.repeat, U = D.forward === L.forward, ae = (L.increment ? 1 : 0) * (U ? -1 : 1);
            x.moveH(-ae, "char"), D.inclusive = !!U;
            var fe = tr(x, j, U, L.selectedCharacter);
            return fe ? (fe.ch += ae, fe) : (x.moveH(ae, "char"), $);
          }
        };
        function Ce(x, $) {
          lt[x] = $;
        }
        function Oe(x, $) {
          for (var D = [], L = 0; L < $; L++)
            D.push(x);
          return D;
        }
        var Te = {
          change: function(x, $, D) {
            var L, j, U = x.state.vim, ae = D[0].anchor, fe = D[0].head;
            if (U.visualMode)
              if ($.fullLine)
                fe.ch = Number.MAX_VALUE, fe.line--, x.setSelection(ae, fe), j = x.getSelection(), x.replaceSelection(""), L = ae;
              else {
                j = x.getSelection();
                var Ue = Oe("", D.length);
                x.replaceSelections(Ue), L = $t(D[0].head, D[0].anchor);
              }
            else {
              j = x.getRange(ae, fe);
              var se = U.lastEditInputState || {};
              if (se.motion == "moveByWords" && !X(j)) {
                var we = /\s+$/.exec(j);
                we && se.motionArgs && se.motionArgs.forward && (fe = de(fe, 0, -we[0].length), j = j.slice(0, -we[0].length));
              }
              var _e = new u(ae.line - 1, Number.MAX_VALUE), Le = x.firstLine() == x.lastLine();
              fe.line > x.lastLine() && $.linewise && !Le ? x.replaceRange("", _e, fe) : x.replaceRange("", ae, fe), $.linewise && (Le || (x.setCursor(_e), s.commands.newlineAndIndent(x)), ae.ch = Number.MAX_VALUE), L = ae;
            }
            be.registerController.pushText(
              $.registerName,
              "change",
              j,
              $.linewise,
              D.length > 1
            ), We.enterInsertMode(x, { head: L }, x.state.vim);
          },
          // delete is a javascript keyword.
          delete: function(x, $, D) {
            var L, j, U = x.state.vim;
            if (U.visualBlock) {
              j = x.getSelection();
              var se = Oe("", D.length);
              x.replaceSelections(se), L = $t(D[0].head, D[0].anchor);
            } else {
              var ae = D[0].anchor, fe = D[0].head;
              $.linewise && fe.line != x.firstLine() && ae.line == x.lastLine() && ae.line == fe.line - 1 && (ae.line == x.firstLine() ? ae.ch = 0 : ae = new u(ae.line - 1, yt(x, ae.line - 1))), j = x.getRange(ae, fe), x.replaceRange("", ae, fe), L = ae, $.linewise && (L = lt.moveToFirstNonWhiteSpaceCharacter(x, ae));
            }
            return be.registerController.pushText(
              $.registerName,
              "delete",
              j,
              $.linewise,
              U.visualBlock
            ), He(x, L);
          },
          indent: function(x, $, D) {
            var L = x.state.vim;
            if (x.indentMore)
              for (var j = L.visualMode ? $.repeat : 1, U = 0; U < j; U++)
                $.indentRight ? x.indentMore() : x.indentLess();
            else {
              var ae = D[0].anchor.line, fe = L.visualBlock ? D[D.length - 1].anchor.line : D[0].head.line, j = L.visualMode ? $.repeat : 1;
              $.linewise && fe--;
              for (var se = ae; se <= fe; se++)
                for (var U = 0; U < j; U++)
                  x.indentLine(se, $.indentRight);
            }
            return lt.moveToFirstNonWhiteSpaceCharacter(x, D[0].anchor);
          },
          indentAuto: function(x, $, D) {
            return x.execCommand("indentAuto"), lt.moveToFirstNonWhiteSpaceCharacter(x, D[0].anchor);
          },
          changeCase: function(x, $, D, L, j) {
            for (var U = x.getSelections(), ae = [], fe = $.toLower, se = 0; se < U.length; se++) {
              var we = U[se], _e = "";
              if (fe === !0)
                _e = we.toLowerCase();
              else if (fe === !1)
                _e = we.toUpperCase();
              else
                for (var Le = 0; Le < we.length; Le++) {
                  var Ue = we.charAt(Le);
                  _e += z(Ue) ? Ue.toLowerCase() : Ue.toUpperCase();
                }
              ae.push(_e);
            }
            return x.replaceSelections(ae), $.shouldMoveCursor ? j : !x.state.vim.visualMode && $.linewise && D[0].anchor.line + 1 == D[0].head.line ? lt.moveToFirstNonWhiteSpaceCharacter(x, L) : $.linewise ? L : $t(D[0].anchor, D[0].head);
          },
          yank: function(x, $, D, L) {
            var j = x.state.vim, U = x.getSelection(), ae = j.visualMode ? $t(j.sel.anchor, j.sel.head, D[0].head, D[0].anchor) : L;
            return be.registerController.pushText(
              $.registerName,
              "yank",
              U,
              $.linewise,
              j.visualBlock
            ), ae;
          }
        };
        function ot(x, $) {
          Te[x] = $;
        }
        var We = {
          jumpListWalk: function(x, $, D) {
            if (!D.visualMode) {
              var L = $.repeat, j = $.forward, U = be.jumpList, ae = U.move(x, j ? L : -L), fe = ae ? ae.find() : void 0;
              fe = fe || x.getCursor(), x.setCursor(fe);
            }
          },
          scroll: function(x, $, D) {
            if (!D.visualMode) {
              var L = $.repeat || 1, j = x.defaultTextHeight(), U = x.getScrollInfo().top, ae = j * L, fe = $.forward ? U + ae : U - ae, se = Je(x.getCursor()), we = x.charCoords(se, "local");
              if ($.forward)
                fe > we.top ? (se.line += (fe - we.top) / j, se.line = Math.ceil(se.line), x.setCursor(se), we = x.charCoords(se, "local"), x.scrollTo(null, we.top)) : x.scrollTo(null, fe);
              else {
                var _e = fe + x.getScrollInfo().clientHeight;
                _e < we.bottom ? (se.line -= (we.bottom - _e) / j, se.line = Math.floor(se.line), x.setCursor(se), we = x.charCoords(se, "local"), x.scrollTo(
                  null,
                  we.bottom - x.getScrollInfo().clientHeight
                )) : x.scrollTo(null, fe);
              }
            }
          },
          scrollToCursor: function(x, $) {
            var D = x.getCursor().line, L = x.charCoords(new u(D, 0), "local"), j = x.getScrollInfo().clientHeight, U = L.top;
            switch ($.position) {
              case "center":
                U = L.bottom - j / 2;
                break;
              case "bottom":
                var ae = new u(D, x.getLine(D).length - 1), fe = x.charCoords(ae, "local"), se = fe.bottom - U;
                U = U - j + se;
                break;
            }
            x.scrollTo(null, U);
          },
          replayMacro: function(x, $, D) {
            var L = $.selectedCharacter, j = $.repeat, U = be.macroModeState;
            for (L == "@" ? L = U.latestRegister : U.latestRegister = L; j--; )
              vi(x, D, U, L);
          },
          enterMacroRecordMode: function(x, $) {
            var D = be.macroModeState, L = $.selectedCharacter;
            be.registerController.isValidRegister(L) && D.enterMacroRecordMode(x, L);
          },
          toggleOverwrite: function(x) {
            x.state.overwrite ? (x.toggleOverwrite(!1), x.setOption("keyMap", "vim-insert"), s.signal(x, "vim-mode-change", { mode: "insert" })) : (x.toggleOverwrite(!0), x.setOption("keyMap", "vim-replace"), s.signal(x, "vim-mode-change", { mode: "replace" }));
          },
          enterInsertMode: function(x, $, D) {
            if (!x.getOption("readOnly")) {
              D.insertMode = !0, D.insertModeRepeat = $ && $.repeat || 1;
              var L = $ ? $.insertAt : null, j = D.sel, U = $.head || x.getCursor("head"), ae = x.listSelections().length;
              if (L == "eol")
                U = new u(U.line, yt(x, U.line));
              else if (L == "bol")
                U = new u(U.line, 0);
              else if (L == "charAfter")
                U = de(U, 0, 1);
              else if (L == "firstNonBlank")
                U = lt.moveToFirstNonWhiteSpaceCharacter(x, U);
              else if (L == "startOfSelectedArea") {
                if (!D.visualMode)
                  return;
                D.visualBlock ? (U = new u(
                  Math.min(j.head.line, j.anchor.line),
                  Math.min(j.head.ch, j.anchor.ch)
                ), ae = Math.abs(j.head.line - j.anchor.line) + 1) : j.head.line < j.anchor.line ? U = j.head : U = new u(j.anchor.line, 0);
              } else if (L == "endOfSelectedArea") {
                if (!D.visualMode)
                  return;
                D.visualBlock ? (U = new u(
                  Math.min(j.head.line, j.anchor.line),
                  Math.max(j.head.ch, j.anchor.ch) + 1
                ), ae = Math.abs(j.head.line - j.anchor.line) + 1) : j.head.line >= j.anchor.line ? U = de(j.head, 0, 1) : U = new u(j.anchor.line, 0);
              } else if (L == "inplace") {
                if (D.visualMode)
                  return;
              } else L == "lastEdit" && (U = qa(x) || U);
              x.setOption("disableInput", !1), $ && $.replace ? (x.toggleOverwrite(!0), x.setOption("keyMap", "vim-replace"), s.signal(x, "vim-mode-change", { mode: "replace" })) : (x.toggleOverwrite(!1), x.setOption("keyMap", "vim-insert"), s.signal(x, "vim-mode-change", { mode: "insert" })), be.macroModeState.isPlaying || (x.on("change", da), s.on(x.getInputField(), "keydown", _r)), D.visualMode && un(x), Fn(x, U, ae);
            }
          },
          toggleVisualMode: function(x, $, D) {
            var L = $.repeat, j = x.getCursor(), U;
            D.visualMode ? D.visualLine ^ $.linewise || D.visualBlock ^ $.blockwise ? (D.visualLine = !!$.linewise, D.visualBlock = !!$.blockwise, s.signal(x, "vim-mode-change", { mode: "visual", subMode: D.visualLine ? "linewise" : D.visualBlock ? "blockwise" : "" }), zn(x)) : un(x) : (D.visualMode = !0, D.visualLine = !!$.linewise, D.visualBlock = !!$.blockwise, U = He(
              x,
              new u(j.line, j.ch + L - 1)
            ), D.sel = {
              anchor: j,
              head: U
            }, s.signal(x, "vim-mode-change", { mode: "visual", subMode: D.visualLine ? "linewise" : D.visualBlock ? "blockwise" : "" }), zn(x), sn(x, D, "<", $t(j, U)), sn(x, D, ">", Mt(j, U)));
          },
          reselectLastSelection: function(x, $, D) {
            var L = D.lastSelection;
            if (D.visualMode && on(x, D), L) {
              var j = L.anchorMark.find(), U = L.headMark.find();
              if (!j || !U)
                return;
              D.sel = {
                anchor: j,
                head: U
              }, D.visualMode = !0, D.visualLine = L.visualLine, D.visualBlock = L.visualBlock, zn(x), sn(x, D, "<", $t(j, U)), sn(x, D, ">", Mt(j, U)), s.signal(x, "vim-mode-change", {
                mode: "visual",
                subMode: D.visualLine ? "linewise" : D.visualBlock ? "blockwise" : ""
              });
            }
          },
          joinLines: function(x, $, D) {
            var L, j;
            if (D.visualMode) {
              if (L = x.getCursor("anchor"), j = x.getCursor("head"), qe(j, L)) {
                var U = j;
                j = L, L = U;
              }
              j.ch = yt(x, j.line) - 1;
            } else {
              var ae = Math.max($.repeat, 2);
              L = x.getCursor(), j = He(x, new u(
                L.line + ae - 1,
                1 / 0
              ));
            }
            for (var fe = 0, se = L.line; se < j.line; se++) {
              fe = yt(x, L.line);
              var U = new u(
                L.line + 1,
                yt(x, L.line + 1)
              ), we = x.getRange(L, U);
              we = $.keepSpaces ? we.replace(/\n\r?/g, "") : we.replace(/\n\s*/g, " "), x.replaceRange(we, L, U);
            }
            var _e = new u(L.line, fe);
            D.visualMode && un(x, !1), x.setCursor(_e);
          },
          newLineAndEnterInsertMode: function(x, $, D) {
            D.insertMode = !0;
            var L = Je(x.getCursor());
            if (L.line === x.firstLine() && !$.after)
              x.replaceRange(`
`, new u(x.firstLine(), 0)), x.setCursor(x.firstLine(), 0);
            else {
              L.line = $.after ? L.line : L.line - 1, L.ch = yt(x, L.line), x.setCursor(L);
              var j = s.commands.newlineAndIndentContinueComment || s.commands.newlineAndIndent;
              j(x);
            }
            this.enterInsertMode(x, { repeat: $.repeat }, D);
          },
          paste: function(x, $, D) {
            var L = Je(x.getCursor()), j = be.registerController.getRegister(
              $.registerName
            ), U = j.toString();
            if (U) {
              if ($.matchIndent) {
                var ae = x.getOption("tabSize"), fe = function(Vt) {
                  var Gn = Vt.split("	").length - 1, Cr = Vt.split(" ").length - 1;
                  return Gn * ae + Cr * 1;
                }, se = x.getLine(x.getCursor().line), we = fe(se.match(/^\s*/)[0]), _e = U.replace(/\n$/, ""), Le = U !== _e, Ue = fe(U.match(/^\s*/)[0]), U = _e.replace(/^\s*/gm, function(Vt) {
                  var Gn = we + (fe(Vt) - Ue);
                  if (Gn < 0)
                    return "";
                  if (x.getOption("indentWithTabs")) {
                    var Cr = Math.floor(Gn / ae);
                    return Array(Cr + 1).join("	");
                  } else
                    return Array(Gn + 1).join(" ");
                });
                U += Le ? `
` : "";
              }
              if ($.repeat > 1)
                var U = Array($.repeat + 1).join(U);
              var Me = j.linewise, Re = j.blockwise;
              if (Re) {
                U = U.split(`
`), Me && U.pop();
                for (var at = 0; at < U.length; at++)
                  U[at] = U[at] == "" ? " " : U[at];
                L.ch += $.after ? 1 : 0, L.ch = Math.min(yt(x, L.line), L.ch);
              } else Me ? D.visualMode ? U = D.visualLine ? U.slice(0, -1) : `
` + U.slice(0, U.length - 1) + `
` : $.after ? (U = `
` + U.slice(0, U.length - 1), L.ch = yt(x, L.line)) : L.ch = 0 : L.ch += $.after ? 1 : 0;
              var Xe, pt;
              if (D.visualMode) {
                D.lastPastedText = U;
                var vt, gt = Dn(x, D), Ct = gt[0], Wt = gt[1], Lt = x.getSelection(), Xt = x.listSelections(), Et = new Array(Xt.length).join("1").split("1");
                D.lastSelection && (vt = D.lastSelection.headMark.find()), be.registerController.unnamedRegister.setText(Lt), Re ? (x.replaceSelections(Et), Wt = new u(Ct.line + U.length - 1, Ct.ch), x.setCursor(Ct), Ut(x, Wt), x.replaceSelections(U), Xe = Ct) : D.visualBlock ? (x.replaceSelections(Et), x.setCursor(Ct), x.replaceRange(U, Ct, Ct), Xe = Ct) : (x.replaceRange(U, Ct, Wt), Xe = x.posFromIndex(x.indexFromPos(Ct) + U.length - 1)), vt && (D.lastSelection.headMark = x.setBookmark(vt)), Me && (Xe.ch = 0);
              } else if (Re) {
                x.setCursor(L);
                for (var at = 0; at < U.length; at++) {
                  var kt = L.line + at;
                  kt > x.lastLine() && x.replaceRange(`
`, new u(kt, 0));
                  var Kt = yt(x, kt);
                  Kt < L.ch && an(x, kt, L.ch);
                }
                x.setCursor(L), Ut(x, new u(L.line + U.length - 1, L.ch)), x.replaceSelections(U), Xe = L;
              } else
                x.replaceRange(U, L), Me && $.after ? Xe = new u(
                  L.line + 1,
                  Yt(x.getLine(L.line + 1))
                ) : Me && !$.after ? Xe = new u(
                  L.line,
                  Yt(x.getLine(L.line))
                ) : !Me && $.after ? (pt = x.indexFromPos(L), Xe = x.posFromIndex(pt + U.length - 1)) : (pt = x.indexFromPos(L), Xe = x.posFromIndex(pt + U.length));
              D.visualMode && un(x, !1), x.setCursor(Xe);
            }
          },
          undo: function(x, $) {
            x.operation(function() {
              ct(x, s.commands.undo, $.repeat)(), x.setCursor(x.getCursor("anchor"));
            });
          },
          redo: function(x, $) {
            ct(x, s.commands.redo, $.repeat)();
          },
          setRegister: function(x, $, D) {
            D.inputState.registerName = $.selectedCharacter;
          },
          setMark: function(x, $, D) {
            var L = $.selectedCharacter;
            sn(x, D, L, x.getCursor());
          },
          replace: function(x, $, D) {
            var L = $.selectedCharacter, j = x.getCursor(), U, ae, fe = x.listSelections();
            if (D.visualMode)
              j = x.getCursor("start"), ae = x.getCursor("end");
            else {
              var se = x.getLine(j.line);
              U = j.ch + $.repeat, U > se.length && (U = se.length), ae = new u(j.line, U);
            }
            if (L == `
`)
              D.visualMode || x.replaceRange("", j, ae), (s.commands.newlineAndIndentContinueComment || s.commands.newlineAndIndent)(x);
            else {
              var we = x.getRange(j, ae);
              if (we = we.replace(/[^\n]/g, L), D.visualBlock) {
                var _e = new Array(x.getOption("tabSize") + 1).join(" ");
                we = x.getSelection(), we = we.replace(/\t/g, _e).replace(/[^\n]/g, L).split(`
`), x.replaceSelections(we);
              } else
                x.replaceRange(we, j, ae);
              D.visualMode ? (j = qe(fe[0].anchor, fe[0].head) ? fe[0].anchor : fe[0].head, x.setCursor(j), un(x, !1)) : x.setCursor(de(ae, 0, -1));
            }
          },
          incrementNumberToken: function(x, $) {
            for (var D = x.getCursor(), L = x.getLine(D.line), j = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi, U, ae, fe, se; (U = j.exec(L)) !== null && (ae = U.index, fe = ae + U[0].length, !(D.ch < fe)); )
              ;
            if (!(!$.backtrack && fe <= D.ch)) {
              if (U) {
                var we = U[2] || U[4], _e = U[3] || U[5], Le = $.increase ? 1 : -1, Ue = { "0b": 2, 0: 8, "": 10, "0x": 16 }[we.toLowerCase()], Me = parseInt(U[1] + _e, Ue) + Le * $.repeat;
                se = Me.toString(Ue);
                var Re = we ? new Array(_e.length - se.length + 1 + U[1].length).join("0") : "";
                se.charAt(0) === "-" ? se = "-" + we + Re + se.substr(1) : se = we + Re + se;
                var at = new u(D.line, ae), Xe = new u(D.line, fe);
                x.replaceRange(se, at, Xe);
              } else
                return;
              x.setCursor(new u(D.line, ae + se.length - 1));
            }
          },
          repeatLastEdit: function(x, $, D) {
            var L = D.lastEditInputState;
            if (L) {
              var j = $.repeat;
              j && $.repeatIsExplicit ? D.lastEditInputState.repeatOverride = j : j = D.lastEditInputState.repeatOverride || j, Sr(
                x,
                D,
                j,
                !1
                /** repeatForInsert */
              );
            }
          },
          indent: function(x, $) {
            x.indentLine(x.getCursor().line, $.indentRight);
          },
          exitInsertMode: Hn
        };
        function Ge(x, $) {
          We[x] = $;
        }
        function He(x, $) {
          var D = x.state.vim, L = D.insertMode || D.visualMode, j = Math.min(Math.max(x.firstLine(), $.line), x.lastLine()), U = yt(x, j) - 1 + !!L, ae = Math.min(Math.max(0, $.ch), U);
          return new u(j, ae);
        }
        function me(x) {
          var $ = {};
          for (var D in x)
            x.hasOwnProperty(D) && ($[D] = x[D]);
          return $;
        }
        function de(x, $, D) {
          return typeof $ == "object" && (D = $.ch, $ = $.line), new u(x.line + $, x.ch + D);
        }
        function Fe(x, $, D, L) {
          for (var j, U = [], ae = [], fe = 0; fe < $.length; fe++) {
            var se = $[fe];
            D == "insert" && se.context != "insert" || se.context && se.context != D || L.operator && se.type == "action" || !(j = Ze(x, se.keys)) || (j == "partial" && U.push(se), j == "full" && ae.push(se));
          }
          return {
            partial: U.length && U,
            full: ae.length && ae
          };
        }
        function Ze(x, $) {
          if ($.slice(-11) == "<character>") {
            var D = $.length - 11, L = x.slice(0, D), j = $.slice(0, D);
            return L == j && x.length > D ? "full" : j.indexOf(L) == 0 ? "partial" : !1;
          } else
            return x == $ ? "full" : $.indexOf(x) == 0 ? "partial" : !1;
        }
        function $e(x) {
          var $ = /^.*(<[^>]+>)$/.exec(x), D = $ ? $[1] : x.slice(-1);
          if (D.length > 1)
            switch (D) {
              case "<CR>":
                D = `
`;
                break;
              case "<Space>":
                D = " ";
                break;
              default:
                D = "";
                break;
            }
          return D;
        }
        function ct(x, $, D) {
          return function() {
            for (var L = 0; L < D; L++)
              $(x);
          };
        }
        function Je(x) {
          return new u(x.line, x.ch);
        }
        function wt(x, $) {
          return x.ch == $.ch && x.line == $.line;
        }
        function qe(x, $) {
          return x.line < $.line || x.line == $.line && x.ch < $.ch;
        }
        function $t(x, $) {
          return arguments.length > 2 && ($ = $t.apply(void 0, Array.prototype.slice.call(arguments, 1))), qe(x, $) ? x : $;
        }
        function Mt(x, $) {
          return arguments.length > 2 && ($ = Mt.apply(void 0, Array.prototype.slice.call(arguments, 1))), qe(x, $) ? $ : x;
        }
        function Tt(x, $, D) {
          var L = qe(x, $), j = qe($, D);
          return L && j;
        }
        function yt(x, $) {
          return x.getLine($).length;
        }
        function Qn(x) {
          return x.trim ? x.trim() : x.replace(/^\s+|\s+$/g, "");
        }
        function rn(x) {
          return x.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
        }
        function an(x, $, D) {
          var L = yt(x, $), j = new Array(D - L + 1).join(" ");
          x.setCursor(new u($, L)), x.replaceRange(j, x.getCursor());
        }
        function Ut(x, $) {
          var D = [], L = x.listSelections(), j = Je(x.clipPos($)), U = !wt($, j), ae = x.getCursor("head"), fe = mr(L, ae), se = wt(L[fe].head, L[fe].anchor), we = L.length - 1, _e = we - fe > fe ? we : 0, Le = L[_e].anchor, Ue = Math.min(Le.line, j.line), Me = Math.max(Le.line, j.line), Re = Le.ch, at = j.ch, Xe = L[_e].head.ch - Re, pt = at - Re;
          Xe > 0 && pt <= 0 ? (Re++, U || at--) : Xe < 0 && pt >= 0 ? (Re--, se || at++) : Xe < 0 && pt == -1 && (Re--, at++);
          for (var vt = Ue; vt <= Me; vt++) {
            var gt = { anchor: new u(vt, Re), head: new u(vt, at) };
            D.push(gt);
          }
          return x.setSelections(D), $.ch = at, Le.ch = Re, Le;
        }
        function Fn(x, $, D) {
          for (var L = [], j = 0; j < D; j++) {
            var U = de($, j, 0);
            L.push({ anchor: U, head: U });
          }
          x.setSelections(L, 0);
        }
        function mr(x, $, D) {
          for (var L = 0; L < x.length; L++) {
            var j = wt(x[L].anchor, $), U = wt(x[L].head, $);
            if (j || U)
              return L;
          }
          return -1;
        }
        function Dn(x, $) {
          var D = $.lastSelection, L = function() {
            var U = x.listSelections(), ae = U[0], fe = U[U.length - 1], se = qe(ae.anchor, ae.head) ? ae.anchor : ae.head, we = qe(fe.anchor, fe.head) ? fe.head : fe.anchor;
            return [se, we];
          }, j = function() {
            var U = x.getCursor(), ae = x.getCursor(), fe = D.visualBlock;
            if (fe) {
              var se = fe.width, we = fe.height;
              ae = new u(U.line + we, U.ch + se);
              for (var _e = [], Le = U.line; Le < ae.line; Le++) {
                var Ue = new u(Le, U.ch), Me = new u(Le, ae.ch), Re = { anchor: Ue, head: Me };
                _e.push(Re);
              }
              x.setSelections(_e);
            } else {
              var at = D.anchorMark.find(), Xe = D.headMark.find(), pt = Xe.line - at.line, vt = Xe.ch - at.ch;
              ae = { line: ae.line + pt, ch: pt ? ae.ch : vt + ae.ch }, D.visualLine && (U = new u(U.line, 0), ae = new u(ae.line, yt(x, ae.line))), x.setSelection(U, ae);
            }
            return [U, ae];
          };
          return $.visualMode ? L() : j();
        }
        function on(x, $) {
          var D = $.sel.anchor, L = $.sel.head;
          $.lastPastedText && (L = x.posFromIndex(x.indexFromPos(D) + $.lastPastedText.length), $.lastPastedText = null), $.lastSelection = {
            anchorMark: x.setBookmark(D),
            headMark: x.setBookmark(L),
            anchor: Je(D),
            head: Je(L),
            visualMode: $.visualMode,
            visualLine: $.visualLine,
            visualBlock: $.visualBlock
          };
        }
        function gr(x, $, D) {
          var L = x.state.vim.sel, j = L.head, U = L.anchor, ae;
          return qe(D, $) && (ae = D, D = $, $ = ae), qe(j, U) ? (j = $t($, j), U = Mt(U, D)) : (U = $t($, U), j = Mt(j, D), j = de(j, 0, -1), j.ch == -1 && j.line != x.firstLine() && (j = new u(j.line - 1, yt(x, j.line - 1)))), [U, j];
        }
        function zn(x, $, j) {
          var L = x.state.vim;
          $ = $ || L.sel;
          var j = j || L.visualLine ? "line" : L.visualBlock ? "block" : "char", U = fn(x, $, j);
          x.setSelections(U.ranges, U.primary);
        }
        function fn(x, $, D, L) {
          var j = Je($.head), U = Je($.anchor);
          if (D == "char") {
            var ae = !L && !qe($.head, $.anchor) ? 1 : 0, fe = qe($.head, $.anchor) ? 1 : 0;
            return j = de($.head, 0, ae), U = de($.anchor, 0, fe), {
              ranges: [{ anchor: U, head: j }],
              primary: 0
            };
          } else if (D == "line") {
            if (qe($.head, $.anchor))
              j.ch = 0, U.ch = yt(x, U.line);
            else {
              U.ch = 0;
              var se = x.lastLine();
              j.line > se && (j.line = se), j.ch = yt(x, j.line);
            }
            return {
              ranges: [{ anchor: U, head: j }],
              primary: 0
            };
          } else if (D == "block") {
            var we = Math.min(U.line, j.line), _e = U.ch, Le = Math.max(U.line, j.line), Ue = j.ch;
            _e < Ue ? Ue += 1 : _e += 1;
            for (var Me = Le - we + 1, Re = j.line == we ? 0 : Me - 1, at = [], Xe = 0; Xe < Me; Xe++)
              at.push({
                anchor: new u(we + Xe, _e),
                head: new u(we + Xe, Ue)
              });
            return {
              ranges: at,
              primary: Re
            };
          }
        }
        function sa(x) {
          var $ = x.getCursor("head");
          return x.getSelection().length == 1 && ($ = $t($, x.getCursor("anchor"))), $;
        }
        function un(x, $) {
          var D = x.state.vim;
          $ !== !1 && x.setCursor(He(x, D.sel.head)), on(x, D), D.visualMode = !1, D.visualLine = !1, D.visualBlock = !1, D.insertMode || s.signal(x, "vim-mode-change", { mode: "normal" });
        }
        function Lr(x, $, D) {
          var L = x.getRange($, D);
          if (/\n\s*$/.test(L)) {
            var j = L.split(`
`);
            j.pop();
            for (var U, U = j.pop(); j.length > 0 && U && X(U); U = j.pop())
              D.line--, D.ch = 0;
            U ? (D.line--, D.ch = yt(x, D.line)) : D.ch = 0;
          }
        }
        function vr(x, $, D) {
          $.ch = 0, D.ch = 0, D.line++;
        }
        function Yt(x) {
          if (!x)
            return 0;
          var $ = x.search(/\S/);
          return $ == -1 ? x.length : $;
        }
        function gn(x, $, D, L, j) {
          for (var U = sa(x), ae = x.getLine(U.line), fe = U.ch, se = j ? T[0] : O[0]; !se(ae.charAt(fe)); )
            if (fe++, fe >= ae.length)
              return null;
          L ? se = O[0] : (se = T[0], se(ae.charAt(fe)) || (se = T[1]));
          for (var we = fe, _e = fe; se(ae.charAt(we)) && we < ae.length; )
            we++;
          for (; se(ae.charAt(_e)) && _e >= 0; )
            _e--;
          if (_e++, $) {
            for (var Le = we; /\s/.test(ae.charAt(we)) && we < ae.length; )
              we++;
            if (Le == we) {
              for (var Ue = _e; /\s/.test(ae.charAt(_e - 1)) && _e > 0; )
                _e--;
              _e || (_e = Ue);
            }
          }
          return { start: new u(U.line, _e), end: new u(U.line, we) };
        }
        function Tn(x, $, D) {
          var L = $;
          if (!s.findMatchingTag || !s.findEnclosingTag)
            return { start: L, end: L };
          var j = s.findMatchingTag(x, $) || s.findEnclosingTag(x, $);
          return !j || !j.open || !j.close ? { start: L, end: L } : D ? { start: j.open.from, end: j.close.to } : { start: j.open.to, end: j.close.from };
        }
        function yr(x, $, D) {
          wt($, D) || be.jumpList.add(x, $, D);
        }
        function Sn(x, $) {
          be.lastCharacterSearch.increment = x, be.lastCharacterSearch.forward = $.forward, be.lastCharacterSearch.selectedCharacter = $.selectedCharacter;
        }
        var jn = {
          "(": "bracket",
          ")": "bracket",
          "{": "bracket",
          "}": "bracket",
          "[": "section",
          "]": "section",
          "*": "comment",
          "/": "comment",
          m: "method",
          M: "method",
          "#": "preprocess"
        }, xr = {
          bracket: {
            isComplete: function(x) {
              if (x.nextCh === x.symb) {
                if (x.depth++, x.depth >= 1) return !0;
              } else x.nextCh === x.reverseSymb && x.depth--;
              return !1;
            }
          },
          section: {
            init: function(x) {
              x.curMoveThrough = !0, x.symb = (x.forward ? "]" : "[") === x.symb ? "{" : "}";
            },
            isComplete: function(x) {
              return x.index === 0 && x.nextCh === x.symb;
            }
          },
          comment: {
            isComplete: function(x) {
              var $ = x.lastCh === "*" && x.nextCh === "/";
              return x.lastCh = x.nextCh, $;
            }
          },
          // TODO: The original Vim implementation only operates on level 1 and 2.
          // The current implementation doesn't check for code block level and
          // therefore it operates on any levels.
          method: {
            init: function(x) {
              x.symb = x.symb === "m" ? "{" : "}", x.reverseSymb = x.symb === "{" ? "}" : "{";
            },
            isComplete: function(x) {
              return x.nextCh === x.symb;
            }
          },
          preprocess: {
            init: function(x) {
              x.index = 0;
            },
            isComplete: function(x) {
              if (x.nextCh === "#") {
                var $ = x.lineText.match(/^#(\w+)/)[1];
                if ($ === "endif") {
                  if (x.forward && x.depth === 0)
                    return !0;
                  x.depth++;
                } else if ($ === "if") {
                  if (!x.forward && x.depth === 0)
                    return !0;
                  x.depth--;
                }
                if ($ === "else" && x.depth === 0) return !0;
              }
              return !1;
            }
          }
        };
        function er(x, $, D, L) {
          var j = Je(x.getCursor()), U = D ? 1 : -1, ae = D ? x.lineCount() : -1, fe = j.ch, se = j.line, we = x.getLine(se), _e = {
            lineText: we,
            nextCh: we.charAt(fe),
            lastCh: null,
            index: fe,
            symb: L,
            reverseSymb: (D ? { ")": "(", "}": "{" } : { "(": ")", "{": "}" })[L],
            forward: D,
            depth: 0,
            curMoveThrough: !1
          }, Le = jn[L];
          if (!Le) return j;
          var Ue = xr[Le].init, Me = xr[Le].isComplete;
          for (Ue && Ue(_e); se !== ae && $; ) {
            if (_e.index += U, _e.nextCh = _e.lineText.charAt(_e.index), !_e.nextCh) {
              if (se += U, _e.lineText = x.getLine(se) || "", U > 0)
                _e.index = 0;
              else {
                var Re = _e.lineText.length;
                _e.index = Re > 0 ? Re - 1 : 0;
              }
              _e.nextCh = _e.lineText.charAt(_e.index);
            }
            Me(_e) && (j.line = se, j.ch = _e.index, $--);
          }
          return _e.nextCh || _e.curMoveThrough ? new u(se, _e.index) : j;
        }
        function pn(x, $, D, L, j) {
          var U = $.line, ae = $.ch, fe = x.getLine(U), se = D ? 1 : -1, we = L ? O : T;
          if (j && fe == "") {
            if (U += se, fe = x.getLine(U), !re(x, U))
              return null;
            ae = D ? 0 : fe.length;
          }
          for (; ; ) {
            if (j && fe == "")
              return { from: 0, to: 0, line: U };
            for (var _e = se > 0 ? fe.length : -1, Le = _e, Ue = _e; ae != _e; ) {
              for (var Me = !1, Re = 0; Re < we.length && !Me; ++Re)
                if (we[Re](fe.charAt(ae))) {
                  for (Le = ae; ae != _e && we[Re](fe.charAt(ae)); )
                    ae += se;
                  if (Ue = ae, Me = Le != Ue, Le == $.ch && U == $.line && Ue == Le + se)
                    continue;
                  return {
                    from: Math.min(Le, Ue + 1),
                    to: Math.max(Le, Ue),
                    line: U
                  };
                }
              Me || (ae += se);
            }
            if (U += se, !re(x, U))
              return null;
            fe = x.getLine(U), ae = se > 0 ? 0 : fe.length;
          }
        }
        function Rn(x, $, D, L, j, U) {
          var ae = Je($), fe = [];
          (L && !j || !L && j) && D++;
          for (var se = !(L && j), we = 0; we < D; we++) {
            var _e = pn(x, $, L, U, se);
            if (!_e) {
              var Le = yt(x, x.lastLine());
              fe.push(L ? { line: x.lastLine(), from: Le, to: Le } : { line: 0, from: 0, to: 0 });
              break;
            }
            fe.push(_e), $ = new u(_e.line, L ? _e.to - 1 : _e.from);
          }
          var Ue = fe.length != D, Me = fe[0], Re = fe.pop();
          return L && !j ? (!Ue && (Me.from != ae.ch || Me.line != ae.line) && (Re = fe.pop()), new u(Re.line, Re.from)) : L && j ? new u(Re.line, Re.to - 1) : !L && j ? (!Ue && (Me.to != ae.ch || Me.line != ae.line) && (Re = fe.pop()), new u(Re.line, Re.to)) : new u(Re.line, Re.from);
        }
        function Mn(x, $, D, L, j) {
          var U = $, ae = new u(U.line + D.repeat - 1, 1 / 0), fe = x.clipPos(ae);
          return fe.ch--, j || (L.lastHPos = 1 / 0, L.lastHSPos = x.charCoords(fe, "div").left), ae;
        }
        function tr(x, $, D, L) {
          for (var j = x.getCursor(), U = j.ch, ae, fe = 0; fe < $; fe++) {
            var se = x.getLine(j.line);
            if (ae = wr(U, se, L, D), ae == -1)
              return null;
            U = ae;
          }
          return new u(x.getCursor().line, ae);
        }
        function On(x, $) {
          var D = x.getCursor().line;
          return He(x, new u(D, $ - 1));
        }
        function sn(x, $, D, L) {
          Be(D, K) && ($.marks[D] && $.marks[D].clear(), $.marks[D] = x.setBookmark(L));
        }
        function wr(x, $, D, L, j) {
          var U;
          return L ? U = $.indexOf(D, x + 1) : U = $.lastIndexOf(D, x - 1), U;
        }
        function Rt(x, $, D, L, j) {
          var U = $.line, ae = x.firstLine(), fe = x.lastLine(), se, we, _e = U;
          function Le(Xe) {
            return !x.getLine(Xe);
          }
          function Ue(Xe, pt, vt) {
            return vt ? Le(Xe) != Le(Xe + pt) : !Le(Xe) && Le(Xe + pt);
          }
          if (L) {
            for (; ae <= _e && _e <= fe && D > 0; )
              Ue(_e, L) && D--, _e += L;
            return new u(_e, 0);
          }
          var Me = x.state.vim;
          if (Me.visualLine && Ue(U, 1, !0)) {
            var Re = Me.sel.anchor;
            Ue(Re.line, -1, !0) && (!j || Re.line != U) && (U += 1);
          }
          var at = Le(U);
          for (_e = U; _e <= fe && D; _e++)
            Ue(_e, 1, !0) && (!j || Le(_e) != at) && D--;
          for (we = new u(_e, 0), _e > fe && !at ? at = !0 : j = !1, _e = U; _e > ae && !((!j || Le(_e) == at || _e == U) && Ue(_e, -1, !0)); _e--)
            ;
          return se = new u(_e, 0), { start: se, end: we };
        }
        function ut(x, $, D, L, j) {
          function U(we) {
            we.pos + we.dir < 0 || we.pos + we.dir >= we.line.length ? we.line = null : we.pos += we.dir;
          }
          function ae(we, _e, Le, Ue) {
            var Me = we.getLine(_e), Re = {
              line: Me,
              ln: _e,
              pos: Le,
              dir: Ue
            };
            if (Re.line === "")
              return { ln: Re.ln, pos: Re.pos };
            var at = Re.pos;
            for (U(Re); Re.line !== null; ) {
              if (at = Re.pos, ue(Re.line[Re.pos]))
                if (j) {
                  for (U(Re); Re.line !== null && X(Re.line[Re.pos]); )
                    at = Re.pos, U(Re);
                  return { ln: Re.ln, pos: at + 1 };
                } else
                  return { ln: Re.ln, pos: Re.pos + 1 };
              U(Re);
            }
            return { ln: Re.ln, pos: at + 1 };
          }
          function fe(we, _e, Le, Ue) {
            var Me = we.getLine(_e), Re = {
              line: Me,
              ln: _e,
              pos: Le,
              dir: Ue
            };
            if (Re.line === "")
              return { ln: Re.ln, pos: Re.pos };
            var at = Re.pos;
            for (U(Re); Re.line !== null; ) {
              if (!X(Re.line[Re.pos]) && !ue(Re.line[Re.pos]))
                at = Re.pos;
              else if (ue(Re.line[Re.pos]))
                return j ? X(Re.line[Re.pos + 1]) ? { ln: Re.ln, pos: Re.pos + 1 } : { ln: Re.ln, pos: at } : { ln: Re.ln, pos: at };
              U(Re);
            }
            return Re.line = Me, j && X(Re.line[Re.pos]) ? { ln: Re.ln, pos: Re.pos } : { ln: Re.ln, pos: at };
          }
          for (var se = {
            ln: $.line,
            pos: $.ch
          }; D > 0; )
            L < 0 ? se = fe(x, se.ln, se.pos, L) : se = ae(x, se.ln, se.pos, L), D--;
          return new u(se.ln, se.pos);
        }
        function Ln(x, $, D, L) {
          function j(se, we) {
            if (we.pos + we.dir < 0 || we.pos + we.dir >= we.line.length) {
              if (we.ln += we.dir, !re(se, we.ln)) {
                we.line = null, we.ln = null, we.pos = null;
                return;
              }
              we.line = se.getLine(we.ln), we.pos = we.dir > 0 ? 0 : we.line.length - 1;
            } else
              we.pos += we.dir;
          }
          function U(se, we, _e, Le) {
            var Xe = se.getLine(we), Ue = Xe === "", Me = {
              line: Xe,
              ln: we,
              pos: _e,
              dir: Le
            }, Re = {
              ln: Me.ln,
              pos: Me.pos
            }, at = Me.line === "";
            for (j(se, Me); Me.line !== null; ) {
              if (Re.ln = Me.ln, Re.pos = Me.pos, Me.line === "" && !at)
                return { ln: Me.ln, pos: Me.pos };
              if (Ue && Me.line !== "" && !X(Me.line[Me.pos]))
                return { ln: Me.ln, pos: Me.pos };
              ue(Me.line[Me.pos]) && !Ue && (Me.pos === Me.line.length - 1 || X(Me.line[Me.pos + 1])) && (Ue = !0), j(se, Me);
            }
            var Xe = se.getLine(Re.ln);
            Re.pos = 0;
            for (var pt = Xe.length - 1; pt >= 0; --pt)
              if (!X(Xe[pt])) {
                Re.pos = pt;
                break;
              }
            return Re;
          }
          function ae(se, we, _e, Le) {
            var at = se.getLine(we), Ue = {
              line: at,
              ln: we,
              pos: _e,
              dir: Le
            }, Me = {
              ln: Ue.ln,
              pos: null
            }, Re = Ue.line === "";
            for (j(se, Ue); Ue.line !== null; ) {
              if (Ue.line === "" && !Re)
                return Me.pos !== null ? Me : { ln: Ue.ln, pos: Ue.pos };
              if (ue(Ue.line[Ue.pos]) && Me.pos !== null && !(Ue.ln === Me.ln && Ue.pos + 1 === Me.pos))
                return Me;
              Ue.line !== "" && !X(Ue.line[Ue.pos]) && (Re = !1, Me = { ln: Ue.ln, pos: Ue.pos }), j(se, Ue);
            }
            var at = se.getLine(Me.ln);
            Me.pos = 0;
            for (var Xe = 0; Xe < at.length; ++Xe)
              if (!X(at[Xe])) {
                Me.pos = Xe;
                break;
              }
            return Me;
          }
          for (var fe = {
            ln: $.line,
            pos: $.ch
          }; D > 0; )
            L < 0 ? fe = ae(x, fe.ln, fe.pos, L) : fe = U(x, fe.ln, fe.pos, L), D--;
          return new u(fe.ln, fe.pos);
        }
        function nr(x, $, D, L) {
          var j = $, U, ae, fe = {
            "(": /[()]/,
            ")": /[()]/,
            "[": /[[\]]/,
            "]": /[[\]]/,
            "{": /[{}]/,
            "}": /[{}]/,
            "<": /[<>]/,
            ">": /[<>]/
          }[D], se = {
            "(": "(",
            ")": "(",
            "[": "[",
            "]": "[",
            "{": "{",
            "}": "{",
            "<": "<",
            ">": "<"
          }[D], we = x.getLine(j.line).charAt(j.ch), _e = we === se ? 1 : 0;
          if (U = x.scanForBracket(new u(j.line, j.ch + _e), -1, void 0, { bracketRegex: fe }), ae = x.scanForBracket(new u(j.line, j.ch + _e), 1, void 0, { bracketRegex: fe }), !U || !ae)
            return { start: j, end: j };
          if (U = U.pos, ae = ae.pos, U.line == ae.line && U.ch > ae.ch || U.line > ae.line) {
            var Le = U;
            U = ae, ae = Le;
          }
          return L ? ae.ch += 1 : U.ch += 1, { start: U, end: ae };
        }
        function Cn(x, $, D, L) {
          var j = Je($), U = x.getLine(j.line), ae = U.split(""), fe, se, we, _e, Le = ae.indexOf(D);
          if (j.ch < Le ? j.ch = Le : Le < j.ch && ae[j.ch] == D && (se = j.ch, --j.ch), ae[j.ch] == D && !se)
            fe = j.ch + 1;
          else
            for (we = j.ch; we > -1 && !fe; we--)
              ae[we] == D && (fe = we + 1);
          if (fe && !se)
            for (we = fe, _e = ae.length; we < _e && !se; we++)
              ae[we] == D && (se = we);
          return !fe || !se ? { start: j, end: j } : (L && (--fe, ++se), {
            start: new u(j.line, fe),
            end: new u(j.line, se)
          });
        }
        G("pcre", !0, "boolean");
        function _t() {
        }
        _t.prototype = {
          getQuery: function() {
            return be.query;
          },
          setQuery: function(x) {
            be.query = x;
          },
          getOverlay: function() {
            return this.searchOverlay;
          },
          setOverlay: function(x) {
            this.searchOverlay = x;
          },
          isReversed: function() {
            return be.isReversed;
          },
          setReversed: function(x) {
            be.isReversed = x;
          },
          getScrollbarAnnotate: function() {
            return this.annotate;
          },
          setScrollbarAnnotate: function(x) {
            this.annotate = x;
          }
        };
        function jt(x) {
          var $ = x.state.vim;
          return $.searchState_ || ($.searchState_ = new _t());
        }
        function ee(x) {
          return xe(x, "/");
        }
        function ge(x) {
          return De(x, "/");
        }
        function xe(x, $) {
          var D = De(x, $) || [];
          if (!D.length) return [];
          var L = [];
          if (D[0] === 0) {
            for (var j = 0; j < D.length; j++)
              typeof D[j] == "number" && L.push(x.substring(D[j] + 1, D[j + 1]));
            return L;
          }
        }
        function De(x, $) {
          $ || ($ = "/");
          for (var D = !1, L = [], j = 0; j < x.length; j++) {
            var U = x.charAt(j);
            !D && U == $ && L.push(j), D = !D && U == "\\";
          }
          return L;
        }
        function ht(x) {
          for (var $ = "|(){", D = "}", L = !1, j = [], U = -1; U < x.length; U++) {
            var ae = x.charAt(U) || "", fe = x.charAt(U + 1) || "", se = fe && $.indexOf(fe) != -1;
            L ? ((ae !== "\\" || !se) && j.push(ae), L = !1) : ae === "\\" ? (L = !0, fe && D.indexOf(fe) != -1 && (se = !0), (!se || fe === "\\") && j.push(ae)) : (j.push(ae), se && fe !== "\\" && j.push("\\"));
          }
          return j.join("");
        }
        var xt = { "\\n": `
`, "\\r": "\r", "\\t": "	" };
        function St(x) {
          for (var $ = !1, D = [], L = -1; L < x.length; L++) {
            var j = x.charAt(L) || "", U = x.charAt(L + 1) || "";
            xt[j + U] ? (D.push(xt[j + U]), L++) : $ ? (D.push(j), $ = !1) : j === "\\" ? ($ = !0, Q(U) || U === "$" ? D.push("$") : U !== "/" && U !== "\\" && D.push("\\")) : (j === "$" && D.push("$"), D.push(j), U === "/" && D.push("\\"));
          }
          return D.join("");
        }
        var It = { "\\/": "/", "\\\\": "\\", "\\n": `
`, "\\r": "\r", "\\t": "	", "\\&": "&" };
        function vn(x) {
          for (var $ = new s.StringStream(x), D = []; !$.eol(); ) {
            for (; $.peek() && $.peek() != "\\"; )
              D.push($.next());
            var L = !1;
            for (var j in It)
              if ($.match(j, !0)) {
                L = !0, D.push(It[j]);
                break;
              }
            L || D.push($.next());
          }
          return D.join("");
        }
        function mt(x, $, D) {
          var L = be.registerController.getRegister("/");
          if (L.setText(x), x instanceof RegExp)
            return x;
          var j = ge(x), U, ae;
          if (!j.length)
            U = x;
          else {
            U = x.substring(0, j[0]);
            var fe = x.substring(j[0]);
            ae = fe.indexOf("i") != -1;
          }
          if (!U)
            return null;
          oe("pcre") || (U = ht(U)), D && ($ = /^[^A-Z]*$/.test(U));
          var se = new RegExp(
            U,
            $ || ae ? "im" : "m"
          );
          return se;
        }
        function qn(x) {
          typeof x == "string" && (x = document.createElement(x));
          for (var $, D = 1; D < arguments.length; D++)
            if ($ = arguments[D])
              if (typeof $ != "object" && ($ = document.createTextNode($)), $.nodeType) x.appendChild($);
              else for (var L in $)
                Object.prototype.hasOwnProperty.call($, L) && (L[0] === "$" ? x.style[L.slice(1)] = $[L] : x.setAttribute(L, $[L]));
          return x;
        }
        function Bt(x, $) {
          var D = qn("div", { $color: "red", $whiteSpace: "pre", class: "cm-vim-message" }, $);
          x.openNotification ? x.openNotification(D, { bottom: !0, duration: 5e3 }) : alert(D.innerText);
        }
        function Vr(x, $) {
          return qn(
            document.createDocumentFragment(),
            qn(
              "span",
              { $fontFamily: "monospace", $whiteSpace: "pre" },
              x,
              qn("input", {
                type: "text",
                autocorrect: "off",
                autocapitalize: "off",
                spellcheck: "false"
              })
            ),
            $ && qn("span", { $color: "#888" }, $)
          );
        }
        function yn(x, $) {
          var D = Vr($.prefix, $.desc);
          if (x.openDialog)
            x.openDialog(D, $.onClose, {
              onKeyDown: $.onKeyDown,
              onKeyUp: $.onKeyUp,
              bottom: !0,
              selectValueOnOpen: !1,
              value: $.value
            });
          else {
            var L = "";
            typeof $.prefix != "string" && $.prefix && (L += $.prefix.textContent), $.desc && (L += " " + $.desc), $.onClose(prompt(L, ""));
          }
        }
        function Ia(x, $) {
          if (x instanceof RegExp && $ instanceof RegExp) {
            for (var D = ["global", "multiline", "ignoreCase", "source"], L = 0; L < D.length; L++) {
              var j = D[L];
              if (x[j] !== $[j])
                return !1;
            }
            return !0;
          }
          return !1;
        }
        function rr(x, $, D, L) {
          if ($) {
            var j = jt(x), U = mt($, !!D, !!L);
            if (U)
              return la(x, U), Ia(U, j.getQuery()) || j.setQuery(U), U;
          }
        }
        function kr(x) {
          if (x.source.charAt(0) == "^")
            var $ = !0;
          return {
            token: function(D) {
              if ($ && !D.sol()) {
                D.skipToEnd();
                return;
              }
              var L = D.match(x, !1);
              if (L)
                return L[0].length == 0 ? (D.next(), "searching") : !D.sol() && (D.backUp(1), !x.exec(D.next() + L[0])) ? (D.next(), null) : (D.match(x), "searching");
              for (; !D.eol() && (D.next(), !D.match(x, !1)); )
                ;
            },
            query: x
          };
        }
        var ar = 0;
        function la(x, $) {
          clearTimeout(ar), ar = setTimeout(function() {
            if (x.state.vim) {
              var D = jt(x), L = D.getOverlay();
              (!L || $ != L.query) && (L && x.removeOverlay(L), L = kr($), x.addOverlay(L), x.showMatchesOnScrollbar && (D.getScrollbarAnnotate() && D.getScrollbarAnnotate().clear(), D.setScrollbarAnnotate(x.showMatchesOnScrollbar($))), D.setOverlay(L));
            }
          }, 50);
        }
        function Nr(x, $, D, L) {
          return L === void 0 && (L = 1), x.operation(function() {
            for (var j = x.getCursor(), U = x.getSearchCursor(D, j), ae = 0; ae < L; ae++) {
              var fe = U.find($);
              if (ae == 0 && fe && wt(U.from(), j)) {
                var se = $ ? U.from() : U.to();
                fe = U.find($), fe && !fe[0] && wt(U.from(), se) && x.getLine(se.line).length == se.ch && (fe = U.find($));
              }
              if (!fe && (U = x.getSearchCursor(
                D,
                $ ? new u(x.lastLine()) : new u(x.firstLine(), 0)
              ), !U.find($)))
                return;
            }
            return U.from();
          });
        }
        function Fa(x, $, D, L, j) {
          return L === void 0 && (L = 1), x.operation(function() {
            var U = x.getCursor(), ae = x.getSearchCursor(D, U), fe = ae.find(!$);
            !j.visualMode && fe && wt(ae.from(), U) && ae.find(!$);
            for (var se = 0; se < L; se++)
              if (fe = ae.find($), !fe && (ae = x.getSearchCursor(
                D,
                $ ? new u(x.lastLine()) : new u(x.firstLine(), 0)
              ), !ae.find($)))
                return;
            return [ae.from(), ae.to()];
          });
        }
        function Ir(x) {
          var $ = jt(x);
          x.removeOverlay(jt(x).getOverlay()), $.setOverlay(null), $.getScrollbarAnnotate() && ($.getScrollbarAnnotate().clear(), $.setScrollbarAnnotate(null));
        }
        function za(x, $, D) {
          return typeof x != "number" && (x = x.line), $ instanceof Array ? Be(x, $) : typeof D == "number" ? x >= $ && x <= D : x == $;
        }
        function Fr(x) {
          var $ = x.getScrollInfo(), D = 6, L = 10, j = x.coordsChar({ left: 0, top: D + $.top }, "local"), U = $.clientHeight - L + $.top, ae = x.coordsChar({ left: 0, top: U }, "local");
          return { top: j.line, bottom: ae.line };
        }
        function ja(x, $, D) {
          if (D == "'" || D == "`")
            return be.jumpList.find(x, -1) || new u(0, 0);
          if (D == ".")
            return qa(x);
          var L = $.marks[D];
          return L && L.find();
        }
        function qa(x) {
          for (var $ = x.doc.history.done, D = $.length; D--; )
            if ($[D].changes)
              return Je($[D].changes[0].to);
        }
        var ua = function() {
          this.buildCommandMap_();
        };
        ua.prototype = {
          processCommand: function(x, $, D) {
            var L = this;
            x.operation(function() {
              x.curOp.isVimOp = !0, L._processCommand(x, $, D);
            });
          },
          _processCommand: function(x, $, D) {
            var L = x.state.vim, j = be.registerController.getRegister(":"), U = j.toString();
            L.visualMode && un(x);
            var ae = new s.StringStream($);
            j.setText($);
            var fe = D || {};
            fe.input = $;
            try {
              this.parseInput_(x, ae, fe);
            } catch (Le) {
              throw Bt(x, Le.toString()), Le;
            }
            var se, we;
            if (!fe.commandName)
              fe.line !== void 0 && (we = "move");
            else if (se = this.matchCommand_(fe.commandName), se) {
              if (we = se.name, se.excludeFromCommandHistory && j.setText(U), this.parseCommandArgs_(ae, fe, se), se.type == "exToKey") {
                for (var _e = 0; _e < se.toKeys.length; _e++)
                  ze.handleKey(x, se.toKeys[_e], "mapping");
                return;
              } else if (se.type == "exToEx") {
                this.processCommand(x, se.toInput);
                return;
              }
            }
            if (!we) {
              Bt(x, 'Not an editor command ":' + $ + '"');
              return;
            }
            try {
              Pn[we](x, fe), (!se || !se.possiblyAsync) && fe.callback && fe.callback();
            } catch (Le) {
              throw Bt(x, Le.toString()), Le;
            }
          },
          parseInput_: function(x, $, D) {
            $.eatWhile(":"), $.eat("%") ? (D.line = x.firstLine(), D.lineEnd = x.lastLine()) : (D.line = this.parseLineSpec_(x, $), D.line !== void 0 && $.eat(",") && (D.lineEnd = this.parseLineSpec_(x, $)));
            var L = $.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
            return L ? D.commandName = L[1] : D.commandName = $.match(/.*/)[0], D;
          },
          parseLineSpec_: function(x, $) {
            var D = $.match(/^(\d+)/);
            if (D)
              return parseInt(D[1], 10) - 1;
            switch ($.next()) {
              case ".":
                return this.parseLineSpecOffset_($, x.getCursor().line);
              case "$":
                return this.parseLineSpecOffset_($, x.lastLine());
              case "'":
                var L = $.next(), j = ja(x, x.state.vim, L);
                if (!j) throw new Error("Mark not set");
                return this.parseLineSpecOffset_($, j.line);
              case "-":
              case "+":
                return $.backUp(1), this.parseLineSpecOffset_($, x.getCursor().line);
              default:
                $.backUp(1);
                return;
            }
          },
          parseLineSpecOffset_: function(x, $) {
            var D = x.match(/^([+-])?(\d+)/);
            if (D) {
              var L = parseInt(D[2], 10);
              D[1] == "-" ? $ -= L : $ += L;
            }
            return $;
          },
          parseCommandArgs_: function(x, $, D) {
            if (!x.eol()) {
              $.argString = x.match(/.*/)[0];
              var L = D.argDelimiter || /\s+/, j = Qn($.argString).split(L);
              j.length && j[0] && ($.args = j);
            }
          },
          matchCommand_: function(x) {
            for (var $ = x.length; $ > 0; $--) {
              var D = x.substring(0, $);
              if (this.commandMap_[D]) {
                var L = this.commandMap_[D];
                if (L.name.indexOf(x) === 0)
                  return L;
              }
            }
            return null;
          },
          buildCommandMap_: function() {
            this.commandMap_ = {};
            for (var x = 0; x < v.length; x++) {
              var $ = v[x], D = $.shortName || $.name;
              this.commandMap_[D] = $;
            }
          },
          map: function(x, $, D) {
            if (x != ":" && x.charAt(0) == ":") {
              if (D)
                throw Error("Mode not supported for ex mappings");
              var L = x.substring(1);
              $ != ":" && $.charAt(0) == ":" ? this.commandMap_[L] = {
                name: L,
                type: "exToEx",
                toInput: $.substring(1),
                user: !0
              } : this.commandMap_[L] = {
                name: L,
                type: "exToKey",
                toKeys: $,
                user: !0
              };
            } else if ($ != ":" && $.charAt(0) == ":") {
              var j = {
                keys: x,
                type: "keyToEx",
                exArgs: { input: $.substring(1) }
              };
              D && (j.context = D), f.unshift(j);
            } else {
              var j = {
                keys: x,
                type: "keyToKey",
                toKeys: $
              };
              D && (j.context = D), f.unshift(j);
            }
          },
          unmap: function(x, $) {
            if (x != ":" && x.charAt(0) == ":") {
              if ($)
                throw Error("Mode not supported for ex mappings");
              var D = x.substring(1);
              if (this.commandMap_[D] && this.commandMap_[D].user)
                return delete this.commandMap_[D], !0;
            } else
              for (var L = x, j = 0; j < f.length; j++)
                if (L == f[j].keys && f[j].context === $)
                  return f.splice(j, 1), !0;
          }
        };
        var Pn = {
          colorscheme: function(x, $) {
            if (!$.args || $.args.length < 1) {
              Bt(x, x.getOption("theme"));
              return;
            }
            x.setOption("theme", $.args[0]);
          },
          map: function(x, $, D) {
            var L = $.args;
            if (!L || L.length < 2) {
              x && Bt(x, "Invalid mapping: " + $.input);
              return;
            }
            Bn.map(L[0], L[1], D);
          },
          imap: function(x, $) {
            this.map(x, $, "insert");
          },
          nmap: function(x, $) {
            this.map(x, $, "normal");
          },
          vmap: function(x, $) {
            this.map(x, $, "visual");
          },
          unmap: function(x, $, D) {
            var L = $.args;
            (!L || L.length < 1 || !Bn.unmap(L[0], D)) && x && Bt(x, "No such mapping: " + $.input);
          },
          move: function(x, $) {
            je.processCommand(x, x.state.vim, {
              type: "motion",
              motion: "moveToLineOrEdgeOfDocument",
              motionArgs: {
                forward: !1,
                explicitRepeat: !0,
                linewise: !0
              },
              repeatOverride: $.line + 1
            });
          },
          set: function(x, $) {
            var D = $.args, L = $.setCfg || {};
            if (!D || D.length < 1) {
              x && Bt(x, "Invalid mapping: " + $.input);
              return;
            }
            var j = D[0].split("="), U = j[0], ae = j[1], fe = !1;
            if (U.charAt(U.length - 1) == "?") {
              if (ae)
                throw Error("Trailing characters: " + $.argString);
              U = U.substring(0, U.length - 1), fe = !0;
            }
            ae === void 0 && U.substring(0, 2) == "no" && (U = U.substring(2), ae = !1);
            var se = te[U] && te[U].type == "boolean";
            if (se && ae == null && (ae = !0), !se && ae === void 0 || fe) {
              var we = oe(U, x, L);
              we instanceof Error ? Bt(x, we.message) : we === !0 || we === !1 ? Bt(x, " " + (we ? "" : "no") + U) : Bt(x, "  " + U + "=" + we);
            } else {
              var _e = ie(U, ae, x, L);
              _e instanceof Error && Bt(x, _e.message);
            }
          },
          setlocal: function(x, $) {
            $.setCfg = { scope: "local" }, this.set(x, $);
          },
          setglobal: function(x, $) {
            $.setCfg = { scope: "global" }, this.set(x, $);
          },
          registers: function(x, $) {
            var D = $.args, L = be.registerController.registers, j = `----------Registers----------

`;
            if (D) {
              var U;
              D = D.join("");
              for (var fe = 0; fe < D.length; fe++)
                if (U = D.charAt(fe), !!be.registerController.isValidRegister(U)) {
                  var se = L[U] || new Qe();
                  j += '"' + U + "    " + se.toString() + `
`;
                }
            } else
              for (var U in L) {
                var ae = L[U].toString();
                ae.length && (j += '"' + U + "    " + ae + `
`);
              }
            Bt(x, j);
          },
          sort: function(x, $) {
            var D, L, j, U, ae;
            function fe() {
              if ($.argString) {
                var Et = new s.StringStream($.argString);
                if (Et.eat("!") && (D = !0), Et.eol())
                  return;
                if (!Et.eatSpace())
                  return "Invalid arguments";
                var kt = Et.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
                if (!kt && !Et.eol())
                  return "Invalid arguments";
                if (kt[1]) {
                  L = kt[1].indexOf("i") != -1, j = kt[1].indexOf("u") != -1;
                  var Kt = kt[1].indexOf("d") != -1 || kt[1].indexOf("n") != -1 && 1, Zt = kt[1].indexOf("x") != -1 && 1, Vt = kt[1].indexOf("o") != -1 && 1;
                  if (Kt + Zt + Vt > 1)
                    return "Invalid arguments";
                  U = Kt && "decimal" || Zt && "hex" || Vt && "octal";
                }
                kt[2] && (ae = new RegExp(kt[2].substr(1, kt[2].length - 2), L ? "i" : ""));
              }
            }
            var se = fe();
            if (se) {
              Bt(x, se + ": " + $.argString);
              return;
            }
            var we = $.line || x.firstLine(), _e = $.lineEnd || $.line || x.lastLine();
            if (we == _e)
              return;
            var Le = new u(we, 0), Ue = new u(_e, yt(x, _e)), Me = x.getRange(Le, Ue).split(`
`), Re = ae || (U == "decimal" ? /(-?)([\d]+)/ : U == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : U == "octal" ? /([0-7]+)/ : null), at = U == "decimal" ? 10 : U == "hex" ? 16 : U == "octal" ? 8 : null, Xe = [], pt = [];
            if (U || ae)
              for (var vt = 0; vt < Me.length; vt++) {
                var gt = ae ? Me[vt].match(ae) : null;
                gt && gt[0] != "" ? Xe.push(gt) : !ae && Re.exec(Me[vt]) ? Xe.push(Me[vt]) : pt.push(Me[vt]);
              }
            else
              pt = Me;
            function Ct(Et, kt) {
              if (D) {
                var Kt;
                Kt = Et, Et = kt, kt = Kt;
              }
              L && (Et = Et.toLowerCase(), kt = kt.toLowerCase());
              var Zt = U && Re.exec(Et), Vt = U && Re.exec(kt);
              return Zt ? (Zt = parseInt((Zt[1] + Zt[2]).toLowerCase(), at), Vt = parseInt((Vt[1] + Vt[2]).toLowerCase(), at), Zt - Vt) : Et < kt ? -1 : 1;
            }
            function Wt(Et, kt) {
              if (D) {
                var Kt;
                Kt = Et, Et = kt, kt = Kt;
              }
              return L && (Et[0] = Et[0].toLowerCase(), kt[0] = kt[0].toLowerCase()), Et[0] < kt[0] ? -1 : 1;
            }
            if (Xe.sort(ae ? Wt : Ct), ae)
              for (var vt = 0; vt < Xe.length; vt++)
                Xe[vt] = Xe[vt].input;
            else U || pt.sort(Ct);
            if (Me = D ? Xe.concat(pt) : pt.concat(Xe), j) {
              var Lt = Me, Xt;
              Me = [];
              for (var vt = 0; vt < Lt.length; vt++)
                Lt[vt] != Xt && Me.push(Lt[vt]), Xt = Lt[vt];
            }
            x.replaceRange(Me.join(`
`), Le, Ue);
          },
          vglobal: function(x, $) {
            this.global(x, $);
          },
          global: function(x, $) {
            var D = $.argString;
            if (!D) {
              Bt(x, "Regular Expression missing from global");
              return;
            }
            var L = $.commandName[0] === "v", j = $.line !== void 0 ? $.line : x.firstLine(), U = $.lineEnd || $.line || x.lastLine(), ae = ee(D), fe = D, se;
            if (ae.length && (fe = ae[0], se = ae.slice(1, ae.length).join("/")), fe)
              try {
                rr(
                  x,
                  fe,
                  !0,
                  !0
                  /** smartCase */
                );
              } catch {
                Bt(x, "Invalid regex: " + fe);
                return;
              }
            for (var we = jt(x).getQuery(), _e = [], Le = j; Le <= U; Le++) {
              var Ue = x.getLineHandle(Le), Me = we.test(Ue.text);
              Me !== L && _e.push(se ? Ue : Ue.text);
            }
            if (!se) {
              Bt(x, _e.join(`
`));
              return;
            }
            var Re = 0, at = function() {
              if (Re < _e.length) {
                var Xe = _e[Re++], pt = x.getLineNumber(Xe);
                if (pt == null) {
                  at();
                  return;
                }
                var vt = pt + 1 + se;
                Bn.processCommand(x, vt, {
                  callback: at
                });
              }
            };
            at();
          },
          substitute: function(x, $) {
            if (!x.getSearchCursor)
              throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
            var D = $.argString, L = D ? xe(D, D[0]) : [], j, U = "", ae, fe, se, we = !1, _e = !1;
            if (L.length)
              j = L[0], oe("pcre") && j !== "" && (j = new RegExp(j).source), U = L[1], U !== void 0 && (oe("pcre") ? U = vn(U.replace(/([^\\])&/g, "$1$$&")) : U = St(U), be.lastSubstituteReplacePart = U), ae = L[2] ? L[2].split(" ") : [];
            else if (D && D.length) {
              Bt(x, "Substitutions should be of the form :s/pattern/replace/");
              return;
            }
            if (ae && (fe = ae[0], se = parseInt(ae[1]), fe && (fe.indexOf("c") != -1 && (we = !0), fe.indexOf("g") != -1 && (_e = !0), oe("pcre") ? j = j + "/" + fe : j = j.replace(/\//g, "\\/") + "/" + fe)), j)
              try {
                rr(
                  x,
                  j,
                  !0,
                  !0
                  /** smartCase */
                );
              } catch {
                Bt(x, "Invalid regex: " + j);
                return;
              }
            if (U = U || be.lastSubstituteReplacePart, U === void 0) {
              Bt(x, "No previous substitute regular expression");
              return;
            }
            var Le = jt(x), Ue = Le.getQuery(), Me = $.line !== void 0 ? $.line : x.getCursor().line, Re = $.lineEnd || Me;
            Me == x.firstLine() && Re == x.lastLine() && (Re = 1 / 0), se && (Me = Re, Re = Me + se - 1);
            var at = He(x, new u(Me, 0)), Xe = x.getSearchCursor(Ue, at);
            mi(x, we, _e, Me, Re, Xe, Ue, U, $.callback);
          },
          redo: s.commands.redo,
          undo: s.commands.undo,
          write: function(x) {
            s.commands.save ? s.commands.save(x) : x.save && x.save();
          },
          nohlsearch: function(x) {
            Ir(x);
          },
          yank: function(x) {
            var $ = Je(x.getCursor()), D = $.line, L = x.getLine(D);
            be.registerController.pushText(
              "0",
              "yank",
              L,
              !0,
              !0
            );
          },
          delmarks: function(x, $) {
            if (!$.argString || !Qn($.argString)) {
              Bt(x, "Argument required");
              return;
            }
            for (var D = x.state.vim, L = new s.StringStream(Qn($.argString)); !L.eol(); ) {
              L.eatSpace();
              var j = L.pos;
              if (!L.match(/[a-zA-Z]/, !1)) {
                Bt(x, "Invalid argument: " + $.argString.substring(j));
                return;
              }
              var U = L.next();
              if (L.match("-", !0)) {
                if (!L.match(/[a-zA-Z]/, !1)) {
                  Bt(x, "Invalid argument: " + $.argString.substring(j));
                  return;
                }
                var ae = U, fe = L.next();
                if (V(ae) && V(fe) || z(ae) && z(fe)) {
                  var se = ae.charCodeAt(0), we = fe.charCodeAt(0);
                  if (se >= we) {
                    Bt(x, "Invalid argument: " + $.argString.substring(j));
                    return;
                  }
                  for (var _e = 0; _e <= we - se; _e++) {
                    var Le = String.fromCharCode(se + _e);
                    delete D.marks[Le];
                  }
                } else {
                  Bt(x, "Invalid argument: " + ae + "-");
                  return;
                }
              } else
                delete D.marks[U];
            }
          }
        }, Bn = new ua();
        function mi(x, $, D, L, j, U, ae, fe, se) {
          x.state.vim.exMode = !0;
          var we = !1, _e, Le, Ue;
          function Me() {
            x.operation(function() {
              for (; !we; )
                Re(), Xe();
              pt();
            });
          }
          function Re() {
            var gt = x.getRange(U.from(), U.to()), Ct = gt.replace(ae, fe), Wt = U.to().line;
            U.replace(Ct), Le = U.to().line, j += Le - Wt, Ue = Le < Wt;
          }
          function at() {
            var gt = _e && Je(U.to()), Ct = U.findNext();
            return Ct && !Ct[0] && gt && wt(U.from(), gt) && (Ct = U.findNext()), Ct;
          }
          function Xe() {
            for (; at() && za(U.from(), L, j); )
              if (!(!D && U.from().line == Le && !Ue)) {
                x.scrollIntoView(U.from(), 30), x.setSelection(U.from(), U.to()), _e = U.from(), we = !1;
                return;
              }
            we = !0;
          }
          function pt(gt) {
            if (gt && gt(), x.focus(), _e) {
              x.setCursor(_e);
              var Ct = x.state.vim;
              Ct.exMode = !1, Ct.lastHPos = Ct.lastHSPos = _e.ch;
            }
            se && se();
          }
          function vt(gt, Ct, Wt) {
            s.e_stop(gt);
            var Lt = s.keyName(gt);
            switch (Lt) {
              case "Y":
                Re(), Xe();
                break;
              case "N":
                Xe();
                break;
              case "A":
                var Xt = se;
                se = void 0, x.operation(Me), se = Xt;
                break;
              case "L":
                Re();
              // fall through and exit.
              case "Q":
              case "Esc":
              case "Ctrl-C":
              case "Ctrl-[":
                pt(Wt);
                break;
            }
            return we && pt(Wt), !0;
          }
          if (Xe(), we) {
            Bt(x, "No matches for " + ae.source);
            return;
          }
          if (!$) {
            Me(), se && se();
            return;
          }
          yn(x, {
            prefix: qn("span", "replace with ", qn("strong", fe), " (y/n/a/q/l)"),
            onKeyDown: vt
          });
        }
        s.keyMap.vim = {
          attach: k,
          detach: C,
          call: E
        };
        function Hn(x) {
          var $ = x.state.vim, D = be.macroModeState, L = be.registerController.getRegister("."), j = D.isPlaying, U = D.lastInsertModeChanges;
          j || (x.off("change", da), s.off(x.getInputField(), "keydown", _r)), !j && $.insertModeRepeat > 1 && (Sr(
            x,
            $,
            $.insertModeRepeat - 1,
            !0
            /** repeatForInsert */
          ), $.lastEditInputState.repeatOverride = $.insertModeRepeat), delete $.insertModeRepeat, $.insertMode = !1, x.setCursor(x.getCursor().line, x.getCursor().ch - 1), x.setOption("keyMap", "vim"), x.setOption("disableInput", !0), x.toggleOverwrite(!1), L.setText(U.changes.join("")), s.signal(x, "vim-mode-change", { mode: "normal" }), D.isRecording && bi(D);
        }
        function ir(x) {
          f.unshift(x);
        }
        function gi(x, $, D, L, j) {
          var U = { keys: x, type: $ };
          U[$] = D, U[$ + "Args"] = L;
          for (var ae in j)
            U[ae] = j[ae];
          ir(U);
        }
        G("insertModeEscKeysTimeout", 200, "number"), s.keyMap["vim-insert"] = {
          // TODO: override navigation keys so that Esc will cancel automatic
          // indentation from o, O, i_<CR>
          fallthrough: ["default"],
          attach: k,
          detach: C,
          call: E
        }, s.keyMap["vim-replace"] = {
          Backspace: "goCharLeft",
          fallthrough: ["vim-insert"],
          attach: k,
          detach: C,
          call: E
        };
        function vi(x, $, D, L) {
          var j = be.registerController.getRegister(L);
          if (L == ":") {
            j.keyBuffer[0] && Bn.processCommand(x, j.keyBuffer[0]), D.isPlaying = !1;
            return;
          }
          var U = j.keyBuffer, ae = 0;
          D.isPlaying = !0, D.replaySearchQueries = j.searchQueries.slice(0);
          for (var fe = 0; fe < U.length; fe++)
            for (var se = U[fe], we, _e; se; )
              if (we = /<\w+-.+?>|<\w+>|./.exec(se), _e = we[0], se = se.substring(we.index + _e.length), ze.handleKey(x, _e, "macro"), $.insertMode) {
                var Le = j.insertModeChanges[ae++].changes;
                be.macroModeState.lastInsertModeChanges.changes = Le, jr(x, Le, 1), Hn(x);
              }
          D.isPlaying = !1;
        }
        function yi(x, $) {
          if (!x.isPlaying) {
            var D = x.latestRegister, L = be.registerController.getRegister(D);
            L && L.pushText($);
          }
        }
        function bi(x) {
          if (!x.isPlaying) {
            var $ = x.latestRegister, D = be.registerController.getRegister($);
            D && D.pushInsertModeChanges && D.pushInsertModeChanges(x.lastInsertModeChanges);
          }
        }
        function ca(x, $) {
          if (!x.isPlaying) {
            var D = x.latestRegister, L = be.registerController.getRegister(D);
            L && L.pushSearchQuery && L.pushSearchQuery($);
          }
        }
        function da(x, $) {
          var D = be.macroModeState, L = D.lastInsertModeChanges;
          if (!D.isPlaying)
            for (; $; ) {
              if (L.expectCursorActivityForChange = !0, L.ignoreCount > 1)
                L.ignoreCount--;
              else if ($.origin == "+input" || $.origin == "paste" || $.origin === void 0) {
                var j = x.listSelections().length;
                j > 1 && (L.ignoreCount = j);
                var U = $.text.join(`
`);
                L.maybeReset && (L.changes = [], L.maybeReset = !1), U && (x.state.overwrite && !/\n/.test(U) ? L.changes.push([U]) : L.changes.push(U));
              }
              $ = $.next;
            }
        }
        function Ha(x) {
          var $ = x.state.vim;
          if ($.insertMode) {
            var D = be.macroModeState;
            if (D.isPlaying)
              return;
            var L = D.lastInsertModeChanges;
            L.expectCursorActivityForChange ? L.expectCursorActivityForChange = !1 : L.maybeReset = !0;
          } else x.curOp.isVimOp || fa(x, $);
        }
        function fa(x, $) {
          var D = x.getCursor("anchor"), L = x.getCursor("head");
          if ($.visualMode && !x.somethingSelected() ? un(x, !1) : !$.visualMode && !$.insertMode && x.somethingSelected() && ($.visualMode = !0, $.visualLine = !1, s.signal(x, "vim-mode-change", { mode: "visual" })), $.visualMode) {
            var j = qe(L, D) ? 0 : -1, U = qe(L, D) ? -1 : 0;
            L = de(L, 0, j), D = de(D, 0, U), $.sel = {
              anchor: D,
              head: L
            }, sn(x, $, "<", $t(L, D)), sn(x, $, ">", Mt(L, D));
          } else $.insertMode || ($.lastHPos = x.getCursor().ch);
        }
        function zr(x) {
          this.keyName = x;
        }
        function _r(x) {
          var $ = be.macroModeState, D = $.lastInsertModeChanges, L = s.keyName(x);
          if (!L)
            return;
          function j() {
            return D.maybeReset && (D.changes = [], D.maybeReset = !1), D.changes.push(new zr(L)), !0;
          }
          (L.indexOf("Delete") != -1 || L.indexOf("Backspace") != -1) && s.lookupKey(L, "vim-insert", j);
        }
        function Sr(x, $, D, L) {
          var j = be.macroModeState;
          j.isPlaying = !0;
          var U = !!$.lastEditActionCommand, ae = $.inputState;
          function fe() {
            U ? je.processAction(x, $, $.lastEditActionCommand) : je.evalInput(x, $);
          }
          function se(_e) {
            if (j.lastInsertModeChanges.changes.length > 0) {
              _e = $.lastEditActionCommand ? _e : 1;
              var Le = j.lastInsertModeChanges;
              jr(x, Le.changes, _e);
            }
          }
          if ($.inputState = $.lastEditInputState, U && $.lastEditActionCommand.interlaceInsertRepeat)
            for (var we = 0; we < D; we++)
              fe(), se(1);
          else
            L || fe(), se(D);
          $.inputState = ae, $.insertMode && !L && Hn(x), j.isPlaying = !1;
        }
        function jr(x, $, D) {
          function L(Le) {
            return typeof Le == "string" ? s.commands[Le](x) : Le(x), !0;
          }
          var j = x.getCursor("head"), U = be.macroModeState.lastInsertModeChanges.visualBlock;
          U && (Fn(x, j, U + 1), D = x.listSelections().length, x.setCursor(j));
          for (var ae = 0; ae < D; ae++) {
            U && x.setCursor(de(j, ae, 0));
            for (var fe = 0; fe < $.length; fe++) {
              var se = $[fe];
              if (se instanceof zr)
                s.lookupKey(se.keyName, "vim-insert", L);
              else if (typeof se == "string")
                x.replaceSelection(se);
              else {
                var we = x.getCursor(), _e = de(we, 0, se[0].length);
                x.replaceRange(se[0], we, _e), x.setCursor(_e);
              }
            }
          }
          U && x.setCursor(de(j, 0, 1));
        }
        function qr(x) {
          var $ = new x.constructor();
          return Object.keys(x).forEach(function(D) {
            var L = x[D];
            Array.isArray(L) ? L = L.slice() : L && typeof L == "object" && L.constructor != Object && (L = qr(L)), $[D] = L;
          }), x.sel && ($.sel = {
            head: x.sel.head && Je(x.sel.head),
            anchor: x.sel.anchor && Je(x.sel.anchor)
          }), $;
        }
        function Ua(x, $, D) {
          var L = !1, j = ze.maybeInitVimState_(x), U = j.visualBlock || j.wasInVisualBlock, ae = x.isInMultiSelectMode();
          if (j.wasInVisualBlock && !ae ? j.wasInVisualBlock = !1 : ae && j.visualBlock && (j.wasInVisualBlock = !0), $ == "<Esc>" && !j.insertMode && !j.visualMode && ae && j.status == "<Esc>")
            tt(x);
          else if (U || !ae || x.inVirtualSelectionMode)
            L = ze.handleKey(x, $, D);
          else {
            var fe = qr(j);
            x.operation(function() {
              x.curOp.isVimOp = !0, x.forEachSelection(function() {
                var se = x.getCursor("head"), we = x.getCursor("anchor"), _e = qe(se, we) ? 0 : -1, Le = qe(se, we) ? -1 : 0;
                se = de(se, 0, _e), we = de(we, 0, Le), x.state.vim.sel.head = se, x.state.vim.sel.anchor = we, L = ze.handleKey(x, $, D), x.virtualSelection && (x.state.vim = qr(fe));
              }), x.curOp.cursorActivity && !L && (x.curOp.cursorActivity = !1), x.state.vim = j;
            }, !0);
          }
          return L && !j.visualMode && !j.insert && j.visualMode != x.somethingSelected() && fa(x, j), L;
        }
        return Ie(), ze;
      }
      function o(s) {
        return s.Vim = a(s), s.Vim;
      }
      n.Vim = o(n);
    });
  })()), vim.exports;
}
requireVim();
var css = { exports: {} }, hasRequiredCss;
function requireCss() {
  return hasRequiredCss || (hasRequiredCss = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("css", function(W, K) {
        var Z = K.inline;
        K.propertyKeywords || (K = n.resolveMode("text/css"));
        var J = W.indentUnit, re = K.tokenHooks, V = K.documentTypes || {}, ne = K.mediaTypes || {}, Q = K.mediaFeatures || {}, z = K.mediaValueKeywords || {}, X = K.propertyKeywords || {}, ue = K.nonStandardPropertyKeywords || {}, Be = K.fontProperties || {}, te = K.counterDescriptors || {}, G = K.colorKeywords || {}, ie = K.valueKeywords || {}, oe = K.allowNested, ye = K.lineComment, ve = K.supportsAtComponent === !0, ke = W.highlightNonStandardPropertyKeywords !== !1, Ae, be;
        function Ie(Ce, Oe) {
          return Ae = Oe, Ce;
        }
        function Se(Ce, Oe) {
          var Te = Ce.next();
          if (re[Te]) {
            var ot = re[Te](Ce, Oe);
            if (ot !== !1) return ot;
          }
          if (Te == "@")
            return Ce.eatWhile(/[\w\\\-]/), Ie("def", Ce.current());
          if (Te == "=" || (Te == "~" || Te == "|") && Ce.eat("="))
            return Ie(null, "compare");
          if (Te == '"' || Te == "'")
            return Oe.tokenize = ze(Te), Oe.tokenize(Ce, Oe);
          if (Te == "#")
            return Ce.eatWhile(/[\w\\\-]/), Ie("atom", "hash");
          if (Te == "!")
            return Ce.match(/^\s*\w*/), Ie("keyword", "important");
          if (/\d/.test(Te) || Te == "." && Ce.eat(/\d/))
            return Ce.eatWhile(/[\w.%]/), Ie("number", "unit");
          if (Te === "-") {
            if (/[\d.]/.test(Ce.peek()))
              return Ce.eatWhile(/[\w.%]/), Ie("number", "unit");
            if (Ce.match(/^-[\w\\\-]*/))
              return Ce.eatWhile(/[\w\\\-]/), Ce.match(/^\s*:/, !1) ? Ie("variable-2", "variable-definition") : Ie("variable-2", "variable");
            if (Ce.match(/^\w+-/))
              return Ie("meta", "meta");
          } else return /[,+>*\/]/.test(Te) ? Ie(null, "select-op") : Te == "." && Ce.match(/^-?[_a-z][_a-z0-9-]*/i) ? Ie("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(Te) ? Ie(null, Te) : Ce.match(/^[\w-.]+(?=\()/) ? (/^(url(-prefix)?|domain|regexp)$/i.test(Ce.current()) && (Oe.tokenize = Ne), Ie("variable callee", "variable")) : /[\w\\\-]/.test(Te) ? (Ce.eatWhile(/[\w\\\-]/), Ie("property", "word")) : Ie(null, null);
        }
        function ze(Ce) {
          return function(Oe, Te) {
            for (var ot = !1, We; (We = Oe.next()) != null; ) {
              if (We == Ce && !ot) {
                Ce == ")" && Oe.backUp(1);
                break;
              }
              ot = !ot && We == "\\";
            }
            return (We == Ce || !ot && Ce != ")") && (Te.tokenize = null), Ie("string", "string");
          };
        }
        function Ne(Ce, Oe) {
          return Ce.next(), Ce.match(/^\s*[\"\')]/, !1) ? Oe.tokenize = null : Oe.tokenize = ze(")"), Ie(null, "(");
        }
        function tt(Ce, Oe, Te) {
          this.type = Ce, this.indent = Oe, this.prev = Te;
        }
        function Qe(Ce, Oe, Te, ot) {
          return Ce.context = new tt(Te, Oe.indentation() + (ot === !1 ? 0 : J), Ce.context), Te;
        }
        function et(Ce) {
          return Ce.context.prev && (Ce.context = Ce.context.prev), Ce.context.type;
        }
        function ce(Ce, Oe, Te) {
          return lt[Te.context.type](Ce, Oe, Te);
        }
        function pe(Ce, Oe, Te, ot) {
          for (var We = ot || 1; We > 0; We--)
            Te.context = Te.context.prev;
          return ce(Ce, Oe, Te);
        }
        function je(Ce) {
          var Oe = Ce.current().toLowerCase();
          ie.hasOwnProperty(Oe) ? be = "atom" : G.hasOwnProperty(Oe) ? be = "keyword" : be = "variable";
        }
        var lt = {};
        return lt.top = function(Ce, Oe, Te) {
          if (Ce == "{")
            return Qe(Te, Oe, "block");
          if (Ce == "}" && Te.context.prev)
            return et(Te);
          if (ve && /@component/i.test(Ce))
            return Qe(Te, Oe, "atComponentBlock");
          if (/^@(-moz-)?document$/i.test(Ce))
            return Qe(Te, Oe, "documentTypes");
          if (/^@(media|supports|(-moz-)?document|import)$/i.test(Ce))
            return Qe(Te, Oe, "atBlock");
          if (/^@(font-face|counter-style)/i.test(Ce))
            return Te.stateArg = Ce, "restricted_atBlock_before";
          if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(Ce))
            return "keyframes";
          if (Ce && Ce.charAt(0) == "@")
            return Qe(Te, Oe, "at");
          if (Ce == "hash")
            be = "builtin";
          else if (Ce == "word")
            be = "tag";
          else {
            if (Ce == "variable-definition")
              return "maybeprop";
            if (Ce == "interpolation")
              return Qe(Te, Oe, "interpolation");
            if (Ce == ":")
              return "pseudo";
            if (oe && Ce == "(")
              return Qe(Te, Oe, "parens");
          }
          return Te.context.type;
        }, lt.block = function(Ce, Oe, Te) {
          if (Ce == "word") {
            var ot = Oe.current().toLowerCase();
            return X.hasOwnProperty(ot) ? (be = "property", "maybeprop") : ue.hasOwnProperty(ot) ? (be = ke ? "string-2" : "property", "maybeprop") : oe ? (be = Oe.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag", "block") : (be += " error", "maybeprop");
          } else return Ce == "meta" ? "block" : !oe && (Ce == "hash" || Ce == "qualifier") ? (be = "error", "block") : lt.top(Ce, Oe, Te);
        }, lt.maybeprop = function(Ce, Oe, Te) {
          return Ce == ":" ? Qe(Te, Oe, "prop") : ce(Ce, Oe, Te);
        }, lt.prop = function(Ce, Oe, Te) {
          if (Ce == ";") return et(Te);
          if (Ce == "{" && oe) return Qe(Te, Oe, "propBlock");
          if (Ce == "}" || Ce == "{") return pe(Ce, Oe, Te);
          if (Ce == "(") return Qe(Te, Oe, "parens");
          if (Ce == "hash" && !/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(Oe.current()))
            be += " error";
          else if (Ce == "word")
            je(Oe);
          else if (Ce == "interpolation")
            return Qe(Te, Oe, "interpolation");
          return "prop";
        }, lt.propBlock = function(Ce, Oe, Te) {
          return Ce == "}" ? et(Te) : Ce == "word" ? (be = "property", "maybeprop") : Te.context.type;
        }, lt.parens = function(Ce, Oe, Te) {
          return Ce == "{" || Ce == "}" ? pe(Ce, Oe, Te) : Ce == ")" ? et(Te) : Ce == "(" ? Qe(Te, Oe, "parens") : Ce == "interpolation" ? Qe(Te, Oe, "interpolation") : (Ce == "word" && je(Oe), "parens");
        }, lt.pseudo = function(Ce, Oe, Te) {
          return Ce == "meta" ? "pseudo" : Ce == "word" ? (be = "variable-3", Te.context.type) : ce(Ce, Oe, Te);
        }, lt.documentTypes = function(Ce, Oe, Te) {
          return Ce == "word" && V.hasOwnProperty(Oe.current()) ? (be = "tag", Te.context.type) : lt.atBlock(Ce, Oe, Te);
        }, lt.atBlock = function(Ce, Oe, Te) {
          if (Ce == "(") return Qe(Te, Oe, "atBlock_parens");
          if (Ce == "}" || Ce == ";") return pe(Ce, Oe, Te);
          if (Ce == "{") return et(Te) && Qe(Te, Oe, oe ? "block" : "top");
          if (Ce == "interpolation") return Qe(Te, Oe, "interpolation");
          if (Ce == "word") {
            var ot = Oe.current().toLowerCase();
            ot == "only" || ot == "not" || ot == "and" || ot == "or" ? be = "keyword" : ne.hasOwnProperty(ot) ? be = "attribute" : Q.hasOwnProperty(ot) ? be = "property" : z.hasOwnProperty(ot) ? be = "keyword" : X.hasOwnProperty(ot) ? be = "property" : ue.hasOwnProperty(ot) ? be = ke ? "string-2" : "property" : ie.hasOwnProperty(ot) ? be = "atom" : G.hasOwnProperty(ot) ? be = "keyword" : be = "error";
          }
          return Te.context.type;
        }, lt.atComponentBlock = function(Ce, Oe, Te) {
          return Ce == "}" ? pe(Ce, Oe, Te) : Ce == "{" ? et(Te) && Qe(Te, Oe, oe ? "block" : "top", !1) : (Ce == "word" && (be = "error"), Te.context.type);
        }, lt.atBlock_parens = function(Ce, Oe, Te) {
          return Ce == ")" ? et(Te) : Ce == "{" || Ce == "}" ? pe(Ce, Oe, Te, 2) : lt.atBlock(Ce, Oe, Te);
        }, lt.restricted_atBlock_before = function(Ce, Oe, Te) {
          return Ce == "{" ? Qe(Te, Oe, "restricted_atBlock") : Ce == "word" && Te.stateArg == "@counter-style" ? (be = "variable", "restricted_atBlock_before") : ce(Ce, Oe, Te);
        }, lt.restricted_atBlock = function(Ce, Oe, Te) {
          return Ce == "}" ? (Te.stateArg = null, et(Te)) : Ce == "word" ? (Te.stateArg == "@font-face" && !Be.hasOwnProperty(Oe.current().toLowerCase()) || Te.stateArg == "@counter-style" && !te.hasOwnProperty(Oe.current().toLowerCase()) ? be = "error" : be = "property", "maybeprop") : "restricted_atBlock";
        }, lt.keyframes = function(Ce, Oe, Te) {
          return Ce == "word" ? (be = "variable", "keyframes") : Ce == "{" ? Qe(Te, Oe, "top") : ce(Ce, Oe, Te);
        }, lt.at = function(Ce, Oe, Te) {
          return Ce == ";" ? et(Te) : Ce == "{" || Ce == "}" ? pe(Ce, Oe, Te) : (Ce == "word" ? be = "tag" : Ce == "hash" && (be = "builtin"), "at");
        }, lt.interpolation = function(Ce, Oe, Te) {
          return Ce == "}" ? et(Te) : Ce == "{" || Ce == ";" ? pe(Ce, Oe, Te) : (Ce == "word" ? be = "variable" : Ce != "variable" && Ce != "(" && Ce != ")" && (be = "error"), "interpolation");
        }, {
          startState: function(Ce) {
            return {
              tokenize: null,
              state: Z ? "block" : "top",
              stateArg: null,
              context: new tt(Z ? "block" : "top", Ce || 0, null)
            };
          },
          token: function(Ce, Oe) {
            if (!Oe.tokenize && Ce.eatSpace()) return null;
            var Te = (Oe.tokenize || Se)(Ce, Oe);
            return Te && typeof Te == "object" && (Ae = Te[1], Te = Te[0]), be = Te, Ae != "comment" && (Oe.state = lt[Oe.state](Ae, Ce, Oe)), be;
          },
          indent: function(Ce, Oe) {
            var Te = Ce.context, ot = Oe && Oe.charAt(0), We = Te.indent;
            return Te.type == "prop" && (ot == "}" || ot == ")") && (Te = Te.prev), Te.prev && (ot == "}" && (Te.type == "block" || Te.type == "top" || Te.type == "interpolation" || Te.type == "restricted_atBlock") ? (Te = Te.prev, We = Te.indent) : (ot == ")" && (Te.type == "parens" || Te.type == "atBlock_parens") || ot == "{" && (Te.type == "at" || Te.type == "atBlock")) && (We = Math.max(0, Te.indent - J))), We;
          },
          electricChars: "}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          blockCommentContinue: " * ",
          lineComment: ye,
          fold: "brace"
        };
      });
      function a(W) {
        for (var K = {}, Z = 0; Z < W.length; ++Z)
          K[W[Z].toLowerCase()] = !0;
        return K;
      }
      var o = [
        "domain",
        "regexp",
        "url",
        "url-prefix"
      ], s = a(o), u = [
        "all",
        "aural",
        "braille",
        "handheld",
        "print",
        "projection",
        "screen",
        "tty",
        "tv",
        "embossed"
      ], d = a(u), f = [
        "width",
        "min-width",
        "max-width",
        "height",
        "min-height",
        "max-height",
        "device-width",
        "min-device-width",
        "max-device-width",
        "device-height",
        "min-device-height",
        "max-device-height",
        "aspect-ratio",
        "min-aspect-ratio",
        "max-aspect-ratio",
        "device-aspect-ratio",
        "min-device-aspect-ratio",
        "max-device-aspect-ratio",
        "color",
        "min-color",
        "max-color",
        "color-index",
        "min-color-index",
        "max-color-index",
        "monochrome",
        "min-monochrome",
        "max-monochrome",
        "resolution",
        "min-resolution",
        "max-resolution",
        "scan",
        "grid",
        "orientation",
        "device-pixel-ratio",
        "min-device-pixel-ratio",
        "max-device-pixel-ratio",
        "pointer",
        "any-pointer",
        "hover",
        "any-hover",
        "prefers-color-scheme",
        "dynamic-range",
        "video-dynamic-range"
      ], g = a(f), v = [
        "landscape",
        "portrait",
        "none",
        "coarse",
        "fine",
        "on-demand",
        "hover",
        "interlace",
        "progressive",
        "dark",
        "light",
        "standard",
        "high"
      ], b = a(v), w = [
        "align-content",
        "align-items",
        "align-self",
        "alignment-adjust",
        "alignment-baseline",
        "all",
        "anchor-point",
        "animation",
        "animation-delay",
        "animation-direction",
        "animation-duration",
        "animation-fill-mode",
        "animation-iteration-count",
        "animation-name",
        "animation-play-state",
        "animation-timing-function",
        "appearance",
        "azimuth",
        "backdrop-filter",
        "backface-visibility",
        "background",
        "background-attachment",
        "background-blend-mode",
        "background-clip",
        "background-color",
        "background-image",
        "background-origin",
        "background-position",
        "background-position-x",
        "background-position-y",
        "background-repeat",
        "background-size",
        "baseline-shift",
        "binding",
        "bleed",
        "block-size",
        "bookmark-label",
        "bookmark-level",
        "bookmark-state",
        "bookmark-target",
        "border",
        "border-bottom",
        "border-bottom-color",
        "border-bottom-left-radius",
        "border-bottom-right-radius",
        "border-bottom-style",
        "border-bottom-width",
        "border-collapse",
        "border-color",
        "border-image",
        "border-image-outset",
        "border-image-repeat",
        "border-image-slice",
        "border-image-source",
        "border-image-width",
        "border-left",
        "border-left-color",
        "border-left-style",
        "border-left-width",
        "border-radius",
        "border-right",
        "border-right-color",
        "border-right-style",
        "border-right-width",
        "border-spacing",
        "border-style",
        "border-top",
        "border-top-color",
        "border-top-left-radius",
        "border-top-right-radius",
        "border-top-style",
        "border-top-width",
        "border-width",
        "bottom",
        "box-decoration-break",
        "box-shadow",
        "box-sizing",
        "break-after",
        "break-before",
        "break-inside",
        "caption-side",
        "caret-color",
        "clear",
        "clip",
        "color",
        "color-profile",
        "column-count",
        "column-fill",
        "column-gap",
        "column-rule",
        "column-rule-color",
        "column-rule-style",
        "column-rule-width",
        "column-span",
        "column-width",
        "columns",
        "contain",
        "content",
        "counter-increment",
        "counter-reset",
        "crop",
        "cue",
        "cue-after",
        "cue-before",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "drop-initial-after-adjust",
        "drop-initial-after-align",
        "drop-initial-before-adjust",
        "drop-initial-before-align",
        "drop-initial-size",
        "drop-initial-value",
        "elevation",
        "empty-cells",
        "fit",
        "fit-content",
        "fit-position",
        "flex",
        "flex-basis",
        "flex-direction",
        "flex-flow",
        "flex-grow",
        "flex-shrink",
        "flex-wrap",
        "float",
        "float-offset",
        "flow-from",
        "flow-into",
        "font",
        "font-family",
        "font-feature-settings",
        "font-kerning",
        "font-language-override",
        "font-optical-sizing",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-synthesis",
        "font-variant",
        "font-variant-alternates",
        "font-variant-caps",
        "font-variant-east-asian",
        "font-variant-ligatures",
        "font-variant-numeric",
        "font-variant-position",
        "font-variation-settings",
        "font-weight",
        "gap",
        "grid",
        "grid-area",
        "grid-auto-columns",
        "grid-auto-flow",
        "grid-auto-rows",
        "grid-column",
        "grid-column-end",
        "grid-column-gap",
        "grid-column-start",
        "grid-gap",
        "grid-row",
        "grid-row-end",
        "grid-row-gap",
        "grid-row-start",
        "grid-template",
        "grid-template-areas",
        "grid-template-columns",
        "grid-template-rows",
        "hanging-punctuation",
        "height",
        "hyphens",
        "icon",
        "image-orientation",
        "image-rendering",
        "image-resolution",
        "inline-box-align",
        "inset",
        "inset-block",
        "inset-block-end",
        "inset-block-start",
        "inset-inline",
        "inset-inline-end",
        "inset-inline-start",
        "isolation",
        "justify-content",
        "justify-items",
        "justify-self",
        "left",
        "letter-spacing",
        "line-break",
        "line-height",
        "line-height-step",
        "line-stacking",
        "line-stacking-ruby",
        "line-stacking-shift",
        "line-stacking-strategy",
        "list-style",
        "list-style-image",
        "list-style-position",
        "list-style-type",
        "margin",
        "margin-bottom",
        "margin-left",
        "margin-right",
        "margin-top",
        "marks",
        "marquee-direction",
        "marquee-loop",
        "marquee-play-count",
        "marquee-speed",
        "marquee-style",
        "mask-clip",
        "mask-composite",
        "mask-image",
        "mask-mode",
        "mask-origin",
        "mask-position",
        "mask-repeat",
        "mask-size",
        "mask-type",
        "max-block-size",
        "max-height",
        "max-inline-size",
        "max-width",
        "min-block-size",
        "min-height",
        "min-inline-size",
        "min-width",
        "mix-blend-mode",
        "move-to",
        "nav-down",
        "nav-index",
        "nav-left",
        "nav-right",
        "nav-up",
        "object-fit",
        "object-position",
        "offset",
        "offset-anchor",
        "offset-distance",
        "offset-path",
        "offset-position",
        "offset-rotate",
        "opacity",
        "order",
        "orphans",
        "outline",
        "outline-color",
        "outline-offset",
        "outline-style",
        "outline-width",
        "overflow",
        "overflow-style",
        "overflow-wrap",
        "overflow-x",
        "overflow-y",
        "padding",
        "padding-bottom",
        "padding-left",
        "padding-right",
        "padding-top",
        "page",
        "page-break-after",
        "page-break-before",
        "page-break-inside",
        "page-policy",
        "pause",
        "pause-after",
        "pause-before",
        "perspective",
        "perspective-origin",
        "pitch",
        "pitch-range",
        "place-content",
        "place-items",
        "place-self",
        "play-during",
        "position",
        "presentation-level",
        "punctuation-trim",
        "quotes",
        "region-break-after",
        "region-break-before",
        "region-break-inside",
        "region-fragment",
        "rendering-intent",
        "resize",
        "rest",
        "rest-after",
        "rest-before",
        "richness",
        "right",
        "rotate",
        "rotation",
        "rotation-point",
        "row-gap",
        "ruby-align",
        "ruby-overhang",
        "ruby-position",
        "ruby-span",
        "scale",
        "scroll-behavior",
        "scroll-margin",
        "scroll-margin-block",
        "scroll-margin-block-end",
        "scroll-margin-block-start",
        "scroll-margin-bottom",
        "scroll-margin-inline",
        "scroll-margin-inline-end",
        "scroll-margin-inline-start",
        "scroll-margin-left",
        "scroll-margin-right",
        "scroll-margin-top",
        "scroll-padding",
        "scroll-padding-block",
        "scroll-padding-block-end",
        "scroll-padding-block-start",
        "scroll-padding-bottom",
        "scroll-padding-inline",
        "scroll-padding-inline-end",
        "scroll-padding-inline-start",
        "scroll-padding-left",
        "scroll-padding-right",
        "scroll-padding-top",
        "scroll-snap-align",
        "scroll-snap-type",
        "shape-image-threshold",
        "shape-inside",
        "shape-margin",
        "shape-outside",
        "size",
        "speak",
        "speak-as",
        "speak-header",
        "speak-numeral",
        "speak-punctuation",
        "speech-rate",
        "stress",
        "string-set",
        "tab-size",
        "table-layout",
        "target",
        "target-name",
        "target-new",
        "target-position",
        "text-align",
        "text-align-last",
        "text-combine-upright",
        "text-decoration",
        "text-decoration-color",
        "text-decoration-line",
        "text-decoration-skip",
        "text-decoration-skip-ink",
        "text-decoration-style",
        "text-emphasis",
        "text-emphasis-color",
        "text-emphasis-position",
        "text-emphasis-style",
        "text-height",
        "text-indent",
        "text-justify",
        "text-orientation",
        "text-outline",
        "text-overflow",
        "text-rendering",
        "text-shadow",
        "text-size-adjust",
        "text-space-collapse",
        "text-transform",
        "text-underline-position",
        "text-wrap",
        "top",
        "touch-action",
        "transform",
        "transform-origin",
        "transform-style",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function",
        "translate",
        "unicode-bidi",
        "user-select",
        "vertical-align",
        "visibility",
        "voice-balance",
        "voice-duration",
        "voice-family",
        "voice-pitch",
        "voice-range",
        "voice-rate",
        "voice-stress",
        "voice-volume",
        "volume",
        "white-space",
        "widows",
        "width",
        "will-change",
        "word-break",
        "word-spacing",
        "word-wrap",
        "writing-mode",
        "z-index",
        // SVG-specific
        "clip-path",
        "clip-rule",
        "mask",
        "enable-background",
        "filter",
        "flood-color",
        "flood-opacity",
        "lighting-color",
        "stop-color",
        "stop-opacity",
        "pointer-events",
        "color-interpolation",
        "color-interpolation-filters",
        "color-rendering",
        "fill",
        "fill-opacity",
        "fill-rule",
        "image-rendering",
        "marker",
        "marker-end",
        "marker-mid",
        "marker-start",
        "paint-order",
        "shape-rendering",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-rendering",
        "baseline-shift",
        "dominant-baseline",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "text-anchor",
        "writing-mode"
      ], C = a(w), k = [
        "accent-color",
        "aspect-ratio",
        "border-block",
        "border-block-color",
        "border-block-end",
        "border-block-end-color",
        "border-block-end-style",
        "border-block-end-width",
        "border-block-start",
        "border-block-start-color",
        "border-block-start-style",
        "border-block-start-width",
        "border-block-style",
        "border-block-width",
        "border-inline",
        "border-inline-color",
        "border-inline-end",
        "border-inline-end-color",
        "border-inline-end-style",
        "border-inline-end-width",
        "border-inline-start",
        "border-inline-start-color",
        "border-inline-start-style",
        "border-inline-start-width",
        "border-inline-style",
        "border-inline-width",
        "content-visibility",
        "margin-block",
        "margin-block-end",
        "margin-block-start",
        "margin-inline",
        "margin-inline-end",
        "margin-inline-start",
        "overflow-anchor",
        "overscroll-behavior",
        "padding-block",
        "padding-block-end",
        "padding-block-start",
        "padding-inline",
        "padding-inline-end",
        "padding-inline-start",
        "scroll-snap-stop",
        "scrollbar-3d-light-color",
        "scrollbar-arrow-color",
        "scrollbar-base-color",
        "scrollbar-dark-shadow-color",
        "scrollbar-face-color",
        "scrollbar-highlight-color",
        "scrollbar-shadow-color",
        "scrollbar-track-color",
        "searchfield-cancel-button",
        "searchfield-decoration",
        "searchfield-results-button",
        "searchfield-results-decoration",
        "shape-inside",
        "zoom"
      ], E = a(k), A = [
        "font-display",
        "font-family",
        "src",
        "unicode-range",
        "font-variant",
        "font-feature-settings",
        "font-stretch",
        "font-weight",
        "font-style"
      ], P = a(A), M = [
        "additive-symbols",
        "fallback",
        "negative",
        "pad",
        "prefix",
        "range",
        "speak-as",
        "suffix",
        "symbols",
        "system"
      ], B = a(M), _ = [
        "aliceblue",
        "antiquewhite",
        "aqua",
        "aquamarine",
        "azure",
        "beige",
        "bisque",
        "black",
        "blanchedalmond",
        "blue",
        "blueviolet",
        "brown",
        "burlywood",
        "cadetblue",
        "chartreuse",
        "chocolate",
        "coral",
        "cornflowerblue",
        "cornsilk",
        "crimson",
        "cyan",
        "darkblue",
        "darkcyan",
        "darkgoldenrod",
        "darkgray",
        "darkgreen",
        "darkgrey",
        "darkkhaki",
        "darkmagenta",
        "darkolivegreen",
        "darkorange",
        "darkorchid",
        "darkred",
        "darksalmon",
        "darkseagreen",
        "darkslateblue",
        "darkslategray",
        "darkslategrey",
        "darkturquoise",
        "darkviolet",
        "deeppink",
        "deepskyblue",
        "dimgray",
        "dimgrey",
        "dodgerblue",
        "firebrick",
        "floralwhite",
        "forestgreen",
        "fuchsia",
        "gainsboro",
        "ghostwhite",
        "gold",
        "goldenrod",
        "gray",
        "grey",
        "green",
        "greenyellow",
        "honeydew",
        "hotpink",
        "indianred",
        "indigo",
        "ivory",
        "khaki",
        "lavender",
        "lavenderblush",
        "lawngreen",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightgoldenrodyellow",
        "lightgray",
        "lightgreen",
        "lightgrey",
        "lightpink",
        "lightsalmon",
        "lightseagreen",
        "lightskyblue",
        "lightslategray",
        "lightslategrey",
        "lightsteelblue",
        "lightyellow",
        "lime",
        "limegreen",
        "linen",
        "magenta",
        "maroon",
        "mediumaquamarine",
        "mediumblue",
        "mediumorchid",
        "mediumpurple",
        "mediumseagreen",
        "mediumslateblue",
        "mediumspringgreen",
        "mediumturquoise",
        "mediumvioletred",
        "midnightblue",
        "mintcream",
        "mistyrose",
        "moccasin",
        "navajowhite",
        "navy",
        "oldlace",
        "olive",
        "olivedrab",
        "orange",
        "orangered",
        "orchid",
        "palegoldenrod",
        "palegreen",
        "paleturquoise",
        "palevioletred",
        "papayawhip",
        "peachpuff",
        "peru",
        "pink",
        "plum",
        "powderblue",
        "purple",
        "rebeccapurple",
        "red",
        "rosybrown",
        "royalblue",
        "saddlebrown",
        "salmon",
        "sandybrown",
        "seagreen",
        "seashell",
        "sienna",
        "silver",
        "skyblue",
        "slateblue",
        "slategray",
        "slategrey",
        "snow",
        "springgreen",
        "steelblue",
        "tan",
        "teal",
        "thistle",
        "tomato",
        "turquoise",
        "violet",
        "wheat",
        "white",
        "whitesmoke",
        "yellow",
        "yellowgreen"
      ], T = a(_), O = [
        "above",
        "absolute",
        "activeborder",
        "additive",
        "activecaption",
        "afar",
        "after-white-space",
        "ahead",
        "alias",
        "all",
        "all-scroll",
        "alphabetic",
        "alternate",
        "always",
        "amharic",
        "amharic-abegede",
        "antialiased",
        "appworkspace",
        "arabic-indic",
        "armenian",
        "asterisks",
        "attr",
        "auto",
        "auto-flow",
        "avoid",
        "avoid-column",
        "avoid-page",
        "avoid-region",
        "axis-pan",
        "background",
        "backwards",
        "baseline",
        "below",
        "bidi-override",
        "binary",
        "bengali",
        "blink",
        "block",
        "block-axis",
        "blur",
        "bold",
        "bolder",
        "border",
        "border-box",
        "both",
        "bottom",
        "break",
        "break-all",
        "break-word",
        "brightness",
        "bullets",
        "button",
        "buttonface",
        "buttonhighlight",
        "buttonshadow",
        "buttontext",
        "calc",
        "cambodian",
        "capitalize",
        "caps-lock-indicator",
        "caption",
        "captiontext",
        "caret",
        "cell",
        "center",
        "checkbox",
        "circle",
        "cjk-decimal",
        "cjk-earthly-branch",
        "cjk-heavenly-stem",
        "cjk-ideographic",
        "clear",
        "clip",
        "close-quote",
        "col-resize",
        "collapse",
        "color",
        "color-burn",
        "color-dodge",
        "column",
        "column-reverse",
        "compact",
        "condensed",
        "conic-gradient",
        "contain",
        "content",
        "contents",
        "content-box",
        "context-menu",
        "continuous",
        "contrast",
        "copy",
        "counter",
        "counters",
        "cover",
        "crop",
        "cross",
        "crosshair",
        "cubic-bezier",
        "currentcolor",
        "cursive",
        "cyclic",
        "darken",
        "dashed",
        "decimal",
        "decimal-leading-zero",
        "default",
        "default-button",
        "dense",
        "destination-atop",
        "destination-in",
        "destination-out",
        "destination-over",
        "devanagari",
        "difference",
        "disc",
        "discard",
        "disclosure-closed",
        "disclosure-open",
        "document",
        "dot-dash",
        "dot-dot-dash",
        "dotted",
        "double",
        "down",
        "drop-shadow",
        "e-resize",
        "ease",
        "ease-in",
        "ease-in-out",
        "ease-out",
        "element",
        "ellipse",
        "ellipsis",
        "embed",
        "end",
        "ethiopic",
        "ethiopic-abegede",
        "ethiopic-abegede-am-et",
        "ethiopic-abegede-gez",
        "ethiopic-abegede-ti-er",
        "ethiopic-abegede-ti-et",
        "ethiopic-halehame-aa-er",
        "ethiopic-halehame-aa-et",
        "ethiopic-halehame-am-et",
        "ethiopic-halehame-gez",
        "ethiopic-halehame-om-et",
        "ethiopic-halehame-sid-et",
        "ethiopic-halehame-so-et",
        "ethiopic-halehame-ti-er",
        "ethiopic-halehame-ti-et",
        "ethiopic-halehame-tig",
        "ethiopic-numeric",
        "ew-resize",
        "exclusion",
        "expanded",
        "extends",
        "extra-condensed",
        "extra-expanded",
        "fantasy",
        "fast",
        "fill",
        "fill-box",
        "fixed",
        "flat",
        "flex",
        "flex-end",
        "flex-start",
        "footnotes",
        "forwards",
        "from",
        "geometricPrecision",
        "georgian",
        "grayscale",
        "graytext",
        "grid",
        "groove",
        "gujarati",
        "gurmukhi",
        "hand",
        "hangul",
        "hangul-consonant",
        "hard-light",
        "hebrew",
        "help",
        "hidden",
        "hide",
        "higher",
        "highlight",
        "highlighttext",
        "hiragana",
        "hiragana-iroha",
        "horizontal",
        "hsl",
        "hsla",
        "hue",
        "hue-rotate",
        "icon",
        "ignore",
        "inactiveborder",
        "inactivecaption",
        "inactivecaptiontext",
        "infinite",
        "infobackground",
        "infotext",
        "inherit",
        "initial",
        "inline",
        "inline-axis",
        "inline-block",
        "inline-flex",
        "inline-grid",
        "inline-table",
        "inset",
        "inside",
        "intrinsic",
        "invert",
        "italic",
        "japanese-formal",
        "japanese-informal",
        "justify",
        "kannada",
        "katakana",
        "katakana-iroha",
        "keep-all",
        "khmer",
        "korean-hangul-formal",
        "korean-hanja-formal",
        "korean-hanja-informal",
        "landscape",
        "lao",
        "large",
        "larger",
        "left",
        "level",
        "lighter",
        "lighten",
        "line-through",
        "linear",
        "linear-gradient",
        "lines",
        "list-item",
        "listbox",
        "listitem",
        "local",
        "logical",
        "loud",
        "lower",
        "lower-alpha",
        "lower-armenian",
        "lower-greek",
        "lower-hexadecimal",
        "lower-latin",
        "lower-norwegian",
        "lower-roman",
        "lowercase",
        "ltr",
        "luminosity",
        "malayalam",
        "manipulation",
        "match",
        "matrix",
        "matrix3d",
        "media-play-button",
        "media-slider",
        "media-sliderthumb",
        "media-volume-slider",
        "media-volume-sliderthumb",
        "medium",
        "menu",
        "menulist",
        "menulist-button",
        "menutext",
        "message-box",
        "middle",
        "min-intrinsic",
        "mix",
        "mongolian",
        "monospace",
        "move",
        "multiple",
        "multiple_mask_images",
        "multiply",
        "myanmar",
        "n-resize",
        "narrower",
        "ne-resize",
        "nesw-resize",
        "no-close-quote",
        "no-drop",
        "no-open-quote",
        "no-repeat",
        "none",
        "normal",
        "not-allowed",
        "nowrap",
        "ns-resize",
        "numbers",
        "numeric",
        "nw-resize",
        "nwse-resize",
        "oblique",
        "octal",
        "opacity",
        "open-quote",
        "optimizeLegibility",
        "optimizeSpeed",
        "oriya",
        "oromo",
        "outset",
        "outside",
        "outside-shape",
        "overlay",
        "overline",
        "padding",
        "padding-box",
        "painted",
        "page",
        "paused",
        "persian",
        "perspective",
        "pinch-zoom",
        "plus-darker",
        "plus-lighter",
        "pointer",
        "polygon",
        "portrait",
        "pre",
        "pre-line",
        "pre-wrap",
        "preserve-3d",
        "progress",
        "push-button",
        "radial-gradient",
        "radio",
        "read-only",
        "read-write",
        "read-write-plaintext-only",
        "rectangle",
        "region",
        "relative",
        "repeat",
        "repeating-linear-gradient",
        "repeating-radial-gradient",
        "repeating-conic-gradient",
        "repeat-x",
        "repeat-y",
        "reset",
        "reverse",
        "rgb",
        "rgba",
        "ridge",
        "right",
        "rotate",
        "rotate3d",
        "rotateX",
        "rotateY",
        "rotateZ",
        "round",
        "row",
        "row-resize",
        "row-reverse",
        "rtl",
        "run-in",
        "running",
        "s-resize",
        "sans-serif",
        "saturate",
        "saturation",
        "scale",
        "scale3d",
        "scaleX",
        "scaleY",
        "scaleZ",
        "screen",
        "scroll",
        "scrollbar",
        "scroll-position",
        "se-resize",
        "searchfield",
        "searchfield-cancel-button",
        "searchfield-decoration",
        "searchfield-results-button",
        "searchfield-results-decoration",
        "self-start",
        "self-end",
        "semi-condensed",
        "semi-expanded",
        "separate",
        "sepia",
        "serif",
        "show",
        "sidama",
        "simp-chinese-formal",
        "simp-chinese-informal",
        "single",
        "skew",
        "skewX",
        "skewY",
        "skip-white-space",
        "slide",
        "slider-horizontal",
        "slider-vertical",
        "sliderthumb-horizontal",
        "sliderthumb-vertical",
        "slow",
        "small",
        "small-caps",
        "small-caption",
        "smaller",
        "soft-light",
        "solid",
        "somali",
        "source-atop",
        "source-in",
        "source-out",
        "source-over",
        "space",
        "space-around",
        "space-between",
        "space-evenly",
        "spell-out",
        "square",
        "square-button",
        "start",
        "static",
        "status-bar",
        "stretch",
        "stroke",
        "stroke-box",
        "sub",
        "subpixel-antialiased",
        "svg_masks",
        "super",
        "sw-resize",
        "symbolic",
        "symbols",
        "system-ui",
        "table",
        "table-caption",
        "table-cell",
        "table-column",
        "table-column-group",
        "table-footer-group",
        "table-header-group",
        "table-row",
        "table-row-group",
        "tamil",
        "telugu",
        "text",
        "text-bottom",
        "text-top",
        "textarea",
        "textfield",
        "thai",
        "thick",
        "thin",
        "threeddarkshadow",
        "threedface",
        "threedhighlight",
        "threedlightshadow",
        "threedshadow",
        "tibetan",
        "tigre",
        "tigrinya-er",
        "tigrinya-er-abegede",
        "tigrinya-et",
        "tigrinya-et-abegede",
        "to",
        "top",
        "trad-chinese-formal",
        "trad-chinese-informal",
        "transform",
        "translate",
        "translate3d",
        "translateX",
        "translateY",
        "translateZ",
        "transparent",
        "ultra-condensed",
        "ultra-expanded",
        "underline",
        "unidirectional-pan",
        "unset",
        "up",
        "upper-alpha",
        "upper-armenian",
        "upper-greek",
        "upper-hexadecimal",
        "upper-latin",
        "upper-norwegian",
        "upper-roman",
        "uppercase",
        "urdu",
        "url",
        "var",
        "vertical",
        "vertical-text",
        "view-box",
        "visible",
        "visibleFill",
        "visiblePainted",
        "visibleStroke",
        "visual",
        "w-resize",
        "wait",
        "wave",
        "wider",
        "window",
        "windowframe",
        "windowtext",
        "words",
        "wrap",
        "wrap-reverse",
        "x-large",
        "x-small",
        "xor",
        "xx-large",
        "xx-small"
      ], I = a(O), q = o.concat(u).concat(f).concat(v).concat(w).concat(k).concat(_).concat(O);
      n.registerHelper("hintWords", "css", q);
      function F(W, K) {
        for (var Z = !1, J; (J = W.next()) != null; ) {
          if (Z && J == "/") {
            K.tokenize = null;
            break;
          }
          Z = J == "*";
        }
        return ["comment", "comment"];
      }
      n.defineMIME("text/css", {
        documentTypes: s,
        mediaTypes: d,
        mediaFeatures: g,
        mediaValueKeywords: b,
        propertyKeywords: C,
        nonStandardPropertyKeywords: E,
        fontProperties: P,
        counterDescriptors: B,
        colorKeywords: T,
        valueKeywords: I,
        tokenHooks: {
          "/": function(W, K) {
            return W.eat("*") ? (K.tokenize = F, F(W, K)) : !1;
          }
        },
        name: "css"
      }), n.defineMIME("text/x-scss", {
        mediaTypes: d,
        mediaFeatures: g,
        mediaValueKeywords: b,
        propertyKeywords: C,
        nonStandardPropertyKeywords: E,
        colorKeywords: T,
        valueKeywords: I,
        fontProperties: P,
        allowNested: !0,
        lineComment: "//",
        tokenHooks: {
          "/": function(W, K) {
            return W.eat("/") ? (W.skipToEnd(), ["comment", "comment"]) : W.eat("*") ? (K.tokenize = F, F(W, K)) : ["operator", "operator"];
          },
          ":": function(W) {
            return W.match(/^\s*\{/, !1) ? [null, null] : !1;
          },
          $: function(W) {
            return W.match(/^[\w-]+/), W.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"];
          },
          "#": function(W) {
            return W.eat("{") ? [null, "interpolation"] : !1;
          }
        },
        name: "css",
        helperType: "scss"
      }), n.defineMIME("text/x-less", {
        mediaTypes: d,
        mediaFeatures: g,
        mediaValueKeywords: b,
        propertyKeywords: C,
        nonStandardPropertyKeywords: E,
        colorKeywords: T,
        valueKeywords: I,
        fontProperties: P,
        allowNested: !0,
        lineComment: "//",
        tokenHooks: {
          "/": function(W, K) {
            return W.eat("/") ? (W.skipToEnd(), ["comment", "comment"]) : W.eat("*") ? (K.tokenize = F, F(W, K)) : ["operator", "operator"];
          },
          "@": function(W) {
            return W.eat("{") ? [null, "interpolation"] : W.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, !1) ? !1 : (W.eatWhile(/[\w\\\-]/), W.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]);
          },
          "&": function() {
            return ["atom", "atom"];
          }
        },
        name: "css",
        helperType: "less"
      }), n.defineMIME("text/x-gss", {
        documentTypes: s,
        mediaTypes: d,
        mediaFeatures: g,
        propertyKeywords: C,
        nonStandardPropertyKeywords: E,
        fontProperties: P,
        counterDescriptors: B,
        colorKeywords: T,
        valueKeywords: I,
        supportsAtComponent: !0,
        tokenHooks: {
          "/": function(W, K) {
            return W.eat("*") ? (K.tokenize = F, F(W, K)) : !1;
          }
        },
        name: "css",
        helperType: "gss"
      });
    });
  })()), css.exports;
}
requireCss();
var clike = { exports: {} }, hasRequiredClike;
function requireClike() {
  return hasRequiredClike || (hasRequiredClike = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      function a(z, X, ue, Be, te, G) {
        this.indented = z, this.column = X, this.type = ue, this.info = Be, this.align = te, this.prev = G;
      }
      function o(z, X, ue, Be) {
        var te = z.indented;
        return z.context && z.context.type == "statement" && ue != "statement" && (te = z.context.indented), z.context = new a(te, X, ue, Be, null, z.context);
      }
      function s(z) {
        var X = z.context.type;
        return (X == ")" || X == "]" || X == "}") && (z.indented = z.context.indented), z.context = z.context.prev;
      }
      function u(z, X, ue) {
        if (X.prevToken == "variable" || X.prevToken == "type" || /\S(?:[^- ]>|[*\]])\s*$|\*$/.test(z.string.slice(0, ue)) || X.typeAtEndOfLine && z.column() == z.indentation()) return !0;
      }
      function d(z) {
        for (; ; ) {
          if (!z || z.type == "top") return !0;
          if (z.type == "}" && z.prev.info != "namespace") return !1;
          z = z.prev;
        }
      }
      n.defineMode("clike", function(z, X) {
        var ue = z.indentUnit, Be = X.statementIndentUnit || ue, te = X.dontAlignCalls, G = X.keywords || {}, ie = X.types || {}, oe = X.builtin || {}, ye = X.blockKeywords || {}, ve = X.defKeywords || {}, ke = X.atoms || {}, Ae = X.hooks || {}, be = X.multiLineStrings, Ie = X.indentStatements !== !1, Se = X.indentSwitch !== !1, ze = X.namespaceSeparator, Ne = X.isPunctuationChar || /[\[\]{}\(\),;\:\.]/, tt = X.numberStart || /[\d\.]/, Qe = X.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i, et = X.isOperatorChar || /[+\-*&%=<>!?|\/]/, ce = X.isIdentifierChar || /[\w\$_\xa1-\uffff]/, pe = X.isReservedIdentifier || !1, je, lt;
        function Ce(We, Ge) {
          var He = We.next();
          if (Ae[He]) {
            var me = Ae[He](We, Ge);
            if (me !== !1) return me;
          }
          if (He == '"' || He == "'")
            return Ge.tokenize = Oe(He), Ge.tokenize(We, Ge);
          if (tt.test(He)) {
            if (We.backUp(1), We.match(Qe)) return "number";
            We.next();
          }
          if (Ne.test(He))
            return je = He, null;
          if (He == "/") {
            if (We.eat("*"))
              return Ge.tokenize = Te, Te(We, Ge);
            if (We.eat("/"))
              return We.skipToEnd(), "comment";
          }
          if (et.test(He)) {
            for (; !We.match(/^\/[\/*]/, !1) && We.eat(et); )
              ;
            return "operator";
          }
          if (We.eatWhile(ce), ze) for (; We.match(ze); )
            We.eatWhile(ce);
          var de = We.current();
          return g(G, de) ? (g(ye, de) && (je = "newstatement"), g(ve, de) && (lt = !0), "keyword") : g(ie, de) ? "type" : g(oe, de) || pe && pe(de) ? (g(ye, de) && (je = "newstatement"), "builtin") : g(ke, de) ? "atom" : "variable";
        }
        function Oe(We) {
          return function(Ge, He) {
            for (var me = !1, de, Fe = !1; (de = Ge.next()) != null; ) {
              if (de == We && !me) {
                Fe = !0;
                break;
              }
              me = !me && de == "\\";
            }
            return (Fe || !(me || be)) && (He.tokenize = null), "string";
          };
        }
        function Te(We, Ge) {
          for (var He = !1, me; me = We.next(); ) {
            if (me == "/" && He) {
              Ge.tokenize = null;
              break;
            }
            He = me == "*";
          }
          return "comment";
        }
        function ot(We, Ge) {
          X.typeFirstDefinitions && We.eol() && d(Ge.context) && (Ge.typeAtEndOfLine = u(We, Ge, We.pos));
        }
        return {
          startState: function(We) {
            return {
              tokenize: null,
              context: new a((We || 0) - ue, 0, "top", null, !1),
              indented: 0,
              startOfLine: !0,
              prevToken: null
            };
          },
          token: function(We, Ge) {
            var He = Ge.context;
            if (We.sol() && (He.align == null && (He.align = !1), Ge.indented = We.indentation(), Ge.startOfLine = !0), We.eatSpace())
              return ot(We, Ge), null;
            je = lt = null;
            var me = (Ge.tokenize || Ce)(We, Ge);
            if (me == "comment" || me == "meta") return me;
            if (He.align == null && (He.align = !0), je == ";" || je == ":" || je == "," && We.match(/^\s*(?:\/\/.*)?$/, !1))
              for (; Ge.context.type == "statement"; ) s(Ge);
            else if (je == "{") o(Ge, We.column(), "}");
            else if (je == "[") o(Ge, We.column(), "]");
            else if (je == "(") o(Ge, We.column(), ")");
            else if (je == "}") {
              for (; He.type == "statement"; ) He = s(Ge);
              for (He.type == "}" && (He = s(Ge)); He.type == "statement"; ) He = s(Ge);
            } else je == He.type ? s(Ge) : Ie && ((He.type == "}" || He.type == "top") && je != ";" || He.type == "statement" && je == "newstatement") && o(Ge, We.column(), "statement", We.current());
            if (me == "variable" && (Ge.prevToken == "def" || X.typeFirstDefinitions && u(We, Ge, We.start) && d(Ge.context) && We.match(/^\s*\(/, !1)) && (me = "def"), Ae.token) {
              var de = Ae.token(We, Ge, me);
              de !== void 0 && (me = de);
            }
            return me == "def" && X.styleDefs === !1 && (me = "variable"), Ge.startOfLine = !1, Ge.prevToken = lt ? "def" : me || je, ot(We, Ge), me;
          },
          indent: function(We, Ge) {
            if (We.tokenize != Ce && We.tokenize != null || We.typeAtEndOfLine) return n.Pass;
            var He = We.context, me = Ge && Ge.charAt(0), de = me == He.type;
            if (He.type == "statement" && me == "}" && (He = He.prev), X.dontIndentStatements)
              for (; He.type == "statement" && X.dontIndentStatements.test(He.info); )
                He = He.prev;
            if (Ae.indent) {
              var Fe = Ae.indent(We, He, Ge, ue);
              if (typeof Fe == "number") return Fe;
            }
            var Ze = He.prev && He.prev.info == "switch";
            if (X.allmanIndentation && /[{(]/.test(me)) {
              for (; He.type != "top" && He.type != "}"; ) He = He.prev;
              return He.indented;
            }
            return He.type == "statement" ? He.indented + (me == "{" ? 0 : Be) : He.align && (!te || He.type != ")") ? He.column + (de ? 0 : 1) : He.type == ")" && !de ? He.indented + Be : He.indented + (de ? 0 : ue) + (!de && Ze && !/^(?:case|default)\b/.test(Ge) ? ue : 0);
          },
          electricInput: Se ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          blockCommentContinue: " * ",
          lineComment: "//",
          fold: "brace"
        };
      });
      function f(z) {
        for (var X = {}, ue = z.split(" "), Be = 0; Be < ue.length; ++Be) X[ue[Be]] = !0;
        return X;
      }
      function g(z, X) {
        return typeof z == "function" ? z(X) : z.propertyIsEnumerable(X);
      }
      var v = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile inline restrict asm fortran", b = "alignas alignof and and_eq audit axiom bitand bitor catch class compl concept constexpr const_cast decltype delete dynamic_cast explicit export final friend import module mutable namespace new noexcept not not_eq operator or or_eq override private protected public reinterpret_cast requires static_assert static_cast template this thread_local throw try typeid typename using virtual xor xor_eq", w = "bycopy byref in inout oneway out self super atomic nonatomic retain copy readwrite readonly strong weak assign typeof nullable nonnull null_resettable _cmd @interface @implementation @end @protocol @encode @property @synthesize @dynamic @class @public @package @private @protected @required @optional @try @catch @finally @import @selector @encode @defs @synchronized @autoreleasepool @compatibility_alias @available", C = "FOUNDATION_EXPORT FOUNDATION_EXTERN NS_INLINE NS_FORMAT_FUNCTION  NS_RETURNS_RETAINEDNS_ERROR_ENUM NS_RETURNS_NOT_RETAINED NS_RETURNS_INNER_POINTER NS_DESIGNATED_INITIALIZER NS_ENUM NS_OPTIONS NS_REQUIRES_NIL_TERMINATION NS_ASSUME_NONNULL_BEGIN NS_ASSUME_NONNULL_END NS_SWIFT_NAME NS_REFINED_FOR_SWIFT", k = f("int long char short double float unsigned signed void bool"), E = f("SEL instancetype id Class Protocol BOOL");
      function A(z) {
        return g(k, z) || /.+_t$/.test(z);
      }
      function P(z) {
        return A(z) || g(E, z);
      }
      var M = "case do else for if switch while struct enum union", B = "struct enum union";
      function _(z, X) {
        if (!X.startOfLine) return !1;
        for (var ue, Be = null; ue = z.peek(); ) {
          if (ue == "\\" && z.match(/^.$/)) {
            Be = _;
            break;
          } else if (ue == "/" && z.match(/^\/[\/\*]/, !1))
            break;
          z.next();
        }
        return X.tokenize = Be, "meta";
      }
      function T(z, X) {
        return X.prevToken == "type" ? "type" : !1;
      }
      function O(z) {
        return !z || z.length < 2 || z[0] != "_" ? !1 : z[1] == "_" || z[1] !== z[1].toLowerCase();
      }
      function I(z) {
        return z.eatWhile(/[\w\.']/), "number";
      }
      function q(z, X) {
        if (z.backUp(1), z.match(/^(?:R|u8R|uR|UR|LR)/)) {
          var ue = z.match(/^"([^\s\\()]{0,16})\(/);
          return ue ? (X.cpp11RawStringDelim = ue[1], X.tokenize = K, K(z, X)) : !1;
        }
        return z.match(/^(?:u8|u|U|L)/) ? z.match(
          /^["']/,
          /* eat */
          !1
        ) ? "string" : !1 : (z.next(), !1);
      }
      function F(z) {
        var X = /(\w+)::~?(\w+)$/.exec(z);
        return X && X[1] == X[2];
      }
      function W(z, X) {
        for (var ue; (ue = z.next()) != null; )
          if (ue == '"' && !z.eat('"')) {
            X.tokenize = null;
            break;
          }
        return "string";
      }
      function K(z, X) {
        var ue = X.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&"), Be = z.match(new RegExp(".*?\\)" + ue + '"'));
        return Be ? X.tokenize = null : z.skipToEnd(), "string";
      }
      function Z(z, X) {
        typeof z == "string" && (z = [z]);
        var ue = [];
        function Be(G) {
          if (G) for (var ie in G) G.hasOwnProperty(ie) && ue.push(ie);
        }
        Be(X.keywords), Be(X.types), Be(X.builtin), Be(X.atoms), ue.length && (X.helperType = z[0], n.registerHelper("hintWords", z[0], ue));
        for (var te = 0; te < z.length; ++te)
          n.defineMIME(z[te], X);
      }
      Z(["text/x-csrc", "text/x-c", "text/x-chdr"], {
        name: "clike",
        keywords: f(v),
        types: A,
        blockKeywords: f(M),
        defKeywords: f(B),
        typeFirstDefinitions: !0,
        atoms: f("NULL true false"),
        isReservedIdentifier: O,
        hooks: {
          "#": _,
          "*": T
        },
        modeProps: { fold: ["brace", "include"] }
      }), Z(["text/x-c++src", "text/x-c++hdr"], {
        name: "clike",
        keywords: f(v + " " + b),
        types: A,
        blockKeywords: f(M + " class try catch"),
        defKeywords: f(B + " class namespace"),
        typeFirstDefinitions: !0,
        atoms: f("true false NULL nullptr"),
        dontIndentStatements: /^template$/,
        isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
        isReservedIdentifier: O,
        hooks: {
          "#": _,
          "*": T,
          u: q,
          U: q,
          L: q,
          R: q,
          0: I,
          1: I,
          2: I,
          3: I,
          4: I,
          5: I,
          6: I,
          7: I,
          8: I,
          9: I,
          token: function(z, X, ue) {
            if (ue == "variable" && z.peek() == "(" && (X.prevToken == ";" || X.prevToken == null || X.prevToken == "}") && F(z.current()))
              return "def";
          }
        },
        namespaceSeparator: "::",
        modeProps: { fold: ["brace", "include"] }
      }), Z("text/x-java", {
        name: "clike",
        keywords: f("abstract assert break case catch class const continue default do else enum extends final finally for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
        types: f("var byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
        blockKeywords: f("catch class do else finally for if switch try while"),
        defKeywords: f("class interface enum @interface"),
        typeFirstDefinitions: !0,
        atoms: f("true false null"),
        number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
        hooks: {
          "@": function(z) {
            return z.match("interface", !1) ? !1 : (z.eatWhile(/[\w\$_]/), "meta");
          },
          '"': function(z, X) {
            return z.match(/""$/) ? (X.tokenize = J, X.tokenize(z, X)) : !1;
          }
        },
        modeProps: { fold: ["brace", "import"] }
      }), Z("text/x-csharp", {
        name: "clike",
        keywords: f("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in init interface internal is lock namespace new operator out override params private protected public readonly record ref required return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
        types: f("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
        blockKeywords: f("catch class do else finally for foreach if struct switch try while"),
        defKeywords: f("class interface namespace record struct var"),
        typeFirstDefinitions: !0,
        atoms: f("true false null"),
        hooks: {
          "@": function(z, X) {
            return z.eat('"') ? (X.tokenize = W, W(z, X)) : (z.eatWhile(/[\w\$_]/), "meta");
          }
        }
      });
      function J(z, X) {
        for (var ue = !1; !z.eol(); ) {
          if (!ue && z.match('"""')) {
            X.tokenize = null;
            break;
          }
          ue = z.next() == "\\" && !ue;
        }
        return "string";
      }
      function re(z) {
        return function(X, ue) {
          for (var Be; Be = X.next(); )
            if (Be == "*" && X.eat("/"))
              if (z == 1) {
                ue.tokenize = null;
                break;
              } else
                return ue.tokenize = re(z - 1), ue.tokenize(X, ue);
            else if (Be == "/" && X.eat("*"))
              return ue.tokenize = re(z + 1), ue.tokenize(X, ue);
          return "comment";
        };
      }
      Z("text/x-scala", {
        name: "clike",
        keywords: f(
          /* scala */
          "abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"
        ),
        types: f(
          "AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"
        ),
        multiLineStrings: !0,
        blockKeywords: f("catch class enum do else finally for forSome if match switch try while"),
        defKeywords: f("class enum def object package trait type val var"),
        atoms: f("true false null"),
        indentStatements: !1,
        indentSwitch: !1,
        isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
        hooks: {
          "@": function(z) {
            return z.eatWhile(/[\w\$_]/), "meta";
          },
          '"': function(z, X) {
            return z.match('""') ? (X.tokenize = J, X.tokenize(z, X)) : !1;
          },
          "'": function(z) {
            return z.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
          },
          "=": function(z, X) {
            var ue = X.context;
            return ue.type == "}" && ue.align && z.eat(">") ? (X.context = new a(ue.indented, ue.column, ue.type, ue.info, null, ue.prev), "operator") : !1;
          },
          "/": function(z, X) {
            return z.eat("*") ? (X.tokenize = re(1), X.tokenize(z, X)) : !1;
          }
        },
        modeProps: { closeBrackets: { pairs: '()[]{}""', triples: '"' } }
      });
      function V(z) {
        return function(X, ue) {
          for (var Be = !1, te, G = !1; !X.eol(); ) {
            if (!z && !Be && X.match('"')) {
              G = !0;
              break;
            }
            if (z && X.match('"""')) {
              G = !0;
              break;
            }
            te = X.next(), !Be && te == "$" && X.match("{") && X.skipTo("}"), Be = !Be && te == "\\" && !z;
          }
          return (G || !z) && (ue.tokenize = null), "string";
        };
      }
      Z("text/x-kotlin", {
        name: "clike",
        keywords: f(
          /*keywords*/
          "package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam value"
        ),
        types: f(
          /* package java.lang */
          "Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"
        ),
        intendSwitch: !1,
        indentStatements: !1,
        multiLineStrings: !0,
        number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
        blockKeywords: f("catch class do else finally for if where try while enum"),
        defKeywords: f("class val var object interface fun"),
        atoms: f("true false null this"),
        hooks: {
          "@": function(z) {
            return z.eatWhile(/[\w\$_]/), "meta";
          },
          "*": function(z, X) {
            return X.prevToken == "." ? "variable" : "operator";
          },
          '"': function(z, X) {
            return X.tokenize = V(z.match('""')), X.tokenize(z, X);
          },
          "/": function(z, X) {
            return z.eat("*") ? (X.tokenize = re(1), X.tokenize(z, X)) : !1;
          },
          indent: function(z, X, ue, Be) {
            var te = ue && ue.charAt(0);
            if ((z.prevToken == "}" || z.prevToken == ")") && ue == "")
              return z.indented;
            if (z.prevToken == "operator" && ue != "}" && z.context.type != "}" || z.prevToken == "variable" && te == "." || (z.prevToken == "}" || z.prevToken == ")") && te == ".")
              return Be * 2 + X.indented;
            if (X.align && X.type == "}")
              return X.indented + (z.context.type == (ue || "").charAt(0) ? 0 : Be);
          }
        },
        modeProps: { closeBrackets: { triples: '"' } }
      }), Z(["x-shader/x-vertex", "x-shader/x-fragment"], {
        name: "clike",
        keywords: f("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
        types: f("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
        blockKeywords: f("for while do if else struct"),
        builtin: f("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
        atoms: f("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TextureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
        indentSwitch: !1,
        hooks: { "#": _ },
        modeProps: { fold: ["brace", "include"] }
      }), Z("text/x-nesc", {
        name: "clike",
        keywords: f(v + " as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
        types: A,
        blockKeywords: f(M),
        atoms: f("null true false"),
        hooks: { "#": _ },
        modeProps: { fold: ["brace", "include"] }
      }), Z("text/x-objectivec", {
        name: "clike",
        keywords: f(v + " " + w),
        types: P,
        builtin: f(C),
        blockKeywords: f(M + " @synthesize @try @catch @finally @autoreleasepool @synchronized"),
        defKeywords: f(B + " @interface @implementation @protocol @class"),
        dontIndentStatements: /^@.*$/,
        typeFirstDefinitions: !0,
        atoms: f("YES NO NULL Nil nil true false nullptr"),
        isReservedIdentifier: O,
        hooks: {
          "#": _,
          "*": T
        },
        modeProps: { fold: ["brace", "include"] }
      }), Z("text/x-objectivec++", {
        name: "clike",
        keywords: f(v + " " + w + " " + b),
        types: P,
        builtin: f(C),
        blockKeywords: f(M + " @synthesize @try @catch @finally @autoreleasepool @synchronized class try catch"),
        defKeywords: f(B + " @interface @implementation @protocol @class class namespace"),
        dontIndentStatements: /^@.*$|^template$/,
        typeFirstDefinitions: !0,
        atoms: f("YES NO NULL Nil nil true false nullptr"),
        isReservedIdentifier: O,
        hooks: {
          "#": _,
          "*": T,
          u: q,
          U: q,
          L: q,
          R: q,
          0: I,
          1: I,
          2: I,
          3: I,
          4: I,
          5: I,
          6: I,
          7: I,
          8: I,
          9: I,
          token: function(z, X, ue) {
            if (ue == "variable" && z.peek() == "(" && (X.prevToken == ";" || X.prevToken == null || X.prevToken == "}") && F(z.current()))
              return "def";
          }
        },
        namespaceSeparator: "::",
        modeProps: { fold: ["brace", "include"] }
      }), Z("text/x-squirrel", {
        name: "clike",
        keywords: f("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
        types: A,
        blockKeywords: f("case catch class else for foreach if switch try while"),
        defKeywords: f("function local class"),
        typeFirstDefinitions: !0,
        atoms: f("true false null"),
        hooks: { "#": _ },
        modeProps: { fold: ["brace", "include"] }
      });
      var ne = null;
      function Q(z) {
        return function(X, ue) {
          for (var Be = !1, te, G = !1; !X.eol(); ) {
            if (!Be && X.match('"') && (z == "single" || X.match('""'))) {
              G = !0;
              break;
            }
            if (!Be && X.match("``")) {
              ne = Q(z), G = !0;
              break;
            }
            te = X.next(), Be = z == "single" && !Be && te == "\\";
          }
          return G && (ue.tokenize = null), "string";
        };
      }
      Z("text/x-ceylon", {
        name: "clike",
        keywords: f("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
        types: function(z) {
          var X = z.charAt(0);
          return X === X.toUpperCase() && X !== X.toLowerCase();
        },
        blockKeywords: f("case catch class dynamic else finally for function if interface module new object switch try while"),
        defKeywords: f("class dynamic function interface module object package value"),
        builtin: f("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
        isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
        isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
        numberStart: /[\d#$]/,
        number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
        multiLineStrings: !0,
        typeFirstDefinitions: !0,
        atoms: f("true false null larger smaller equal empty finished"),
        indentSwitch: !1,
        styleDefs: !1,
        hooks: {
          "@": function(z) {
            return z.eatWhile(/[\w\$_]/), "meta";
          },
          '"': function(z, X) {
            return X.tokenize = Q(z.match('""') ? "triple" : "single"), X.tokenize(z, X);
          },
          "`": function(z, X) {
            return !ne || !z.match("`") ? !1 : (X.tokenize = ne, ne = null, X.tokenize(z, X));
          },
          "'": function(z) {
            return z.eatWhile(/[\w\$_\xa1-\uffff]/), "atom";
          },
          token: function(z, X, ue) {
            if ((ue == "variable" || ue == "type") && X.prevToken == ".")
              return "variable-2";
          }
        },
        modeProps: {
          fold: ["brace", "import"],
          closeBrackets: { triples: '"' }
        }
      });
    });
  })()), clike.exports;
}
requireClike();
var diff = { exports: {} }, hasRequiredDiff;
function requireDiff() {
  return hasRequiredDiff || (hasRequiredDiff = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("diff", function() {
        var a = {
          "+": "positive",
          "-": "negative",
          "@": "meta"
        };
        return {
          token: function(o) {
            var s = o.string.search(/[\t ]+?$/);
            if (!o.sol() || s === 0)
              return o.skipToEnd(), ("error " + (a[o.string.charAt(0)] || "")).replace(/ $/, "");
            var u = a[o.peek()] || o.skipToEnd();
            return s === -1 ? o.skipToEnd() : o.pos = s, u;
          }
        };
      }), n.defineMIME("text/x-diff", "diff");
    });
  })()), diff.exports;
}
requireDiff();
var go = { exports: {} }, hasRequiredGo;
function requireGo() {
  return hasRequiredGo || (hasRequiredGo = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("go", function(a) {
        var o = a.indentUnit, s = {
          break: !0,
          case: !0,
          chan: !0,
          const: !0,
          continue: !0,
          default: !0,
          defer: !0,
          else: !0,
          fallthrough: !0,
          for: !0,
          func: !0,
          go: !0,
          goto: !0,
          if: !0,
          import: !0,
          interface: !0,
          map: !0,
          package: !0,
          range: !0,
          return: !0,
          select: !0,
          struct: !0,
          switch: !0,
          type: !0,
          var: !0,
          bool: !0,
          byte: !0,
          complex64: !0,
          complex128: !0,
          float32: !0,
          float64: !0,
          int8: !0,
          int16: !0,
          int32: !0,
          int64: !0,
          string: !0,
          uint8: !0,
          uint16: !0,
          uint32: !0,
          uint64: !0,
          int: !0,
          uint: !0,
          uintptr: !0,
          error: !0,
          rune: !0,
          any: !0,
          comparable: !0
        }, u = {
          true: !0,
          false: !0,
          iota: !0,
          nil: !0,
          append: !0,
          cap: !0,
          close: !0,
          complex: !0,
          copy: !0,
          delete: !0,
          imag: !0,
          len: !0,
          make: !0,
          new: !0,
          panic: !0,
          print: !0,
          println: !0,
          real: !0,
          recover: !0
        }, d = /[+\-*&^%:=<>!|\/]/, f;
        function g(E, A) {
          var P = E.next();
          if (P == '"' || P == "'" || P == "`")
            return A.tokenize = v(P), A.tokenize(E, A);
          if (/[\d\.]/.test(P))
            return P == "." ? E.match(/^[0-9]+([eE][\-+]?[0-9]+)?/) : P == "0" ? E.match(/^[xX][0-9a-fA-F]+/) || E.match(/^0[0-7]+/) : E.match(/^[0-9]*\.?[0-9]*([eE][\-+]?[0-9]+)?/), "number";
          if (/[\[\]{}\(\),;\:\.]/.test(P))
            return f = P, null;
          if (P == "/") {
            if (E.eat("*"))
              return A.tokenize = b, b(E, A);
            if (E.eat("/"))
              return E.skipToEnd(), "comment";
          }
          if (d.test(P))
            return E.eatWhile(d), "operator";
          E.eatWhile(/[\w\$_\xa1-\uffff]/);
          var M = E.current();
          return s.propertyIsEnumerable(M) ? ((M == "case" || M == "default") && (f = "case"), "keyword") : u.propertyIsEnumerable(M) ? "atom" : "variable";
        }
        function v(E) {
          return function(A, P) {
            for (var M = !1, B, _ = !1; (B = A.next()) != null; ) {
              if (B == E && !M) {
                _ = !0;
                break;
              }
              M = !M && E != "`" && B == "\\";
            }
            return (_ || !(M || E == "`")) && (P.tokenize = g), "string";
          };
        }
        function b(E, A) {
          for (var P = !1, M; M = E.next(); ) {
            if (M == "/" && P) {
              A.tokenize = g;
              break;
            }
            P = M == "*";
          }
          return "comment";
        }
        function w(E, A, P, M, B) {
          this.indented = E, this.column = A, this.type = P, this.align = M, this.prev = B;
        }
        function C(E, A, P) {
          return E.context = new w(E.indented, A, P, null, E.context);
        }
        function k(E) {
          if (E.context.prev) {
            var A = E.context.type;
            return (A == ")" || A == "]" || A == "}") && (E.indented = E.context.indented), E.context = E.context.prev;
          }
        }
        return {
          startState: function(E) {
            return {
              tokenize: null,
              context: new w((E || 0) - o, 0, "top", !1),
              indented: 0,
              startOfLine: !0
            };
          },
          token: function(E, A) {
            var P = A.context;
            if (E.sol() && (P.align == null && (P.align = !1), A.indented = E.indentation(), A.startOfLine = !0, P.type == "case" && (P.type = "}")), E.eatSpace()) return null;
            f = null;
            var M = (A.tokenize || g)(E, A);
            return M == "comment" || (P.align == null && (P.align = !0), f == "{" ? C(A, E.column(), "}") : f == "[" ? C(A, E.column(), "]") : f == "(" ? C(A, E.column(), ")") : f == "case" ? P.type = "case" : (f == "}" && P.type == "}" || f == P.type) && k(A), A.startOfLine = !1), M;
          },
          indent: function(E, A) {
            if (E.tokenize != g && E.tokenize != null) return n.Pass;
            var P = E.context, M = A && A.charAt(0);
            if (P.type == "case" && /^(?:case|default)\b/.test(A))
              return E.context.type = "}", P.indented;
            var B = M == P.type;
            return P.align ? P.column + (B ? 0 : 1) : P.indented + (B ? 0 : o);
          },
          electricChars: "{}):",
          closeBrackets: "()[]{}''\"\"``",
          fold: "brace",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//"
        };
      }), n.defineMIME("text/x-go", "go");
    });
  })()), go.exports;
}
requireGo();
var gfm = { exports: {} }, markdown$2 = { exports: {} }, xml = { exports: {} }, hasRequiredXml;
function requireXml() {
  return hasRequiredXml || (hasRequiredXml = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      var a = {
        autoSelfClosers: {
          area: !0,
          base: !0,
          br: !0,
          col: !0,
          command: !0,
          embed: !0,
          frame: !0,
          hr: !0,
          img: !0,
          input: !0,
          keygen: !0,
          link: !0,
          meta: !0,
          param: !0,
          source: !0,
          track: !0,
          wbr: !0,
          menuitem: !0
        },
        implicitlyClosed: {
          dd: !0,
          li: !0,
          optgroup: !0,
          option: !0,
          p: !0,
          rp: !0,
          rt: !0,
          tbody: !0,
          td: !0,
          tfoot: !0,
          th: !0,
          tr: !0
        },
        contextGrabbers: {
          dd: { dd: !0, dt: !0 },
          dt: { dd: !0, dt: !0 },
          li: { li: !0 },
          option: { option: !0, optgroup: !0 },
          optgroup: { optgroup: !0 },
          p: {
            address: !0,
            article: !0,
            aside: !0,
            blockquote: !0,
            dir: !0,
            div: !0,
            dl: !0,
            fieldset: !0,
            footer: !0,
            form: !0,
            h1: !0,
            h2: !0,
            h3: !0,
            h4: !0,
            h5: !0,
            h6: !0,
            header: !0,
            hgroup: !0,
            hr: !0,
            menu: !0,
            nav: !0,
            ol: !0,
            p: !0,
            pre: !0,
            section: !0,
            table: !0,
            ul: !0
          },
          rp: { rp: !0, rt: !0 },
          rt: { rp: !0, rt: !0 },
          tbody: { tbody: !0, tfoot: !0 },
          td: { td: !0, th: !0 },
          tfoot: { tbody: !0 },
          th: { td: !0, th: !0 },
          thead: { tbody: !0, tfoot: !0 },
          tr: { tr: !0 }
        },
        doNotIndent: { pre: !0 },
        allowUnquoted: !0,
        allowMissing: !0,
        caseFold: !0
      }, o = {
        autoSelfClosers: {},
        implicitlyClosed: {},
        contextGrabbers: {},
        doNotIndent: {},
        allowUnquoted: !1,
        allowMissing: !1,
        allowMissingTagName: !1,
        caseFold: !1
      };
      n.defineMode("xml", function(s, u) {
        var d = s.indentUnit, f = {}, g = u.htmlMode ? a : o;
        for (var v in g) f[v] = g[v];
        for (var v in u) f[v] = u[v];
        var b, w;
        function C(V, ne) {
          function Q(ue) {
            return ne.tokenize = ue, ue(V, ne);
          }
          var z = V.next();
          if (z == "<")
            return V.eat("!") ? V.eat("[") ? V.match("CDATA[") ? Q(A("atom", "]]>")) : null : V.match("--") ? Q(A("comment", "-->")) : V.match("DOCTYPE", !0, !0) ? (V.eatWhile(/[\w\._\-]/), Q(P(1))) : null : V.eat("?") ? (V.eatWhile(/[\w\._\-]/), ne.tokenize = A("meta", "?>"), "meta") : (b = V.eat("/") ? "closeTag" : "openTag", ne.tokenize = k, "tag bracket");
          if (z == "&") {
            var X;
            return V.eat("#") ? V.eat("x") ? X = V.eatWhile(/[a-fA-F\d]/) && V.eat(";") : X = V.eatWhile(/[\d]/) && V.eat(";") : X = V.eatWhile(/[\w\.\-:]/) && V.eat(";"), X ? "atom" : "error";
          } else
            return V.eatWhile(/[^&<]/), null;
        }
        C.isInText = !0;
        function k(V, ne) {
          var Q = V.next();
          if (Q == ">" || Q == "/" && V.eat(">"))
            return ne.tokenize = C, b = Q == ">" ? "endTag" : "selfcloseTag", "tag bracket";
          if (Q == "=")
            return b = "equals", null;
          if (Q == "<") {
            ne.tokenize = C, ne.state = O, ne.tagName = ne.tagStart = null;
            var z = ne.tokenize(V, ne);
            return z ? z + " tag error" : "tag error";
          } else return /[\'\"]/.test(Q) ? (ne.tokenize = E(Q), ne.stringStartCol = V.column(), ne.tokenize(V, ne)) : (V.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word");
        }
        function E(V) {
          var ne = function(Q, z) {
            for (; !Q.eol(); )
              if (Q.next() == V) {
                z.tokenize = k;
                break;
              }
            return "string";
          };
          return ne.isInAttribute = !0, ne;
        }
        function A(V, ne) {
          return function(Q, z) {
            for (; !Q.eol(); ) {
              if (Q.match(ne)) {
                z.tokenize = C;
                break;
              }
              Q.next();
            }
            return V;
          };
        }
        function P(V) {
          return function(ne, Q) {
            for (var z; (z = ne.next()) != null; ) {
              if (z == "<")
                return Q.tokenize = P(V + 1), Q.tokenize(ne, Q);
              if (z == ">")
                if (V == 1) {
                  Q.tokenize = C;
                  break;
                } else
                  return Q.tokenize = P(V - 1), Q.tokenize(ne, Q);
            }
            return "meta";
          };
        }
        function M(V) {
          return V && V.toLowerCase();
        }
        function B(V, ne, Q) {
          this.prev = V.context, this.tagName = ne || "", this.indent = V.indented, this.startOfLine = Q, (f.doNotIndent.hasOwnProperty(ne) || V.context && V.context.noIndent) && (this.noIndent = !0);
        }
        function _(V) {
          V.context && (V.context = V.context.prev);
        }
        function T(V, ne) {
          for (var Q; ; ) {
            if (!V.context || (Q = V.context.tagName, !f.contextGrabbers.hasOwnProperty(M(Q)) || !f.contextGrabbers[M(Q)].hasOwnProperty(M(ne))))
              return;
            _(V);
          }
        }
        function O(V, ne, Q) {
          return V == "openTag" ? (Q.tagStart = ne.column(), I) : V == "closeTag" ? q : O;
        }
        function I(V, ne, Q) {
          return V == "word" ? (Q.tagName = ne.current(), w = "tag", K) : f.allowMissingTagName && V == "endTag" ? (w = "tag bracket", K(V, ne, Q)) : (w = "error", I);
        }
        function q(V, ne, Q) {
          if (V == "word") {
            var z = ne.current();
            return Q.context && Q.context.tagName != z && f.implicitlyClosed.hasOwnProperty(M(Q.context.tagName)) && _(Q), Q.context && Q.context.tagName == z || f.matchClosing === !1 ? (w = "tag", F) : (w = "tag error", W);
          } else return f.allowMissingTagName && V == "endTag" ? (w = "tag bracket", F(V, ne, Q)) : (w = "error", W);
        }
        function F(V, ne, Q) {
          return V != "endTag" ? (w = "error", F) : (_(Q), O);
        }
        function W(V, ne, Q) {
          return w = "error", F(V, ne, Q);
        }
        function K(V, ne, Q) {
          if (V == "word")
            return w = "attribute", Z;
          if (V == "endTag" || V == "selfcloseTag") {
            var z = Q.tagName, X = Q.tagStart;
            return Q.tagName = Q.tagStart = null, V == "selfcloseTag" || f.autoSelfClosers.hasOwnProperty(M(z)) ? T(Q, z) : (T(Q, z), Q.context = new B(Q, z, X == Q.indented)), O;
          }
          return w = "error", K;
        }
        function Z(V, ne, Q) {
          return V == "equals" ? J : (f.allowMissing || (w = "error"), K(V, ne, Q));
        }
        function J(V, ne, Q) {
          return V == "string" ? re : V == "word" && f.allowUnquoted ? (w = "string", K) : (w = "error", K(V, ne, Q));
        }
        function re(V, ne, Q) {
          return V == "string" ? re : K(V, ne, Q);
        }
        return {
          startState: function(V) {
            var ne = {
              tokenize: C,
              state: O,
              indented: V || 0,
              tagName: null,
              tagStart: null,
              context: null
            };
            return V != null && (ne.baseIndent = V), ne;
          },
          token: function(V, ne) {
            if (!ne.tagName && V.sol() && (ne.indented = V.indentation()), V.eatSpace()) return null;
            b = null;
            var Q = ne.tokenize(V, ne);
            return (Q || b) && Q != "comment" && (w = null, ne.state = ne.state(b || Q, V, ne), w && (Q = w == "error" ? Q + " error" : w)), Q;
          },
          indent: function(V, ne, Q) {
            var z = V.context;
            if (V.tokenize.isInAttribute)
              return V.tagStart == V.indented ? V.stringStartCol + 1 : V.indented + d;
            if (z && z.noIndent) return n.Pass;
            if (V.tokenize != k && V.tokenize != C)
              return Q ? Q.match(/^(\s*)/)[0].length : 0;
            if (V.tagName)
              return f.multilineTagIndentPastTag !== !1 ? V.tagStart + V.tagName.length + 2 : V.tagStart + d * (f.multilineTagIndentFactor || 1);
            if (f.alignCDATA && /<!\[CDATA\[/.test(ne)) return 0;
            var X = ne && /^<(\/)?([\w_:\.-]*)/.exec(ne);
            if (X && X[1])
              for (; z; )
                if (z.tagName == X[2]) {
                  z = z.prev;
                  break;
                } else if (f.implicitlyClosed.hasOwnProperty(M(z.tagName)))
                  z = z.prev;
                else
                  break;
            else if (X)
              for (; z; ) {
                var ue = f.contextGrabbers[M(z.tagName)];
                if (ue && ue.hasOwnProperty(M(X[2])))
                  z = z.prev;
                else
                  break;
              }
            for (; z && z.prev && !z.startOfLine; )
              z = z.prev;
            return z ? z.indent + d : V.baseIndent || 0;
          },
          electricInput: /<\/[\s\w:]+>$/,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          configuration: f.htmlMode ? "html" : "xml",
          helperType: f.htmlMode ? "html" : "xml",
          skipAttribute: function(V) {
            V.state == J && (V.state = K);
          },
          xmlCurrentTag: function(V) {
            return V.tagName ? { name: V.tagName, close: V.type == "closeTag" } : null;
          },
          xmlCurrentContext: function(V) {
            for (var ne = [], Q = V.context; Q; Q = Q.prev)
              ne.push(Q.tagName);
            return ne.reverse();
          }
        };
      }), n.defineMIME("text/xml", "xml"), n.defineMIME("application/xml", "xml"), n.mimeModes.hasOwnProperty("text/html") || n.defineMIME("text/html", { name: "xml", htmlMode: !0 });
    });
  })()), xml.exports;
}
var meta = { exports: {} }, hasRequiredMeta;
function requireMeta() {
  return hasRequiredMeta || (hasRequiredMeta = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.modeInfo = [
        { name: "APL", mime: "text/apl", mode: "apl", ext: ["dyalog", "apl"] },
        { name: "PGP", mimes: ["application/pgp", "application/pgp-encrypted", "application/pgp-keys", "application/pgp-signature"], mode: "asciiarmor", ext: ["asc", "pgp", "sig"] },
        { name: "ASN.1", mime: "text/x-ttcn-asn", mode: "asn.1", ext: ["asn", "asn1"] },
        { name: "Asterisk", mime: "text/x-asterisk", mode: "asterisk", file: /^extensions\.conf$/i },
        { name: "Brainfuck", mime: "text/x-brainfuck", mode: "brainfuck", ext: ["b", "bf"] },
        { name: "C", mime: "text/x-csrc", mode: "clike", ext: ["c", "h", "ino"] },
        { name: "C++", mime: "text/x-c++src", mode: "clike", ext: ["cpp", "c++", "cc", "cxx", "hpp", "h++", "hh", "hxx"], alias: ["cpp"] },
        { name: "Cobol", mime: "text/x-cobol", mode: "cobol", ext: ["cob", "cpy", "cbl"] },
        { name: "C#", mime: "text/x-csharp", mode: "clike", ext: ["cs"], alias: ["csharp", "cs"] },
        { name: "Clojure", mime: "text/x-clojure", mode: "clojure", ext: ["clj", "cljc", "cljx"] },
        { name: "ClojureScript", mime: "text/x-clojurescript", mode: "clojure", ext: ["cljs"] },
        { name: "Closure Stylesheets (GSS)", mime: "text/x-gss", mode: "css", ext: ["gss"] },
        { name: "CMake", mime: "text/x-cmake", mode: "cmake", ext: ["cmake", "cmake.in"], file: /^CMakeLists\.txt$/ },
        { name: "CoffeeScript", mimes: ["application/vnd.coffeescript", "text/coffeescript", "text/x-coffeescript"], mode: "coffeescript", ext: ["coffee"], alias: ["coffee", "coffee-script"] },
        { name: "Common Lisp", mime: "text/x-common-lisp", mode: "commonlisp", ext: ["cl", "lisp", "el"], alias: ["lisp"] },
        { name: "Cypher", mime: "application/x-cypher-query", mode: "cypher", ext: ["cyp", "cypher"] },
        { name: "Cython", mime: "text/x-cython", mode: "python", ext: ["pyx", "pxd", "pxi"] },
        { name: "Crystal", mime: "text/x-crystal", mode: "crystal", ext: ["cr"] },
        { name: "CSS", mime: "text/css", mode: "css", ext: ["css"] },
        { name: "CQL", mime: "text/x-cassandra", mode: "sql", ext: ["cql"] },
        { name: "D", mime: "text/x-d", mode: "d", ext: ["d"] },
        { name: "Dart", mimes: ["application/dart", "text/x-dart"], mode: "dart", ext: ["dart"] },
        { name: "diff", mime: "text/x-diff", mode: "diff", ext: ["diff", "patch"] },
        { name: "Django", mime: "text/x-django", mode: "django" },
        { name: "Dockerfile", mime: "text/x-dockerfile", mode: "dockerfile", file: /^Dockerfile$/ },
        { name: "DTD", mime: "application/xml-dtd", mode: "dtd", ext: ["dtd"] },
        { name: "Dylan", mime: "text/x-dylan", mode: "dylan", ext: ["dylan", "dyl", "intr"] },
        { name: "EBNF", mime: "text/x-ebnf", mode: "ebnf" },
        { name: "ECL", mime: "text/x-ecl", mode: "ecl", ext: ["ecl"] },
        { name: "edn", mime: "application/edn", mode: "clojure", ext: ["edn"] },
        { name: "Eiffel", mime: "text/x-eiffel", mode: "eiffel", ext: ["e"] },
        { name: "Elm", mime: "text/x-elm", mode: "elm", ext: ["elm"] },
        { name: "Embedded JavaScript", mime: "application/x-ejs", mode: "htmlembedded", ext: ["ejs"] },
        { name: "Embedded Ruby", mime: "application/x-erb", mode: "htmlembedded", ext: ["erb"] },
        { name: "Erlang", mime: "text/x-erlang", mode: "erlang", ext: ["erl"] },
        { name: "Esper", mime: "text/x-esper", mode: "sql" },
        { name: "Factor", mime: "text/x-factor", mode: "factor", ext: ["factor"] },
        { name: "FCL", mime: "text/x-fcl", mode: "fcl" },
        { name: "Forth", mime: "text/x-forth", mode: "forth", ext: ["forth", "fth", "4th"] },
        { name: "Fortran", mime: "text/x-fortran", mode: "fortran", ext: ["f", "for", "f77", "f90", "f95"] },
        { name: "F#", mime: "text/x-fsharp", mode: "mllike", ext: ["fs"], alias: ["fsharp"] },
        { name: "Gas", mime: "text/x-gas", mode: "gas", ext: ["s"] },
        { name: "Gherkin", mime: "text/x-feature", mode: "gherkin", ext: ["feature"] },
        { name: "GitHub Flavored Markdown", mime: "text/x-gfm", mode: "gfm", file: /^(readme|contributing|history)\.md$/i },
        { name: "Go", mime: "text/x-go", mode: "go", ext: ["go"] },
        { name: "Groovy", mime: "text/x-groovy", mode: "groovy", ext: ["groovy", "gradle"], file: /^Jenkinsfile$/ },
        { name: "HAML", mime: "text/x-haml", mode: "haml", ext: ["haml"] },
        { name: "Haskell", mime: "text/x-haskell", mode: "haskell", ext: ["hs"] },
        { name: "Haskell (Literate)", mime: "text/x-literate-haskell", mode: "haskell-literate", ext: ["lhs"] },
        { name: "Haxe", mime: "text/x-haxe", mode: "haxe", ext: ["hx"] },
        { name: "HXML", mime: "text/x-hxml", mode: "haxe", ext: ["hxml"] },
        { name: "ASP.NET", mime: "application/x-aspx", mode: "htmlembedded", ext: ["aspx"], alias: ["asp", "aspx"] },
        { name: "HTML", mime: "text/html", mode: "htmlmixed", ext: ["html", "htm", "handlebars", "hbs"], alias: ["xhtml"] },
        { name: "HTTP", mime: "message/http", mode: "http" },
        { name: "IDL", mime: "text/x-idl", mode: "idl", ext: ["pro"] },
        { name: "Pug", mime: "text/x-pug", mode: "pug", ext: ["jade", "pug"], alias: ["jade"] },
        { name: "Java", mime: "text/x-java", mode: "clike", ext: ["java"] },
        { name: "Java Server Pages", mime: "application/x-jsp", mode: "htmlembedded", ext: ["jsp"], alias: ["jsp"] },
        {
          name: "JavaScript",
          mimes: ["text/javascript", "text/ecmascript", "application/javascript", "application/x-javascript", "application/ecmascript"],
          mode: "javascript",
          ext: ["js"],
          alias: ["ecmascript", "js", "node"]
        },
        { name: "JSON", mimes: ["application/json", "application/x-json"], mode: "javascript", ext: ["json", "map"], alias: ["json5"] },
        { name: "JSON-LD", mime: "application/ld+json", mode: "javascript", ext: ["jsonld"], alias: ["jsonld"] },
        { name: "JSX", mime: "text/jsx", mode: "jsx", ext: ["jsx"] },
        { name: "Jinja2", mime: "text/jinja2", mode: "jinja2", ext: ["j2", "jinja", "jinja2"] },
        { name: "Julia", mime: "text/x-julia", mode: "julia", ext: ["jl"], alias: ["jl"] },
        { name: "Kotlin", mime: "text/x-kotlin", mode: "clike", ext: ["kt"] },
        { name: "LESS", mime: "text/x-less", mode: "css", ext: ["less"] },
        { name: "LiveScript", mime: "text/x-livescript", mode: "livescript", ext: ["ls"], alias: ["ls"] },
        { name: "Lua", mime: "text/x-lua", mode: "lua", ext: ["lua"] },
        { name: "Markdown", mime: "text/x-markdown", mode: "markdown", ext: ["markdown", "md", "mkd"] },
        { name: "mIRC", mime: "text/mirc", mode: "mirc" },
        { name: "MariaDB SQL", mime: "text/x-mariadb", mode: "sql" },
        { name: "Mathematica", mime: "text/x-mathematica", mode: "mathematica", ext: ["m", "nb", "wl", "wls"] },
        { name: "Modelica", mime: "text/x-modelica", mode: "modelica", ext: ["mo"] },
        { name: "MUMPS", mime: "text/x-mumps", mode: "mumps", ext: ["mps"] },
        { name: "MS SQL", mime: "text/x-mssql", mode: "sql" },
        { name: "mbox", mime: "application/mbox", mode: "mbox", ext: ["mbox"] },
        { name: "MySQL", mime: "text/x-mysql", mode: "sql" },
        { name: "Nginx", mime: "text/x-nginx-conf", mode: "nginx", file: /nginx.*\.conf$/i },
        { name: "NSIS", mime: "text/x-nsis", mode: "nsis", ext: ["nsh", "nsi"] },
        {
          name: "NTriples",
          mimes: ["application/n-triples", "application/n-quads", "text/n-triples"],
          mode: "ntriples",
          ext: ["nt", "nq"]
        },
        { name: "Objective-C", mime: "text/x-objectivec", mode: "clike", ext: ["m"], alias: ["objective-c", "objc"] },
        { name: "Objective-C++", mime: "text/x-objectivec++", mode: "clike", ext: ["mm"], alias: ["objective-c++", "objc++"] },
        { name: "OCaml", mime: "text/x-ocaml", mode: "mllike", ext: ["ml", "mli", "mll", "mly"] },
        { name: "Octave", mime: "text/x-octave", mode: "octave", ext: ["m"] },
        { name: "Oz", mime: "text/x-oz", mode: "oz", ext: ["oz"] },
        { name: "Pascal", mime: "text/x-pascal", mode: "pascal", ext: ["p", "pas"] },
        { name: "PEG.js", mime: "null", mode: "pegjs", ext: ["jsonld"] },
        { name: "Perl", mime: "text/x-perl", mode: "perl", ext: ["pl", "pm"] },
        { name: "PHP", mimes: ["text/x-php", "application/x-httpd-php", "application/x-httpd-php-open"], mode: "php", ext: ["php", "php3", "php4", "php5", "php7", "phtml"] },
        { name: "Pig", mime: "text/x-pig", mode: "pig", ext: ["pig"] },
        { name: "Plain Text", mime: "text/plain", mode: "null", ext: ["txt", "text", "conf", "def", "list", "log"] },
        { name: "PLSQL", mime: "text/x-plsql", mode: "sql", ext: ["pls"] },
        { name: "PostgreSQL", mime: "text/x-pgsql", mode: "sql" },
        { name: "PowerShell", mime: "application/x-powershell", mode: "powershell", ext: ["ps1", "psd1", "psm1"] },
        { name: "Properties files", mime: "text/x-properties", mode: "properties", ext: ["properties", "ini", "in"], alias: ["ini", "properties"] },
        { name: "ProtoBuf", mime: "text/x-protobuf", mode: "protobuf", ext: ["proto"] },
        { name: "Python", mime: "text/x-python", mode: "python", ext: ["BUILD", "bzl", "py", "pyw"], file: /^(BUCK|BUILD)$/ },
        { name: "Puppet", mime: "text/x-puppet", mode: "puppet", ext: ["pp"] },
        { name: "Q", mime: "text/x-q", mode: "q", ext: ["q"] },
        { name: "R", mime: "text/x-rsrc", mode: "r", ext: ["r", "R"], alias: ["rscript"] },
        { name: "reStructuredText", mime: "text/x-rst", mode: "rst", ext: ["rst"], alias: ["rst"] },
        { name: "RPM Changes", mime: "text/x-rpm-changes", mode: "rpm" },
        { name: "RPM Spec", mime: "text/x-rpm-spec", mode: "rpm", ext: ["spec"] },
        { name: "Ruby", mime: "text/x-ruby", mode: "ruby", ext: ["rb"], alias: ["jruby", "macruby", "rake", "rb", "rbx"] },
        { name: "Rust", mime: "text/x-rustsrc", mode: "rust", ext: ["rs"] },
        { name: "SAS", mime: "text/x-sas", mode: "sas", ext: ["sas"] },
        { name: "Sass", mime: "text/x-sass", mode: "sass", ext: ["sass"] },
        { name: "Scala", mime: "text/x-scala", mode: "clike", ext: ["scala"] },
        { name: "Scheme", mime: "text/x-scheme", mode: "scheme", ext: ["scm", "ss"] },
        { name: "SCSS", mime: "text/x-scss", mode: "css", ext: ["scss"] },
        { name: "Shell", mimes: ["text/x-sh", "application/x-sh"], mode: "shell", ext: ["sh", "ksh", "bash"], alias: ["bash", "sh", "zsh"], file: /^PKGBUILD$/ },
        { name: "Sieve", mime: "application/sieve", mode: "sieve", ext: ["siv", "sieve"] },
        { name: "Slim", mimes: ["text/x-slim", "application/x-slim"], mode: "slim", ext: ["slim"] },
        { name: "Smalltalk", mime: "text/x-stsrc", mode: "smalltalk", ext: ["st"] },
        { name: "Smarty", mime: "text/x-smarty", mode: "smarty", ext: ["tpl"] },
        { name: "Solr", mime: "text/x-solr", mode: "solr" },
        { name: "SML", mime: "text/x-sml", mode: "mllike", ext: ["sml", "sig", "fun", "smackspec"] },
        { name: "Soy", mime: "text/x-soy", mode: "soy", ext: ["soy"], alias: ["closure template"] },
        { name: "SPARQL", mime: "application/sparql-query", mode: "sparql", ext: ["rq", "sparql"], alias: ["sparul"] },
        { name: "Spreadsheet", mime: "text/x-spreadsheet", mode: "spreadsheet", alias: ["excel", "formula"] },
        { name: "SQL", mime: "text/x-sql", mode: "sql", ext: ["sql"] },
        { name: "SQLite", mime: "text/x-sqlite", mode: "sql" },
        { name: "Squirrel", mime: "text/x-squirrel", mode: "clike", ext: ["nut"] },
        { name: "Stylus", mime: "text/x-styl", mode: "stylus", ext: ["styl"] },
        { name: "Swift", mime: "text/x-swift", mode: "swift", ext: ["swift"] },
        { name: "sTeX", mime: "text/x-stex", mode: "stex" },
        { name: "LaTeX", mime: "text/x-latex", mode: "stex", ext: ["text", "ltx", "tex"], alias: ["tex"] },
        { name: "SystemVerilog", mime: "text/x-systemverilog", mode: "verilog", ext: ["v", "sv", "svh"] },
        { name: "Tcl", mime: "text/x-tcl", mode: "tcl", ext: ["tcl"] },
        { name: "Textile", mime: "text/x-textile", mode: "textile", ext: ["textile"] },
        { name: "TiddlyWiki", mime: "text/x-tiddlywiki", mode: "tiddlywiki" },
        { name: "Tiki wiki", mime: "text/tiki", mode: "tiki" },
        { name: "TOML", mime: "text/x-toml", mode: "toml", ext: ["toml"] },
        { name: "Tornado", mime: "text/x-tornado", mode: "tornado" },
        { name: "troff", mime: "text/troff", mode: "troff", ext: ["1", "2", "3", "4", "5", "6", "7", "8", "9"] },
        { name: "TTCN", mime: "text/x-ttcn", mode: "ttcn", ext: ["ttcn", "ttcn3", "ttcnpp"] },
        { name: "TTCN_CFG", mime: "text/x-ttcn-cfg", mode: "ttcn-cfg", ext: ["cfg"] },
        { name: "Turtle", mime: "text/turtle", mode: "turtle", ext: ["ttl"] },
        { name: "TypeScript", mime: "application/typescript", mode: "javascript", ext: ["ts"], alias: ["ts"] },
        { name: "TypeScript-JSX", mime: "text/typescript-jsx", mode: "jsx", ext: ["tsx"], alias: ["tsx"] },
        { name: "Twig", mime: "text/x-twig", mode: "twig" },
        { name: "Web IDL", mime: "text/x-webidl", mode: "webidl", ext: ["webidl"] },
        { name: "VB.NET", mime: "text/x-vb", mode: "vb", ext: ["vb"] },
        { name: "VBScript", mime: "text/vbscript", mode: "vbscript", ext: ["vbs"] },
        { name: "Velocity", mime: "text/velocity", mode: "velocity", ext: ["vtl"] },
        { name: "Verilog", mime: "text/x-verilog", mode: "verilog", ext: ["v"] },
        { name: "VHDL", mime: "text/x-vhdl", mode: "vhdl", ext: ["vhd", "vhdl"] },
        { name: "Vue.js Component", mimes: ["script/x-vue", "text/x-vue"], mode: "vue", ext: ["vue"] },
        { name: "XML", mimes: ["application/xml", "text/xml"], mode: "xml", ext: ["xml", "xsl", "xsd", "svg"], alias: ["rss", "wsdl", "xsd"] },
        { name: "XQuery", mime: "application/xquery", mode: "xquery", ext: ["xy", "xquery"] },
        { name: "Yacas", mime: "text/x-yacas", mode: "yacas", ext: ["ys"] },
        { name: "YAML", mimes: ["text/x-yaml", "text/yaml"], mode: "yaml", ext: ["yaml", "yml"], alias: ["yml"] },
        { name: "Z80", mime: "text/x-z80", mode: "z80", ext: ["z80"] },
        { name: "mscgen", mime: "text/x-mscgen", mode: "mscgen", ext: ["mscgen", "mscin", "msc"] },
        { name: "xu", mime: "text/x-xu", mode: "mscgen", ext: ["xu"] },
        { name: "msgenny", mime: "text/x-msgenny", mode: "mscgen", ext: ["msgenny"] },
        { name: "WebAssembly", mime: "text/webassembly", mode: "wast", ext: ["wat", "wast"] }
      ];
      for (var a = 0; a < n.modeInfo.length; a++) {
        var o = n.modeInfo[a];
        o.mimes && (o.mime = o.mimes[0]);
      }
      n.findModeByMIME = function(s) {
        s = s.toLowerCase();
        for (var u = 0; u < n.modeInfo.length; u++) {
          var d = n.modeInfo[u];
          if (d.mime == s) return d;
          if (d.mimes) {
            for (var f = 0; f < d.mimes.length; f++)
              if (d.mimes[f] == s) return d;
          }
        }
        if (/\+xml$/.test(s)) return n.findModeByMIME("application/xml");
        if (/\+json$/.test(s)) return n.findModeByMIME("application/json");
      }, n.findModeByExtension = function(s) {
        s = s.toLowerCase();
        for (var u = 0; u < n.modeInfo.length; u++) {
          var d = n.modeInfo[u];
          if (d.ext) {
            for (var f = 0; f < d.ext.length; f++)
              if (d.ext[f] == s) return d;
          }
        }
      }, n.findModeByFileName = function(s) {
        for (var u = 0; u < n.modeInfo.length; u++) {
          var d = n.modeInfo[u];
          if (d.file && d.file.test(s)) return d;
        }
        var f = s.lastIndexOf("."), g = f > -1 && s.substring(f + 1, s.length);
        if (g) return n.findModeByExtension(g);
      }, n.findModeByName = function(s) {
        s = s.toLowerCase();
        for (var u = 0; u < n.modeInfo.length; u++) {
          var d = n.modeInfo[u];
          if (d.name.toLowerCase() == s) return d;
          if (d.alias) {
            for (var f = 0; f < d.alias.length; f++)
              if (d.alias[f].toLowerCase() == s) return d;
          }
        }
      };
    });
  })()), meta.exports;
}
var hasRequiredMarkdown;
function requireMarkdown() {
  return hasRequiredMarkdown || (hasRequiredMarkdown = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireXml(), requireMeta());
    })(function(n) {
      n.defineMode("markdown", function(a, o) {
        var s = n.getMode(a, "text/html"), u = s.name == "null";
        function d(te) {
          if (n.findModeByName) {
            var G = n.findModeByName(te);
            G && (te = G.mime || G.mimes[0]);
          }
          var ie = n.getMode(a, te);
          return ie.name == "null" ? null : ie;
        }
        o.highlightFormatting === void 0 && (o.highlightFormatting = !1), o.maxBlockquoteDepth === void 0 && (o.maxBlockquoteDepth = 0), o.taskLists === void 0 && (o.taskLists = !1), o.strikethrough === void 0 && (o.strikethrough = !1), o.emoji === void 0 && (o.emoji = !1), o.fencedCodeBlockHighlighting === void 0 && (o.fencedCodeBlockHighlighting = !0), o.fencedCodeBlockDefaultMode === void 0 && (o.fencedCodeBlockDefaultMode = "text/plain"), o.xml === void 0 && (o.xml = !0), o.tokenTypeOverrides === void 0 && (o.tokenTypeOverrides = {});
        var f = {
          header: "header",
          code: "comment",
          quote: "quote",
          list1: "variable-2",
          list2: "variable-3",
          list3: "keyword",
          hr: "hr",
          image: "image",
          imageAltText: "image-alt-text",
          imageMarker: "image-marker",
          formatting: "formatting",
          linkInline: "link",
          linkEmail: "link",
          linkText: "link",
          linkHref: "string",
          em: "em",
          strong: "strong",
          strikethrough: "strikethrough",
          emoji: "builtin"
        };
        for (var g in f)
          f.hasOwnProperty(g) && o.tokenTypeOverrides[g] && (f[g] = o.tokenTypeOverrides[g]);
        var v = /^([*\-_])(?:\s*\1){2,}\s*$/, b = /^(?:[*\-+]|^[0-9]+([.)]))\s+/, w = /^\[(x| )\](?=\s)/i, C = o.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/, k = /^ {0,3}(?:\={1,}|-{2,})\s*$/, E = /^[^#!\[\]*_\\<>` "'(~:]+/, A = /^(~~~+|```+)[ \t]*([\w\/+#-]*)[^\n`]*$/, P = /^\s*\[[^\]]+?\]:.*$/, M = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E42\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDF3C-\uDF3E]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]/, B = "    ";
        function _(te, G, ie) {
          return G.f = G.inline = ie, ie(te, G);
        }
        function T(te, G, ie) {
          return G.f = G.block = ie, ie(te, G);
        }
        function O(te) {
          return !te || !/\S/.test(te.string);
        }
        function I(te) {
          if (te.linkTitle = !1, te.linkHref = !1, te.linkText = !1, te.em = !1, te.strong = !1, te.strikethrough = !1, te.quote = 0, te.indentedCode = !1, te.f == F) {
            var G = u;
            if (!G) {
              var ie = n.innerMode(s, te.htmlState);
              G = ie.mode.name == "xml" && ie.state.tagStart === null && !ie.state.context && ie.state.tokenize.isInText;
            }
            G && (te.f = J, te.block = q, te.htmlState = null);
          }
          return te.trailingSpace = 0, te.trailingSpaceNewLine = !1, te.prevLine = te.thisLine, te.thisLine = { stream: null }, null;
        }
        function q(te, G) {
          var ie = te.column() === G.indentation, oe = O(G.prevLine.stream), ye = G.indentedCode, ve = G.prevLine.hr, ke = G.list !== !1, Ae = (G.listStack[G.listStack.length - 1] || 0) + 3;
          G.indentedCode = !1;
          var be = G.indentation;
          if (G.indentationDiff === null && (G.indentationDiff = G.indentation, ke)) {
            for (G.list = null; be < G.listStack[G.listStack.length - 1]; )
              G.listStack.pop(), G.listStack.length ? G.indentation = G.listStack[G.listStack.length - 1] : G.list = !1;
            G.list !== !1 && (G.indentationDiff = be - G.listStack[G.listStack.length - 1]);
          }
          var Ie = !oe && !ve && !G.prevLine.header && (!ke || !ye) && !G.prevLine.fencedCodeEnd, Se = (G.list === !1 || ve || oe) && G.indentation <= Ae && te.match(v), ze = null;
          if (G.indentationDiff >= 4 && (ye || G.prevLine.fencedCodeEnd || G.prevLine.header || oe))
            return te.skipToEnd(), G.indentedCode = !0, f.code;
          if (te.eatSpace())
            return null;
          if (ie && G.indentation <= Ae && (ze = te.match(C)) && ze[1].length <= 6)
            return G.quote = 0, G.header = ze[1].length, G.thisLine.header = !0, o.highlightFormatting && (G.formatting = "header"), G.f = G.inline, K(G);
          if (G.indentation <= Ae && te.eat(">"))
            return G.quote = ie ? 1 : G.quote + 1, o.highlightFormatting && (G.formatting = "quote"), te.eatSpace(), K(G);
          if (!Se && !G.setext && ie && G.indentation <= Ae && (ze = te.match(b))) {
            var Ne = ze[1] ? "ol" : "ul";
            return G.indentation = be + te.current().length, G.list = !0, G.quote = 0, G.listStack.push(G.indentation), G.em = !1, G.strong = !1, G.code = !1, G.strikethrough = !1, o.taskLists && te.match(w, !1) && (G.taskList = !0), G.f = G.inline, o.highlightFormatting && (G.formatting = ["list", "list-" + Ne]), K(G);
          } else {
            if (ie && G.indentation <= Ae && (ze = te.match(A, !0)))
              return G.quote = 0, G.fencedEndRE = new RegExp(ze[1] + "+ *$"), G.localMode = o.fencedCodeBlockHighlighting && d(ze[2] || o.fencedCodeBlockDefaultMode), G.localMode && (G.localState = n.startState(G.localMode)), G.f = G.block = W, o.highlightFormatting && (G.formatting = "code-block"), G.code = -1, K(G);
            if (
              // if setext set, indicates line after ---/===
              G.setext || // line before ---/===
              (!Ie || !ke) && !G.quote && G.list === !1 && !G.code && !Se && !P.test(te.string) && (ze = te.lookAhead(1)) && (ze = ze.match(k))
            )
              return G.setext ? (G.header = G.setext, G.setext = 0, te.skipToEnd(), o.highlightFormatting && (G.formatting = "header")) : (G.header = ze[0].charAt(0) == "=" ? 1 : 2, G.setext = G.header), G.thisLine.header = !0, G.f = G.inline, K(G);
            if (Se)
              return te.skipToEnd(), G.hr = !0, G.thisLine.hr = !0, f.hr;
            if (te.peek() === "[")
              return _(te, G, z);
          }
          return _(te, G, G.inline);
        }
        function F(te, G) {
          var ie = s.token(te, G.htmlState);
          if (!u) {
            var oe = n.innerMode(s, G.htmlState);
            (oe.mode.name == "xml" && oe.state.tagStart === null && !oe.state.context && oe.state.tokenize.isInText || G.md_inside && te.current().indexOf(">") > -1) && (G.f = J, G.block = q, G.htmlState = null);
          }
          return ie;
        }
        function W(te, G) {
          var ie = G.listStack[G.listStack.length - 1] || 0, oe = G.indentation < ie, ye = ie + 3;
          if (G.fencedEndRE && G.indentation <= ye && (oe || te.match(G.fencedEndRE))) {
            o.highlightFormatting && (G.formatting = "code-block");
            var ve;
            return oe || (ve = K(G)), G.localMode = G.localState = null, G.block = q, G.f = J, G.fencedEndRE = null, G.code = 0, G.thisLine.fencedCodeEnd = !0, oe ? T(te, G, G.block) : ve;
          } else return G.localMode ? G.localMode.token(te, G.localState) : (te.skipToEnd(), f.code);
        }
        function K(te) {
          var G = [];
          if (te.formatting) {
            G.push(f.formatting), typeof te.formatting == "string" && (te.formatting = [te.formatting]);
            for (var ie = 0; ie < te.formatting.length; ie++)
              G.push(f.formatting + "-" + te.formatting[ie]), te.formatting[ie] === "header" && G.push(f.formatting + "-" + te.formatting[ie] + "-" + te.header), te.formatting[ie] === "quote" && (!o.maxBlockquoteDepth || o.maxBlockquoteDepth >= te.quote ? G.push(f.formatting + "-" + te.formatting[ie] + "-" + te.quote) : G.push("error"));
          }
          if (te.taskOpen)
            return G.push("meta"), G.length ? G.join(" ") : null;
          if (te.taskClosed)
            return G.push("property"), G.length ? G.join(" ") : null;
          if (te.linkHref ? G.push(f.linkHref, "url") : (te.strong && G.push(f.strong), te.em && G.push(f.em), te.strikethrough && G.push(f.strikethrough), te.emoji && G.push(f.emoji), te.linkText && G.push(f.linkText), te.code && G.push(f.code), te.image && G.push(f.image), te.imageAltText && G.push(f.imageAltText, "link"), te.imageMarker && G.push(f.imageMarker)), te.header && G.push(f.header, f.header + "-" + te.header), te.quote && (G.push(f.quote), !o.maxBlockquoteDepth || o.maxBlockquoteDepth >= te.quote ? G.push(f.quote + "-" + te.quote) : G.push(f.quote + "-" + o.maxBlockquoteDepth)), te.list !== !1) {
            var oe = (te.listStack.length - 1) % 3;
            oe ? oe === 1 ? G.push(f.list2) : G.push(f.list3) : G.push(f.list1);
          }
          return te.trailingSpaceNewLine ? G.push("trailing-space-new-line") : te.trailingSpace && G.push("trailing-space-" + (te.trailingSpace % 2 ? "a" : "b")), G.length ? G.join(" ") : null;
        }
        function Z(te, G) {
          if (te.match(E, !0))
            return K(G);
        }
        function J(te, G) {
          var ie = G.text(te, G);
          if (typeof ie < "u")
            return ie;
          if (G.list)
            return G.list = null, K(G);
          if (G.taskList) {
            var oe = te.match(w, !0)[1] === " ";
            return oe ? G.taskOpen = !0 : G.taskClosed = !0, o.highlightFormatting && (G.formatting = "task"), G.taskList = !1, K(G);
          }
          if (G.taskOpen = !1, G.taskClosed = !1, G.header && te.match(/^#+$/, !0))
            return o.highlightFormatting && (G.formatting = "header"), K(G);
          var ye = te.next();
          if (G.linkTitle) {
            G.linkTitle = !1;
            var ve = ye;
            ye === "(" && (ve = ")"), ve = (ve + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
            var ke = "^\\s*(?:[^" + ve + "\\\\]+|\\\\\\\\|\\\\.)" + ve;
            if (te.match(new RegExp(ke), !0))
              return f.linkHref;
          }
          if (ye === "`") {
            var Ae = G.formatting;
            o.highlightFormatting && (G.formatting = "code"), te.eatWhile("`");
            var be = te.current().length;
            if (G.code == 0 && (!G.quote || be == 1))
              return G.code = be, K(G);
            if (be == G.code) {
              var Ie = K(G);
              return G.code = 0, Ie;
            } else
              return G.formatting = Ae, K(G);
          } else if (G.code)
            return K(G);
          if (ye === "\\" && (te.next(), o.highlightFormatting)) {
            var Se = K(G), ze = f.formatting + "-escape";
            return Se ? Se + " " + ze : ze;
          }
          if (ye === "!" && te.match(/\[[^\]]*\] ?(?:\(|\[)/, !1))
            return G.imageMarker = !0, G.image = !0, o.highlightFormatting && (G.formatting = "image"), K(G);
          if (ye === "[" && G.imageMarker && te.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, !1))
            return G.imageMarker = !1, G.imageAltText = !0, o.highlightFormatting && (G.formatting = "image"), K(G);
          if (ye === "]" && G.imageAltText) {
            o.highlightFormatting && (G.formatting = "image");
            var Se = K(G);
            return G.imageAltText = !1, G.image = !1, G.inline = G.f = V, Se;
          }
          if (ye === "[" && !G.image)
            return G.linkText && te.match(/^.*?\]/) || (G.linkText = !0, o.highlightFormatting && (G.formatting = "link")), K(G);
          if (ye === "]" && G.linkText) {
            o.highlightFormatting && (G.formatting = "link");
            var Se = K(G);
            return G.linkText = !1, G.inline = G.f = te.match(/\(.*?\)| ?\[.*?\]/, !1) ? V : J, Se;
          }
          if (ye === "<" && te.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) {
            G.f = G.inline = re, o.highlightFormatting && (G.formatting = "link");
            var Se = K(G);
            return Se ? Se += " " : Se = "", Se + f.linkInline;
          }
          if (ye === "<" && te.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) {
            G.f = G.inline = re, o.highlightFormatting && (G.formatting = "link");
            var Se = K(G);
            return Se ? Se += " " : Se = "", Se + f.linkEmail;
          }
          if (o.xml && ye === "<" && te.match(/^(!--|\?|!\[CDATA\[|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*(?:>|$))/i, !1)) {
            var Ne = te.string.indexOf(">", te.pos);
            if (Ne != -1) {
              var tt = te.string.substring(te.start, Ne);
              /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(tt) && (G.md_inside = !0);
            }
            return te.backUp(1), G.htmlState = n.startState(s), T(te, G, F);
          }
          if (o.xml && ye === "<" && te.match(/^\/\w*?>/))
            return G.md_inside = !1, "tag";
          if (ye === "*" || ye === "_") {
            for (var Qe = 1, et = te.pos == 1 ? " " : te.string.charAt(te.pos - 2); Qe < 3 && te.eat(ye); ) Qe++;
            var ce = te.peek() || " ", pe = !/\s/.test(ce) && (!M.test(ce) || /\s/.test(et) || M.test(et)), je = !/\s/.test(et) && (!M.test(et) || /\s/.test(ce) || M.test(ce)), lt = null, Ce = null;
            if (Qe % 2 && (!G.em && pe && (ye === "*" || !je || M.test(et)) ? lt = !0 : G.em == ye && je && (ye === "*" || !pe || M.test(ce)) && (lt = !1)), Qe > 1 && (!G.strong && pe && (ye === "*" || !je || M.test(et)) ? Ce = !0 : G.strong == ye && je && (ye === "*" || !pe || M.test(ce)) && (Ce = !1)), Ce != null || lt != null) {
              o.highlightFormatting && (G.formatting = lt == null ? "strong" : Ce == null ? "em" : "strong em"), lt === !0 && (G.em = ye), Ce === !0 && (G.strong = ye);
              var Ie = K(G);
              return lt === !1 && (G.em = !1), Ce === !1 && (G.strong = !1), Ie;
            }
          } else if (ye === " " && (te.eat("*") || te.eat("_"))) {
            if (te.peek() === " ")
              return K(G);
            te.backUp(1);
          }
          if (o.strikethrough) {
            if (ye === "~" && te.eatWhile(ye)) {
              if (G.strikethrough) {
                o.highlightFormatting && (G.formatting = "strikethrough");
                var Ie = K(G);
                return G.strikethrough = !1, Ie;
              } else if (te.match(/^[^\s]/, !1))
                return G.strikethrough = !0, o.highlightFormatting && (G.formatting = "strikethrough"), K(G);
            } else if (ye === " " && te.match("~~", !0)) {
              if (te.peek() === " ")
                return K(G);
              te.backUp(2);
            }
          }
          if (o.emoji && ye === ":" && te.match(/^(?:[a-z_\d+][a-z_\d+-]*|\-[a-z_\d+][a-z_\d+-]*):/)) {
            G.emoji = !0, o.highlightFormatting && (G.formatting = "emoji");
            var Oe = K(G);
            return G.emoji = !1, Oe;
          }
          return ye === " " && (te.match(/^ +$/, !1) ? G.trailingSpace++ : G.trailingSpace && (G.trailingSpaceNewLine = !0)), K(G);
        }
        function re(te, G) {
          var ie = te.next();
          if (ie === ">") {
            G.f = G.inline = J, o.highlightFormatting && (G.formatting = "link");
            var oe = K(G);
            return oe ? oe += " " : oe = "", oe + f.linkInline;
          }
          return te.match(/^[^>]+/, !0), f.linkInline;
        }
        function V(te, G) {
          if (te.eatSpace())
            return null;
          var ie = te.next();
          return ie === "(" || ie === "[" ? (G.f = G.inline = Q(ie === "(" ? ")" : "]"), o.highlightFormatting && (G.formatting = "link-string"), G.linkHref = !0, K(G)) : "error";
        }
        var ne = {
          ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
          "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
        };
        function Q(te) {
          return function(G, ie) {
            var oe = G.next();
            if (oe === te) {
              ie.f = ie.inline = J, o.highlightFormatting && (ie.formatting = "link-string");
              var ye = K(ie);
              return ie.linkHref = !1, ye;
            }
            return G.match(ne[te]), ie.linkHref = !0, K(ie);
          };
        }
        function z(te, G) {
          return te.match(/^([^\]\\]|\\.)*\]:/, !1) ? (G.f = X, te.next(), o.highlightFormatting && (G.formatting = "link"), G.linkText = !0, K(G)) : _(te, G, J);
        }
        function X(te, G) {
          if (te.match("]:", !0)) {
            G.f = G.inline = ue, o.highlightFormatting && (G.formatting = "link");
            var ie = K(G);
            return G.linkText = !1, ie;
          }
          return te.match(/^([^\]\\]|\\.)+/, !0), f.linkText;
        }
        function ue(te, G) {
          return te.eatSpace() ? null : (te.match(/^[^\s]+/, !0), te.peek() === void 0 ? G.linkTitle = !0 : te.match(/^(?:\s+(?:"(?:[^"\\]|\\.)+"|'(?:[^'\\]|\\.)+'|\((?:[^)\\]|\\.)+\)))?/, !0), G.f = G.inline = J, f.linkHref + " url");
        }
        var Be = {
          startState: function() {
            return {
              f: q,
              prevLine: { stream: null },
              thisLine: { stream: null },
              block: q,
              htmlState: null,
              indentation: 0,
              inline: J,
              text: Z,
              formatting: !1,
              linkText: !1,
              linkHref: !1,
              linkTitle: !1,
              code: 0,
              em: !1,
              strong: !1,
              header: 0,
              setext: 0,
              hr: !1,
              taskList: !1,
              list: !1,
              listStack: [],
              quote: 0,
              trailingSpace: 0,
              trailingSpaceNewLine: !1,
              strikethrough: !1,
              emoji: !1,
              fencedEndRE: null
            };
          },
          copyState: function(te) {
            return {
              f: te.f,
              prevLine: te.prevLine,
              thisLine: te.thisLine,
              block: te.block,
              htmlState: te.htmlState && n.copyState(s, te.htmlState),
              indentation: te.indentation,
              localMode: te.localMode,
              localState: te.localMode ? n.copyState(te.localMode, te.localState) : null,
              inline: te.inline,
              text: te.text,
              formatting: !1,
              linkText: te.linkText,
              linkTitle: te.linkTitle,
              linkHref: te.linkHref,
              code: te.code,
              em: te.em,
              strong: te.strong,
              strikethrough: te.strikethrough,
              emoji: te.emoji,
              header: te.header,
              setext: te.setext,
              hr: te.hr,
              taskList: te.taskList,
              list: te.list,
              listStack: te.listStack.slice(0),
              quote: te.quote,
              indentedCode: te.indentedCode,
              trailingSpace: te.trailingSpace,
              trailingSpaceNewLine: te.trailingSpaceNewLine,
              md_inside: te.md_inside,
              fencedEndRE: te.fencedEndRE
            };
          },
          token: function(te, G) {
            if (G.formatting = !1, te != G.thisLine.stream) {
              if (G.header = 0, G.hr = !1, te.match(/^\s*$/, !0))
                return I(G), null;
              if (G.prevLine = G.thisLine, G.thisLine = { stream: te }, G.taskList = !1, G.trailingSpace = 0, G.trailingSpaceNewLine = !1, !G.localState && (G.f = G.block, G.f != F)) {
                var ie = te.match(/^\s*/, !0)[0].replace(/\t/g, B).length;
                if (G.indentation = ie, G.indentationDiff = null, ie > 0) return null;
              }
            }
            return G.f(te, G);
          },
          innerMode: function(te) {
            return te.block == F ? { state: te.htmlState, mode: s } : te.localState ? { state: te.localState, mode: te.localMode } : { state: te, mode: Be };
          },
          indent: function(te, G, ie) {
            return te.block == F && s.indent ? s.indent(te.htmlState, G, ie) : te.localState && te.localMode.indent ? te.localMode.indent(te.localState, G, ie) : n.Pass;
          },
          blankLine: I,
          getType: K,
          blockCommentStart: "<!--",
          blockCommentEnd: "-->",
          closeBrackets: "()[]{}''\"\"``",
          fold: "markdown"
        };
        return Be;
      }, "xml"), n.defineMIME("text/markdown", "markdown"), n.defineMIME("text/x-markdown", "markdown");
    });
  })()), markdown$2.exports;
}
var overlay = { exports: {} }, hasRequiredOverlay;
function requireOverlay() {
  return hasRequiredOverlay || (hasRequiredOverlay = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.overlayMode = function(a, o, s) {
        return {
          startState: function() {
            return {
              base: n.startState(a),
              overlay: n.startState(o),
              basePos: 0,
              baseCur: null,
              overlayPos: 0,
              overlayCur: null,
              streamSeen: null
            };
          },
          copyState: function(u) {
            return {
              base: n.copyState(a, u.base),
              overlay: n.copyState(o, u.overlay),
              basePos: u.basePos,
              baseCur: null,
              overlayPos: u.overlayPos,
              overlayCur: null
            };
          },
          token: function(u, d) {
            return (u != d.streamSeen || Math.min(d.basePos, d.overlayPos) < u.start) && (d.streamSeen = u, d.basePos = d.overlayPos = u.start), u.start == d.basePos && (d.baseCur = a.token(u, d.base), d.basePos = u.pos), u.start == d.overlayPos && (u.pos = u.start, d.overlayCur = o.token(u, d.overlay), d.overlayPos = u.pos), u.pos = Math.min(d.basePos, d.overlayPos), d.overlayCur == null ? d.baseCur : d.baseCur != null && d.overlay.combineTokens || s && d.overlay.combineTokens == null ? d.baseCur + " " + d.overlayCur : d.overlayCur;
          },
          indent: a.indent && function(u, d, f) {
            return a.indent(u.base, d, f);
          },
          electricChars: a.electricChars,
          innerMode: function(u) {
            return { state: u.base, mode: a };
          },
          blankLine: function(u) {
            var d, f;
            return a.blankLine && (d = a.blankLine(u.base)), o.blankLine && (f = o.blankLine(u.overlay)), f == null ? d : s && d != null ? d + " " + f : f;
          }
        };
      };
    });
  })()), overlay.exports;
}
var hasRequiredGfm;
function requireGfm() {
  return hasRequiredGfm || (hasRequiredGfm = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireMarkdown(), requireOverlay());
    })(function(n) {
      var a = /^((?:(?:aaas?|about|acap|adiumxtra|af[ps]|aim|apt|attachment|aw|beshare|bitcoin|bolo|callto|cap|chrome(?:-extension)?|cid|coap|com-eventbrite-attendee|content|crid|cvs|data|dav|dict|dlna-(?:playcontainer|playsingle)|dns|doi|dtn|dvb|ed2k|facetime|feed|file|finger|fish|ftp|geo|gg|git|gizmoproject|go|gopher|gtalk|h323|hcp|https?|iax|icap|icon|im|imap|info|ipn|ipp|irc[6s]?|iris(?:\.beep|\.lwz|\.xpc|\.xpcs)?|itms|jar|javascript|jms|keyparc|lastfm|ldaps?|magnet|mailto|maps|market|message|mid|mms|ms-help|msnim|msrps?|mtqp|mumble|mupdate|mvn|news|nfs|nih?|nntp|notes|oid|opaquelocktoken|palm|paparazzi|platform|pop|pres|proxy|psyc|query|res(?:ource)?|rmi|rsync|rtmp|rtsp|secondlife|service|session|sftp|sgn|shttp|sieve|sips?|skype|sm[bs]|snmp|soap\.beeps?|soldat|spotify|ssh|steam|svn|tag|teamspeak|tel(?:net)?|tftp|things|thismessage|tip|tn3270|tv|udp|unreal|urn|ut2004|vemmi|ventrilo|view-source|webcal|wss?|wtai|wyciwyg|xcon(?:-userid)?|xfire|xmlrpc\.beeps?|xmpp|xri|ymsgr|z39\.50[rs]?):(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]|\([^\s()<>]*\))+(?:\([^\s()<>]*\)|[^\s`*!()\[\]{};:'".,<>?]))/i;
      n.defineMode("gfm", function(o, s) {
        var u = 0;
        function d(b) {
          return b.code = !1, null;
        }
        var f = {
          startState: function() {
            return {
              code: !1,
              codeBlock: !1,
              ateSpace: !1
            };
          },
          copyState: function(b) {
            return {
              code: b.code,
              codeBlock: b.codeBlock,
              ateSpace: b.ateSpace
            };
          },
          token: function(b, w) {
            if (w.combineTokens = null, w.codeBlock)
              return b.match(/^```+/) ? (w.codeBlock = !1, null) : (b.skipToEnd(), null);
            if (b.sol() && (w.code = !1), b.sol() && b.match(/^```+/))
              return b.skipToEnd(), w.codeBlock = !0, null;
            if (b.peek() === "`") {
              b.next();
              var C = b.pos;
              b.eatWhile("`");
              var k = 1 + b.pos - C;
              return w.code ? k === u && (w.code = !1) : (u = k, w.code = !0), null;
            } else if (w.code)
              return b.next(), null;
            if (b.eatSpace())
              return w.ateSpace = !0, null;
            if ((b.sol() || w.ateSpace) && (w.ateSpace = !1, s.gitHubSpice !== !1)) {
              if (b.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+@)?(?=.{0,6}\d)(?:[a-f0-9]{7,40}\b)/))
                return w.combineTokens = !0, "link";
              if (b.match(/^(?:[a-zA-Z0-9\-_]+\/)?(?:[a-zA-Z0-9\-_]+)?#[0-9]+\b/))
                return w.combineTokens = !0, "link";
            }
            return b.match(a) && b.string.slice(b.start - 2, b.start) != "](" && (b.start == 0 || /\W/.test(b.string.charAt(b.start - 1))) ? (w.combineTokens = !0, "link") : (b.next(), null);
          },
          blankLine: d
        }, g = {
          taskLists: !0,
          strikethrough: !0,
          emoji: !0
        };
        for (var v in s)
          g[v] = s[v];
        return g.name = "markdown", n.overlayMode(n.getMode(o, g), f);
      }, "markdown"), n.defineMIME("text/x-gfm", "gfm");
    });
  })()), gfm.exports;
}
requireGfm();
var handlebars = { exports: {} }, simple = { exports: {} }, hasRequiredSimple;
function requireSimple() {
  return hasRequiredSimple || (hasRequiredSimple = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineSimpleMode = function(w, C) {
        n.defineMode(w, function(k) {
          return n.simpleMode(k, C);
        });
      }, n.simpleMode = function(w, C) {
        a(C, "start");
        var k = {}, E = C.meta || {}, A = !1;
        for (var P in C) if (P != E && C.hasOwnProperty(P))
          for (var M = k[P] = [], B = C[P], _ = 0; _ < B.length; _++) {
            var T = B[_];
            M.push(new u(T, C)), (T.indent || T.dedent) && (A = !0);
          }
        var O = {
          startState: function() {
            return {
              state: "start",
              pending: null,
              local: null,
              localState: null,
              indent: A ? [] : null
            };
          },
          copyState: function(q) {
            var F = {
              state: q.state,
              pending: q.pending,
              local: q.local,
              localState: null,
              indent: q.indent && q.indent.slice(0)
            };
            q.localState && (F.localState = n.copyState(q.local.mode, q.localState)), q.stack && (F.stack = q.stack.slice(0));
            for (var W = q.persistentStates; W; W = W.next)
              F.persistentStates = {
                mode: W.mode,
                spec: W.spec,
                state: W.state == q.localState ? F.localState : n.copyState(W.mode, W.state),
                next: F.persistentStates
              };
            return F;
          },
          token: d(k, w),
          innerMode: function(q) {
            return q.local && { mode: q.local.mode, state: q.localState };
          },
          indent: b(k, E)
        };
        if (E) for (var I in E) E.hasOwnProperty(I) && (O[I] = E[I]);
        return O;
      };
      function a(w, C) {
        if (!w.hasOwnProperty(C))
          throw new Error("Undefined state " + C + " in simple mode");
      }
      function o(w, C) {
        if (!w) return /(?:)/;
        var k = "";
        return w instanceof RegExp ? (w.ignoreCase && (k = "i"), w.unicode && (k += "u"), w = w.source) : w = String(w), new RegExp((C === !1 ? "" : "^") + "(?:" + w + ")", k);
      }
      function s(w) {
        if (!w) return null;
        if (w.apply) return w;
        if (typeof w == "string") return w.replace(/\./g, " ");
        for (var C = [], k = 0; k < w.length; k++)
          C.push(w[k] && w[k].replace(/\./g, " "));
        return C;
      }
      function u(w, C) {
        (w.next || w.push) && a(C, w.next || w.push), this.regex = o(w.regex), this.token = s(w.token), this.data = w;
      }
      function d(w, C) {
        return function(k, E) {
          if (E.pending) {
            var A = E.pending.shift();
            return E.pending.length == 0 && (E.pending = null), k.pos += A.text.length, A.token;
          }
          if (E.local)
            if (E.local.end && k.match(E.local.end)) {
              var P = E.local.endToken || null;
              return E.local = E.localState = null, P;
            } else {
              var P = E.local.mode.token(k, E.localState), M;
              return E.local.endScan && (M = E.local.endScan.exec(k.current())) && (k.pos = k.start + M.index), P;
            }
          for (var B = w[E.state], _ = 0; _ < B.length; _++) {
            var T = B[_], O = (!T.data.sol || k.sol()) && k.match(T.regex);
            if (O) {
              T.data.next ? E.state = T.data.next : T.data.push ? ((E.stack || (E.stack = [])).push(E.state), E.state = T.data.push) : T.data.pop && E.stack && E.stack.length && (E.state = E.stack.pop()), T.data.mode && g(C, E, T.data.mode, T.token), T.data.indent && E.indent.push(k.indentation() + C.indentUnit), T.data.dedent && E.indent.pop();
              var I = T.token;
              if (I && I.apply && (I = I(O)), O.length > 2 && T.token && typeof T.token != "string") {
                for (var q = 2; q < O.length; q++)
                  O[q] && (E.pending || (E.pending = [])).push({ text: O[q], token: T.token[q - 1] });
                return k.backUp(O[0].length - (O[1] ? O[1].length : 0)), I[0];
              } else return I && I.join ? I[0] : I;
            }
          }
          return k.next(), null;
        };
      }
      function f(w, C) {
        if (w === C) return !0;
        if (!w || typeof w != "object" || !C || typeof C != "object") return !1;
        var k = 0;
        for (var E in w) if (w.hasOwnProperty(E)) {
          if (!C.hasOwnProperty(E) || !f(w[E], C[E])) return !1;
          k++;
        }
        for (var E in C) C.hasOwnProperty(E) && k--;
        return k == 0;
      }
      function g(w, C, k, E) {
        var A;
        if (k.persistent) for (var P = C.persistentStates; P && !A; P = P.next)
          (k.spec ? f(k.spec, P.spec) : k.mode == P.mode) && (A = P);
        var M = A ? A.mode : k.mode || n.getMode(w, k.spec), B = A ? A.state : n.startState(M);
        k.persistent && !A && (C.persistentStates = { mode: M, spec: k.spec, state: B, next: C.persistentStates }), C.localState = B, C.local = {
          mode: M,
          end: k.end && o(k.end),
          endScan: k.end && k.forceEnd !== !1 && o(k.end, !1),
          endToken: E && E.join ? E[E.length - 1] : E
        };
      }
      function v(w, C) {
        for (var k = 0; k < C.length; k++) if (C[k] === w) return !0;
      }
      function b(w, C) {
        return function(k, E, A) {
          if (k.local && k.local.mode.indent)
            return k.local.mode.indent(k.localState, E, A);
          if (k.indent == null || k.local || C.dontIndentStates && v(k.state, C.dontIndentStates) > -1)
            return n.Pass;
          var P = k.indent.length - 1, M = w[k.state];
          e: for (; ; ) {
            for (var B = 0; B < M.length; B++) {
              var _ = M[B];
              if (_.data.dedent && _.data.dedentIfLineStart !== !1) {
                var T = _.regex.exec(E);
                if (T && T[0]) {
                  P--, (_.next || _.push) && (M = w[_.next || _.push]), E = E.slice(T[0].length);
                  continue e;
                }
              }
            }
            break;
          }
          return P < 0 ? 0 : k.indent[P];
        };
      }
    });
  })()), simple.exports;
}
var multiplex = { exports: {} }, hasRequiredMultiplex;
function requireMultiplex() {
  return hasRequiredMultiplex || (hasRequiredMultiplex = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.multiplexingMode = function(a) {
        var o = Array.prototype.slice.call(arguments, 1);
        function s(u, d, f, g) {
          if (typeof d == "string") {
            var v = u.indexOf(d, f);
            return g && v > -1 ? v + d.length : v;
          }
          var b = d.exec(f ? u.slice(f) : u);
          return b ? b.index + f + (g ? b[0].length : 0) : -1;
        }
        return {
          startState: function() {
            return {
              outer: n.startState(a),
              innerActive: null,
              inner: null,
              startingInner: !1
            };
          },
          copyState: function(u) {
            return {
              outer: n.copyState(a, u.outer),
              innerActive: u.innerActive,
              inner: u.innerActive && n.copyState(u.innerActive.mode, u.inner),
              startingInner: u.startingInner
            };
          },
          token: function(u, d) {
            if (d.innerActive) {
              var A = d.innerActive, g = u.string;
              if (!A.close && u.sol())
                return d.innerActive = d.inner = null, this.token(u, d);
              var w = A.close && !d.startingInner ? s(g, A.close, u.pos, A.parseDelimiters) : -1;
              if (w == u.pos && !A.parseDelimiters)
                return u.match(A.close), d.innerActive = d.inner = null, A.delimStyle && A.delimStyle + " " + A.delimStyle + "-close";
              w > -1 && (u.string = g.slice(0, w));
              var P = A.mode.token(u, d.inner);
              return w > -1 ? u.string = g : u.pos > u.start && (d.startingInner = !1), w == u.pos && A.parseDelimiters && (d.innerActive = d.inner = null), A.innerStyle && (P ? P = P + " " + A.innerStyle : P = A.innerStyle), P;
            } else {
              for (var f = 1 / 0, g = u.string, v = 0; v < o.length; ++v) {
                var b = o[v], w = s(g, b.open, u.pos);
                if (w == u.pos) {
                  b.parseDelimiters || u.match(b.open), d.startingInner = !!b.parseDelimiters, d.innerActive = b;
                  var C = 0;
                  if (a.indent) {
                    var k = a.indent(d.outer, "", "");
                    k !== n.Pass && (C = k);
                  }
                  return d.inner = n.startState(b.mode, C), b.delimStyle && b.delimStyle + " " + b.delimStyle + "-open";
                } else w != -1 && w < f && (f = w);
              }
              f != 1 / 0 && (u.string = g.slice(0, f));
              var E = a.token(u, d.outer);
              return f != 1 / 0 && (u.string = g), E;
            }
          },
          indent: function(u, d, f) {
            var g = u.innerActive ? u.innerActive.mode : a;
            return g.indent ? g.indent(u.innerActive ? u.inner : u.outer, d, f) : n.Pass;
          },
          blankLine: function(u) {
            var d = u.innerActive ? u.innerActive.mode : a;
            if (d.blankLine && d.blankLine(u.innerActive ? u.inner : u.outer), u.innerActive)
              u.innerActive.close === `
` && (u.innerActive = u.inner = null);
            else for (var f = 0; f < o.length; ++f) {
              var g = o[f];
              g.open === `
` && (u.innerActive = g, u.inner = n.startState(g.mode, d.indent ? d.indent(u.outer, "", "") : 0));
            }
          },
          electricChars: a.electricChars,
          innerMode: function(u) {
            return u.inner ? { state: u.inner, mode: u.innerActive.mode } : { state: u.outer, mode: a };
          }
        };
      };
    });
  })()), multiplex.exports;
}
var hasRequiredHandlebars;
function requireHandlebars() {
  return hasRequiredHandlebars || (hasRequiredHandlebars = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireSimple(), requireMultiplex());
    })(function(n) {
      n.defineSimpleMode("handlebars-tags", {
        start: [
          { regex: /\{\{\{/, push: "handlebars_raw", token: "tag" },
          { regex: /\{\{!--/, push: "dash_comment", token: "comment" },
          { regex: /\{\{!/, push: "comment", token: "comment" },
          { regex: /\{\{/, push: "handlebars", token: "tag" }
        ],
        handlebars_raw: [
          { regex: /\}\}\}/, pop: !0, token: "tag" }
        ],
        handlebars: [
          { regex: /\}\}/, pop: !0, token: "tag" },
          // Double and single quotes
          { regex: /"(?:[^\\"]|\\.)*"?/, token: "string" },
          { regex: /'(?:[^\\']|\\.)*'?/, token: "string" },
          // Handlebars keywords
          { regex: />|[#\/]([A-Za-z_]\w*)/, token: "keyword" },
          { regex: /(?:else|this)\b/, token: "keyword" },
          // Numeral
          { regex: /\d+/i, token: "number" },
          // Atoms like = and .
          { regex: /=|~|@|true|false/, token: "atom" },
          // Paths
          { regex: /(?:\.\.\/)*(?:[A-Za-z_][\w\.]*)+/, token: "variable-2" }
        ],
        dash_comment: [
          { regex: /--\}\}/, pop: !0, token: "comment" },
          // Commented code
          { regex: /./, token: "comment" }
        ],
        comment: [
          { regex: /\}\}/, pop: !0, token: "comment" },
          { regex: /./, token: "comment" }
        ],
        meta: {
          blockCommentStart: "{{--",
          blockCommentEnd: "--}}"
        }
      }), n.defineMode("handlebars", function(a, o) {
        var s = n.getMode(a, "handlebars-tags");
        return !o || !o.base ? s : n.multiplexingMode(
          n.getMode(a, o.base),
          { open: "{{", close: /\}\}\}?/, mode: s, parseDelimiters: !0 }
        );
      }), n.defineMIME("text/x-handlebars-template", "handlebars");
    });
  })()), handlebars.exports;
}
requireHandlebars();
var haml = { exports: {} }, htmlmixed = { exports: {} }, javascript = { exports: {} }, hasRequiredJavascript;
function requireJavascript() {
  return hasRequiredJavascript || (hasRequiredJavascript = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("javascript", function(a, o) {
        var s = a.indentUnit, u = o.statementIndent, d = o.jsonld, f = o.json || d, g = o.trackScope !== !1, v = o.typescript, b = o.wordCharacters || /[\w$\xa1-\uffff]/, w = (function() {
          function ee(It) {
            return { type: It, style: "keyword" };
          }
          var ge = ee("keyword a"), xe = ee("keyword b"), De = ee("keyword c"), ht = ee("keyword d"), xt = ee("operator"), St = { type: "atom", style: "atom" };
          return {
            if: ee("if"),
            while: ge,
            with: ge,
            else: xe,
            do: xe,
            try: xe,
            finally: xe,
            return: ht,
            break: ht,
            continue: ht,
            new: ee("new"),
            delete: De,
            void: De,
            throw: De,
            debugger: ee("debugger"),
            var: ee("var"),
            const: ee("var"),
            let: ee("var"),
            function: ee("function"),
            catch: ee("catch"),
            for: ee("for"),
            switch: ee("switch"),
            case: ee("case"),
            default: ee("default"),
            in: xt,
            typeof: xt,
            instanceof: xt,
            true: St,
            false: St,
            null: St,
            undefined: St,
            NaN: St,
            Infinity: St,
            this: ee("this"),
            class: ee("class"),
            super: ee("atom"),
            yield: De,
            export: ee("export"),
            import: ee("import"),
            extends: De,
            await: De
          };
        })(), C = /[+\-*&%=<>!?|~^@]/, k = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
        function E(ee) {
          for (var ge = !1, xe, De = !1; (xe = ee.next()) != null; ) {
            if (!ge) {
              if (xe == "/" && !De) return;
              xe == "[" ? De = !0 : De && xe == "]" && (De = !1);
            }
            ge = !ge && xe == "\\";
          }
        }
        var A, P;
        function M(ee, ge, xe) {
          return A = ee, P = xe, ge;
        }
        function B(ee, ge) {
          var xe = ee.next();
          if (xe == '"' || xe == "'")
            return ge.tokenize = _(xe), ge.tokenize(ee, ge);
          if (xe == "." && ee.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/))
            return M("number", "number");
          if (xe == "." && ee.match(".."))
            return M("spread", "meta");
          if (/[\[\]{}\(\),;\:\.]/.test(xe))
            return M(xe);
          if (xe == "=" && ee.eat(">"))
            return M("=>", "operator");
          if (xe == "0" && ee.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/))
            return M("number", "number");
          if (/\d/.test(xe))
            return ee.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/), M("number", "number");
          if (xe == "/")
            return ee.eat("*") ? (ge.tokenize = T, T(ee, ge)) : ee.eat("/") ? (ee.skipToEnd(), M("comment", "comment")) : jt(ee, ge, 1) ? (E(ee), ee.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/), M("regexp", "string-2")) : (ee.eat("="), M("operator", "operator", ee.current()));
          if (xe == "`")
            return ge.tokenize = O, O(ee, ge);
          if (xe == "#" && ee.peek() == "!")
            return ee.skipToEnd(), M("meta", "meta");
          if (xe == "#" && ee.eatWhile(b))
            return M("variable", "property");
          if (xe == "<" && ee.match("!--") || xe == "-" && ee.match("->") && !/\S/.test(ee.string.slice(0, ee.start)))
            return ee.skipToEnd(), M("comment", "comment");
          if (C.test(xe))
            return (xe != ">" || !ge.lexical || ge.lexical.type != ">") && (ee.eat("=") ? (xe == "!" || xe == "=") && ee.eat("=") : /[<>*+\-|&?]/.test(xe) && (ee.eat(xe), xe == ">" && ee.eat(xe))), xe == "?" && ee.eat(".") ? M(".") : M("operator", "operator", ee.current());
          if (b.test(xe)) {
            ee.eatWhile(b);
            var De = ee.current();
            if (ge.lastType != ".") {
              if (w.propertyIsEnumerable(De)) {
                var ht = w[De];
                return M(ht.type, ht.style, De);
              }
              if (De == "async" && ee.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, !1))
                return M("async", "keyword", De);
            }
            return M("variable", "variable", De);
          }
        }
        function _(ee) {
          return function(ge, xe) {
            var De = !1, ht;
            if (d && ge.peek() == "@" && ge.match(k))
              return xe.tokenize = B, M("jsonld-keyword", "meta");
            for (; (ht = ge.next()) != null && !(ht == ee && !De); )
              De = !De && ht == "\\";
            return De || (xe.tokenize = B), M("string", "string");
          };
        }
        function T(ee, ge) {
          for (var xe = !1, De; De = ee.next(); ) {
            if (De == "/" && xe) {
              ge.tokenize = B;
              break;
            }
            xe = De == "*";
          }
          return M("comment", "comment");
        }
        function O(ee, ge) {
          for (var xe = !1, De; (De = ee.next()) != null; ) {
            if (!xe && (De == "`" || De == "$" && ee.eat("{"))) {
              ge.tokenize = B;
              break;
            }
            xe = !xe && De == "\\";
          }
          return M("quasi", "string-2", ee.current());
        }
        var I = "([{}])";
        function q(ee, ge) {
          ge.fatArrowAt && (ge.fatArrowAt = null);
          var xe = ee.string.indexOf("=>", ee.start);
          if (!(xe < 0)) {
            if (v) {
              var De = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(ee.string.slice(ee.start, xe));
              De && (xe = De.index);
            }
            for (var ht = 0, xt = !1, St = xe - 1; St >= 0; --St) {
              var It = ee.string.charAt(St), vn = I.indexOf(It);
              if (vn >= 0 && vn < 3) {
                if (!ht) {
                  ++St;
                  break;
                }
                if (--ht == 0) {
                  It == "(" && (xt = !0);
                  break;
                }
              } else if (vn >= 3 && vn < 6)
                ++ht;
              else if (b.test(It))
                xt = !0;
              else if (/["'\/`]/.test(It))
                for (; ; --St) {
                  if (St == 0) return;
                  var mt = ee.string.charAt(St - 1);
                  if (mt == It && ee.string.charAt(St - 2) != "\\") {
                    St--;
                    break;
                  }
                }
              else if (xt && !ht) {
                ++St;
                break;
              }
            }
            xt && !ht && (ge.fatArrowAt = St);
          }
        }
        var F = {
          atom: !0,
          number: !0,
          variable: !0,
          string: !0,
          regexp: !0,
          this: !0,
          import: !0,
          "jsonld-keyword": !0
        };
        function W(ee, ge, xe, De, ht, xt) {
          this.indented = ee, this.column = ge, this.type = xe, this.prev = ht, this.info = xt, De != null && (this.align = De);
        }
        function K(ee, ge) {
          if (!g) return !1;
          for (var xe = ee.localVars; xe; xe = xe.next)
            if (xe.name == ge) return !0;
          for (var De = ee.context; De; De = De.prev)
            for (var xe = De.vars; xe; xe = xe.next)
              if (xe.name == ge) return !0;
        }
        function Z(ee, ge, xe, De, ht) {
          var xt = ee.cc;
          for (J.state = ee, J.stream = ht, J.marked = null, J.cc = xt, J.style = ge, ee.lexical.hasOwnProperty("align") || (ee.lexical.align = !0); ; ) {
            var St = xt.length ? xt.pop() : f ? Ie : Ae;
            if (St(xe, De)) {
              for (; xt.length && xt[xt.length - 1].lex; )
                xt.pop()();
              return J.marked ? J.marked : xe == "variable" && K(ee, De) ? "variable-2" : ge;
            }
          }
        }
        var J = { state: null, marked: null, cc: null };
        function re() {
          for (var ee = arguments.length - 1; ee >= 0; ee--) J.cc.push(arguments[ee]);
        }
        function V() {
          return re.apply(null, arguments), !0;
        }
        function ne(ee, ge) {
          for (var xe = ge; xe; xe = xe.next) if (xe.name == ee) return !0;
          return !1;
        }
        function Q(ee) {
          var ge = J.state;
          if (J.marked = "def", !!g) {
            if (ge.context) {
              if (ge.lexical.info == "var" && ge.context && ge.context.block) {
                var xe = z(ee, ge.context);
                if (xe != null) {
                  ge.context = xe;
                  return;
                }
              } else if (!ne(ee, ge.localVars)) {
                ge.localVars = new Be(ee, ge.localVars);
                return;
              }
            }
            o.globalVars && !ne(ee, ge.globalVars) && (ge.globalVars = new Be(ee, ge.globalVars));
          }
        }
        function z(ee, ge) {
          if (ge)
            if (ge.block) {
              var xe = z(ee, ge.prev);
              return xe ? xe == ge.prev ? ge : new ue(xe, ge.vars, !0) : null;
            } else return ne(ee, ge.vars) ? ge : new ue(ge.prev, new Be(ee, ge.vars), !1);
          else return null;
        }
        function X(ee) {
          return ee == "public" || ee == "private" || ee == "protected" || ee == "abstract" || ee == "readonly";
        }
        function ue(ee, ge, xe) {
          this.prev = ee, this.vars = ge, this.block = xe;
        }
        function Be(ee, ge) {
          this.name = ee, this.next = ge;
        }
        var te = new Be("this", new Be("arguments", null));
        function G() {
          J.state.context = new ue(J.state.context, J.state.localVars, !1), J.state.localVars = te;
        }
        function ie() {
          J.state.context = new ue(J.state.context, J.state.localVars, !0), J.state.localVars = null;
        }
        G.lex = ie.lex = !0;
        function oe() {
          J.state.localVars = J.state.context.vars, J.state.context = J.state.context.prev;
        }
        oe.lex = !0;
        function ye(ee, ge) {
          var xe = function() {
            var De = J.state, ht = De.indented;
            if (De.lexical.type == "stat") ht = De.lexical.indented;
            else for (var xt = De.lexical; xt && xt.type == ")" && xt.align; xt = xt.prev)
              ht = xt.indented;
            De.lexical = new W(ht, J.stream.column(), ee, null, De.lexical, ge);
          };
          return xe.lex = !0, xe;
        }
        function ve() {
          var ee = J.state;
          ee.lexical.prev && (ee.lexical.type == ")" && (ee.indented = ee.lexical.indented), ee.lexical = ee.lexical.prev);
        }
        ve.lex = !0;
        function ke(ee) {
          function ge(xe) {
            return xe == ee ? V() : ee == ";" || xe == "}" || xe == ")" || xe == "]" ? re() : V(ge);
          }
          return ge;
        }
        function Ae(ee, ge) {
          return ee == "var" ? V(ye("vardef", ge), Dn, ke(";"), ve) : ee == "keyword a" ? V(ye("form"), ze, Ae, ve) : ee == "keyword b" ? V(ye("form"), Ae, ve) : ee == "keyword d" ? J.stream.match(/^\s*$/, !1) ? V() : V(ye("stat"), tt, ke(";"), ve) : ee == "debugger" ? V(ke(";")) : ee == "{" ? V(ye("}"), ie, Ze, ve, oe) : ee == ";" ? V() : ee == "if" ? (J.state.lexical.info == "else" && J.state.cc[J.state.cc.length - 1] == ve && J.state.cc.pop()(), V(ye("form"), ze, Ae, ve, un)) : ee == "function" ? V(gn) : ee == "for" ? V(ye("form"), ie, Lr, Ae, oe, ve) : ee == "class" || v && ge == "interface" ? (J.marked = "keyword", V(ye("form", ee == "class" ? ee : ge), xr, ve)) : ee == "variable" ? v && ge == "declare" ? (J.marked = "keyword", V(Ae)) : v && (ge == "module" || ge == "enum" || ge == "type") && J.stream.match(/^\s*\w/, !1) ? (J.marked = "keyword", ge == "enum" ? V(nr) : ge == "type" ? V(yr, ke("operator"), qe, ke(";")) : V(ye("form"), on, ke("{"), ye("}"), Ze, ve, ve)) : v && ge == "namespace" ? (J.marked = "keyword", V(ye("form"), Ie, Ae, ve)) : v && ge == "abstract" ? (J.marked = "keyword", V(Ae)) : V(ye("stat"), ot) : ee == "switch" ? V(
            ye("form"),
            ze,
            ke("{"),
            ye("}", "switch"),
            ie,
            Ze,
            ve,
            ve,
            oe
          ) : ee == "case" ? V(Ie, ke(":")) : ee == "default" ? V(ke(":")) : ee == "catch" ? V(ye("form"), G, be, Ae, ve, oe) : ee == "export" ? V(ye("stat"), Mn, ve) : ee == "import" ? V(ye("stat"), On, ve) : ee == "async" ? V(Ae) : ge == "@" ? V(Ie, Ae) : re(ye("stat"), Ie, ke(";"), ve);
        }
        function be(ee) {
          if (ee == "(") return V(Sn, ke(")"));
        }
        function Ie(ee, ge) {
          return Ne(ee, ge, !1);
        }
        function Se(ee, ge) {
          return Ne(ee, ge, !0);
        }
        function ze(ee) {
          return ee != "(" ? re() : V(ye(")"), tt, ke(")"), ve);
        }
        function Ne(ee, ge, xe) {
          if (J.state.fatArrowAt == J.stream.start) {
            var De = xe ? lt : je;
            if (ee == "(") return V(G, ye(")"), de(Sn, ")"), ve, ke("=>"), De, oe);
            if (ee == "variable") return re(G, on, ke("=>"), De, oe);
          }
          var ht = xe ? et : Qe;
          return F.hasOwnProperty(ee) ? V(ht) : ee == "function" ? V(gn, ht) : ee == "class" || v && ge == "interface" ? (J.marked = "keyword", V(ye("form"), jn, ve)) : ee == "keyword c" || ee == "async" ? V(xe ? Se : Ie) : ee == "(" ? V(ye(")"), tt, ke(")"), ve, ht) : ee == "operator" || ee == "spread" ? V(xe ? Se : Ie) : ee == "[" ? V(ye("]"), Ln, ve, ht) : ee == "{" ? Fe(Ge, "}", null, ht) : ee == "quasi" ? re(ce, ht) : ee == "new" ? V(Ce(xe)) : V();
        }
        function tt(ee) {
          return ee.match(/[;\}\)\],]/) ? re() : re(Ie);
        }
        function Qe(ee, ge) {
          return ee == "," ? V(tt) : et(ee, ge, !1);
        }
        function et(ee, ge, xe) {
          var De = xe == !1 ? Qe : et, ht = xe == !1 ? Ie : Se;
          if (ee == "=>") return V(G, xe ? lt : je, oe);
          if (ee == "operator")
            return /\+\+|--/.test(ge) || v && ge == "!" ? V(De) : v && ge == "<" && J.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, !1) ? V(ye(">"), de(qe, ">"), ve, De) : ge == "?" ? V(Ie, ke(":"), ht) : V(ht);
          if (ee == "quasi")
            return re(ce, De);
          if (ee != ";") {
            if (ee == "(") return Fe(Se, ")", "call", De);
            if (ee == ".") return V(We, De);
            if (ee == "[") return V(ye("]"), tt, ke("]"), ve, De);
            if (v && ge == "as")
              return J.marked = "keyword", V(qe, De);
            if (ee == "regexp")
              return J.state.lastType = J.marked = "operator", J.stream.backUp(J.stream.pos - J.stream.start - 1), V(ht);
          }
        }
        function ce(ee, ge) {
          return ee != "quasi" ? re() : ge.slice(ge.length - 2) != "${" ? V(ce) : V(tt, pe);
        }
        function pe(ee) {
          if (ee == "}")
            return J.marked = "string-2", J.state.tokenize = O, V(ce);
        }
        function je(ee) {
          return q(J.stream, J.state), re(ee == "{" ? Ae : Ie);
        }
        function lt(ee) {
          return q(J.stream, J.state), re(ee == "{" ? Ae : Se);
        }
        function Ce(ee) {
          return function(ge) {
            return ge == "." ? V(ee ? Te : Oe) : ge == "variable" && v ? V(Ut, ee ? et : Qe) : re(ee ? Se : Ie);
          };
        }
        function Oe(ee, ge) {
          if (ge == "target")
            return J.marked = "keyword", V(Qe);
        }
        function Te(ee, ge) {
          if (ge == "target")
            return J.marked = "keyword", V(et);
        }
        function ot(ee) {
          return ee == ":" ? V(ve, Ae) : re(Qe, ke(";"), ve);
        }
        function We(ee) {
          if (ee == "variable")
            return J.marked = "property", V();
        }
        function Ge(ee, ge) {
          if (ee == "async")
            return J.marked = "property", V(Ge);
          if (ee == "variable" || J.style == "keyword") {
            if (J.marked = "property", ge == "get" || ge == "set") return V(He);
            var xe;
            return v && J.state.fatArrowAt == J.stream.start && (xe = J.stream.match(/^\s*:\s*/, !1)) && (J.state.fatArrowAt = J.stream.pos + xe[0].length), V(me);
          } else {
            if (ee == "number" || ee == "string")
              return J.marked = d ? "property" : J.style + " property", V(me);
            if (ee == "jsonld-keyword")
              return V(me);
            if (v && X(ge))
              return J.marked = "keyword", V(Ge);
            if (ee == "[")
              return V(Ie, $e, ke("]"), me);
            if (ee == "spread")
              return V(Se, me);
            if (ge == "*")
              return J.marked = "keyword", V(Ge);
            if (ee == ":")
              return re(me);
          }
        }
        function He(ee) {
          return ee != "variable" ? re(me) : (J.marked = "property", V(gn));
        }
        function me(ee) {
          if (ee == ":") return V(Se);
          if (ee == "(") return re(gn);
        }
        function de(ee, ge, xe) {
          function De(ht, xt) {
            if (xe ? xe.indexOf(ht) > -1 : ht == ",") {
              var St = J.state.lexical;
              return St.info == "call" && (St.pos = (St.pos || 0) + 1), V(function(It, vn) {
                return It == ge || vn == ge ? re() : re(ee);
              }, De);
            }
            return ht == ge || xt == ge ? V() : xe && xe.indexOf(";") > -1 ? re(ee) : V(ke(ge));
          }
          return function(ht, xt) {
            return ht == ge || xt == ge ? V() : re(ee, De);
          };
        }
        function Fe(ee, ge, xe) {
          for (var De = 3; De < arguments.length; De++)
            J.cc.push(arguments[De]);
          return V(ye(ge, xe), de(ee, ge), ve);
        }
        function Ze(ee) {
          return ee == "}" ? V() : re(Ae, Ze);
        }
        function $e(ee, ge) {
          if (v) {
            if (ee == ":") return V(qe);
            if (ge == "?") return V($e);
          }
        }
        function ct(ee, ge) {
          if (v && (ee == ":" || ge == "in")) return V(qe);
        }
        function Je(ee) {
          if (v && ee == ":")
            return J.stream.match(/^\s*\w+\s+is\b/, !1) ? V(Ie, wt, qe) : V(qe);
        }
        function wt(ee, ge) {
          if (ge == "is")
            return J.marked = "keyword", V();
        }
        function qe(ee, ge) {
          if (ge == "keyof" || ge == "typeof" || ge == "infer" || ge == "readonly")
            return J.marked = "keyword", V(ge == "typeof" ? Se : qe);
          if (ee == "variable" || ge == "void")
            return J.marked = "type", V(an);
          if (ge == "|" || ge == "&") return V(qe);
          if (ee == "string" || ee == "number" || ee == "atom") return V(an);
          if (ee == "[") return V(ye("]"), de(qe, "]", ","), ve, an);
          if (ee == "{") return V(ye("}"), Mt, ve, an);
          if (ee == "(") return V(de(rn, ")"), $t, an);
          if (ee == "<") return V(de(qe, ">"), qe);
          if (ee == "quasi")
            return re(yt, an);
        }
        function $t(ee) {
          if (ee == "=>") return V(qe);
        }
        function Mt(ee) {
          return ee.match(/[\}\)\]]/) ? V() : ee == "," || ee == ";" ? V(Mt) : re(Tt, Mt);
        }
        function Tt(ee, ge) {
          if (ee == "variable" || J.style == "keyword")
            return J.marked = "property", V(Tt);
          if (ge == "?" || ee == "number" || ee == "string")
            return V(Tt);
          if (ee == ":")
            return V(qe);
          if (ee == "[")
            return V(ke("variable"), ct, ke("]"), Tt);
          if (ee == "(")
            return re(Tn, Tt);
          if (!ee.match(/[;\}\)\],]/))
            return V();
        }
        function yt(ee, ge) {
          return ee != "quasi" ? re() : ge.slice(ge.length - 2) != "${" ? V(yt) : V(qe, Qn);
        }
        function Qn(ee) {
          if (ee == "}")
            return J.marked = "string-2", J.state.tokenize = O, V(yt);
        }
        function rn(ee, ge) {
          return ee == "variable" && J.stream.match(/^\s*[?:]/, !1) || ge == "?" ? V(rn) : ee == ":" ? V(qe) : ee == "spread" ? V(rn) : re(qe);
        }
        function an(ee, ge) {
          if (ge == "<") return V(ye(">"), de(qe, ">"), ve, an);
          if (ge == "|" || ee == "." || ge == "&") return V(qe);
          if (ee == "[") return V(qe, ke("]"), an);
          if (ge == "extends" || ge == "implements")
            return J.marked = "keyword", V(qe);
          if (ge == "?") return V(qe, ke(":"), qe);
        }
        function Ut(ee, ge) {
          if (ge == "<") return V(ye(">"), de(qe, ">"), ve, an);
        }
        function Fn() {
          return re(qe, mr);
        }
        function mr(ee, ge) {
          if (ge == "=") return V(qe);
        }
        function Dn(ee, ge) {
          return ge == "enum" ? (J.marked = "keyword", V(nr)) : re(on, $e, fn, sa);
        }
        function on(ee, ge) {
          if (v && X(ge))
            return J.marked = "keyword", V(on);
          if (ee == "variable")
            return Q(ge), V();
          if (ee == "spread") return V(on);
          if (ee == "[") return Fe(zn, "]");
          if (ee == "{") return Fe(gr, "}");
        }
        function gr(ee, ge) {
          return ee == "variable" && !J.stream.match(/^\s*:/, !1) ? (Q(ge), V(fn)) : (ee == "variable" && (J.marked = "property"), ee == "spread" ? V(on) : ee == "}" ? re() : ee == "[" ? V(Ie, ke("]"), ke(":"), gr) : V(ke(":"), on, fn));
        }
        function zn() {
          return re(on, fn);
        }
        function fn(ee, ge) {
          if (ge == "=") return V(Se);
        }
        function sa(ee) {
          if (ee == ",") return V(Dn);
        }
        function un(ee, ge) {
          if (ee == "keyword b" && ge == "else") return V(ye("form", "else"), Ae, ve);
        }
        function Lr(ee, ge) {
          if (ge == "await") return V(Lr);
          if (ee == "(") return V(ye(")"), vr, ve);
        }
        function vr(ee) {
          return ee == "var" ? V(Dn, Yt) : ee == "variable" ? V(Yt) : re(Yt);
        }
        function Yt(ee, ge) {
          return ee == ")" ? V() : ee == ";" ? V(Yt) : ge == "in" || ge == "of" ? (J.marked = "keyword", V(Ie, Yt)) : re(Ie, Yt);
        }
        function gn(ee, ge) {
          if (ge == "*")
            return J.marked = "keyword", V(gn);
          if (ee == "variable")
            return Q(ge), V(gn);
          if (ee == "(") return V(G, ye(")"), de(Sn, ")"), ve, Je, Ae, oe);
          if (v && ge == "<") return V(ye(">"), de(Fn, ">"), ve, gn);
        }
        function Tn(ee, ge) {
          if (ge == "*")
            return J.marked = "keyword", V(Tn);
          if (ee == "variable")
            return Q(ge), V(Tn);
          if (ee == "(") return V(G, ye(")"), de(Sn, ")"), ve, Je, oe);
          if (v && ge == "<") return V(ye(">"), de(Fn, ">"), ve, Tn);
        }
        function yr(ee, ge) {
          if (ee == "keyword" || ee == "variable")
            return J.marked = "type", V(yr);
          if (ge == "<")
            return V(ye(">"), de(Fn, ">"), ve);
        }
        function Sn(ee, ge) {
          return ge == "@" && V(Ie, Sn), ee == "spread" ? V(Sn) : v && X(ge) ? (J.marked = "keyword", V(Sn)) : v && ee == "this" ? V($e, fn) : re(on, $e, fn);
        }
        function jn(ee, ge) {
          return ee == "variable" ? xr(ee, ge) : er(ee, ge);
        }
        function xr(ee, ge) {
          if (ee == "variable")
            return Q(ge), V(er);
        }
        function er(ee, ge) {
          if (ge == "<") return V(ye(">"), de(Fn, ">"), ve, er);
          if (ge == "extends" || ge == "implements" || v && ee == ",")
            return ge == "implements" && (J.marked = "keyword"), V(v ? qe : Ie, er);
          if (ee == "{") return V(ye("}"), pn, ve);
        }
        function pn(ee, ge) {
          if (ee == "async" || ee == "variable" && (ge == "static" || ge == "get" || ge == "set" || v && X(ge)) && J.stream.match(/^\s+#?[\w$\xa1-\uffff]/, !1))
            return J.marked = "keyword", V(pn);
          if (ee == "variable" || J.style == "keyword")
            return J.marked = "property", V(Rn, pn);
          if (ee == "number" || ee == "string") return V(Rn, pn);
          if (ee == "[")
            return V(Ie, $e, ke("]"), Rn, pn);
          if (ge == "*")
            return J.marked = "keyword", V(pn);
          if (v && ee == "(") return re(Tn, pn);
          if (ee == ";" || ee == ",") return V(pn);
          if (ee == "}") return V();
          if (ge == "@") return V(Ie, pn);
        }
        function Rn(ee, ge) {
          if (ge == "!" || ge == "?") return V(Rn);
          if (ee == ":") return V(qe, fn);
          if (ge == "=") return V(Se);
          var xe = J.state.lexical.prev, De = xe && xe.info == "interface";
          return re(De ? Tn : gn);
        }
        function Mn(ee, ge) {
          return ge == "*" ? (J.marked = "keyword", V(ut, ke(";"))) : ge == "default" ? (J.marked = "keyword", V(Ie, ke(";"))) : ee == "{" ? V(de(tr, "}"), ut, ke(";")) : re(Ae);
        }
        function tr(ee, ge) {
          if (ge == "as")
            return J.marked = "keyword", V(ke("variable"));
          if (ee == "variable") return re(Se, tr);
        }
        function On(ee) {
          return ee == "string" ? V() : ee == "(" ? re(Ie) : ee == "." ? re(Qe) : re(sn, wr, ut);
        }
        function sn(ee, ge) {
          return ee == "{" ? Fe(sn, "}") : (ee == "variable" && Q(ge), ge == "*" && (J.marked = "keyword"), V(Rt));
        }
        function wr(ee) {
          if (ee == ",") return V(sn, wr);
        }
        function Rt(ee, ge) {
          if (ge == "as")
            return J.marked = "keyword", V(sn);
        }
        function ut(ee, ge) {
          if (ge == "from")
            return J.marked = "keyword", V(Ie);
        }
        function Ln(ee) {
          return ee == "]" ? V() : re(de(Se, "]"));
        }
        function nr() {
          return re(ye("form"), on, ke("{"), ye("}"), de(Cn, "}"), ve, ve);
        }
        function Cn() {
          return re(on, fn);
        }
        function _t(ee, ge) {
          return ee.lastType == "operator" || ee.lastType == "," || C.test(ge.charAt(0)) || /[,.]/.test(ge.charAt(0));
        }
        function jt(ee, ge, xe) {
          return ge.tokenize == B && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(ge.lastType) || ge.lastType == "quasi" && /\{\s*$/.test(ee.string.slice(0, ee.pos - (xe || 0)));
        }
        return {
          startState: function(ee) {
            var ge = {
              tokenize: B,
              lastType: "sof",
              cc: [],
              lexical: new W((ee || 0) - s, 0, "block", !1),
              localVars: o.localVars,
              context: o.localVars && new ue(null, null, !1),
              indented: ee || 0
            };
            return o.globalVars && typeof o.globalVars == "object" && (ge.globalVars = o.globalVars), ge;
          },
          token: function(ee, ge) {
            if (ee.sol() && (ge.lexical.hasOwnProperty("align") || (ge.lexical.align = !1), ge.indented = ee.indentation(), q(ee, ge)), ge.tokenize != T && ee.eatSpace()) return null;
            var xe = ge.tokenize(ee, ge);
            return A == "comment" ? xe : (ge.lastType = A == "operator" && (P == "++" || P == "--") ? "incdec" : A, Z(ge, xe, A, P, ee));
          },
          indent: function(ee, ge) {
            if (ee.tokenize == T || ee.tokenize == O) return n.Pass;
            if (ee.tokenize != B) return 0;
            var xe = ge && ge.charAt(0), De = ee.lexical, ht;
            if (!/^\s*else\b/.test(ge)) for (var xt = ee.cc.length - 1; xt >= 0; --xt) {
              var St = ee.cc[xt];
              if (St == ve) De = De.prev;
              else if (St != un && St != oe) break;
            }
            for (; (De.type == "stat" || De.type == "form") && (xe == "}" || (ht = ee.cc[ee.cc.length - 1]) && (ht == Qe || ht == et) && !/^[,\.=+\-*:?[\(]/.test(ge)); )
              De = De.prev;
            u && De.type == ")" && De.prev.type == "stat" && (De = De.prev);
            var It = De.type, vn = xe == It;
            return It == "vardef" ? De.indented + (ee.lastType == "operator" || ee.lastType == "," ? De.info.length + 1 : 0) : It == "form" && xe == "{" ? De.indented : It == "form" ? De.indented + s : It == "stat" ? De.indented + (_t(ee, ge) ? u || s : 0) : De.info == "switch" && !vn && o.doubleIndentSwitch != !1 ? De.indented + (/^(?:case|default)\b/.test(ge) ? s : 2 * s) : De.align ? De.column + (vn ? 0 : 1) : De.indented + (vn ? 0 : s);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: f ? null : "/*",
          blockCommentEnd: f ? null : "*/",
          blockCommentContinue: f ? null : " * ",
          lineComment: f ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: f ? "json" : "javascript",
          jsonldMode: d,
          jsonMode: f,
          expressionAllowed: jt,
          skipExpression: function(ee) {
            Z(ee, "atom", "atom", "true", new n.StringStream("", 2, null));
          }
        };
      }), n.registerHelper("wordChars", "javascript", /[\w$]/), n.defineMIME("text/javascript", "javascript"), n.defineMIME("text/ecmascript", "javascript"), n.defineMIME("application/javascript", "javascript"), n.defineMIME("application/x-javascript", "javascript"), n.defineMIME("application/ecmascript", "javascript"), n.defineMIME("application/json", { name: "javascript", json: !0 }), n.defineMIME("application/x-json", { name: "javascript", json: !0 }), n.defineMIME("application/manifest+json", { name: "javascript", json: !0 }), n.defineMIME("application/ld+json", { name: "javascript", jsonld: !0 }), n.defineMIME("text/typescript", { name: "javascript", typescript: !0 }), n.defineMIME("application/typescript", { name: "javascript", typescript: !0 });
    });
  })()), javascript.exports;
}
var hasRequiredHtmlmixed;
function requireHtmlmixed() {
  return hasRequiredHtmlmixed || (hasRequiredHtmlmixed = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireXml(), requireJavascript(), requireCss());
    })(function(n) {
      var a = {
        script: [
          ["lang", /(javascript|babel)/i, "javascript"],
          ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
          ["type", /./, "text/plain"],
          [null, null, "javascript"]
        ],
        style: [
          ["lang", /^css$/i, "css"],
          ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
          ["type", /./, "text/plain"],
          [null, null, "css"]
        ]
      };
      function o(b, w, C) {
        var k = b.current(), E = k.search(w);
        return E > -1 ? b.backUp(k.length - E) : k.match(/<\/?$/) && (b.backUp(k.length), b.match(w, !1) || b.match(k)), C;
      }
      var s = {};
      function u(b) {
        var w = s[b];
        return w || (s[b] = new RegExp("\\s+" + b + `\\s*=\\s*('|")?([^'"]+)('|")?\\s*`));
      }
      function d(b, w) {
        var C = b.match(u(w));
        return C ? /^\s*(.*?)\s*$/.exec(C[2])[1] : "";
      }
      function f(b, w) {
        return new RegExp((w ? "^" : "") + "</\\s*" + b + "\\s*>", "i");
      }
      function g(b, w) {
        for (var C in b)
          for (var k = w[C] || (w[C] = []), E = b[C], A = E.length - 1; A >= 0; A--)
            k.unshift(E[A]);
      }
      function v(b, w) {
        for (var C = 0; C < b.length; C++) {
          var k = b[C];
          if (!k[0] || k[1].test(d(w, k[0]))) return k[2];
        }
      }
      n.defineMode("htmlmixed", function(b, w) {
        var C = n.getMode(b, {
          name: "xml",
          htmlMode: !0,
          multilineTagIndentFactor: w.multilineTagIndentFactor,
          multilineTagIndentPastTag: w.multilineTagIndentPastTag,
          allowMissingTagName: w.allowMissingTagName
        }), k = {}, E = w && w.tags, A = w && w.scriptTypes;
        if (g(a, k), E && g(E, k), A) for (var P = A.length - 1; P >= 0; P--)
          k.script.unshift(["type", A[P].matches, A[P].mode]);
        function M(B, _) {
          var T = C.token(B, _.htmlState), O = /\btag\b/.test(T), I;
          if (O && !/[<>\s\/]/.test(B.current()) && (I = _.htmlState.tagName && _.htmlState.tagName.toLowerCase()) && k.hasOwnProperty(I))
            _.inTag = I + " ";
          else if (_.inTag && O && />$/.test(B.current())) {
            var q = /^([\S]+) (.*)/.exec(_.inTag);
            _.inTag = null;
            var F = B.current() == ">" && v(k[q[1]], q[2]), W = n.getMode(b, F), K = f(q[1], !0), Z = f(q[1], !1);
            _.token = function(J, re) {
              return J.match(K, !1) ? (re.token = M, re.localState = re.localMode = null, null) : o(J, Z, re.localMode.token(J, re.localState));
            }, _.localMode = W, _.localState = n.startState(W, C.indent(_.htmlState, "", ""));
          } else _.inTag && (_.inTag += B.current(), B.eol() && (_.inTag += " "));
          return T;
        }
        return {
          startState: function() {
            var B = n.startState(C);
            return { token: M, inTag: null, localMode: null, localState: null, htmlState: B };
          },
          copyState: function(B) {
            var _;
            return B.localState && (_ = n.copyState(B.localMode, B.localState)), {
              token: B.token,
              inTag: B.inTag,
              localMode: B.localMode,
              localState: _,
              htmlState: n.copyState(C, B.htmlState)
            };
          },
          token: function(B, _) {
            return _.token(B, _);
          },
          indent: function(B, _, T) {
            return !B.localMode || /^\s*<\//.test(_) ? C.indent(B.htmlState, _, T) : B.localMode.indent ? B.localMode.indent(B.localState, _, T) : n.Pass;
          },
          innerMode: function(B) {
            return { state: B.localState || B.htmlState, mode: B.localMode || C };
          }
        };
      }, "xml", "javascript", "css"), n.defineMIME("text/html", "htmlmixed");
    });
  })()), htmlmixed.exports;
}
var ruby = { exports: {} }, hasRequiredRuby;
function requireRuby() {
  return hasRequiredRuby || (hasRequiredRuby = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      function a(v) {
        for (var b = {}, w = 0, C = v.length; w < C; ++w) b[v[w]] = !0;
        return b;
      }
      var o = [
        "alias",
        "and",
        "BEGIN",
        "begin",
        "break",
        "case",
        "class",
        "def",
        "defined?",
        "do",
        "else",
        "elsif",
        "END",
        "end",
        "ensure",
        "false",
        "for",
        "if",
        "in",
        "module",
        "next",
        "not",
        "or",
        "redo",
        "rescue",
        "retry",
        "return",
        "self",
        "super",
        "then",
        "true",
        "undef",
        "unless",
        "until",
        "when",
        "while",
        "yield",
        "nil",
        "raise",
        "throw",
        "catch",
        "fail",
        "loop",
        "callcc",
        "caller",
        "lambda",
        "proc",
        "public",
        "protected",
        "private",
        "require",
        "load",
        "require_relative",
        "extend",
        "autoload",
        "__END__",
        "__FILE__",
        "__LINE__",
        "__dir__"
      ], s = a(o), u = a([
        "def",
        "class",
        "case",
        "for",
        "while",
        "until",
        "module",
        "catch",
        "loop",
        "proc",
        "begin"
      ]), d = a(["end", "until"]), f = { "[": "]", "{": "}", "(": ")" }, g = { "]": "[", "}": "{", ")": "(" };
      n.defineMode("ruby", function(v) {
        var b;
        function w(_, T, O) {
          return O.tokenize.push(_), _(T, O);
        }
        function C(_, T) {
          if (_.sol() && _.match("=begin") && _.eol())
            return T.tokenize.push(B), "comment";
          if (_.eatSpace()) return null;
          var O = _.next(), I;
          if (O == "`" || O == "'" || O == '"')
            return w(P(O, "string", O == '"' || O == "`"), _, T);
          if (O == "/")
            return k(_) ? w(P(O, "string-2", !0), _, T) : "operator";
          if (O == "%") {
            var q = "string", F = !0;
            _.eat("s") ? q = "atom" : _.eat(/[WQ]/) ? q = "string" : _.eat(/[r]/) ? q = "string-2" : _.eat(/[wxq]/) && (q = "string", F = !1);
            var W = _.eat(/[^\w\s=]/);
            return W ? (f.propertyIsEnumerable(W) && (W = f[W]), w(P(W, q, F, !0), _, T)) : "operator";
          } else {
            if (O == "#")
              return _.skipToEnd(), "comment";
            if (O == "<" && (I = _.match(/^<([-~])[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/)))
              return w(M(I[2], I[1]), _, T);
            if (O == "0")
              return _.eat("x") ? _.eatWhile(/[\da-fA-F]/) : _.eat("b") ? _.eatWhile(/[01]/) : _.eatWhile(/[0-7]/), "number";
            if (/\d/.test(O))
              return _.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/), "number";
            if (O == "?") {
              for (; _.match(/^\\[CM]-/); )
                ;
              return _.eat("\\") ? _.eatWhile(/\w/) : _.next(), "string";
            } else {
              if (O == ":")
                return _.eat("'") ? w(P("'", "atom", !1), _, T) : _.eat('"') ? w(P('"', "atom", !0), _, T) : _.eat(/[\<\>]/) ? (_.eat(/[\<\>]/), "atom") : _.eat(/[\+\-\*\/\&\|\:\!]/) ? "atom" : _.eat(/[a-zA-Z$@_\xa1-\uffff]/) ? (_.eatWhile(/[\w$\xa1-\uffff]/), _.eat(/[\?\!\=]/), "atom") : "operator";
              if (O == "@" && _.match(/^@?[a-zA-Z_\xa1-\uffff]/))
                return _.eat("@"), _.eatWhile(/[\w\xa1-\uffff]/), "variable-2";
              if (O == "$")
                return _.eat(/[a-zA-Z_]/) ? _.eatWhile(/[\w]/) : _.eat(/\d/) ? _.eat(/\d/) : _.next(), "variable-3";
              if (/[a-zA-Z_\xa1-\uffff]/.test(O))
                return _.eatWhile(/[\w\xa1-\uffff]/), _.eat(/[\?\!]/), _.eat(":") ? "atom" : "ident";
              if (O == "|" && (T.varList || T.lastTok == "{" || T.lastTok == "do"))
                return b = "|", null;
              if (/[\(\)\[\]{}\\;]/.test(O))
                return b = O, null;
              if (O == "-" && _.eat(">"))
                return "arrow";
              if (/[=+\-\/*:\.^%<>~|]/.test(O)) {
                var K = _.eatWhile(/[=+\-\/*:\.^%<>~|]/);
                return O == "." && !K && (b = "."), "operator";
              } else
                return null;
            }
          }
        }
        function k(_) {
          for (var T = _.pos, O = 0, I, q = !1, F = !1; (I = _.next()) != null; )
            if (F)
              F = !1;
            else {
              if ("[{(".indexOf(I) > -1)
                O++;
              else if ("]})".indexOf(I) > -1) {
                if (O--, O < 0) break;
              } else if (I == "/" && O == 0) {
                q = !0;
                break;
              }
              F = I == "\\";
            }
          return _.backUp(_.pos - T), q;
        }
        function E(_) {
          return _ || (_ = 1), function(T, O) {
            if (T.peek() == "}") {
              if (_ == 1)
                return O.tokenize.pop(), O.tokenize[O.tokenize.length - 1](T, O);
              O.tokenize[O.tokenize.length - 1] = E(_ - 1);
            } else T.peek() == "{" && (O.tokenize[O.tokenize.length - 1] = E(_ + 1));
            return C(T, O);
          };
        }
        function A() {
          var _ = !1;
          return function(T, O) {
            return _ ? (O.tokenize.pop(), O.tokenize[O.tokenize.length - 1](T, O)) : (_ = !0, C(T, O));
          };
        }
        function P(_, T, O, I) {
          return function(q, F) {
            var W = !1, K;
            for (F.context.type === "read-quoted-paused" && (F.context = F.context.prev, q.eat("}")); (K = q.next()) != null; ) {
              if (K == _ && (I || !W)) {
                F.tokenize.pop();
                break;
              }
              if (O && K == "#" && !W) {
                if (q.eat("{")) {
                  _ == "}" && (F.context = { prev: F.context, type: "read-quoted-paused" }), F.tokenize.push(E());
                  break;
                } else if (/[@\$]/.test(q.peek())) {
                  F.tokenize.push(A());
                  break;
                }
              }
              W = !W && K == "\\";
            }
            return T;
          };
        }
        function M(_, T) {
          return function(O, I) {
            return T && O.eatSpace(), O.match(_) ? I.tokenize.pop() : O.skipToEnd(), "string";
          };
        }
        function B(_, T) {
          return _.sol() && _.match("=end") && _.eol() && T.tokenize.pop(), _.skipToEnd(), "comment";
        }
        return {
          startState: function() {
            return {
              tokenize: [C],
              indented: 0,
              context: { type: "top", indented: -v.indentUnit },
              continuedLine: !1,
              lastTok: null,
              varList: !1
            };
          },
          token: function(_, T) {
            b = null, _.sol() && (T.indented = _.indentation());
            var O = T.tokenize[T.tokenize.length - 1](_, T), I, q = b;
            if (O == "ident") {
              var F = _.current();
              O = T.lastTok == "." ? "property" : s.propertyIsEnumerable(_.current()) ? "keyword" : /^[A-Z]/.test(F) ? "tag" : T.lastTok == "def" || T.lastTok == "class" || T.varList ? "def" : "variable", O == "keyword" && (q = F, u.propertyIsEnumerable(F) ? I = "indent" : d.propertyIsEnumerable(F) ? I = "dedent" : ((F == "if" || F == "unless") && _.column() == _.indentation() || F == "do" && T.context.indented < T.indented) && (I = "indent"));
            }
            return (b || O && O != "comment") && (T.lastTok = q), b == "|" && (T.varList = !T.varList), I == "indent" || /[\(\[\{]/.test(b) ? T.context = { prev: T.context, type: b || O, indented: T.indented } : (I == "dedent" || /[\)\]\}]/.test(b)) && T.context.prev && (T.context = T.context.prev), _.eol() && (T.continuedLine = b == "\\" || O == "operator"), O;
          },
          indent: function(_, T) {
            if (_.tokenize[_.tokenize.length - 1] != C) return n.Pass;
            var O = T && T.charAt(0), I = _.context, q = I.type == g[O] || I.type == "keyword" && /^(?:end|until|else|elsif|when|rescue)\b/.test(T);
            return I.indented + (q ? 0 : v.indentUnit) + (_.continuedLine ? v.indentUnit : 0);
          },
          electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
          lineComment: "#",
          fold: "indent"
        };
      }), n.defineMIME("text/x-ruby", "ruby"), n.registerHelper("hintWords", "ruby", o);
    });
  })()), ruby.exports;
}
var hasRequiredHaml;
function requireHaml() {
  return hasRequiredHaml || (hasRequiredHaml = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireHtmlmixed(), requireRuby());
    })(function(n) {
      n.defineMode("haml", function(a) {
        var o = n.getMode(a, { name: "htmlmixed" }), s = n.getMode(a, "ruby");
        function u(g) {
          return function(v, b) {
            var w = v.peek();
            return w == g && b.rubyState.tokenize.length == 1 ? (v.next(), b.tokenize = f, "closeAttributeTag") : d(v, b);
          };
        }
        function d(g, v) {
          return g.match("-#") ? (g.skipToEnd(), "comment") : s.token(g, v.rubyState);
        }
        function f(g, v) {
          var b = g.peek();
          if (v.previousToken.style == "comment" && v.indented > v.previousToken.indented)
            return g.skipToEnd(), "commentLine";
          if (v.startOfLine) {
            if (b == "!" && g.match("!!"))
              return g.skipToEnd(), "tag";
            if (g.match(/^%[\w:#\.]+=/))
              return v.tokenize = d, "hamlTag";
            if (g.match(/^%[\w:]+/))
              return "hamlTag";
            if (b == "/")
              return g.skipToEnd(), "comment";
          }
          if ((v.startOfLine || v.previousToken.style == "hamlTag") && (b == "#" || b == "."))
            return g.match(/[\w-#\.]*/), "hamlAttribute";
          if (v.startOfLine && !g.match("-->", !1) && (b == "=" || b == "-"))
            return v.tokenize = d, v.tokenize(g, v);
          if (v.previousToken.style == "hamlTag" || v.previousToken.style == "closeAttributeTag" || v.previousToken.style == "hamlAttribute") {
            if (b == "(")
              return v.tokenize = u(")"), v.tokenize(g, v);
            if (b == "{" && !g.match(/^\{%.*/))
              return v.tokenize = u("}"), v.tokenize(g, v);
          }
          return o.token(g, v.htmlState);
        }
        return {
          // default to html mode
          startState: function() {
            var g = n.startState(o), v = n.startState(s);
            return {
              htmlState: g,
              rubyState: v,
              indented: 0,
              previousToken: { style: null, indented: 0 },
              tokenize: f
            };
          },
          copyState: function(g) {
            return {
              htmlState: n.copyState(o, g.htmlState),
              rubyState: n.copyState(s, g.rubyState),
              indented: g.indented,
              previousToken: g.previousToken,
              tokenize: g.tokenize
            };
          },
          token: function(g, v) {
            if (g.sol() && (v.indented = g.indentation(), v.startOfLine = !0), g.eatSpace()) return null;
            var b = v.tokenize(g, v);
            if (v.startOfLine = !1, b && b != "commentLine" && (v.previousToken = { style: b, indented: v.indented }), g.eol() && v.tokenize == d) {
              g.backUp(1);
              var w = g.peek();
              g.next(), w && w != "," && (v.tokenize = f);
            }
            return b == "hamlTag" ? b = "tag" : b == "commentLine" ? b = "comment" : b == "hamlAttribute" ? b = "attribute" : b == "closeAttributeTag" && (b = null), b;
          }
        };
      }, "htmlmixed", "ruby"), n.defineMIME("text/x-haml", "haml");
    });
  })()), haml.exports;
}
requireHaml();
requireHtmlmixed();
requireJavascript();
requireMarkdown();
var nginx = { exports: {} }, hasRequiredNginx;
function requireNginx() {
  return hasRequiredNginx || (hasRequiredNginx = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("nginx", function(a) {
        function o(E) {
          for (var A = {}, P = E.split(" "), M = 0; M < P.length; ++M) A[P[M]] = !0;
          return A;
        }
        var s = o(
          /* ngxDirectiveControl */
          "break return rewrite set accept_mutex accept_mutex_delay access_log add_after_body add_before_body add_header addition_types aio alias allow ancient_browser ancient_browser_value auth_basic auth_basic_user_file auth_http auth_http_header auth_http_timeout autoindex autoindex_exact_size autoindex_localtime charset charset_types client_body_buffer_size client_body_in_file_only client_body_in_single_buffer client_body_temp_path client_body_timeout client_header_buffer_size client_header_timeout client_max_body_size connection_pool_size create_full_put_path daemon dav_access dav_methods debug_connection debug_points default_type degradation degrade deny devpoll_changes devpoll_events directio directio_alignment empty_gif env epoll_events error_log eventport_events expires fastcgi_bind fastcgi_buffer_size fastcgi_buffers fastcgi_busy_buffers_size fastcgi_cache fastcgi_cache_key fastcgi_cache_methods fastcgi_cache_min_uses fastcgi_cache_path fastcgi_cache_use_stale fastcgi_cache_valid fastcgi_catch_stderr fastcgi_connect_timeout fastcgi_hide_header fastcgi_ignore_client_abort fastcgi_ignore_headers fastcgi_index fastcgi_intercept_errors fastcgi_max_temp_file_size fastcgi_next_upstream fastcgi_param fastcgi_pass_header fastcgi_pass_request_body fastcgi_pass_request_headers fastcgi_read_timeout fastcgi_send_lowat fastcgi_send_timeout fastcgi_split_path_info fastcgi_store fastcgi_store_access fastcgi_temp_file_write_size fastcgi_temp_path fastcgi_upstream_fail_timeout fastcgi_upstream_max_fails flv geoip_city geoip_country google_perftools_profiles gzip gzip_buffers gzip_comp_level gzip_disable gzip_hash gzip_http_version gzip_min_length gzip_no_buffer gzip_proxied gzip_static gzip_types gzip_vary gzip_window if_modified_since ignore_invalid_headers image_filter image_filter_buffer image_filter_jpeg_quality image_filter_transparency imap_auth imap_capabilities imap_client_buffer index ip_hash keepalive_requests keepalive_timeout kqueue_changes kqueue_events large_client_header_buffers limit_conn limit_conn_log_level limit_rate limit_rate_after limit_req limit_req_log_level limit_req_zone limit_zone lingering_time lingering_timeout lock_file log_format log_not_found log_subrequest map_hash_bucket_size map_hash_max_size master_process memcached_bind memcached_buffer_size memcached_connect_timeout memcached_next_upstream memcached_read_timeout memcached_send_timeout memcached_upstream_fail_timeout memcached_upstream_max_fails merge_slashes min_delete_depth modern_browser modern_browser_value msie_padding msie_refresh multi_accept open_file_cache open_file_cache_errors open_file_cache_events open_file_cache_min_uses open_file_cache_valid open_log_file_cache output_buffers override_charset perl perl_modules perl_require perl_set pid pop3_auth pop3_capabilities port_in_redirect postpone_gzipping postpone_output protocol proxy proxy_bind proxy_buffer proxy_buffer_size proxy_buffering proxy_buffers proxy_busy_buffers_size proxy_cache proxy_cache_key proxy_cache_methods proxy_cache_min_uses proxy_cache_path proxy_cache_use_stale proxy_cache_valid proxy_connect_timeout proxy_headers_hash_bucket_size proxy_headers_hash_max_size proxy_hide_header proxy_ignore_client_abort proxy_ignore_headers proxy_intercept_errors proxy_max_temp_file_size proxy_method proxy_next_upstream proxy_pass_error_message proxy_pass_header proxy_pass_request_body proxy_pass_request_headers proxy_read_timeout proxy_redirect proxy_send_lowat proxy_send_timeout proxy_set_body proxy_set_header proxy_ssl_session_reuse proxy_store proxy_store_access proxy_temp_file_write_size proxy_temp_path proxy_timeout proxy_upstream_fail_timeout proxy_upstream_max_fails random_index read_ahead real_ip_header recursive_error_pages request_pool_size reset_timedout_connection resolver resolver_timeout rewrite_log rtsig_overflow_events rtsig_overflow_test rtsig_overflow_threshold rtsig_signo satisfy secure_link_secret send_lowat send_timeout sendfile sendfile_max_chunk server_name_in_redirect server_names_hash_bucket_size server_names_hash_max_size server_tokens set_real_ip_from smtp_auth smtp_capabilities smtp_client_buffer smtp_greeting_delay so_keepalive source_charset ssi ssi_ignore_recycled_buffers ssi_min_file_chunk ssi_silent_errors ssi_types ssi_value_length ssl ssl_certificate ssl_certificate_key ssl_ciphers ssl_client_certificate ssl_crl ssl_dhparam ssl_engine ssl_prefer_server_ciphers ssl_protocols ssl_session_cache ssl_session_timeout ssl_verify_client ssl_verify_depth starttls stub_status sub_filter sub_filter_once sub_filter_types tcp_nodelay tcp_nopush thread_stack_size timeout timer_resolution types_hash_bucket_size types_hash_max_size underscores_in_headers uninitialized_variable_warn use user userid userid_domain userid_expires userid_mark userid_name userid_p3p userid_path userid_service valid_referers variables_hash_bucket_size variables_hash_max_size worker_connections worker_cpu_affinity worker_priority worker_processes worker_rlimit_core worker_rlimit_nofile worker_rlimit_sigpending worker_threads working_directory xclient xml_entities xslt_stylesheet xslt_typesdrew@li229-23"
        ), u = o(
          /* ngxDirectiveBlock */
          "http mail events server types location upstream charset_map limit_except if geo map"
        ), d = o(
          /* ngxDirectiveImportant */
          "include root server server_name listen internal proxy_pass memcached_pass fastcgi_pass try_files"
        ), f = a.indentUnit, g;
        function v(E, A) {
          return g = A, E;
        }
        function b(E, A) {
          E.eatWhile(/[\w\$_]/);
          var P = E.current();
          if (s.propertyIsEnumerable(P))
            return "keyword";
          if (u.propertyIsEnumerable(P))
            return "variable-2";
          if (d.propertyIsEnumerable(P))
            return "string-2";
          var M = E.next();
          if (M == "@")
            return E.eatWhile(/[\w\\\-]/), v("meta", E.current());
          if (M == "/" && E.eat("*"))
            return A.tokenize = w, w(E, A);
          if (M == "<" && E.eat("!"))
            return A.tokenize = C, C(E, A);
          if (M == "=") v(null, "compare");
          else return (M == "~" || M == "|") && E.eat("=") ? v(null, "compare") : M == '"' || M == "'" ? (A.tokenize = k(M), A.tokenize(E, A)) : M == "#" ? (E.skipToEnd(), v("comment", "comment")) : M == "!" ? (E.match(/^\s*\w*/), v("keyword", "important")) : /\d/.test(M) ? (E.eatWhile(/[\w.%]/), v("number", "unit")) : /[,.+>*\/]/.test(M) ? v(null, "select-op") : /[;{}:\[\]]/.test(M) ? v(null, M) : (E.eatWhile(/[\w\\\-]/), v("variable", "variable"));
        }
        function w(E, A) {
          for (var P = !1, M; (M = E.next()) != null; ) {
            if (P && M == "/") {
              A.tokenize = b;
              break;
            }
            P = M == "*";
          }
          return v("comment", "comment");
        }
        function C(E, A) {
          for (var P = 0, M; (M = E.next()) != null; ) {
            if (P >= 2 && M == ">") {
              A.tokenize = b;
              break;
            }
            P = M == "-" ? P + 1 : 0;
          }
          return v("comment", "comment");
        }
        function k(E) {
          return function(A, P) {
            for (var M = !1, B; (B = A.next()) != null && !(B == E && !M); )
              M = !M && B == "\\";
            return M || (P.tokenize = b), v("string", "string");
          };
        }
        return {
          startState: function(E) {
            return {
              tokenize: b,
              baseIndent: E || 0,
              stack: []
            };
          },
          token: function(E, A) {
            if (E.eatSpace()) return null;
            g = null;
            var P = A.tokenize(E, A), M = A.stack[A.stack.length - 1];
            return g == "hash" && M == "rule" ? P = "atom" : P == "variable" && (M == "rule" ? P = "number" : (!M || M == "@media{") && (P = "tag")), M == "rule" && /^[\{\};]$/.test(g) && A.stack.pop(), g == "{" ? M == "@media" ? A.stack[A.stack.length - 1] = "@media{" : A.stack.push("{") : g == "}" ? A.stack.pop() : g == "@media" ? A.stack.push("@media") : M == "{" && g != "comment" && A.stack.push("rule"), P;
          },
          indent: function(E, A) {
            var P = E.stack.length;
            return /^\}/.test(A) && (P -= E.stack[E.stack.length - 1] == "rule" ? 2 : 1), E.baseIndent + P * f;
          },
          electricChars: "}"
        };
      }), n.defineMIME("text/x-nginx-conf", "nginx");
    });
  })()), nginx.exports;
}
requireNginx();
var php = { exports: {} }, hasRequiredPhp;
function requirePhp() {
  return hasRequiredPhp || (hasRequiredPhp = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireHtmlmixed(), requireClike());
    })(function(n) {
      function a(b) {
        for (var w = {}, C = b.split(" "), k = 0; k < C.length; ++k) w[C[k]] = !0;
        return w;
      }
      function o(b, w, C) {
        return b.length == 0 ? s(w) : function(k, E) {
          for (var A = b[0], P = 0; P < A.length; P++) if (k.match(A[P][0]))
            return E.tokenize = o(b.slice(1), w), A[P][1];
          return E.tokenize = s(w, C), "string";
        };
      }
      function s(b, w) {
        return function(C, k) {
          return u(C, k, b, w);
        };
      }
      function u(b, w, C, k) {
        if (k !== !1 && b.match("${", !1) || b.match("{$", !1))
          return w.tokenize = null, "string";
        if (k !== !1 && b.match(/^\$[a-zA-Z_][a-zA-Z0-9_]*/))
          return b.match("[", !1) && (w.tokenize = o([
            [["[", null]],
            [
              [/\d[\w\.]*/, "number"],
              [/\$[a-zA-Z_][a-zA-Z0-9_]*/, "variable-2"],
              [/[\w\$]+/, "variable"]
            ],
            [["]", null]]
          ], C, k)), b.match(/^->\w/, !1) && (w.tokenize = o([
            [["->", null]],
            [[/[\w]+/, "variable"]]
          ], C, k)), "variable-2";
        for (var E = !1; !b.eol() && (E || k === !1 || !b.match("{$", !1) && !b.match(/^(\$[a-zA-Z_][a-zA-Z0-9_]*|\$\{)/, !1)); ) {
          if (!E && b.match(C)) {
            w.tokenize = null, w.tokStack.pop(), w.tokStack.pop();
            break;
          }
          E = b.next() == "\\" && !E;
        }
        return "string";
      }
      var d = "abstract and array as break case catch class clone const continue declare default do else elseif enddeclare endfor endforeach endif endswitch endwhile enum extends final for foreach function global goto if implements interface instanceof namespace new or private protected public static switch throw trait try use var while xor die echo empty exit eval include include_once isset list require require_once return print unset __halt_compiler self static parent yield insteadof finally readonly match", f = "true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__", g = "func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage memory_get_peak_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count";
      n.registerHelper("hintWords", "php", [d, f, g].join(" ").split(" ")), n.registerHelper("wordChars", "php", /[\w$]/);
      var v = {
        name: "clike",
        helperType: "php",
        keywords: a(d),
        blockKeywords: a("catch do else elseif for foreach if switch try while finally"),
        defKeywords: a("class enum function interface namespace trait"),
        atoms: a(f),
        builtin: a(g),
        multiLineStrings: !0,
        hooks: {
          $: function(b) {
            return b.eatWhile(/[\w\$_]/), "variable-2";
          },
          "<": function(b, w) {
            var C;
            if (C = b.match(/^<<\s*/)) {
              var k = b.eat(/['"]/);
              b.eatWhile(/[\w\.]/);
              var E = b.current().slice(C[0].length + (k ? 2 : 1));
              if (k && b.eat(k), E)
                return (w.tokStack || (w.tokStack = [])).push(E, 0), w.tokenize = s(E, k != "'"), "string";
            }
            return !1;
          },
          "#": function(b) {
            for (; !b.eol() && !b.match("?>", !1); ) b.next();
            return "comment";
          },
          "/": function(b) {
            if (b.eat("/")) {
              for (; !b.eol() && !b.match("?>", !1); ) b.next();
              return "comment";
            }
            return !1;
          },
          '"': function(b, w) {
            return (w.tokStack || (w.tokStack = [])).push('"', 0), w.tokenize = s('"'), "string";
          },
          "{": function(b, w) {
            return w.tokStack && w.tokStack.length && w.tokStack[w.tokStack.length - 1]++, !1;
          },
          "}": function(b, w) {
            return w.tokStack && w.tokStack.length > 0 && !--w.tokStack[w.tokStack.length - 1] && (w.tokenize = s(w.tokStack[w.tokStack.length - 2])), !1;
          }
        }
      };
      n.defineMode("php", function(b, w) {
        var C = n.getMode(b, w && w.htmlMode || "text/html"), k = n.getMode(b, v);
        function E(A, P) {
          var M = P.curMode == k;
          if (A.sol() && P.pending && P.pending != '"' && P.pending != "'" && (P.pending = null), M)
            return M && P.php.tokenize == null && A.match("?>") ? (P.curMode = C, P.curState = P.html, P.php.context.prev || (P.php = null), "meta") : k.token(A, P.curState);
          if (A.match(/^<\?\w*/))
            return P.curMode = k, P.php || (P.php = n.startState(k, C.indent(P.html, "", ""))), P.curState = P.php, "meta";
          if (P.pending == '"' || P.pending == "'") {
            for (; !A.eol() && A.next() != P.pending; )
              ;
            var B = "string";
          } else if (P.pending && A.pos < P.pending.end) {
            A.pos = P.pending.end;
            var B = P.pending.style;
          } else
            var B = C.token(A, P.curState);
          P.pending && (P.pending = null);
          var _ = A.current(), T = _.search(/<\?/), O;
          return T != -1 && (B == "string" && (O = _.match(/[\'\"]$/)) && !/\?>/.test(_) ? P.pending = O[0] : P.pending = { end: A.pos, style: B }, A.backUp(_.length - T)), B;
        }
        return {
          startState: function() {
            var A = n.startState(C), P = w.startOpen ? n.startState(k) : null;
            return {
              html: A,
              php: P,
              curMode: w.startOpen ? k : C,
              curState: w.startOpen ? P : A,
              pending: null
            };
          },
          copyState: function(A) {
            var P = A.html, M = n.copyState(C, P), B = A.php, _ = B && n.copyState(k, B), T;
            return A.curMode == C ? T = M : T = _, {
              html: M,
              php: _,
              curMode: A.curMode,
              curState: T,
              pending: A.pending
            };
          },
          token: E,
          indent: function(A, P, M) {
            return A.curMode != k && /^\s*<\//.test(P) || A.curMode == k && /^\?>/.test(P) ? C.indent(A.html, P, M) : A.curMode.indent(A.curState, P, M);
          },
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//",
          innerMode: function(A) {
            return { state: A.curState, mode: A.curMode };
          }
        };
      }, "htmlmixed", "clike"), n.defineMIME("application/x-httpd-php", "php"), n.defineMIME("application/x-httpd-php-open", { name: "php", startOpen: !0 }), n.defineMIME("text/x-php", v);
    });
  })()), php.exports;
}
requirePhp();
var python = { exports: {} }, hasRequiredPython;
function requirePython() {
  return hasRequiredPython || (hasRequiredPython = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      function a(g) {
        return new RegExp("^((" + g.join(")|(") + "))\\b");
      }
      var o = a(["and", "or", "not", "is"]), s = [
        "as",
        "assert",
        "break",
        "class",
        "continue",
        "def",
        "del",
        "elif",
        "else",
        "except",
        "finally",
        "for",
        "from",
        "global",
        "if",
        "import",
        "lambda",
        "pass",
        "raise",
        "return",
        "try",
        "while",
        "with",
        "yield",
        "in",
        "False",
        "True"
      ], u = [
        "abs",
        "all",
        "any",
        "bin",
        "bool",
        "bytearray",
        "callable",
        "chr",
        "classmethod",
        "compile",
        "complex",
        "delattr",
        "dict",
        "dir",
        "divmod",
        "enumerate",
        "eval",
        "filter",
        "float",
        "format",
        "frozenset",
        "getattr",
        "globals",
        "hasattr",
        "hash",
        "help",
        "hex",
        "id",
        "input",
        "int",
        "isinstance",
        "issubclass",
        "iter",
        "len",
        "list",
        "locals",
        "map",
        "max",
        "memoryview",
        "min",
        "next",
        "object",
        "oct",
        "open",
        "ord",
        "pow",
        "property",
        "range",
        "repr",
        "reversed",
        "round",
        "set",
        "setattr",
        "slice",
        "sorted",
        "staticmethod",
        "str",
        "sum",
        "super",
        "tuple",
        "type",
        "vars",
        "zip",
        "__import__",
        "NotImplemented",
        "Ellipsis",
        "__debug__"
      ];
      n.registerHelper("hintWords", "python", s.concat(u).concat(["exec", "print"]));
      function d(g) {
        return g.scopes[g.scopes.length - 1];
      }
      n.defineMode("python", function(g, v) {
        for (var b = "error", w = v.delimiters || v.singleDelimiters || /^[\(\)\[\]\{\}@,:`=;\.\\]/, C = [
          v.singleOperators,
          v.doubleOperators,
          v.doubleDelimiters,
          v.tripleDelimiters,
          v.operators || /^([-+*/%\/&|^]=?|[<>=]+|\/\/=?|\*\*=?|!=|[~!@]|\.\.\.)/
        ], k = 0; k < C.length; k++) C[k] || C.splice(k--, 1);
        var E = v.hangingIndent || g.indentUnit, A = s, P = u;
        v.extra_keywords != null && (A = A.concat(v.extra_keywords)), v.extra_builtins != null && (P = P.concat(v.extra_builtins));
        var M = !(v.version && Number(v.version) < 3);
        if (M) {
          var B = v.identifiers || /^[_A-Za-z\u00A1-\uFFFF][_A-Za-z0-9\u00A1-\uFFFF]*/;
          A = A.concat(["nonlocal", "None", "aiter", "anext", "async", "await", "breakpoint", "match", "case"]), P = P.concat(["ascii", "bytes", "exec", "print"]);
          var _ = new RegExp(`^(([rbuf]|(br)|(rb)|(fr)|(rf))?('{3}|"{3}|['"]))`, "i");
        } else {
          var B = v.identifiers || /^[_A-Za-z][_A-Za-z0-9]*/;
          A = A.concat(["exec", "print"]), P = P.concat([
            "apply",
            "basestring",
            "buffer",
            "cmp",
            "coerce",
            "execfile",
            "file",
            "intern",
            "long",
            "raw_input",
            "reduce",
            "reload",
            "unichr",
            "unicode",
            "xrange",
            "None"
          ]);
          var _ = new RegExp(`^(([rubf]|(ur)|(br))?('{3}|"{3}|['"]))`, "i");
        }
        var T = a(A), O = a(P);
        function I(ne, Q) {
          var z = ne.sol() && Q.lastToken != "\\";
          if (z && (Q.indent = ne.indentation()), z && d(Q).type == "py") {
            var X = d(Q).offset;
            if (ne.eatSpace()) {
              var ue = ne.indentation();
              return ue > X ? K(Q) : ue < X && J(ne, Q) && ne.peek() != "#" && (Q.errorToken = !0), null;
            } else {
              var Be = q(ne, Q);
              return X > 0 && J(ne, Q) && (Be += " " + b), Be;
            }
          }
          return q(ne, Q);
        }
        function q(ne, Q, z) {
          if (ne.eatSpace()) return null;
          if (!z && ne.match(/^#.*/)) return "comment";
          if (ne.match(/^[0-9\.]/, !1)) {
            var X = !1;
            if (ne.match(/^[\d_]*\.\d+(e[\+\-]?\d+)?/i) && (X = !0), ne.match(/^[\d_]+\.\d*/) && (X = !0), ne.match(/^\.\d+/) && (X = !0), X)
              return ne.eat(/J/i), "number";
            var ue = !1;
            if (ne.match(/^0x[0-9a-f_]+/i) && (ue = !0), ne.match(/^0b[01_]+/i) && (ue = !0), ne.match(/^0o[0-7_]+/i) && (ue = !0), ne.match(/^[1-9][\d_]*(e[\+\-]?[\d_]+)?/) && (ne.eat(/J/i), ue = !0), ne.match(/^0(?![\dx])/i) && (ue = !0), ue)
              return ne.eat(/L/i), "number";
          }
          if (ne.match(_)) {
            var Be = ne.current().toLowerCase().indexOf("f") !== -1;
            return Be ? (Q.tokenize = F(ne.current(), Q.tokenize), Q.tokenize(ne, Q)) : (Q.tokenize = W(ne.current(), Q.tokenize), Q.tokenize(ne, Q));
          }
          for (var te = 0; te < C.length; te++)
            if (ne.match(C[te])) return "operator";
          return ne.match(w) ? "punctuation" : Q.lastToken == "." && ne.match(B) ? "property" : ne.match(T) || ne.match(o) ? "keyword" : ne.match(O) ? "builtin" : ne.match(/^(self|cls)\b/) ? "variable-2" : ne.match(B) ? Q.lastToken == "def" || Q.lastToken == "class" ? "def" : "variable" : (ne.next(), z ? null : b);
        }
        function F(ne, Q) {
          for (; "rubf".indexOf(ne.charAt(0).toLowerCase()) >= 0; )
            ne = ne.substr(1);
          var z = ne.length == 1, X = "string";
          function ue(te) {
            return function(G, ie) {
              var oe = q(G, ie, !0);
              return oe == "punctuation" && (G.current() == "{" ? ie.tokenize = ue(te + 1) : G.current() == "}" && (te > 1 ? ie.tokenize = ue(te - 1) : ie.tokenize = Be)), oe;
            };
          }
          function Be(te, G) {
            for (; !te.eol(); )
              if (te.eatWhile(/[^'"\{\}\\]/), te.eat("\\")) {
                if (te.next(), z && te.eol())
                  return X;
              } else {
                if (te.match(ne))
                  return G.tokenize = Q, X;
                if (te.match("{{"))
                  return X;
                if (te.match("{", !1))
                  return G.tokenize = ue(0), te.current() ? X : G.tokenize(te, G);
                if (te.match("}}"))
                  return X;
                if (te.match("}"))
                  return b;
                te.eat(/['"]/);
              }
            if (z) {
              if (v.singleLineStringErrors)
                return b;
              G.tokenize = Q;
            }
            return X;
          }
          return Be.isString = !0, Be;
        }
        function W(ne, Q) {
          for (; "rubf".indexOf(ne.charAt(0).toLowerCase()) >= 0; )
            ne = ne.substr(1);
          var z = ne.length == 1, X = "string";
          function ue(Be, te) {
            for (; !Be.eol(); )
              if (Be.eatWhile(/[^'"\\]/), Be.eat("\\")) {
                if (Be.next(), z && Be.eol())
                  return X;
              } else {
                if (Be.match(ne))
                  return te.tokenize = Q, X;
                Be.eat(/['"]/);
              }
            if (z) {
              if (v.singleLineStringErrors)
                return b;
              te.tokenize = Q;
            }
            return X;
          }
          return ue.isString = !0, ue;
        }
        function K(ne) {
          for (; d(ne).type != "py"; ) ne.scopes.pop();
          ne.scopes.push({
            offset: d(ne).offset + g.indentUnit,
            type: "py",
            align: null
          });
        }
        function Z(ne, Q, z) {
          var X = ne.match(/^[\s\[\{\(]*(?:#|$)/, !1) ? null : ne.column() + 1;
          Q.scopes.push({
            offset: Q.indent + E,
            type: z,
            align: X
          });
        }
        function J(ne, Q) {
          for (var z = ne.indentation(); Q.scopes.length > 1 && d(Q).offset > z; ) {
            if (d(Q).type != "py") return !0;
            Q.scopes.pop();
          }
          return d(Q).offset != z;
        }
        function re(ne, Q) {
          ne.sol() && (Q.beginningOfLine = !0, Q.dedent = !1);
          var z = Q.tokenize(ne, Q), X = ne.current();
          if (Q.beginningOfLine && X == "@")
            return ne.match(B, !1) ? "meta" : M ? "operator" : b;
          if (/\S/.test(X) && (Q.beginningOfLine = !1), (z == "variable" || z == "builtin") && Q.lastToken == "meta" && (z = "meta"), (X == "pass" || X == "return") && (Q.dedent = !0), X == "lambda" && (Q.lambda = !0), X == ":" && !Q.lambda && d(Q).type == "py" && ne.match(/^\s*(?:#|$)/, !1) && K(Q), X.length == 1 && !/string|comment/.test(z)) {
            var ue = "[({".indexOf(X);
            if (ue != -1 && Z(ne, Q, "])}".slice(ue, ue + 1)), ue = "])}".indexOf(X), ue != -1)
              if (d(Q).type == X) Q.indent = Q.scopes.pop().offset - E;
              else return b;
          }
          return Q.dedent && ne.eol() && d(Q).type == "py" && Q.scopes.length > 1 && Q.scopes.pop(), z;
        }
        var V = {
          startState: function(ne) {
            return {
              tokenize: I,
              scopes: [{ offset: ne || 0, type: "py", align: null }],
              indent: ne || 0,
              lastToken: null,
              lambda: !1,
              dedent: 0
            };
          },
          token: function(ne, Q) {
            var z = Q.errorToken;
            z && (Q.errorToken = !1);
            var X = re(ne, Q);
            return X && X != "comment" && (Q.lastToken = X == "keyword" || X == "punctuation" ? ne.current() : X), X == "punctuation" && (X = null), ne.eol() && Q.lambda && (Q.lambda = !1), z ? X + " " + b : X;
          },
          indent: function(ne, Q) {
            if (ne.tokenize != I)
              return ne.tokenize.isString ? n.Pass : 0;
            var z = d(ne), X = z.type == Q.charAt(0) || z.type == "py" && !ne.dedent && /^(else:|elif |except |finally:)/.test(Q);
            return z.align != null ? z.align - (X ? 1 : 0) : z.offset - (X ? E : 0);
          },
          electricInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/,
          closeBrackets: { triples: `'"` },
          lineComment: "#",
          fold: "indent"
        };
        return V;
      }), n.defineMIME("text/x-python", "python");
      var f = function(g) {
        return g.split(" ");
      };
      n.defineMIME("text/x-cython", {
        name: "python",
        extra_keywords: f("by cdef cimport cpdef ctypedef enum except extern gil include nogil property public readonly struct union DEF IF ELIF ELSE")
      });
    });
  })()), python.exports;
}
requirePython();
requireRuby();
var shell = { exports: {} }, hasRequiredShell;
function requireShell() {
  return hasRequiredShell || (hasRequiredShell = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("shell", function() {
        var a = {};
        function o(k, E) {
          for (var A = 0; A < E.length; A++)
            a[E[A]] = k;
        }
        var s = ["true", "false"], u = [
          "if",
          "then",
          "do",
          "else",
          "elif",
          "while",
          "until",
          "for",
          "in",
          "esac",
          "fi",
          "fin",
          "fil",
          "done",
          "exit",
          "set",
          "unset",
          "export",
          "function"
        ], d = [
          "ab",
          "awk",
          "bash",
          "beep",
          "cat",
          "cc",
          "cd",
          "chown",
          "chmod",
          "chroot",
          "clear",
          "cp",
          "curl",
          "cut",
          "diff",
          "echo",
          "find",
          "gawk",
          "gcc",
          "get",
          "git",
          "grep",
          "hg",
          "kill",
          "killall",
          "ln",
          "ls",
          "make",
          "mkdir",
          "openssl",
          "mv",
          "nc",
          "nl",
          "node",
          "npm",
          "ping",
          "ps",
          "restart",
          "rm",
          "rmdir",
          "sed",
          "service",
          "sh",
          "shopt",
          "shred",
          "source",
          "sort",
          "sleep",
          "ssh",
          "start",
          "stop",
          "su",
          "sudo",
          "svn",
          "tee",
          "telnet",
          "top",
          "touch",
          "vi",
          "vim",
          "wall",
          "wc",
          "wget",
          "who",
          "write",
          "yes",
          "zsh"
        ];
        n.registerHelper("hintWords", "shell", s.concat(u, d)), o("atom", s), o("keyword", u), o("builtin", d);
        function f(k, E) {
          if (k.eatSpace()) return null;
          var A = k.sol(), P = k.next();
          if (P === "\\")
            return k.next(), null;
          if (P === "'" || P === '"' || P === "`")
            return E.tokens.unshift(g(P, P === "`" ? "quote" : "string")), C(k, E);
          if (P === "#")
            return A && k.eat("!") ? (k.skipToEnd(), "meta") : (k.skipToEnd(), "comment");
          if (P === "$")
            return E.tokens.unshift(b), C(k, E);
          if (P === "+" || P === "=")
            return "operator";
          if (P === "-")
            return k.eat("-"), k.eatWhile(/\w/), "attribute";
          if (P == "<") {
            if (k.match("<<")) return "operator";
            var M = k.match(/^<-?\s*['"]?([^'"]*)['"]?/);
            if (M)
              return E.tokens.unshift(w(M[1])), "string-2";
          }
          if (/\d/.test(P) && (k.eatWhile(/\d/), k.eol() || !/\w/.test(k.peek())))
            return "number";
          k.eatWhile(/[\w-]/);
          var B = k.current();
          return k.peek() === "=" && /\w+/.test(B) ? "def" : a.hasOwnProperty(B) ? a[B] : null;
        }
        function g(k, E) {
          var A = k == "(" ? ")" : k == "{" ? "}" : k;
          return function(P, M) {
            for (var B, _ = !1; (B = P.next()) != null; ) {
              if (B === A && !_) {
                M.tokens.shift();
                break;
              } else if (B === "$" && !_ && k !== "'" && P.peek() != A) {
                _ = !0, P.backUp(1), M.tokens.unshift(b);
                break;
              } else {
                if (!_ && k !== A && B === k)
                  return M.tokens.unshift(g(k, E)), C(P, M);
                if (!_ && /['"]/.test(B) && !/['"]/.test(k)) {
                  M.tokens.unshift(v(B, "string")), P.backUp(1);
                  break;
                }
              }
              _ = !_ && B === "\\";
            }
            return E;
          };
        }
        function v(k, E) {
          return function(A, P) {
            return P.tokens[0] = g(k, E), A.next(), C(A, P);
          };
        }
        var b = function(k, E) {
          E.tokens.length > 1 && k.eat("$");
          var A = k.next();
          return /['"({]/.test(A) ? (E.tokens[0] = g(A, A == "(" ? "quote" : A == "{" ? "def" : "string"), C(k, E)) : (/\d/.test(A) || k.eatWhile(/\w/), E.tokens.shift(), "def");
        };
        function w(k) {
          return function(E, A) {
            return E.sol() && E.string == k && A.tokens.shift(), E.skipToEnd(), "string-2";
          };
        }
        function C(k, E) {
          return (E.tokens[0] || f)(k, E);
        }
        return {
          startState: function() {
            return { tokens: [] };
          },
          token: function(k, E) {
            return C(k, E);
          },
          closeBrackets: "()[]{}''\"\"``",
          lineComment: "#",
          fold: "brace"
        };
      }), n.defineMIME("text/x-sh", "shell"), n.defineMIME("application/x-sh", "shell");
    });
  })()), shell.exports;
}
requireShell();
var sql = { exports: {} }, hasRequiredSql;
function requireSql() {
  return hasRequiredSql || (hasRequiredSql = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("sql", function(v, b) {
        var w = b.client || {}, C = b.atoms || { false: !0, true: !0, null: !0 }, k = b.builtin || f(g), E = b.keywords || f(d), A = b.operatorChars || /^[*+\-%<>!=&|~^\/]/, P = b.support || {}, M = b.hooks || {}, B = b.dateSQL || { date: !0, time: !0, timestamp: !0 }, _ = b.backslashStringEscapes !== !1, T = b.brackets || /^[\{}\(\)\[\]]/, O = b.punctuation || /^[;.,:]/;
        function I(Z, J) {
          var re = Z.next();
          if (M[re]) {
            var V = M[re](Z, J);
            if (V !== !1) return V;
          }
          if (P.hexNumber && (re == "0" && Z.match(/^[xX][0-9a-fA-F]+/) || (re == "x" || re == "X") && Z.match(/^'[0-9a-fA-F]*'/)))
            return "number";
          if (P.binaryNumber && ((re == "b" || re == "B") && Z.match(/^'[01]*'/) || re == "0" && Z.match(/^b[01]+/)))
            return "number";
          if (re.charCodeAt(0) > 47 && re.charCodeAt(0) < 58)
            return Z.match(/^[0-9]*(\.[0-9]+)?([eE][-+]?[0-9]+)?/), P.decimallessFloat && Z.match(/^\.(?!\.)/), "number";
          if (re == "?" && (Z.eatSpace() || Z.eol() || Z.eat(";")))
            return "variable-3";
          if (re == "'" || re == '"' && P.doubleQuote)
            return J.tokenize = q(re), J.tokenize(Z, J);
          if ((P.nCharCast && (re == "n" || re == "N") || P.charsetCast && re == "_" && Z.match(/[a-z][a-z0-9]*/i)) && (Z.peek() == "'" || Z.peek() == '"'))
            return "keyword";
          if (P.escapeConstant && (re == "e" || re == "E") && (Z.peek() == "'" || Z.peek() == '"' && P.doubleQuote))
            return J.tokenize = function(Q, z) {
              return (z.tokenize = q(Q.next(), !0))(Q, z);
            }, "keyword";
          if (P.commentSlashSlash && re == "/" && Z.eat("/"))
            return Z.skipToEnd(), "comment";
          if (P.commentHash && re == "#" || re == "-" && Z.eat("-") && (!P.commentSpaceRequired || Z.eat(" ")))
            return Z.skipToEnd(), "comment";
          if (re == "/" && Z.eat("*"))
            return J.tokenize = F(1), J.tokenize(Z, J);
          if (re == ".") {
            if (P.zerolessFloat && Z.match(/^(?:\d+(?:e[+-]?\d+)?)/i))
              return "number";
            if (Z.match(/^\.+/))
              return null;
            if (Z.match(/^[\w\d_$#]+/))
              return "variable-2";
          } else {
            if (A.test(re))
              return Z.eatWhile(A), "operator";
            if (T.test(re))
              return "bracket";
            if (O.test(re))
              return Z.eatWhile(O), "punctuation";
            if (re == "{" && (Z.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || Z.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/)))
              return "number";
            Z.eatWhile(/^[_\w\d]/);
            var ne = Z.current().toLowerCase();
            return B.hasOwnProperty(ne) && (Z.match(/^( )+'[^']*'/) || Z.match(/^( )+"[^"]*"/)) ? "number" : C.hasOwnProperty(ne) ? "atom" : k.hasOwnProperty(ne) ? "type" : E.hasOwnProperty(ne) ? "keyword" : w.hasOwnProperty(ne) ? "builtin" : null;
          }
        }
        function q(Z, J) {
          return function(re, V) {
            for (var ne = !1, Q; (Q = re.next()) != null; ) {
              if (Q == Z && !ne) {
                V.tokenize = I;
                break;
              }
              ne = (_ || J) && !ne && Q == "\\";
            }
            return "string";
          };
        }
        function F(Z) {
          return function(J, re) {
            var V = J.match(/^.*?(\/\*|\*\/)/);
            return V ? V[1] == "/*" ? re.tokenize = F(Z + 1) : Z > 1 ? re.tokenize = F(Z - 1) : re.tokenize = I : J.skipToEnd(), "comment";
          };
        }
        function W(Z, J, re) {
          J.context = {
            prev: J.context,
            indent: Z.indentation(),
            col: Z.column(),
            type: re
          };
        }
        function K(Z) {
          Z.indent = Z.context.indent, Z.context = Z.context.prev;
        }
        return {
          startState: function() {
            return { tokenize: I, context: null };
          },
          token: function(Z, J) {
            if (Z.sol() && J.context && J.context.align == null && (J.context.align = !1), J.tokenize == I && Z.eatSpace()) return null;
            var re = J.tokenize(Z, J);
            if (re == "comment") return re;
            J.context && J.context.align == null && (J.context.align = !0);
            var V = Z.current();
            return V == "(" ? W(Z, J, ")") : V == "[" ? W(Z, J, "]") : J.context && J.context.type == V && K(J), re;
          },
          indent: function(Z, J) {
            var re = Z.context;
            if (!re) return n.Pass;
            var V = J.charAt(0) == re.type;
            return re.align ? re.col + (V ? 0 : 1) : re.indent + (V ? 0 : v.indentUnit);
          },
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: P.commentSlashSlash ? "//" : P.commentHash ? "#" : "--",
          closeBrackets: "()[]{}''\"\"``",
          config: b
        };
      });
      function a(v) {
        for (var b; (b = v.next()) != null; )
          if (b == "`" && !v.eat("`")) return "variable-2";
        return v.backUp(v.current().length - 1), v.eatWhile(/\w/) ? "variable-2" : null;
      }
      function o(v) {
        for (var b; (b = v.next()) != null; )
          if (b == '"' && !v.eat('"')) return "variable-2";
        return v.backUp(v.current().length - 1), v.eatWhile(/\w/) ? "variable-2" : null;
      }
      function s(v) {
        return v.eat("@") && (v.match("session."), v.match("local."), v.match("global.")), v.eat("'") ? (v.match(/^.*'/), "variable-2") : v.eat('"') ? (v.match(/^.*"/), "variable-2") : v.eat("`") ? (v.match(/^.*`/), "variable-2") : v.match(/^[0-9a-zA-Z$\.\_]+/) ? "variable-2" : null;
      }
      function u(v) {
        return v.eat("N") ? "atom" : v.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;
      }
      var d = "alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit ";
      function f(v) {
        for (var b = {}, w = v.split(" "), C = 0; C < w.length; ++C) b[w[C]] = !0;
        return b;
      }
      var g = "bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric";
      n.defineMIME("text/x-sql", {
        name: "sql",
        keywords: f(d + "begin"),
        builtin: f(g),
        atoms: f("false true null unknown"),
        dateSQL: f("date time timestamp"),
        support: f("doubleQuote binaryNumber hexNumber")
      }), n.defineMIME("text/x-mssql", {
        name: "sql",
        client: f("$partition binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id"),
        keywords: f(d + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx updlock with"),
        builtin: f("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),
        atoms: f("is not null like and or in left right between inner outer join all any some cross unpivot pivot exists"),
        operatorChars: /^[*+\-%<>!=^\&|\/]/,
        brackets: /^[\{}\(\)]/,
        punctuation: /^[;.,:/]/,
        backslashStringEscapes: !1,
        dateSQL: f("date datetimeoffset datetime2 smalldatetime datetime time"),
        hooks: {
          "@": s
        }
      }), n.defineMIME("text/x-mysql", {
        name: "sql",
        client: f("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: f(d + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group group_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: f("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: f("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: f("date time timestamp"),
        support: f("decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@": s,
          "`": a,
          "\\": u
        }
      }), n.defineMIME("text/x-mariadb", {
        name: "sql",
        client: f("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),
        keywords: f(d + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group group_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),
        builtin: f("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),
        atoms: f("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^]/,
        dateSQL: f("date time timestamp"),
        support: f("decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),
        hooks: {
          "@": s,
          "`": a,
          "\\": u
        }
      }), n.defineMIME("text/x-sqlite", {
        name: "sql",
        // commands of the official SQLite client, ref: https://www.sqlite.org/cli.html#dotcmd
        client: f("auth backup bail binary changes check clone databases dbinfo dump echo eqp exit explain fullschema headers help import imposter indexes iotrace limit lint load log mode nullvalue once open output print prompt quit read restore save scanstats schema separator session shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width"),
        // ref: http://sqlite.org/lang_keywords.html
        keywords: f(d + "abort action add after all analyze attach autoincrement before begin cascade case cast check collate column commit conflict constraint cross current_date current_time current_timestamp database default deferrable deferred detach each else end escape except exclusive exists explain fail for foreign full glob if ignore immediate index indexed initially inner instead intersect isnull key left limit match natural no notnull null of offset outer plan pragma primary query raise recursive references regexp reindex release rename replace restrict right rollback row savepoint temp temporary then to transaction trigger unique using vacuum view virtual when with without"),
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        builtin: f("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text clob bigint int int2 int8 integer float double char varchar date datetime year unsigned signed numeric real"),
        // ref: http://sqlite.org/syntax/literal-value.html
        atoms: f("null current_date current_time current_timestamp"),
        // ref: http://sqlite.org/lang_expr.html#binaryops
        operatorChars: /^[*+\-%<>!=&|/~]/,
        // SQLite is weakly typed, ref: http://sqlite.org/datatype3.html. This is just a list of some common types.
        dateSQL: f("date time timestamp datetime"),
        support: f("decimallessFloat zerolessFloat"),
        identifierQuote: '"',
        //ref: http://sqlite.org/lang_keywords.html
        hooks: {
          // bind-parameters ref:http://sqlite.org/lang_expr.html#varparam
          "@": s,
          ":": s,
          "?": s,
          $: s,
          // The preferred way to escape Identifiers is using double quotes, ref: http://sqlite.org/lang_keywords.html
          '"': o,
          // there is also support for backticks, ref: http://sqlite.org/lang_keywords.html
          "`": a
        }
      }), n.defineMIME("text/x-cassandra", {
        name: "sql",
        client: {},
        keywords: f("add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime"),
        builtin: f("ascii bigint blob boolean counter decimal double float frozen inet int list map static text timestamp timeuuid tuple uuid varchar varint"),
        atoms: f("false true infinity NaN"),
        operatorChars: /^[<>=]/,
        dateSQL: {},
        support: f("commentSlashSlash decimallessFloat"),
        hooks: {}
      }), n.defineMIME("text/x-plsql", {
        name: "sql",
        client: f("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),
        keywords: f("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),
        builtin: f("abs acos add_months ascii asin atan atan2 average bfile bfilename bigserial bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least length lengthb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim serial sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid unlogged upper user userenv varchar varchar2 variance varying vsize xml"),
        operatorChars: /^[*\/+\-%<>!=~]/,
        dateSQL: f("date time timestamp"),
        support: f("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")
      }), n.defineMIME("text/x-hive", {
        name: "sql",
        keywords: f("select alter $elem$ $key$ $value$ add after all analyze and archive as asc before between binary both bucket buckets by cascade case cast change cluster clustered clusterstatus collection column columns comment compute concatenate continue create cross cursor data database databases dbproperties deferred delete delimited desc describe directory disable distinct distribute drop else enable end escaped exclusive exists explain export extended external fetch fields fileformat first format formatted from full function functions grant group having hold_ddltime idxproperties if import in index indexes inpath inputdriver inputformat insert intersect into is items join keys lateral left like limit lines load local location lock locks mapjoin materialized minus msck no_drop nocompress not of offline on option or order out outer outputdriver outputformat overwrite partition partitioned partitions percent plus preserve procedure purge range rcfile read readonly reads rebuild recordreader recordwriter recover reduce regexp rename repair replace restrict revoke right rlike row schema schemas semi sequencefile serde serdeproperties set shared show show_database sort sorted ssl statistics stored streamtable table tables tablesample tblproperties temporary terminated textfile then tmp to touch transform trigger unarchive undo union uniquejoin unlock update use using utc utc_tmestamp view when where while with admin authorization char compact compactions conf cube current current_date current_timestamp day decimal defined dependency directories elem_type exchange file following for grouping hour ignore inner interval jar less logical macro minute month more none noscan over owner partialscan preceding pretty principals protection reload rewrite role roles rollup rows second server sets skewed transactions truncate unbounded unset uri user values window year"),
        builtin: f("bool boolean long timestamp tinyint smallint bigint int float double date datetime unsigned string array struct map uniontype key_type utctimestamp value_type varchar"),
        atoms: f("false true null unknown"),
        operatorChars: /^[*+\-%<>!=]/,
        dateSQL: f("date timestamp"),
        support: f("doubleQuote binaryNumber hexNumber")
      }), n.defineMIME("text/x-pgsql", {
        name: "sql",
        client: f("source"),
        // For PostgreSQL - https://www.postgresql.org/docs/11/sql-keywords-appendix.html
        // For pl/pgsql lang - https://github.com/postgres/postgres/blob/REL_11_2/src/pl/plpgsql/src/pl_scanner.c
        keywords: f(d + "a abort abs absent absolute access according action ada add admin after aggregate alias all allocate also alter always analyse analyze and any are array array_agg array_max_cardinality as asc asensitive assert assertion assignment asymmetric at atomic attach attribute attributes authorization avg backward base64 before begin begin_frame begin_partition bernoulli between bigint binary bit bit_length blob blocked bom boolean both breadth by c cache call called cardinality cascade cascaded case cast catalog catalog_name ceil ceiling chain char char_length character character_length character_set_catalog character_set_name character_set_schema characteristics characters check checkpoint class class_origin clob close cluster coalesce cobol collate collation collation_catalog collation_name collation_schema collect column column_name columns command_function command_function_code comment comments commit committed concurrently condition condition_number configuration conflict connect connection connection_name constant constraint constraint_catalog constraint_name constraint_schema constraints constructor contains content continue control conversion convert copy corr corresponding cost count covar_pop covar_samp create cross csv cube cume_dist current current_catalog current_date current_default_transform_group current_path current_role current_row current_schema current_time current_timestamp current_transform_group_for_type current_user cursor cursor_name cycle data database datalink datatype date datetime_interval_code datetime_interval_precision day db deallocate debug dec decimal declare default defaults deferrable deferred defined definer degree delete delimiter delimiters dense_rank depends depth deref derived desc describe descriptor detach detail deterministic diagnostics dictionary disable discard disconnect dispatch distinct dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue do document domain double drop dump dynamic dynamic_function dynamic_function_code each element else elseif elsif empty enable encoding encrypted end end_frame end_partition endexec enforced enum equals errcode error escape event every except exception exclude excluding exclusive exec execute exists exit exp explain expression extension external extract false family fetch file filter final first first_value flag float floor following for force foreach foreign fortran forward found frame_row free freeze from fs full function functions fusion g general generated get global go goto grant granted greatest group grouping groups handler having header hex hierarchy hint hold hour id identity if ignore ilike immediate immediately immutable implementation implicit import in include including increment indent index indexes indicator info inherit inherits initially inline inner inout input insensitive insert instance instantiable instead int integer integrity intersect intersection interval into invoker is isnull isolation join k key key_member key_type label lag language large last last_value lateral lead leading leakproof least left length level library like like_regex limit link listen ln load local localtime localtimestamp location locator lock locked log logged loop lower m map mapping match matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text method min minute minvalue mod mode modifies module month more move multiset mumps name names namespace national natural nchar nclob nesting new next nfc nfd nfkc nfkd nil no none normalize normalized not nothing notice notify notnull nowait nth_value ntile null nullable nullif nulls number numeric object occurrences_regex octet_length octets of off offset oids old on only open operator option options or order ordering ordinality others out outer output over overlaps overlay overriding owned owner p pad parallel parameter parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partial partition pascal passing passthrough password path percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding precision prepare prepared preserve primary print_strict_params prior privileges procedural procedure procedures program public publication query quote raise range rank read reads real reassign recheck recovery recursive ref references referencing refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex relative release rename repeatable replace replica requiring reset respect restart restore restrict result result_oid return returned_cardinality returned_length returned_octet_length returned_sqlstate returning returns reverse revoke right role rollback rollup routine routine_catalog routine_name routine_schema routines row row_count row_number rows rowtype rule savepoint scale schema schema_name schemas scope scope_catalog scope_name scope_schema scroll search second section security select selective self sensitive sequence sequences serializable server server_name session session_user set setof sets share show similar simple size skip slice smallint snapshot some source space specific specific_name specifictype sql sqlcode sqlerror sqlexception sqlstate sqlwarning sqrt stable stacked standalone start state statement static statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time system_user t table table_name tables tablesample tablespace temp template temporary text then ties time timestamp timezone_hour timezone_minute to token top_level_count trailing transaction transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex translation treat trigger trigger_catalog trigger_name trigger_schema trim trim_array true truncate trusted type types uescape unbounded uncommitted under unencrypted union unique unknown unlink unlisten unlogged unnamed unnest until untyped update upper uri usage use_column use_variable user user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema using vacuum valid validate validator value value_of values var_pop var_samp varbinary varchar variable_conflict variadic varying verbose version versioning view views volatile warning when whenever where while whitespace width_bucket window with within without work wrapper write xml xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate year yes zone"),
        // https://www.postgresql.org/docs/11/datatype.html
        builtin: f("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: f("false true null unknown"),
        operatorChars: /^[*\/+\-%<>!=&|^\/#@?~]/,
        backslashStringEscapes: !1,
        dateSQL: f("date time timestamp"),
        support: f("decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast escapeConstant")
      }), n.defineMIME("text/x-gql", {
        name: "sql",
        keywords: f("ancestor and asc by contains desc descendant distinct from group has in is limit offset on order select superset where"),
        atoms: f("false true"),
        builtin: f("blob datetime first key __key__ string integer double boolean null"),
        operatorChars: /^[*+\-%<>!=]/
      }), n.defineMIME("text/x-gpsql", {
        name: "sql",
        client: f("source"),
        //https://github.com/greenplum-db/gpdb/blob/master/src/include/parser/kwlist.h
        keywords: f("abort absolute access action active add admin after aggregate all also alter always analyse analyze and any array as asc assertion assignment asymmetric at authorization backward before begin between bigint binary bit boolean both by cache called cascade cascaded case cast chain char character characteristics check checkpoint class close cluster coalesce codegen collate column comment commit committed concurrency concurrently configuration connection constraint constraints contains content continue conversion copy cost cpu_rate_limit create createdb createexttable createrole createuser cross csv cube current current_catalog current_date current_role current_schema current_time current_timestamp current_user cursor cycle data database day deallocate dec decimal declare decode default defaults deferrable deferred definer delete delimiter delimiters deny desc dictionary disable discard distinct distributed do document domain double drop dxl each else enable encoding encrypted end enum errors escape every except exchange exclude excluding exclusive execute exists explain extension external extract false family fetch fields filespace fill filter first float following for force foreign format forward freeze from full function global grant granted greatest group group_id grouping handler hash having header hold host hour identity if ignore ilike immediate immutable implicit in including inclusive increment index indexes inherit inherits initially inline inner inout input insensitive insert instead int integer intersect interval into invoker is isnull isolation join key language large last leading least left level like limit list listen load local localtime localtimestamp location lock log login mapping master match maxvalue median merge minute minvalue missing mode modifies modify month move name names national natural nchar new newline next no nocreatedb nocreateexttable nocreaterole nocreateuser noinherit nologin none noovercommit nosuperuser not nothing notify notnull nowait null nullif nulls numeric object of off offset oids old on only operator option options or order ordered others out outer over overcommit overlaps overlay owned owner parser partial partition partitions passing password percent percentile_cont percentile_disc placing plans position preceding precision prepare prepared preserve primary prior privileges procedural procedure protocol queue quote randomly range read readable reads real reassign recheck recursive ref references reindex reject relative release rename repeatable replace replica reset resource restart restrict returning returns revoke right role rollback rollup rootpartition row rows rule savepoint scatter schema scroll search second security segment select sequence serializable session session_user set setof sets share show similar simple smallint some split sql stable standalone start statement statistics stdin stdout storage strict strip subpartition subpartitions substring superuser symmetric sysid system table tablespace temp template temporary text then threshold ties time timestamp to trailing transaction treat trigger trim true truncate trusted type unbounded uncommitted unencrypted union unique unknown unlisten until update user using vacuum valid validation validator value values varchar variadic varying verbose version view volatile web when where whitespace window with within without work writable write xml xmlattributes xmlconcat xmlelement xmlexists xmlforest xmlparse xmlpi xmlroot xmlserialize year yes zone"),
        builtin: f("bigint int8 bigserial serial8 bit varying varbit boolean bool box bytea character char varchar cidr circle date double precision float float8 inet integer int int4 interval json jsonb line lseg macaddr macaddr8 money numeric decimal path pg_lsn point polygon real float4 smallint int2 smallserial serial2 serial serial4 text time without zone with timetz timestamp timestamptz tsquery tsvector txid_snapshot uuid xml"),
        atoms: f("false true null unknown"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: f("date time timestamp"),
        support: f("decimallessFloat zerolessFloat binaryNumber hexNumber nCharCast charsetCast")
      }), n.defineMIME("text/x-sparksql", {
        name: "sql",
        keywords: f("add after all alter analyze and anti archive array as asc at between bucket buckets by cache cascade case cast change clear cluster clustered codegen collection column columns comment commit compact compactions compute concatenate cost create cross cube current current_date current_timestamp database databases data dbproperties defined delete delimited deny desc describe dfs directories distinct distribute drop else end escaped except exchange exists explain export extended external false fields fileformat first following for format formatted from full function functions global grant group grouping having if ignore import in index indexes inner inpath inputformat insert intersect interval into is items join keys last lateral lazy left like limit lines list load local location lock locks logical macro map minus msck natural no not null nulls of on optimize option options or order out outer outputformat over overwrite partition partitioned partitions percent preceding principals purge range recordreader recordwriter recover reduce refresh regexp rename repair replace reset restrict revoke right rlike role roles rollback rollup row rows schema schemas select semi separated serde serdeproperties set sets show skewed sort sorted start statistics stored stratify struct table tables tablesample tblproperties temp temporary terminated then to touch transaction transactions transform true truncate unarchive unbounded uncache union unlock unset use using values view when where window with"),
        builtin: f("abs acos acosh add_months aggregate and any approx_count_distinct approx_percentile array array_contains array_distinct array_except array_intersect array_join array_max array_min array_position array_remove array_repeat array_sort array_union arrays_overlap arrays_zip ascii asin asinh assert_true atan atan2 atanh avg base64 between bigint bin binary bit_and bit_count bit_get bit_length bit_or bit_xor bool_and bool_or boolean bround btrim cardinality case cast cbrt ceil ceiling char char_length character_length chr coalesce collect_list collect_set concat concat_ws conv corr cos cosh cot count count_if count_min_sketch covar_pop covar_samp crc32 cume_dist current_catalog current_database current_date current_timestamp current_timezone current_user date date_add date_format date_from_unix_date date_part date_sub date_trunc datediff day dayofmonth dayofweek dayofyear decimal decode degrees delimited dense_rank div double e element_at elt encode every exists exp explode explode_outer expm1 extract factorial filter find_in_set first first_value flatten float floor forall format_number format_string from_csv from_json from_unixtime from_utc_timestamp get_json_object getbit greatest grouping grouping_id hash hex hour hypot if ifnull in initcap inline inline_outer input_file_block_length input_file_block_start input_file_name inputformat instr int isnan isnotnull isnull java_method json_array_length json_object_keys json_tuple kurtosis lag last last_day last_value lcase lead least left length levenshtein like ln locate log log10 log1p log2 lower lpad ltrim make_date make_dt_interval make_interval make_timestamp make_ym_interval map map_concat map_entries map_filter map_from_arrays map_from_entries map_keys map_values map_zip_with max max_by md5 mean min min_by minute mod monotonically_increasing_id month months_between named_struct nanvl negative next_day not now nth_value ntile nullif nvl nvl2 octet_length or outputformat overlay parse_url percent_rank percentile percentile_approx pi pmod posexplode posexplode_outer position positive pow power printf quarter radians raise_error rand randn random rank rcfile reflect regexp regexp_extract regexp_extract_all regexp_like regexp_replace repeat replace reverse right rint rlike round row_number rpad rtrim schema_of_csv schema_of_json second sentences sequence sequencefile serde session_window sha sha1 sha2 shiftleft shiftright shiftrightunsigned shuffle sign signum sin sinh size skewness slice smallint some sort_array soundex space spark_partition_id split sqrt stack std stddev stddev_pop stddev_samp str_to_map string struct substr substring substring_index sum tan tanh textfile timestamp timestamp_micros timestamp_millis timestamp_seconds tinyint to_csv to_date to_json to_timestamp to_unix_timestamp to_utc_timestamp transform transform_keys transform_values translate trim trunc try_add try_divide typeof ucase unbase64 unhex uniontype unix_date unix_micros unix_millis unix_seconds unix_timestamp upper uuid var_pop var_samp variance version weekday weekofyear when width_bucket window xpath xpath_boolean xpath_double xpath_float xpath_int xpath_long xpath_number xpath_short xpath_string xxhash64 year zip_with"),
        atoms: f("false true null"),
        operatorChars: /^[*\/+\-%<>!=~&|^]/,
        dateSQL: f("date time timestamp"),
        support: f("doubleQuote zerolessFloat")
      }), n.defineMIME("text/x-esper", {
        name: "sql",
        client: f("source"),
        // http://www.espertech.com/esper/release-5.5.0/esper-reference/html/appendix_keywords.html
        keywords: f("alter and as asc between by count create delete desc distinct drop from group having in insert into is join like not on or order select set table union update values where limit after all and as at asc avedev avg between by case cast coalesce count create current_timestamp day days delete define desc distinct else end escape events every exists false first from full group having hour hours in inner insert instanceof into irstream is istream join last lastweekday left limit like max match_recognize matches median measures metadatasql min minute minutes msec millisecond milliseconds not null offset on or order outer output partition pattern prev prior regexp retain-union retain-intersection right rstream sec second seconds select set some snapshot sql stddev sum then true unidirectional until update variable weekday when where window"),
        builtin: {},
        atoms: f("false true null"),
        operatorChars: /^[*+\-%<>!=&|^\/#@?~]/,
        dateSQL: f("time"),
        support: f("decimallessFloat zerolessFloat binaryNumber hexNumber")
      }), n.defineMIME("text/x-trino", {
        name: "sql",
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/core/trino-parser/src/main/antlr4/io/trino/sql/parser/SqlBase.g4#L859-L1129
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/docs/src/main/sphinx/functions/list.rst
        keywords: f("abs absent acos add admin after all all_match alter analyze and any any_match approx_distinct approx_most_frequent approx_percentile approx_set arbitrary array_agg array_distinct array_except array_intersect array_join array_max array_min array_position array_remove array_sort array_union arrays_overlap as asc asin at at_timezone atan atan2 authorization avg bar bernoulli beta_cdf between bing_tile bing_tile_at bing_tile_coordinates bing_tile_polygon bing_tile_quadkey bing_tile_zoom_level bing_tiles_around bit_count bitwise_and bitwise_and_agg bitwise_left_shift bitwise_not bitwise_or bitwise_or_agg bitwise_right_shift bitwise_right_shift_arithmetic bitwise_xor bool_and bool_or both by call cardinality cascade case cast catalogs cbrt ceil ceiling char2hexint checksum chr classify coalesce codepoint column columns combinations comment commit committed concat concat_ws conditional constraint contains contains_sequence convex_hull_agg copartition corr cos cosh cosine_similarity count count_if covar_pop covar_samp crc32 create cross cube cume_dist current current_catalog current_date current_groups current_path current_role current_schema current_time current_timestamp current_timezone current_user data date_add date_diff date_format date_parse date_trunc day day_of_month day_of_week day_of_year deallocate default define definer degrees delete dense_rank deny desc describe descriptor distinct distributed dow doy drop e element_at else empty empty_approx_set encoding end error escape evaluate_classifier_predictions every except excluding execute exists exp explain extract false features fetch filter final first first_value flatten floor following for format format_datetime format_number from from_base from_base32 from_base64 from_base64url from_big_endian_32 from_big_endian_64 from_encoded_polyline from_geojson_geometry from_hex from_ieee754_32 from_ieee754_64 from_iso8601_date from_iso8601_timestamp from_iso8601_timestamp_nanos from_unixtime from_unixtime_nanos from_utf8 full functions geometric_mean geometry_from_hadoop_shape geometry_invalid_reason geometry_nearest_points geometry_to_bing_tiles geometry_union geometry_union_agg grant granted grants graphviz great_circle_distance greatest group grouping groups hamming_distance hash_counts having histogram hmac_md5 hmac_sha1 hmac_sha256 hmac_sha512 hour human_readable_seconds if ignore in including index infinity initial inner input insert intersect intersection_cardinality into inverse_beta_cdf inverse_normal_cdf invoker io is is_finite is_infinite is_json_scalar is_nan isolation jaccard_index join json_array json_array_contains json_array_get json_array_length json_exists json_extract json_extract_scalar json_format json_object json_parse json_query json_size json_value keep key keys kurtosis lag last last_day_of_month last_value lateral lead leading learn_classifier learn_libsvm_classifier learn_libsvm_regressor learn_regressor least left length level levenshtein_distance like limit line_interpolate_point line_interpolate_points line_locate_point listagg ln local localtime localtimestamp log log10 log2 logical lower lpad ltrim luhn_check make_set_digest map_agg map_concat map_entries map_filter map_from_entries map_keys map_union map_values map_zip_with match match_recognize matched matches materialized max max_by md5 measures merge merge_set_digest millisecond min min_by minute mod month multimap_agg multimap_from_entries murmur3 nan natural next nfc nfd nfkc nfkd ngrams no none none_match normal_cdf normalize not now nth_value ntile null nullif nulls numeric_histogram object objectid_timestamp of offset omit on one only option or order ordinality outer output over overflow parse_data_size parse_datetime parse_duration partition partitions passing past path pattern per percent_rank permute pi position pow power preceding prepare privileges properties prune qdigest_agg quarter quotes radians rand random range rank read recursive reduce reduce_agg refresh regexp_count regexp_extract regexp_extract_all regexp_like regexp_position regexp_replace regexp_split regr_intercept regr_slope regress rename render repeat repeatable replace reset respect restrict returning reverse revoke rgb right role roles rollback rollup round row_number rows rpad rtrim running scalar schema schemas second security seek select sequence serializable session set sets sha1 sha256 sha512 show shuffle sign simplify_geometry sin skewness skip slice some soundex spatial_partitioning spatial_partitions split split_part split_to_map split_to_multimap spooky_hash_v2_32 spooky_hash_v2_64 sqrt st_area st_asbinary st_astext st_boundary st_buffer st_centroid st_contains st_convexhull st_coorddim st_crosses st_difference st_dimension st_disjoint st_distance st_endpoint st_envelope st_envelopeaspts st_equals st_exteriorring st_geometries st_geometryfromtext st_geometryn st_geometrytype st_geomfrombinary st_interiorringn st_interiorrings st_intersection st_intersects st_isclosed st_isempty st_isring st_issimple st_isvalid st_length st_linefromtext st_linestring st_multipoint st_numgeometries st_numinteriorring st_numpoints st_overlaps st_point st_pointn st_points st_polygon st_relate st_startpoint st_symdifference st_touches st_union st_within st_x st_xmax st_xmin st_y st_ymax st_ymin start starts_with stats stddev stddev_pop stddev_samp string strpos subset substr substring sum system table tables tablesample tan tanh tdigest_agg text then ties timestamp_objectid timezone_hour timezone_minute to to_base to_base32 to_base64 to_base64url to_big_endian_32 to_big_endian_64 to_char to_date to_encoded_polyline to_geojson_geometry to_geometry to_hex to_ieee754_32 to_ieee754_64 to_iso8601 to_milliseconds to_spherical_geography to_timestamp to_unixtime to_utf8 trailing transaction transform transform_keys transform_values translate trim trim_array true truncate try try_cast type typeof uescape unbounded uncommitted unconditional union unique unknown unmatched unnest update upper url_decode url_encode url_extract_fragment url_extract_host url_extract_parameter url_extract_path url_extract_port url_extract_protocol url_extract_query use user using utf16 utf32 utf8 validate value value_at_quantile values values_at_quantiles var_pop var_samp variance verbose version view week week_of_year when where width_bucket wilson_interval_lower wilson_interval_upper window with with_timezone within without word_stem work wrapper write xxhash64 year year_of_week yow zip zip_with"),
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/core/trino-main/src/main/java/io/trino/metadata/TypeRegistry.java#L131-L168
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/plugin/trino-ml/src/main/java/io/trino/plugin/ml/MLPlugin.java#L35
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/plugin/trino-mongodb/src/main/java/io/trino/plugin/mongodb/MongoPlugin.java#L32
        // https://github.com/trinodb/trino/blob/bc7a4eeedde28684c7ae6f74cefcaf7c6e782174/plugin/trino-geospatial/src/main/java/io/trino/plugin/geospatial/GeoPlugin.java#L37
        builtin: f("array bigint bingtile boolean char codepoints color date decimal double function geometry hyperloglog int integer interval ipaddress joniregexp json json2016 jsonpath kdbtree likepattern map model objectid p4hyperloglog precision qdigest re2jregexp real regressor row setdigest smallint sphericalgeography tdigest time timestamp tinyint uuid varbinary varchar zone"),
        atoms: f("false true null unknown"),
        // https://trino.io/docs/current/functions/list.html#id1
        operatorChars: /^[[\]|<>=!\-+*/%]/,
        dateSQL: f("date time timestamp zone"),
        // hexNumber is necessary for VARBINARY literals, e.g. X'65683F'
        // but it also enables 0xFF hex numbers, which Trino doesn't support.
        support: f("decimallessFloat zerolessFloat hexNumber")
      });
    });
  })()), sql.exports;
}
requireSql();
var twig = { exports: {} }, hasRequiredTwig;
function requireTwig() {
  return hasRequiredTwig || (hasRequiredTwig = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireMultiplex());
    })(function(n) {
      n.defineMode("twig:inner", function() {
        var a = ["and", "as", "autoescape", "endautoescape", "block", "do", "endblock", "else", "elseif", "extends", "for", "endfor", "embed", "endembed", "filter", "endfilter", "flush", "from", "if", "endif", "in", "is", "include", "import", "not", "or", "set", "spaceless", "endspaceless", "with", "endwith", "trans", "endtrans", "blocktrans", "endblocktrans", "macro", "endmacro", "use", "verbatim", "endverbatim"], o = /^[+\-*&%=<>!?|~^]/, s = /^[:\[\(\{]/, u = ["true", "false", "null", "empty", "defined", "divisibleby", "divisible by", "even", "odd", "iterable", "sameas", "same as"], d = /^(\d[+\-\*\/])?\d+(\.\d+)?/;
        a = new RegExp("((" + a.join(")|(") + "))\\b"), u = new RegExp("((" + u.join(")|(") + "))\\b");
        function f(g, v) {
          var b = g.peek();
          if (v.incomment)
            return g.skipTo("#}") ? (g.eatWhile(/\#|}/), v.incomment = !1) : g.skipToEnd(), "comment";
          if (v.intag) {
            if (v.operator) {
              if (v.operator = !1, g.match(u))
                return "atom";
              if (g.match(d))
                return "number";
            }
            if (v.sign) {
              if (v.sign = !1, g.match(u))
                return "atom";
              if (g.match(d))
                return "number";
            }
            if (v.instring)
              return b == v.instring && (v.instring = !1), g.next(), "string";
            if (b == "'" || b == '"')
              return v.instring = b, g.next(), "string";
            if (g.match(v.intag + "}") || g.eat("-") && g.match(v.intag + "}"))
              return v.intag = !1, "tag";
            if (g.match(o))
              return v.operator = !0, "operator";
            if (g.match(s))
              v.sign = !0;
            else if (g.eat(" ") || g.sol()) {
              if (g.match(a))
                return "keyword";
              if (g.match(u))
                return "atom";
              if (g.match(d))
                return "number";
              g.sol() && g.next();
            } else
              g.next();
            return "variable";
          } else if (g.eat("{")) {
            if (g.eat("#"))
              return v.incomment = !0, g.skipTo("#}") ? (g.eatWhile(/\#|}/), v.incomment = !1) : g.skipToEnd(), "comment";
            if (b = g.eat(/\{|%/))
              return v.intag = b, b == "{" && (v.intag = "}"), g.eat("-"), "tag";
          }
          g.next();
        }
        return {
          startState: function() {
            return {};
          },
          token: function(g, v) {
            return f(g, v);
          }
        };
      }), n.defineMode("twig", function(a, o) {
        var s = n.getMode(a, "twig:inner");
        return !o || !o.base ? s : n.multiplexingMode(
          n.getMode(a, o.base),
          {
            open: /\{[{#%]/,
            close: /[}#%]\}/,
            mode: s,
            parseDelimiters: !0
          }
        );
      }), n.defineMIME("text/x-twig", "twig");
    });
  })()), twig.exports;
}
requireTwig();
var vue = { exports: {} }, coffeescript = { exports: {} }, hasRequiredCoffeescript;
function requireCoffeescript() {
  return hasRequiredCoffeescript || (hasRequiredCoffeescript = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("coffeescript", function(a, o) {
        var s = "error";
        function u(W) {
          return new RegExp("^((" + W.join(")|(") + "))\\b");
        }
        var d = /^(?:->|=>|\+[+=]?|-[\-=]?|\*[\*=]?|\/[\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\|=?|\^=?|\~|!|\?|(or|and|\|\||&&|\?)=)/, f = /^(?:[()\[\]{},:`=;]|\.\.?\.?)/, g = /^[_A-Za-z$][_A-Za-z$0-9]*/, v = /^@[_A-Za-z$][_A-Za-z$0-9]*/, b = u([
          "and",
          "or",
          "not",
          "is",
          "isnt",
          "in",
          "instanceof",
          "typeof"
        ]), w = [
          "for",
          "while",
          "loop",
          "if",
          "unless",
          "else",
          "switch",
          "try",
          "catch",
          "finally",
          "class"
        ], C = [
          "break",
          "by",
          "continue",
          "debugger",
          "delete",
          "do",
          "in",
          "of",
          "new",
          "return",
          "then",
          "this",
          "@",
          "throw",
          "when",
          "until",
          "extends"
        ], k = u(w.concat(C));
        w = u(w);
        var E = /^('{3}|\"{3}|['\"])/, A = /^(\/{3}|\/)/, P = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"], M = u(P);
        function B(W, K) {
          if (W.sol()) {
            K.scope.align === null && (K.scope.align = !1);
            var Z = K.scope.offset;
            if (W.eatSpace()) {
              var J = W.indentation();
              return J > Z && K.scope.type == "coffee" ? "indent" : J < Z ? "dedent" : null;
            } else
              Z > 0 && I(W, K);
          }
          if (W.eatSpace())
            return null;
          var re = W.peek();
          if (W.match("####"))
            return W.skipToEnd(), "comment";
          if (W.match("###"))
            return K.tokenize = T, K.tokenize(W, K);
          if (re === "#")
            return W.skipToEnd(), "comment";
          if (W.match(/^-?[0-9\.]/, !1)) {
            var V = !1;
            if (W.match(/^-?\d*\.\d+(e[\+\-]?\d+)?/i) && (V = !0), W.match(/^-?\d+\.\d*/) && (V = !0), W.match(/^-?\.\d+/) && (V = !0), V)
              return W.peek() == "." && W.backUp(1), "number";
            var ne = !1;
            if (W.match(/^-?0x[0-9a-f]+/i) && (ne = !0), W.match(/^-?[1-9]\d*(e[\+\-]?\d+)?/) && (ne = !0), W.match(/^-?0(?![\dx])/i) && (ne = !0), ne)
              return "number";
          }
          if (W.match(E))
            return K.tokenize = _(W.current(), !1, "string"), K.tokenize(W, K);
          if (W.match(A)) {
            if (W.current() != "/" || W.match(/^.*\//, !1))
              return K.tokenize = _(W.current(), !0, "string-2"), K.tokenize(W, K);
            W.backUp(1);
          }
          return W.match(d) || W.match(b) ? "operator" : W.match(f) ? "punctuation" : W.match(M) ? "atom" : W.match(v) || K.prop && W.match(g) ? "property" : W.match(k) ? "keyword" : W.match(g) ? "variable" : (W.next(), s);
        }
        function _(W, K, Z) {
          return function(J, re) {
            for (; !J.eol(); )
              if (J.eatWhile(/[^'"\/\\]/), J.eat("\\")) {
                if (J.next(), K && J.eol())
                  return Z;
              } else {
                if (J.match(W))
                  return re.tokenize = B, Z;
                J.eat(/['"\/]/);
              }
            return K && (o.singleLineStringErrors ? Z = s : re.tokenize = B), Z;
          };
        }
        function T(W, K) {
          for (; !W.eol(); ) {
            if (W.eatWhile(/[^#]/), W.match("###")) {
              K.tokenize = B;
              break;
            }
            W.eatWhile("#");
          }
          return "comment";
        }
        function O(W, K, Z) {
          Z = Z || "coffee";
          for (var J = 0, re = !1, V = null, ne = K.scope; ne; ne = ne.prev)
            if (ne.type === "coffee" || ne.type == "}") {
              J = ne.offset + a.indentUnit;
              break;
            }
          Z !== "coffee" ? (re = null, V = W.column() + W.current().length) : K.scope.align && (K.scope.align = !1), K.scope = {
            offset: J,
            type: Z,
            prev: K.scope,
            align: re,
            alignOffset: V
          };
        }
        function I(W, K) {
          if (K.scope.prev)
            if (K.scope.type === "coffee") {
              for (var Z = W.indentation(), J = !1, re = K.scope; re; re = re.prev)
                if (Z === re.offset) {
                  J = !0;
                  break;
                }
              if (!J)
                return !0;
              for (; K.scope.prev && K.scope.offset !== Z; )
                K.scope = K.scope.prev;
              return !1;
            } else
              return K.scope = K.scope.prev, !1;
        }
        function q(W, K) {
          var Z = K.tokenize(W, K), J = W.current();
          J === "return" && (K.dedent = !0), ((J === "->" || J === "=>") && W.eol() || Z === "indent") && O(W, K);
          var re = "[({".indexOf(J);
          if (re !== -1 && O(W, K, "])}".slice(re, re + 1)), w.exec(J) && O(W, K), J == "then" && I(W, K), Z === "dedent" && I(W, K))
            return s;
          if (re = "])}".indexOf(J), re !== -1) {
            for (; K.scope.type == "coffee" && K.scope.prev; )
              K.scope = K.scope.prev;
            K.scope.type == J && (K.scope = K.scope.prev);
          }
          return K.dedent && W.eol() && (K.scope.type == "coffee" && K.scope.prev && (K.scope = K.scope.prev), K.dedent = !1), Z;
        }
        var F = {
          startState: function(W) {
            return {
              tokenize: B,
              scope: { offset: W || 0, type: "coffee", prev: null, align: !1 },
              prop: !1,
              dedent: 0
            };
          },
          token: function(W, K) {
            var Z = K.scope.align === null && K.scope;
            Z && W.sol() && (Z.align = !1);
            var J = q(W, K);
            return J && J != "comment" && (Z && (Z.align = !0), K.prop = J == "punctuation" && W.current() == "."), J;
          },
          indent: function(W, K) {
            if (W.tokenize != B) return 0;
            var Z = W.scope, J = K && "])}".indexOf(K.charAt(0)) > -1;
            if (J) for (; Z.type == "coffee" && Z.prev; ) Z = Z.prev;
            var re = J && Z.type === K.charAt(0);
            return Z.align ? Z.alignOffset - (re ? 1 : 0) : (re ? Z.prev : Z).offset;
          },
          lineComment: "#",
          fold: "indent"
        };
        return F;
      }), n.defineMIME("application/vnd.coffeescript", "coffeescript"), n.defineMIME("text/x-coffeescript", "coffeescript"), n.defineMIME("text/coffeescript", "coffeescript");
    });
  })()), coffeescript.exports;
}
var sass = { exports: {} }, hasRequiredSass;
function requireSass() {
  return hasRequiredSass || (hasRequiredSass = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireCss());
    })(function(n) {
      n.defineMode("sass", function(a) {
        var o = n.mimeModes["text/css"], s = o.propertyKeywords || {}, u = o.colorKeywords || {}, d = o.valueKeywords || {}, f = o.fontProperties || {};
        function g(F) {
          return new RegExp("^" + F.join("|"));
        }
        var v = ["true", "false", "null", "auto"], b = new RegExp("^" + v.join("|")), w = [
          "\\(",
          "\\)",
          "=",
          ">",
          "<",
          "==",
          ">=",
          "<=",
          "\\+",
          "-",
          "\\!=",
          "/",
          "\\*",
          "%",
          "and",
          "or",
          "not",
          ";",
          "\\{",
          "\\}",
          ":"
        ], C = g(w), k = /^::?[a-zA-Z_][\w\-]*/, E;
        function A(F) {
          return !F.peek() || F.match(/\s+$/, !1);
        }
        function P(F, W) {
          var K = F.peek();
          return K === ")" ? (F.next(), W.tokenizer = I, "operator") : K === "(" ? (F.next(), F.eatSpace(), "operator") : K === "'" || K === '"' ? (W.tokenizer = B(F.next()), "string") : (W.tokenizer = B(")", !1), "string");
        }
        function M(F, W) {
          return function(K, Z) {
            return K.sol() && K.indentation() <= F ? (Z.tokenizer = I, I(K, Z)) : (W && K.skipTo("*/") ? (K.next(), K.next(), Z.tokenizer = I) : K.skipToEnd(), "comment");
          };
        }
        function B(F, W) {
          W == null && (W = !0);
          function K(Z, J) {
            var re = Z.next(), V = Z.peek(), ne = Z.string.charAt(Z.pos - 2), Q = re !== "\\" && V === F || re === F && ne !== "\\";
            return Q ? (re !== F && W && Z.next(), A(Z) && (J.cursorHalf = 0), J.tokenizer = I, "string") : re === "#" && V === "{" ? (J.tokenizer = _(K), Z.next(), "operator") : "string";
          }
          return K;
        }
        function _(F) {
          return function(W, K) {
            return W.peek() === "}" ? (W.next(), K.tokenizer = F, "operator") : I(W, K);
          };
        }
        function T(F) {
          if (F.indentCount == 0) {
            F.indentCount++;
            var W = F.scopes[0].offset, K = W + a.indentUnit;
            F.scopes.unshift({ offset: K });
          }
        }
        function O(F) {
          F.scopes.length != 1 && F.scopes.shift();
        }
        function I(F, W) {
          var K = F.peek();
          if (F.match("/*"))
            return W.tokenizer = M(F.indentation(), !0), W.tokenizer(F, W);
          if (F.match("//"))
            return W.tokenizer = M(F.indentation(), !1), W.tokenizer(F, W);
          if (F.match("#{"))
            return W.tokenizer = _(I), "operator";
          if (K === '"' || K === "'")
            return F.next(), W.tokenizer = B(K), "string";
          if (W.cursorHalf) {
            if (K === "#" && (F.next(), F.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)) || F.match(/^-?[0-9\.]+/))
              return A(F) && (W.cursorHalf = 0), "number";
            if (F.match(/^(px|em|in)\b/))
              return A(F) && (W.cursorHalf = 0), "unit";
            if (F.match(b))
              return A(F) && (W.cursorHalf = 0), "keyword";
            if (F.match(/^url/) && F.peek() === "(")
              return W.tokenizer = P, A(F) && (W.cursorHalf = 0), "atom";
            if (K === "$")
              return F.next(), F.eatWhile(/[\w-]/), A(F) && (W.cursorHalf = 0), "variable-2";
            if (K === "!")
              return F.next(), W.cursorHalf = 0, F.match(/^[\w]+/) ? "keyword" : "operator";
            if (F.match(C))
              return A(F) && (W.cursorHalf = 0), "operator";
            if (F.eatWhile(/[\w-]/))
              return A(F) && (W.cursorHalf = 0), E = F.current().toLowerCase(), d.hasOwnProperty(E) ? "atom" : u.hasOwnProperty(E) ? "keyword" : s.hasOwnProperty(E) ? (W.prevProp = F.current().toLowerCase(), "property") : "tag";
            if (A(F))
              return W.cursorHalf = 0, null;
          } else {
            if (K === "-" && F.match(/^-\w+-/))
              return "meta";
            if (K === ".") {
              if (F.next(), F.match(/^[\w-]+/))
                return T(W), "qualifier";
              if (F.peek() === "#")
                return T(W), "tag";
            }
            if (K === "#") {
              if (F.next(), F.match(/^[\w-]+/))
                return T(W), "builtin";
              if (F.peek() === "#")
                return T(W), "tag";
            }
            if (K === "$")
              return F.next(), F.eatWhile(/[\w-]/), "variable-2";
            if (F.match(/^-?[0-9\.]+/))
              return "number";
            if (F.match(/^(px|em|in)\b/))
              return "unit";
            if (F.match(b))
              return "keyword";
            if (F.match(/^url/) && F.peek() === "(")
              return W.tokenizer = P, "atom";
            if (K === "=" && F.match(/^=[\w-]+/))
              return T(W), "meta";
            if (K === "+" && F.match(/^\+[\w-]+/))
              return "variable-3";
            if (K === "@" && F.match("@extend") && (F.match(/\s*[\w]/) || O(W)), F.match(/^@(else if|if|media|else|for|each|while|mixin|function)/))
              return T(W), "def";
            if (K === "@")
              return F.next(), F.eatWhile(/[\w-]/), "def";
            if (F.eatWhile(/[\w-]/))
              if (F.match(/ *: *[\w-\+\$#!\("']/, !1)) {
                E = F.current().toLowerCase();
                var Z = W.prevProp + "-" + E;
                return s.hasOwnProperty(Z) ? "property" : s.hasOwnProperty(E) ? (W.prevProp = E, "property") : f.hasOwnProperty(E) ? "property" : "tag";
              } else return F.match(/ *:/, !1) ? (T(W), W.cursorHalf = 1, W.prevProp = F.current().toLowerCase(), "property") : (F.match(/ *,/, !1) || T(W), "tag");
            if (K === ":")
              return F.match(k) ? "variable-3" : (F.next(), W.cursorHalf = 1, "operator");
          }
          return F.match(C) ? "operator" : (F.next(), null);
        }
        function q(F, W) {
          F.sol() && (W.indentCount = 0);
          var K = W.tokenizer(F, W), Z = F.current();
          if ((Z === "@return" || Z === "}") && O(W), K !== null) {
            for (var J = F.pos - Z.length, re = J + a.indentUnit * W.indentCount, V = [], ne = 0; ne < W.scopes.length; ne++) {
              var Q = W.scopes[ne];
              Q.offset <= re && V.push(Q);
            }
            W.scopes = V;
          }
          return K;
        }
        return {
          startState: function() {
            return {
              tokenizer: I,
              scopes: [{ offset: 0, type: "sass" }],
              indentCount: 0,
              cursorHalf: 0,
              // cursor half tells us if cursor lies after (1)
              // or before (0) colon (well... more or less)
              definedVars: [],
              definedMixins: []
            };
          },
          token: function(F, W) {
            var K = q(F, W);
            return W.lastToken = { style: K, content: F.current() }, K;
          },
          indent: function(F) {
            return F.scopes[0].offset;
          },
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          lineComment: "//",
          fold: "indent"
        };
      }, "css"), n.defineMIME("text/x-sass", "sass");
    });
  })()), sass.exports;
}
var stylus = { exports: {} }, hasRequiredStylus;
function requireStylus() {
  return hasRequiredStylus || (hasRequiredStylus = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("stylus", function(_) {
        for (var T = _.indentUnit, O = "", I = M(a), q = /^(a|b|i|s|col|em)$/i, F = M(d), W = M(f), K = M(b), Z = M(v), J = M(o), re = P(o), V = M(u), ne = M(s), Q = M(g), z = /^\s*([.]{2,3}|&&|\|\||\*\*|[?!=:]?=|[-+*\/%<>]=?|\?:|\~)/, X = P(w), ue = M(C), Be = new RegExp(/^\-(moz|ms|o|webkit)-/i), te = M(k), G = "", ie = {}, oe, ye, ve, ke; O.length < T; ) O += " ";
        function Ae(me, de) {
          if (G = me.string.match(/(^[\w-]+\s*=\s*$)|(^\s*[\w-]+\s*=\s*[\w-])|(^\s*(\.|#|@|\$|\&|\[|\d|\+|::?|\{|\>|~|\/)?\s*[\w-]*([a-z0-9-]|\*|\/\*)(\(|,)?)/), de.context.line.firstWord = G ? G[0].replace(/^\s*/, "") : "", de.context.line.indent = me.indentation(), oe = me.peek(), me.match("//"))
            return me.skipToEnd(), ["comment", "comment"];
          if (me.match("/*"))
            return de.tokenize = be, be(me, de);
          if (oe == '"' || oe == "'")
            return me.next(), de.tokenize = Ie(oe), de.tokenize(me, de);
          if (oe == "@")
            return me.next(), me.eatWhile(/[\w\\-]/), ["def", me.current()];
          if (oe == "#") {
            if (me.next(), me.match(/^[0-9a-f]{3}([0-9a-f]([0-9a-f]{2}){0,2})?\b(?!-)/i))
              return ["atom", "atom"];
            if (me.match(/^[a-z][\w-]*/i))
              return ["builtin", "hash"];
          }
          return me.match(Be) ? ["meta", "vendor-prefixes"] : me.match(/^-?[0-9]?\.?[0-9]/) ? (me.eatWhile(/[a-z%]/i), ["number", "unit"]) : oe == "!" ? (me.next(), [me.match(/^(important|optional)/i) ? "keyword" : "operator", "important"]) : oe == "." && me.match(/^\.[a-z][\w-]*/i) ? ["qualifier", "qualifier"] : me.match(re) ? (me.peek() == "(" && (de.tokenize = Se), ["property", "word"]) : me.match(/^[a-z][\w-]*\(/i) ? (me.backUp(1), ["keyword", "mixin"]) : me.match(/^(\+|-)[a-z][\w-]*\(/i) ? (me.backUp(1), ["keyword", "block-mixin"]) : me.string.match(/^\s*&/) && me.match(/^[-_]+[a-z][\w-]*/) ? ["qualifier", "qualifier"] : me.match(/^(\/|&)(-|_|:|\.|#|[a-z])/) ? (me.backUp(1), ["variable-3", "reference"]) : me.match(/^&{1}\s*$/) ? ["variable-3", "reference"] : me.match(X) ? ["operator", "operator"] : me.match(/^\$?[-_]*[a-z0-9]+[\w-]*/i) ? me.match(/^(\.|\[)[\w-\'\"\]]+/i, !1) && !ce(me.current()) ? (me.match("."), ["variable-2", "variable-name"]) : ["variable-2", "word"] : me.match(z) ? ["operator", me.current()] : /[:;,{}\[\]\(\)]/.test(oe) ? (me.next(), [null, oe]) : (me.next(), [null, null]);
        }
        function be(me, de) {
          for (var Fe = !1, Ze; (Ze = me.next()) != null; ) {
            if (Fe && Ze == "/") {
              de.tokenize = null;
              break;
            }
            Fe = Ze == "*";
          }
          return ["comment", "comment"];
        }
        function Ie(me) {
          return function(de, Fe) {
            for (var Ze = !1, $e; ($e = de.next()) != null; ) {
              if ($e == me && !Ze) {
                me == ")" && de.backUp(1);
                break;
              }
              Ze = !Ze && $e == "\\";
            }
            return ($e == me || !Ze && me != ")") && (Fe.tokenize = null), ["string", "string"];
          };
        }
        function Se(me, de) {
          return me.next(), me.match(/\s*[\"\')]/, !1) ? de.tokenize = null : de.tokenize = Ie(")"), [null, "("];
        }
        function ze(me, de, Fe, Ze) {
          this.type = me, this.indent = de, this.prev = Fe, this.line = Ze || { firstWord: "", indent: 0 };
        }
        function Ne(me, de, Fe, Ze) {
          return Ze = Ze >= 0 ? Ze : T, me.context = new ze(Fe, de.indentation() + Ze, me.context), Fe;
        }
        function tt(me, de) {
          var Fe = me.context.indent - T;
          return de = de || !1, me.context = me.context.prev, de && (me.context.indent = Fe), me.context.type;
        }
        function Qe(me, de, Fe) {
          return ie[Fe.context.type](me, de, Fe);
        }
        function et(me, de, Fe, Ze) {
          for (var $e = 1; $e > 0; $e--)
            Fe.context = Fe.context.prev;
          return Qe(me, de, Fe);
        }
        function ce(me) {
          return me.toLowerCase() in I;
        }
        function pe(me) {
          return me = me.toLowerCase(), me in F || me in Q;
        }
        function je(me) {
          return me.toLowerCase() in ue;
        }
        function lt(me) {
          return me.toLowerCase().match(Be);
        }
        function Ce(me) {
          var de = me.toLowerCase(), Fe = "variable-2";
          return ce(me) ? Fe = "tag" : je(me) ? Fe = "block-keyword" : pe(me) ? Fe = "property" : de in K || de in te ? Fe = "atom" : de == "return" || de in Z ? Fe = "keyword" : me.match(/^[A-Z]/) && (Fe = "string"), Fe;
        }
        function Oe(me, de) {
          return Ge(de) && (me == "{" || me == "]" || me == "hash" || me == "qualifier") || me == "block-mixin";
        }
        function Te(me, de) {
          return me == "{" && de.match(/^\s*\$?[\w-]+/i, !1);
        }
        function ot(me, de) {
          return me == ":" && de.match(/^[a-z-]+/, !1);
        }
        function We(me) {
          return me.sol() || me.string.match(new RegExp("^\\s*" + B(me.current())));
        }
        function Ge(me) {
          return me.eol() || me.match(/^\s*$/, !1);
        }
        function He(me) {
          var de = /^\s*[-_]*[a-z0-9]+[\w-]*/i, Fe = typeof me == "string" ? me.match(de) : me.string.match(de);
          return Fe ? Fe[0].replace(/^\s*/, "") : "";
        }
        return ie.block = function(me, de, Fe) {
          if (me == "comment" && We(de) || me == "," && Ge(de) || me == "mixin")
            return Ne(Fe, de, "block", 0);
          if (Te(me, de))
            return Ne(Fe, de, "interpolation");
          if (Ge(de) && me == "]" && !/^\s*(\.|#|:|\[|\*|&)/.test(de.string) && !ce(He(de)))
            return Ne(Fe, de, "block", 0);
          if (Oe(me, de))
            return Ne(Fe, de, "block");
          if (me == "}" && Ge(de))
            return Ne(Fe, de, "block", 0);
          if (me == "variable-name")
            return de.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/) || je(He(de)) ? Ne(Fe, de, "variableName") : Ne(Fe, de, "variableName", 0);
          if (me == "=")
            return !Ge(de) && !je(He(de)) ? Ne(Fe, de, "block", 0) : Ne(Fe, de, "block");
          if (me == "*" && (Ge(de) || de.match(/\s*(,|\.|#|\[|:|{)/, !1)))
            return ke = "tag", Ne(Fe, de, "block");
          if (ot(me, de))
            return Ne(Fe, de, "pseudo");
          if (/@(font-face|media|supports|(-moz-)?document)/.test(me))
            return Ne(Fe, de, Ge(de) ? "block" : "atBlock");
          if (/@(-(moz|ms|o|webkit)-)?keyframes$/.test(me))
            return Ne(Fe, de, "keyframes");
          if (/@extends?/.test(me))
            return Ne(Fe, de, "extend", 0);
          if (me && me.charAt(0) == "@")
            return de.indentation() > 0 && pe(de.current().slice(1)) ? (ke = "variable-2", "block") : /(@import|@require|@charset)/.test(me) ? Ne(Fe, de, "block", 0) : Ne(Fe, de, "block");
          if (me == "reference" && Ge(de))
            return Ne(Fe, de, "block");
          if (me == "(")
            return Ne(Fe, de, "parens");
          if (me == "vendor-prefixes")
            return Ne(Fe, de, "vendorPrefixes");
          if (me == "word") {
            var Ze = de.current();
            if (ke = Ce(Ze), ke == "property")
              return We(de) ? Ne(Fe, de, "block", 0) : (ke = "atom", "block");
            if (ke == "tag") {
              if (/embed|menu|pre|progress|sub|table/.test(Ze) && pe(He(de)) || de.string.match(new RegExp("\\[\\s*" + Ze + "|" + Ze + "\\s*\\]")))
                return ke = "atom", "block";
              if (q.test(Ze) && (We(de) && de.string.match(/=/) || !We(de) && !de.string.match(/^(\s*\.|#|\&|\[|\/|>|\*)/) && !ce(He(de))))
                return ke = "variable-2", je(He(de)) ? "block" : Ne(Fe, de, "block", 0);
              if (Ge(de)) return Ne(Fe, de, "block");
            }
            if (ke == "block-keyword")
              return ke = "keyword", de.current(/(if|unless)/) && !We(de) ? "block" : Ne(Fe, de, "block");
            if (Ze == "return") return Ne(Fe, de, "block", 0);
            if (ke == "variable-2" && de.string.match(/^\s?\$[\w-\.\[\]\'\"]+$/))
              return Ne(Fe, de, "block");
          }
          return Fe.context.type;
        }, ie.parens = function(me, de, Fe) {
          if (me == "(") return Ne(Fe, de, "parens");
          if (me == ")")
            return Fe.context.prev.type == "parens" ? tt(Fe) : de.string.match(/^[a-z][\w-]*\(/i) && Ge(de) || je(He(de)) || /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(He(de)) || !de.string.match(/^-?[a-z][\w-\.\[\]\'\"]*\s*=/) && ce(He(de)) ? Ne(Fe, de, "block") : de.string.match(/^[\$-]?[a-z][\w-\.\[\]\'\"]*\s*=/) || de.string.match(/^\s*(\(|\)|[0-9])/) || de.string.match(/^\s+[a-z][\w-]*\(/i) || de.string.match(/^\s+[\$-]?[a-z]/i) ? Ne(Fe, de, "block", 0) : Ge(de) ? Ne(Fe, de, "block") : Ne(Fe, de, "block", 0);
          if (me && me.charAt(0) == "@" && pe(de.current().slice(1)) && (ke = "variable-2"), me == "word") {
            var Ze = de.current();
            ke = Ce(Ze), ke == "tag" && q.test(Ze) && (ke = "variable-2"), (ke == "property" || Ze == "to") && (ke = "atom");
          }
          return me == "variable-name" ? Ne(Fe, de, "variableName") : ot(me, de) ? Ne(Fe, de, "pseudo") : Fe.context.type;
        }, ie.vendorPrefixes = function(me, de, Fe) {
          return me == "word" ? (ke = "property", Ne(Fe, de, "block", 0)) : tt(Fe);
        }, ie.pseudo = function(me, de, Fe) {
          return pe(He(de.string)) ? et(me, de, Fe) : (de.match(/^[a-z-]+/), ke = "variable-3", Ge(de) ? Ne(Fe, de, "block") : tt(Fe));
        }, ie.atBlock = function(me, de, Fe) {
          if (me == "(") return Ne(Fe, de, "atBlock_parens");
          if (Oe(me, de))
            return Ne(Fe, de, "block");
          if (Te(me, de))
            return Ne(Fe, de, "interpolation");
          if (me == "word") {
            var Ze = de.current().toLowerCase();
            if (/^(only|not|and|or)$/.test(Ze) ? ke = "keyword" : J.hasOwnProperty(Ze) ? ke = "tag" : ne.hasOwnProperty(Ze) ? ke = "attribute" : V.hasOwnProperty(Ze) ? ke = "property" : W.hasOwnProperty(Ze) ? ke = "string-2" : ke = Ce(de.current()), ke == "tag" && Ge(de))
              return Ne(Fe, de, "block");
          }
          return me == "operator" && /^(not|and|or)$/.test(de.current()) && (ke = "keyword"), Fe.context.type;
        }, ie.atBlock_parens = function(me, de, Fe) {
          if (me == "{" || me == "}") return Fe.context.type;
          if (me == ")")
            return Ge(de) ? Ne(Fe, de, "block") : Ne(Fe, de, "atBlock");
          if (me == "word") {
            var Ze = de.current().toLowerCase();
            return ke = Ce(Ze), /^(max|min)/.test(Ze) && (ke = "property"), ke == "tag" && (q.test(Ze) ? ke = "variable-2" : ke = "atom"), Fe.context.type;
          }
          return ie.atBlock(me, de, Fe);
        }, ie.keyframes = function(me, de, Fe) {
          return de.indentation() == "0" && (me == "}" && We(de) || me == "]" || me == "hash" || me == "qualifier" || ce(de.current())) ? et(me, de, Fe) : me == "{" ? Ne(Fe, de, "keyframes") : me == "}" ? We(de) ? tt(Fe, !0) : Ne(Fe, de, "keyframes") : me == "unit" && /^[0-9]+\%$/.test(de.current()) ? Ne(Fe, de, "keyframes") : me == "word" && (ke = Ce(de.current()), ke == "block-keyword") ? (ke = "keyword", Ne(Fe, de, "keyframes")) : /@(font-face|media|supports|(-moz-)?document)/.test(me) ? Ne(Fe, de, Ge(de) ? "block" : "atBlock") : me == "mixin" ? Ne(Fe, de, "block", 0) : Fe.context.type;
        }, ie.interpolation = function(me, de, Fe) {
          return me == "{" && tt(Fe) && Ne(Fe, de, "block"), me == "}" ? de.string.match(/^\s*(\.|#|:|\[|\*|&|>|~|\+|\/)/i) || de.string.match(/^\s*[a-z]/i) && ce(He(de)) ? Ne(Fe, de, "block") : !de.string.match(/^(\{|\s*\&)/) || de.match(/\s*[\w-]/, !1) ? Ne(Fe, de, "block", 0) : Ne(Fe, de, "block") : me == "variable-name" ? Ne(Fe, de, "variableName", 0) : (me == "word" && (ke = Ce(de.current()), ke == "tag" && (ke = "atom")), Fe.context.type);
        }, ie.extend = function(me, de, Fe) {
          return me == "[" || me == "=" ? "extend" : me == "]" ? tt(Fe) : me == "word" ? (ke = Ce(de.current()), "extend") : tt(Fe);
        }, ie.variableName = function(me, de, Fe) {
          return me == "string" || me == "[" || me == "]" || de.current().match(/^(\.|\$)/) ? (de.current().match(/^\.[\w-]+/i) && (ke = "variable-2"), "variableName") : et(me, de, Fe);
        }, {
          startState: function(me) {
            return {
              tokenize: null,
              state: "block",
              context: new ze("block", me || 0, null)
            };
          },
          token: function(me, de) {
            return !de.tokenize && me.eatSpace() ? null : (ye = (de.tokenize || Ae)(me, de), ye && typeof ye == "object" && (ve = ye[1], ye = ye[0]), ke = ye, de.state = ie[de.state](ve, me, de), ke);
          },
          indent: function(me, de, Fe) {
            var Ze = me.context, $e = de && de.charAt(0), ct = Ze.indent, Je = He(de), wt = Fe.match(/^\s*/)[0].replace(/\t/g, O).length, qe = me.context.prev ? me.context.prev.line.firstWord : "", $t = me.context.prev ? me.context.prev.line.indent : wt;
            return Ze.prev && ($e == "}" && (Ze.type == "block" || Ze.type == "atBlock" || Ze.type == "keyframes") || $e == ")" && (Ze.type == "parens" || Ze.type == "atBlock_parens") || $e == "{" && Ze.type == "at") ? ct = Ze.indent - T : /(\})/.test($e) || (/@|\$|\d/.test($e) || /^\{/.test(de) || /^\s*\/(\/|\*)/.test(de) || /^\s*\/\*/.test(qe) || /^\s*[\w-\.\[\]\'\"]+\s*(\?|:|\+)?=/i.test(de) || /^(\+|-)?[a-z][\w-]*\(/i.test(de) || /^return/.test(de) || je(Je) ? ct = wt : /(\.|#|:|\[|\*|&|>|~|\+|\/)/.test($e) || ce(Je) ? /\,\s*$/.test(qe) ? ct = $t : /^\s+/.test(Fe) && (/(\.|#|:|\[|\*|&|>|~|\+|\/)/.test(qe) || ce(qe)) ? ct = wt <= $t ? $t : $t + T : ct = wt : !/,\s*$/.test(Fe) && (lt(Je) || pe(Je)) && (je(qe) ? ct = wt <= $t ? $t : $t + T : /^\{/.test(qe) ? ct = wt <= $t ? wt : $t + T : lt(qe) || pe(qe) ? ct = wt >= $t ? $t : wt : /^(\.|#|:|\[|\*|&|@|\+|\-|>|~|\/)/.test(qe) || /=\s*$/.test(qe) || ce(qe) || /^\$[\w-\.\[\]\'\"]/.test(qe) ? ct = $t + T : ct = wt)), ct;
          },
          electricChars: "}",
          blockCommentStart: "/*",
          blockCommentEnd: "*/",
          blockCommentContinue: " * ",
          lineComment: "//",
          fold: "indent"
        };
      });
      var a = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "bgsound", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "nobr", "noframes", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "var", "video"], o = ["domain", "regexp", "url-prefix", "url"], s = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"], u = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "dynamic-range", "video-dynamic-range"], d = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-position", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marker-offset", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode", "font-smoothing", "osx-font-smoothing"], f = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"], g = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"], v = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"], b = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "column", "compact", "condensed", "conic-gradient", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew", "help", "hidden", "hide", "high", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "malayalam", "match", "matrix", "matrix3d", "media-play-button", "media-slider", "media-sliderthumb", "media-volume-slider", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeating-conic-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row-resize", "rtl", "run-in", "running", "s-resize", "sans-serif", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "spell-out", "square", "square-button", "standard", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "x-large", "x-small", "xor", "xx-large", "xx-small", "bicubic", "optimizespeed", "grayscale", "row", "row-reverse", "wrap", "wrap-reverse", "column-reverse", "flex-start", "flex-end", "space-between", "space-around", "unset"], w = ["in", "and", "or", "not", "is not", "is a", "is", "isnt", "defined", "if unless"], C = ["for", "if", "else", "unless", "from", "to"], k = ["null", "true", "false", "href", "title", "type", "not-allowed", "readonly", "disabled"], E = ["@font-face", "@keyframes", "@media", "@viewport", "@page", "@host", "@supports", "@block", "@css"], A = a.concat(
        o,
        s,
        u,
        d,
        f,
        v,
        b,
        g,
        w,
        C,
        k,
        E
      );
      function P(_) {
        return _ = _.sort(function(T, O) {
          return O > T;
        }), new RegExp("^((" + _.join(")|(") + "))\\b");
      }
      function M(_) {
        for (var T = {}, O = 0; O < _.length; ++O) T[_[O]] = !0;
        return T;
      }
      function B(_) {
        return _.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
      n.registerHelper("hintWords", "stylus", A), n.defineMIME("text/x-styl", "stylus");
    });
  })()), stylus.exports;
}
var pug = { exports: {} }, hasRequiredPug;
function requirePug() {
  return hasRequiredPug || (hasRequiredPug = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireJavascript(), requireCss(), requireHtmlmixed());
    })(function(n) {
      n.defineMode("pug", function(a) {
        var o = "keyword", s = "meta", u = "builtin", d = "qualifier", f = {
          "{": "}",
          "(": ")",
          "[": "]"
        }, g = n.getMode(a, "javascript");
        function v() {
          this.javaScriptLine = !1, this.javaScriptLineExcludesColon = !1, this.javaScriptArguments = !1, this.javaScriptArgumentsDepth = 0, this.isInterpolating = !1, this.interpolationNesting = 0, this.jsState = n.startState(g), this.restOfLine = "", this.isIncludeFiltered = !1, this.isEach = !1, this.lastTag = "", this.scriptType = "", this.isAttrs = !1, this.attrsNest = [], this.inAttributeName = !0, this.attributeIsType = !1, this.attrValue = "", this.indentOf = 1 / 0, this.indentToken = "", this.innerMode = null, this.innerState = null, this.innerModeForLine = !1;
        }
        v.prototype.copy = function() {
          var ce = new v();
          return ce.javaScriptLine = this.javaScriptLine, ce.javaScriptLineExcludesColon = this.javaScriptLineExcludesColon, ce.javaScriptArguments = this.javaScriptArguments, ce.javaScriptArgumentsDepth = this.javaScriptArgumentsDepth, ce.isInterpolating = this.isInterpolating, ce.interpolationNesting = this.interpolationNesting, ce.jsState = n.copyState(g, this.jsState), ce.innerMode = this.innerMode, this.innerMode && this.innerState && (ce.innerState = n.copyState(this.innerMode, this.innerState)), ce.restOfLine = this.restOfLine, ce.isIncludeFiltered = this.isIncludeFiltered, ce.isEach = this.isEach, ce.lastTag = this.lastTag, ce.scriptType = this.scriptType, ce.isAttrs = this.isAttrs, ce.attrsNest = this.attrsNest.slice(), ce.inAttributeName = this.inAttributeName, ce.attributeIsType = this.attributeIsType, ce.attrValue = this.attrValue, ce.indentOf = this.indentOf, ce.indentToken = this.indentToken, ce.innerModeForLine = this.innerModeForLine, ce;
        };
        function b(ce, pe) {
          if (ce.sol() && (pe.javaScriptLine = !1, pe.javaScriptLineExcludesColon = !1), pe.javaScriptLine) {
            if (pe.javaScriptLineExcludesColon && ce.peek() === ":") {
              pe.javaScriptLine = !1, pe.javaScriptLineExcludesColon = !1;
              return;
            }
            var je = g.token(ce, pe.jsState);
            return ce.eol() && (pe.javaScriptLine = !1), je || !0;
          }
        }
        function w(ce, pe) {
          if (pe.javaScriptArguments) {
            if (pe.javaScriptArgumentsDepth === 0 && ce.peek() !== "(") {
              pe.javaScriptArguments = !1;
              return;
            }
            if (ce.peek() === "(" ? pe.javaScriptArgumentsDepth++ : ce.peek() === ")" && pe.javaScriptArgumentsDepth--, pe.javaScriptArgumentsDepth === 0) {
              pe.javaScriptArguments = !1;
              return;
            }
            var je = g.token(ce, pe.jsState);
            return je || !0;
          }
        }
        function C(ce) {
          if (ce.match(/^yield\b/))
            return "keyword";
        }
        function k(ce) {
          if (ce.match(/^(?:doctype) *([^\n]+)?/))
            return s;
        }
        function E(ce, pe) {
          if (ce.match("#{"))
            return pe.isInterpolating = !0, pe.interpolationNesting = 0, "punctuation";
        }
        function A(ce, pe) {
          if (pe.isInterpolating) {
            if (ce.peek() === "}") {
              if (pe.interpolationNesting--, pe.interpolationNesting < 0)
                return ce.next(), pe.isInterpolating = !1, "punctuation";
            } else ce.peek() === "{" && pe.interpolationNesting++;
            return g.token(ce, pe.jsState) || !0;
          }
        }
        function P(ce, pe) {
          if (ce.match(/^case\b/))
            return pe.javaScriptLine = !0, o;
        }
        function M(ce, pe) {
          if (ce.match(/^when\b/))
            return pe.javaScriptLine = !0, pe.javaScriptLineExcludesColon = !0, o;
        }
        function B(ce) {
          if (ce.match(/^default\b/))
            return o;
        }
        function _(ce, pe) {
          if (ce.match(/^extends?\b/))
            return pe.restOfLine = "string", o;
        }
        function T(ce, pe) {
          if (ce.match(/^append\b/))
            return pe.restOfLine = "variable", o;
        }
        function O(ce, pe) {
          if (ce.match(/^prepend\b/))
            return pe.restOfLine = "variable", o;
        }
        function I(ce, pe) {
          if (ce.match(/^block\b *(?:(prepend|append)\b)?/))
            return pe.restOfLine = "variable", o;
        }
        function q(ce, pe) {
          if (ce.match(/^include\b/))
            return pe.restOfLine = "string", o;
        }
        function F(ce, pe) {
          if (ce.match(/^include:([a-zA-Z0-9\-]+)/, !1) && ce.match("include"))
            return pe.isIncludeFiltered = !0, o;
        }
        function W(ce, pe) {
          if (pe.isIncludeFiltered) {
            var je = X(ce, pe);
            return pe.isIncludeFiltered = !1, pe.restOfLine = "string", je;
          }
        }
        function K(ce, pe) {
          if (ce.match(/^mixin\b/))
            return pe.javaScriptLine = !0, o;
        }
        function Z(ce, pe) {
          if (ce.match(/^\+([-\w]+)/))
            return ce.match(/^\( *[-\w]+ *=/, !1) || (pe.javaScriptArguments = !0, pe.javaScriptArgumentsDepth = 0), "variable";
          if (ce.match("+#{", !1))
            return ce.next(), pe.mixinCallAfter = !0, E(ce, pe);
        }
        function J(ce, pe) {
          if (pe.mixinCallAfter)
            return pe.mixinCallAfter = !1, ce.match(/^\( *[-\w]+ *=/, !1) || (pe.javaScriptArguments = !0, pe.javaScriptArgumentsDepth = 0), !0;
        }
        function re(ce, pe) {
          if (ce.match(/^(if|unless|else if|else)\b/))
            return pe.javaScriptLine = !0, o;
        }
        function V(ce, pe) {
          if (ce.match(/^(- *)?(each|for)\b/))
            return pe.isEach = !0, o;
        }
        function ne(ce, pe) {
          if (pe.isEach) {
            if (ce.match(/^ in\b/))
              return pe.javaScriptLine = !0, pe.isEach = !1, o;
            if (ce.sol() || ce.eol())
              pe.isEach = !1;
            else if (ce.next()) {
              for (; !ce.match(/^ in\b/, !1) && ce.next(); ) ;
              return "variable";
            }
          }
        }
        function Q(ce, pe) {
          if (ce.match(/^while\b/))
            return pe.javaScriptLine = !0, o;
        }
        function z(ce, pe) {
          var je;
          if (je = ce.match(/^(\w(?:[-:\w]*\w)?)\/?/))
            return pe.lastTag = je[1].toLowerCase(), pe.lastTag === "script" && (pe.scriptType = "application/javascript"), "tag";
        }
        function X(ce, pe) {
          if (ce.match(/^:([\w\-]+)/)) {
            var je;
            return a && a.innerModes && (je = a.innerModes(ce.current().substring(1))), je || (je = ce.current().substring(1)), typeof je == "string" && (je = n.getMode(a, je)), Se(ce, pe, je), "atom";
          }
        }
        function ue(ce, pe) {
          if (ce.match(/^(!?=|-)/))
            return pe.javaScriptLine = !0, "punctuation";
        }
        function Be(ce) {
          if (ce.match(/^#([\w-]+)/))
            return u;
        }
        function te(ce) {
          if (ce.match(/^\.([\w-]+)/))
            return d;
        }
        function G(ce, pe) {
          if (ce.peek() == "(")
            return ce.next(), pe.isAttrs = !0, pe.attrsNest = [], pe.inAttributeName = !0, pe.attrValue = "", pe.attributeIsType = !1, "punctuation";
        }
        function ie(ce, pe) {
          if (pe.isAttrs) {
            if (f[ce.peek()] && pe.attrsNest.push(f[ce.peek()]), pe.attrsNest[pe.attrsNest.length - 1] === ce.peek())
              pe.attrsNest.pop();
            else if (ce.eat(")"))
              return pe.isAttrs = !1, "punctuation";
            if (pe.inAttributeName && ce.match(/^[^=,\)!]+/))
              return (ce.peek() === "=" || ce.peek() === "!") && (pe.inAttributeName = !1, pe.jsState = n.startState(g), pe.lastTag === "script" && ce.current().trim().toLowerCase() === "type" ? pe.attributeIsType = !0 : pe.attributeIsType = !1), "attribute";
            var je = g.token(ce, pe.jsState);
            if (pe.attributeIsType && je === "string" && (pe.scriptType = ce.current().toString()), pe.attrsNest.length === 0 && (je === "string" || je === "variable" || je === "keyword"))
              try {
                return Function("", "var x " + pe.attrValue.replace(/,\s*$/, "").replace(/^!/, "")), pe.inAttributeName = !0, pe.attrValue = "", ce.backUp(ce.current().length), ie(ce, pe);
              } catch {
              }
            return pe.attrValue += ce.current(), je || !0;
          }
        }
        function oe(ce, pe) {
          if (ce.match(/^&attributes\b/))
            return pe.javaScriptArguments = !0, pe.javaScriptArgumentsDepth = 0, "keyword";
        }
        function ye(ce) {
          if (ce.sol() && ce.eatSpace())
            return "indent";
        }
        function ve(ce, pe) {
          if (ce.match(/^ *\/\/(-)?([^\n]*)/))
            return pe.indentOf = ce.indentation(), pe.indentToken = "comment", "comment";
        }
        function ke(ce) {
          if (ce.match(/^: */))
            return "colon";
        }
        function Ae(ce, pe) {
          if (ce.match(/^(?:\| ?| )([^\n]+)/))
            return "string";
          if (ce.match(/^(<[^\n]*)/, !1))
            return Se(ce, pe, "htmlmixed"), pe.innerModeForLine = !0, ze(ce, pe, !0);
        }
        function be(ce, pe) {
          if (ce.eat(".")) {
            var je = null;
            return pe.lastTag === "script" && pe.scriptType.toLowerCase().indexOf("javascript") != -1 ? je = pe.scriptType.toLowerCase().replace(/"|'/g, "") : pe.lastTag === "style" && (je = "css"), Se(ce, pe, je), "dot";
          }
        }
        function Ie(ce) {
          return ce.next(), null;
        }
        function Se(ce, pe, je) {
          je = n.mimeModes[je] || je, je = a.innerModes && a.innerModes(je) || je, je = n.mimeModes[je] || je, je = n.getMode(a, je), pe.indentOf = ce.indentation(), je && je.name !== "null" ? pe.innerMode = je : pe.indentToken = "string";
        }
        function ze(ce, pe, je) {
          if (ce.indentation() > pe.indentOf || pe.innerModeForLine && !ce.sol() || je)
            return pe.innerMode ? (pe.innerState || (pe.innerState = pe.innerMode.startState ? n.startState(pe.innerMode, ce.indentation()) : {}), ce.hideFirstChars(pe.indentOf + 2, function() {
              return pe.innerMode.token(ce, pe.innerState) || !0;
            })) : (ce.skipToEnd(), pe.indentToken);
          ce.sol() && (pe.indentOf = 1 / 0, pe.indentToken = null, pe.innerMode = null, pe.innerState = null);
        }
        function Ne(ce, pe) {
          if (ce.sol() && (pe.restOfLine = ""), pe.restOfLine) {
            ce.skipToEnd();
            var je = pe.restOfLine;
            return pe.restOfLine = "", je;
          }
        }
        function tt() {
          return new v();
        }
        function Qe(ce) {
          return ce.copy();
        }
        function et(ce, pe) {
          var je = ze(ce, pe) || Ne(ce, pe) || A(ce, pe) || W(ce, pe) || ne(ce, pe) || ie(ce, pe) || b(ce, pe) || w(ce, pe) || J(ce, pe) || C(ce) || k(ce) || E(ce, pe) || P(ce, pe) || M(ce, pe) || B(ce) || _(ce, pe) || T(ce, pe) || O(ce, pe) || I(ce, pe) || q(ce, pe) || F(ce, pe) || K(ce, pe) || Z(ce, pe) || re(ce, pe) || V(ce, pe) || Q(ce, pe) || z(ce, pe) || X(ce, pe) || ue(ce, pe) || Be(ce) || te(ce) || G(ce, pe) || oe(ce, pe) || ye(ce) || Ae(ce, pe) || ve(ce, pe) || ke(ce) || be(ce, pe) || Ie(ce);
          return je === !0 ? null : je;
        }
        return {
          startState: tt,
          copyState: Qe,
          token: et
        };
      }, "javascript", "css", "htmlmixed"), n.defineMIME("text/x-pug", "pug"), n.defineMIME("text/x-jade", "pug");
    });
  })()), pug.exports;
}
var hasRequiredVue;
function requireVue() {
  return hasRequiredVue || (hasRequiredVue = 1, (function(e, t) {
    (function(n) {
      n(
        requireCodemirror(),
        requireOverlay(),
        requireXml(),
        requireJavascript(),
        requireCoffeescript(),
        requireCss(),
        requireSass(),
        requireStylus(),
        requirePug(),
        requireHandlebars()
      );
    })(function(n) {
      var a = {
        script: [
          ["lang", /coffee(script)?/, "coffeescript"],
          ["type", /^(?:text|application)\/(?:x-)?coffee(?:script)?$/, "coffeescript"],
          ["lang", /^babel$/, "javascript"],
          ["type", /^text\/babel$/, "javascript"],
          ["type", /^text\/ecmascript-\d+$/, "javascript"]
        ],
        style: [
          ["lang", /^stylus$/i, "stylus"],
          ["lang", /^sass$/i, "sass"],
          ["lang", /^less$/i, "text/x-less"],
          ["lang", /^scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?styl(us)?$/i, "stylus"],
          ["type", /^text\/sass/i, "sass"],
          ["type", /^(text\/)?(x-)?scss$/i, "text/x-scss"],
          ["type", /^(text\/)?(x-)?less$/i, "text/x-less"]
        ],
        template: [
          ["lang", /^vue-template$/i, "vue"],
          ["lang", /^pug$/i, "pug"],
          ["lang", /^handlebars$/i, "handlebars"],
          ["type", /^(text\/)?(x-)?pug$/i, "pug"],
          ["type", /^text\/x-handlebars-template$/i, "handlebars"],
          [null, null, "vue-template"]
        ]
      };
      n.defineMode("vue-template", function(o, s) {
        var u = {
          token: function(d) {
            if (d.match(/^\{\{.*?\}\}/)) return "meta mustache";
            for (; d.next() && !d.match("{{", !1); )
              ;
            return null;
          }
        };
        return n.overlayMode(n.getMode(o, s.backdrop || "text/html"), u);
      }), n.defineMode("vue", function(o) {
        return n.getMode(o, { name: "htmlmixed", tags: a });
      }, "htmlmixed", "xml", "javascript", "coffeescript", "css", "sass", "stylus", "pug", "handlebars"), n.defineMIME("script/x-vue", "vue"), n.defineMIME("text/x-vue", "vue");
    });
  })()), vue.exports;
}
requireVue();
requireXml();
var yaml = { exports: {} }, hasRequiredYaml;
function requireYaml() {
  return hasRequiredYaml || (hasRequiredYaml = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror());
    })(function(n) {
      n.defineMode("yaml", function() {
        var a = ["true", "false", "on", "off", "yes", "no"], o = new RegExp("\\b((" + a.join(")|(") + "))$", "i");
        return {
          token: function(s, u) {
            var d = s.peek(), f = u.escaped;
            if (u.escaped = !1, d == "#" && (s.pos == 0 || /\s/.test(s.string.charAt(s.pos - 1))))
              return s.skipToEnd(), "comment";
            if (s.match(/^('([^']|\\.)*'?|"([^"]|\\.)*"?)/))
              return "string";
            if (u.literal && s.indentation() > u.keyCol)
              return s.skipToEnd(), "string";
            if (u.literal && (u.literal = !1), s.sol()) {
              if (u.keyCol = 0, u.pair = !1, u.pairStart = !1, s.match("---") || s.match("..."))
                return "def";
              if (s.match(/\s*-\s+/))
                return "meta";
            }
            if (s.match(/^(\{|\}|\[|\])/))
              return d == "{" ? u.inlinePairs++ : d == "}" ? u.inlinePairs-- : d == "[" ? u.inlineList++ : u.inlineList--, "meta";
            if (u.inlineList > 0 && !f && d == ",")
              return s.next(), "meta";
            if (u.inlinePairs > 0 && !f && d == ",")
              return u.keyCol = 0, u.pair = !1, u.pairStart = !1, s.next(), "meta";
            if (u.pairStart) {
              if (s.match(/^\s*(\||\>)\s*/))
                return u.literal = !0, "meta";
              if (s.match(/^\s*(\&|\*)[a-z0-9\._-]+\b/i))
                return "variable-2";
              if (u.inlinePairs == 0 && s.match(/^\s*-?[0-9\.\,]+\s?$/) || u.inlinePairs > 0 && s.match(/^\s*-?[0-9\.\,]+\s?(?=(,|}))/))
                return "number";
              if (s.match(o))
                return "keyword";
            }
            return !u.pair && s.match(/^\s*(?:[,\[\]{}&*!|>'"%@`][^\s'":]|[^,\[\]{}#&*!|>'"%@`])[^#]*?(?=\s*:($|\s))/) ? (u.pair = !0, u.keyCol = s.indentation(), "atom") : u.pair && s.match(/^:\s*/) ? (u.pairStart = !0, "meta") : (u.pairStart = !1, u.escaped = d == "\\", s.next(), null);
          },
          startState: function() {
            return {
              pair: !1,
              pairStart: !1,
              keyCol: 0,
              inlinePairs: 0,
              inlineList: 0,
              literal: !1,
              escaped: !1
            };
          },
          lineComment: "#",
          fold: "indent"
        };
      }), n.defineMIME("text/x-yaml", "yaml"), n.defineMIME("text/yaml", "yaml");
    });
  })()), yaml.exports;
}
requireYaml();
var yamlFrontmatter = { exports: {} }, hasRequiredYamlFrontmatter;
function requireYamlFrontmatter() {
  return hasRequiredYamlFrontmatter || (hasRequiredYamlFrontmatter = 1, (function(e, t) {
    (function(n) {
      n(requireCodemirror(), requireYaml());
    })(function(n) {
      var a = 0, o = 1, s = 2;
      n.defineMode("yaml-frontmatter", function(u, d) {
        var f = n.getMode(u, "yaml"), g = n.getMode(u, d && d.base || "gfm");
        function v(b) {
          return b.state == o ? { mode: f, state: b.yaml } : { mode: g, state: b.inner };
        }
        return {
          startState: function() {
            return {
              state: a,
              yaml: null,
              inner: n.startState(g)
            };
          },
          copyState: function(b) {
            return {
              state: b.state,
              yaml: b.yaml && n.copyState(f, b.yaml),
              inner: n.copyState(g, b.inner)
            };
          },
          token: function(b, w) {
            if (w.state == a)
              return b.match("---", !1) ? (w.state = o, w.yaml = n.startState(f), f.token(b, w.yaml)) : (w.state = s, g.token(b, w.inner));
            if (w.state == o) {
              var C = b.sol() && b.match(/(---|\.\.\.)/, !1), k = f.token(b, w.yaml);
              return C && (w.state = s, w.yaml = null), k;
            } else
              return g.token(b, w.inner);
          },
          innerMode: v,
          indent: function(b, w, C) {
            var k = v(b);
            return k.mode.indent ? k.mode.indent(k.state, w, C) : n.Pass;
          },
          blankLine: function(b) {
            var w = v(b);
            if (w.mode.blankLine) return w.mode.blankLine(w.state);
          }
        };
      });
    });
  })()), yamlFrontmatter.exports;
}
requireYamlFrontmatter();
const _hoisted_1$Z = ["textContent"], _hoisted_2$A = ["textContent"], _sfc_main$1B = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "CodeEditor",
  props: {
    allowModeSelection: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    fieldActions: { type: Array, default: () => [] },
    indentType: { type: String, default: "tabs" },
    keyMap: { type: String, default: "sublime" },
    lineNumbers: { type: Boolean, default: !0 },
    lineWrapping: { type: Boolean, default: !0 },
    mode: { type: String, default: "javascript" },
    modelValue: { type: String, default: "" },
    readOnly: { type: Boolean, default: !1 },
    rulers: { type: Object, default: () => {
    } },
    showModeLabel: { type: Boolean, default: !0 },
    tabSize: { type: Number, required: !1 },
    theme: { type: String, default: "material" },
    title: { type: String, default: () => __("Code Editor") }
  },
  emits: ["update:mode", "update:model-value", "focus", "blur"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = ref([
      { value: "clike", label: "C-Like" },
      { value: "css", label: "CSS" },
      { value: "diff", label: "Diff" },
      { value: "go", label: "Go" },
      { value: "haml", label: "HAML" },
      { value: "handlebars", label: "Handlebars" },
      { value: "htmlmixed", label: "HTML" },
      { value: "less", label: "LESS" },
      { value: "markdown", label: "Markdown" },
      { value: "gfm", label: "Markdown (GHF)" },
      { value: "nginx", label: "Nginx" },
      { value: "text/x-java", label: "Java" },
      { value: "javascript", label: "JavaScript" },
      { value: "jsx", label: "JSX" },
      { value: "text/x-objectivec", label: "Objective-C" },
      { value: "php", label: "PHP" },
      { value: "python", label: "Python" },
      { value: "ruby", label: "Ruby" },
      { value: "scss", label: "SCSS" },
      { value: "shell", label: "Shell" },
      { value: "sql", label: "SQL" },
      { value: "twig", label: "Twig" },
      { value: "vue", label: "Vue" },
      { value: "xml", label: "XML" },
      { value: "yaml-frontmatter", label: "YAML" }
    ]), u = ref(null), d = useTemplateRef("codemirrorElement"), f = ref(!1);
    t({
      refresh: v,
      toggleFullscreen: A,
      fullScreenMode: f
    }), onMounted(() => {
      nextTick(() => g());
    });
    function g() {
      u.value = markRaw(
        CodeMirror(d.value, {
          value: o.modelValue || "",
          mode: o.mode,
          direction: document.querySelector("html").getAttribute("dir") ?? "ltr",
          addModeClass: !0,
          keyMap: o.keyMap,
          tabSize: o.tabSize,
          indentWithTabs: o.indentType !== "spaces",
          lineNumbers: o.lineNumbers,
          lineWrapping: o.lineWrapping,
          matchBrackets: !0,
          readOnly: o.readOnly || o.disabled ? "nocursor" : !1,
          theme: w.value,
          inputStyle: "contenteditable",
          rulers: k
        })
      ), u.value.on("change", (P) => {
        a("update:model-value", P.doc.getValue());
      }), u.value.on("focus", () => a("focus")), u.value.on("blur", () => a("blur")), v();
    }
    function v() {
      nextTick(() => u.value?.refresh());
    }
    watch(
      () => o.disabled,
      (P) => {
        u.value?.setOption("readOnly", P ? "nocursor" : !1);
      },
      { immediate: !0 }
    ), watch(
      () => o.mode,
      (P) => {
        u.value?.setOption("mode", P);
      },
      { immediate: !0 }
    ), watch(
      () => o.modelValue,
      (P) => {
        P !== u.value?.doc.getValue() && (P || (P = ""), u.value?.doc.setValue(P));
      },
      { immediate: !0 }
    );
    const b = computed(() => s.value.find((P) => P.value === o.mode)?.label || o.mode), w = computed(() => o.theme === "light" ? "default" : "material"), C = computed(() => `theme-${o.theme}`), k = computed(() => {
      if (!o.rulers)
        return [];
      let P = o.theme === "light" ? "#d1d5db" : "#546e7a";
      return Object.entries(o.rulers).map(([M, B]) => {
        let _ = B === "dashed" ? "dashed" : "solid";
        return {
          column: parseInt(M),
          lineStyle: _,
          color: P
        };
      });
    }), E = computed(() => o.allowModeSelection || o.showModeLabel);
    function A() {
      f.value = !f.value;
    }
    return watch(
      () => f.value,
      (P) => {
        u.value.setOption("fullScreen", P), P || d.value.removeAttribute("style");
      }
    ), (P, M) => {
      const B = resolveComponent("publish-field-fullscreen-header"), _ = resolveComponent("portal");
      return openBlock(), createBlock(_, {
        name: "code-fullscreen",
        disabled: !f.value,
        "target-class": "code-fieldtype"
      }, {
        default: withCtx(() => [
          createElementVNode("div", {
            class: normalizeClass([
              "@container/markdown border border-transparent with-contrast:border-gray-500 block w-full overflow-hidden rounded-lg bg-white dark:bg-gray-900",
              "text-gray-900 dark:text-gray-300",
              "shadow-ui-sm appearance-none antialiased disabled:shadow-none",
              C.value,
              { "code-fullscreen": f.value }
            ])
          }, [
            f.value ? (openBlock(), createBlock(B, {
              key: 0,
              title: e.title,
              "field-actions": e.fieldActions,
              onClose: A
            }, {
              default: withCtx(() => [
                e.allowModeSelection ? (openBlock(), createBlock(unref(_sfc_main$q), {
                  key: 0,
                  class: "w-32",
                  size: "sm",
                  options: s.value,
                  disabled: e.disabled,
                  "model-value": e.mode,
                  "onUpdate:modelValue": M[0] || (M[0] = (T) => P.$emit("update:mode", T))
                }, null, 8, ["options", "disabled", "model-value"])) : e.showModeLabel ? (openBlock(), createElementBlock("div", {
                  key: 1,
                  textContent: toDisplayString(b.value),
                  class: "font-mono text-xs text-gray-700"
                }, null, 8, _hoisted_1$Z)) : createCommentVNode("", !0)
              ]),
              _: 1
            }, 8, ["title", "field-actions"])) : createCommentVNode("", !0),
            E.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(["flex items-center justify-between rounded-t-lg bg-gray-50 px-2 py-1 dark:bg-gray-950 border border-b-0 border-gray-300 dark:border-none", { "border-dashed": e.readOnly }])
            }, [
              createElementVNode("div", null, [
                e.allowModeSelection ? (openBlock(), createBlock(unref(_sfc_main$q), {
                  key: 0,
                  class: "w-auto",
                  size: "xs",
                  options: s.value,
                  disabled: e.disabled,
                  "model-value": e.mode,
                  searchable: "",
                  "onUpdate:modelValue": M[1] || (M[1] = (T) => P.$emit("update:mode", T))
                }, null, 8, ["options", "disabled", "model-value"])) : (openBlock(), createElementBlock("span", {
                  key: 1,
                  textContent: toDisplayString(b.value),
                  class: "font-mono text-xs text-gray-700"
                }, null, 8, _hoisted_2$A))
              ])
            ], 2)) : createCommentVNode("", !0),
            createVNode(_sfc_main$1C, { onResized: v }, {
              default: withCtx(() => [
                createElementVNode("div", {
                  ref_key: "codemirrorElement",
                  ref: d,
                  class: "font-mono text-sm"
                }, null, 512)
              ]),
              _: 1
            })
          ], 2)
        ]),
        _: 1
      }, 8, ["disabled"]);
    };
  }
});
var fuzzysort$2 = { exports: {} }, fuzzysort$1 = fuzzysort$2.exports, hasRequiredFuzzysort;
function requireFuzzysort() {
  return hasRequiredFuzzysort || (hasRequiredFuzzysort = 1, (function(e) {
    ((t, n) => {
      e.exports ? e.exports = n() : t.fuzzysort = n();
    })(fuzzysort$1, (t) => {
      var n = (ie, oe) => {
        if (!ie || !oe) return ue;
        var ye = k(ie);
        ne(oe) || (oe = C(oe));
        var ve = ye.bitflags;
        return (ve & oe._bitflags) !== ve ? ue : A(ye, oe);
      }, a = (ie, oe, ye) => {
        if (!ie) return ye?.all ? E(oe, ye) : X;
        var ve = k(ie), ke = ve.bitflags, Ae = ve.containsSpace, be = b(ye?.threshold || 0), Ie = ye?.limit || Q, Se = 0, ze = 0, Ne = oe.length;
        function tt(de) {
          Se < Ie ? (G.add(de), ++Se) : (++ze, de._score > G.peek()._score && G.replaceTop(de));
        }
        if (ye?.key)
          for (var Qe = ye.key, et = 0; et < Ne; ++et) {
            var ce = oe[et], pe = V(ce, Qe);
            if (pe && (ne(pe) || (pe = C(pe)), (ke & pe._bitflags) === ke)) {
              var je = A(ve, pe);
              je !== ue && (je._score < be || (je.obj = ce, tt(je)));
            }
          }
        else if (ye?.keys) {
          var lt = ye.keys, Ce = lt.length;
          e: for (var et = 0; et < Ne; ++et) {
            var ce = oe[et];
            {
              for (var Oe = 0, Te = 0; Te < Ce; ++Te) {
                var Qe = lt[Te], pe = V(ce, Qe);
                if (!pe) {
                  J[Te] = Be;
                  continue;
                }
                ne(pe) || (pe = C(pe)), J[Te] = pe, Oe |= pe._bitflags;
              }
              if ((ke & Oe) !== ke) continue;
            }
            if (Ae) for (let Ze = 0; Ze < ve.spaceSearches.length; Ze++) K[Ze] = z;
            for (var Te = 0; Te < Ce; ++Te) {
              if (pe = J[Te], pe === Be) {
                re[Te] = Be;
                continue;
              }
              if (re[Te] = A(
                ve,
                pe,
                /*allowSpaces=*/
                !1,
                /*allowPartialMatch=*/
                Ae
              ), re[Te] === ue) {
                re[Te] = Be;
                continue;
              }
              if (Ae) for (let $e = 0; $e < ve.spaceSearches.length; $e++) {
                if (Z[$e] > -1e3 && K[$e] > z) {
                  var ot = (K[$e] + Z[$e]) / 4;
                  ot > K[$e] && (K[$e] = ot);
                }
                Z[$e] > K[$e] && (K[$e] = Z[$e]);
              }
            }
            if (Ae) {
              for (let Ze = 0; Ze < ve.spaceSearches.length; Ze++)
                if (K[Ze] === z) continue e;
            } else {
              var We = !1;
              for (let Ze = 0; Ze < Ce; Ze++)
                if (re[Ze]._score !== z) {
                  We = !0;
                  break;
                }
              if (!We) continue;
            }
            var Ge = new f(Ce);
            for (let Ze = 0; Ze < Ce; Ze++)
              Ge[Ze] = re[Ze];
            if (Ae) {
              var He = 0;
              for (let Ze = 0; Ze < ve.spaceSearches.length; Ze++) He += K[Ze];
            } else {
              var He = z;
              for (let $e = 0; $e < Ce; $e++) {
                var je = Ge[$e];
                if (je._score > -1e3 && He > z) {
                  var ot = (He + je._score) / 4;
                  ot > He && (He = ot);
                }
                je._score > He && (He = je._score);
              }
            }
            if (Ge.obj = ce, Ge._score = He, ye?.scoreFn) {
              if (He = ye.scoreFn(Ge), !He) continue;
              He = b(He), Ge._score = He;
            }
            He < be || tt(Ge);
          }
        } else
          for (var et = 0; et < Ne; ++et) {
            var pe = oe[et];
            if (pe && (ne(pe) || (pe = C(pe)), (ke & pe._bitflags) === ke)) {
              var je = A(ve, pe);
              je !== ue && (je._score < be || tt(je));
            }
          }
        if (Se === 0) return X;
        for (var me = new Array(Se), et = Se - 1; et >= 0; --et) me[et] = G.poll();
        return me.total = Se + ze, me;
      }, o = (ie, oe = "<b>", ye = "</b>") => {
        for (var ve = typeof oe == "function" ? oe : void 0, ke = ie.target, Ae = ke.length, be = ie.indexes, Ie = "", Se = 0, ze = 0, Ne = !1, tt = [], Qe = 0; Qe < Ae; ++Qe) {
          var et = ke[Qe];
          if (be[ze] === Qe) {
            if (++ze, Ne || (Ne = !0, ve ? (tt.push(Ie), Ie = "") : Ie += oe), ze === be.length) {
              ve ? (Ie += et, tt.push(ve(Ie, Se++)), Ie = "", tt.push(ke.substr(Qe + 1))) : Ie += et + ye + ke.substr(Qe + 1);
              break;
            }
          } else
            Ne && (Ne = !1, ve ? (tt.push(ve(Ie, Se++)), Ie = "") : Ie += ye);
          Ie += et;
        }
        return ve ? tt : Ie;
      }, s = (ie) => {
        typeof ie == "number" ? ie = "" + ie : typeof ie != "string" && (ie = "");
        var oe = B(ie);
        return g(ie, { _targetLower: oe._lower, _targetLowerCodes: oe.lowerCodes, _bitflags: oe.bitflags });
      }, u = () => {
        O.clear(), I.clear();
      };
      class d {
        get indexes() {
          return this._indexes.slice(0, this._indexes.len).sort((oe, ye) => oe - ye);
        }
        set indexes(oe) {
          return this._indexes = oe;
        }
        highlight(oe, ye) {
          return o(this, oe, ye);
        }
        get score() {
          return v(this._score);
        }
        set score(oe) {
          this._score = b(oe);
        }
      }
      class f extends Array {
        get score() {
          return v(this._score);
        }
        set score(oe) {
          this._score = b(oe);
        }
      }
      var g = (ie, oe) => {
        const ye = new d();
        return ye.target = ie, ye.obj = oe.obj ?? ue, ye._score = oe._score ?? z, ye._indexes = oe._indexes ?? [], ye._targetLower = oe._targetLower ?? "", ye._targetLowerCodes = oe._targetLowerCodes ?? ue, ye._nextBeginningIndexes = oe._nextBeginningIndexes ?? ue, ye._bitflags = oe._bitflags ?? 0, ye;
      }, v = (ie) => ie === z ? 0 : ie > 1 ? ie : Math.E ** (((-ie + 1) ** 0.04307 - 1) * -2), b = (ie) => ie === 0 ? z : ie > 1 ? ie : 1 - Math.pow(Math.log(ie) / -2 + 1, 1 / 0.04307), w = (ie) => {
        typeof ie == "number" ? ie = "" + ie : typeof ie != "string" && (ie = ""), ie = ie.trim();
        var oe = B(ie), ye = [];
        if (oe.containsSpace) {
          var ve = ie.split(/\s+/);
          ve = [...new Set(ve)];
          for (var ke = 0; ke < ve.length; ke++)
            if (ve[ke] !== "") {
              var Ae = B(ve[ke]);
              ye.push({ lowerCodes: Ae.lowerCodes, _lower: ve[ke].toLowerCase(), containsSpace: !1 });
            }
        }
        return { lowerCodes: oe.lowerCodes, _lower: oe._lower, containsSpace: oe.containsSpace, bitflags: oe.bitflags, spaceSearches: ye };
      }, C = (ie) => {
        if (ie.length > 999) return s(ie);
        var oe = O.get(ie);
        return oe !== void 0 || (oe = s(ie), O.set(ie, oe)), oe;
      }, k = (ie) => {
        if (ie.length > 999) return w(ie);
        var oe = I.get(ie);
        return oe !== void 0 || (oe = w(ie), I.set(ie, oe)), oe;
      }, E = (ie, oe) => {
        var ye = [];
        ye.total = ie.length;
        var ve = oe?.limit || Q;
        if (oe?.key)
          for (var ke = 0; ke < ie.length; ke++) {
            var Ae = ie[ke], be = V(Ae, oe.key);
            if (be != ue) {
              ne(be) || (be = C(be));
              var Ie = g(be.target, { _score: be._score, obj: Ae });
              if (ye.push(Ie), ye.length >= ve) return ye;
            }
          }
        else if (oe?.keys)
          for (var ke = 0; ke < ie.length; ke++) {
            for (var Ae = ie[ke], Se = new f(oe.keys.length), ze = oe.keys.length - 1; ze >= 0; --ze) {
              var be = V(Ae, oe.keys[ze]);
              if (!be) {
                Se[ze] = Be;
                continue;
              }
              ne(be) || (be = C(be)), be._score = z, be._indexes.len = 0, Se[ze] = be;
            }
            if (Se.obj = Ae, Se._score = z, ye.push(Se), ye.length >= ve) return ye;
          }
        else
          for (var ke = 0; ke < ie.length; ke++) {
            var be = ie[ke];
            if (be != ue && (ne(be) || (be = C(be)), be._score = z, be._indexes.len = 0, ye.push(be), ye.length >= ve))
              return ye;
          }
        return ye;
      }, A = (ie, oe, ye = !1, ve = !1) => {
        if (ye === !1 && ie.containsSpace) return P(ie, oe, ve);
        for (var ke = ie._lower, Ae = ie.lowerCodes, be = Ae[0], Ie = oe._targetLowerCodes, Se = Ae.length, ze = Ie.length, et = 0, Ne = 0, tt = 0; ; ) {
          var Qe = be === Ie[Ne];
          if (Qe) {
            if (q[tt++] = Ne, ++et, et === Se) break;
            be = Ae[et];
          }
          if (++Ne, Ne >= ze) return ue;
        }
        var et = 0, ce = !1, pe = 0, je = oe._nextBeginningIndexes;
        je === ue && (je = oe._nextBeginningIndexes = T(oe.target)), Ne = q[0] === 0 ? 0 : je[q[0] - 1];
        var lt = 0;
        if (Ne !== ze) for (; ; )
          if (Ne >= ze) {
            if (et <= 0 || (++lt, lt > 200)) break;
            --et;
            var Ce = F[--pe];
            Ne = je[Ce];
          } else {
            var Qe = Ae[et] === Ie[Ne];
            if (Qe) {
              if (F[pe++] = Ne, ++et, et === Se) {
                ce = !0;
                break;
              }
              ++Ne;
            } else
              Ne = je[Ne];
          }
        var Oe = Se <= 1 ? -1 : oe._targetLower.indexOf(ke, q[0]), Te = !!~Oe, ot = Te ? Oe === 0 || oe._nextBeginningIndexes[Oe - 1] === Oe : !1;
        if (Te && !ot) {
          for (var We = 0; We < je.length; We = je[We])
            if (!(We <= Oe)) {
              for (var Ge = 0; Ge < Se && Ae[Ge] === oe._targetLowerCodes[We + Ge]; Ge++) ;
              if (Ge === Se) {
                Oe = We, ot = !0;
                break;
              }
            }
        }
        var He = (Ze) => {
          for (var $e = 0, ct = 0, Je = 1; Je < Se; ++Je)
            Ze[Je] - Ze[Je - 1] !== 1 && ($e -= Ze[Je], ++ct);
          var wt = Ze[Se - 1] - Ze[0] - (Se - 1);
          if ($e -= (12 + wt) * ct, Ze[0] !== 0 && ($e -= Ze[0] * Ze[0] * 0.2), !ce)
            $e *= 1e3;
          else {
            for (var qe = 1, Je = je[0]; Je < ze; Je = je[Je]) ++qe;
            qe > 24 && ($e *= (qe - 24) * 10);
          }
          return $e -= (ze - Se) / 2, Te && ($e /= 1 + Se * Se * 1), ot && ($e /= 1 + Se * Se * 1), $e -= (ze - Se) / 2, $e;
        };
        if (ce)
          if (ot) {
            for (var We = 0; We < Se; ++We) q[We] = Oe + We;
            var me = q, de = He(q);
          } else
            var me = F, de = He(F);
        else {
          if (Te) for (var We = 0; We < Se; ++We) q[We] = Oe + We;
          var me = q, de = He(me);
        }
        oe._score = de;
        for (var We = 0; We < Se; ++We) oe._indexes[We] = me[We];
        oe._indexes.len = Se;
        const Fe = new d();
        return Fe.target = oe.target, Fe._score = oe._score, Fe._indexes = oe._indexes, Fe;
      }, P = (ie, oe, ye) => {
        for (var ve = /* @__PURE__ */ new Set(), ke = 0, Ae = ue, be = 0, Ie = ie.spaceSearches, Se = Ie.length, ze = 0, Ne = () => {
          for (let ot = ze - 1; ot >= 0; ot--) oe._nextBeginningIndexes[W[ot * 2 + 0]] = W[ot * 2 + 1];
        }, tt = !1, Te = 0; Te < Se; ++Te) {
          Z[Te] = z;
          var Qe = Ie[Te];
          if (Ae = A(Qe, oe), ye) {
            if (Ae === ue) continue;
            tt = !0;
          } else if (Ae === ue)
            return Ne(), ue;
          var et = Te === Se - 1;
          if (!et) {
            var ce = Ae._indexes, pe = !0;
            for (let We = 0; We < ce.len - 1; We++)
              if (ce[We + 1] - ce[We] !== 1) {
                pe = !1;
                break;
              }
            if (pe) {
              var je = ce[ce.len - 1] + 1, lt = oe._nextBeginningIndexes[je - 1];
              for (let We = je - 1; We >= 0 && lt === oe._nextBeginningIndexes[We]; We--)
                oe._nextBeginningIndexes[We] = je, W[ze * 2 + 0] = We, W[ze * 2 + 1] = lt, ze++;
            }
          }
          ke += Ae._score / Se, Z[Te] = Ae._score / Se, Ae._indexes[0] < be && (ke -= (be - Ae._indexes[0]) * 2), be = Ae._indexes[0];
          for (var Ce = 0; Ce < Ae._indexes.len; ++Ce) ve.add(Ae._indexes[Ce]);
        }
        if (ye && !tt) return ue;
        Ne();
        var Oe = A(
          ie,
          oe,
          /*allowSpaces=*/
          !0
        );
        if (Oe !== ue && Oe._score > ke) {
          if (ye)
            for (var Te = 0; Te < Se; ++Te)
              Z[Te] = Oe._score / Se;
          return Oe;
        }
        ye && (Ae = oe), Ae._score = ke;
        var Te = 0;
        for (let ot of ve) Ae._indexes[Te++] = ot;
        return Ae._indexes.len = Te, Ae;
      }, M = (ie) => ie.replace(new RegExp("\\p{Script=Latin}+", "gu"), (oe) => oe.normalize("NFD")).replace(/[\u0300-\u036f]/g, ""), B = (ie) => {
        ie = M(ie);
        for (var oe = ie.length, ye = ie.toLowerCase(), ve = [], ke = 0, Ae = !1, be = 0; be < oe; ++be) {
          var Ie = ve[be] = ye.charCodeAt(be);
          if (Ie === 32) {
            Ae = !0;
            continue;
          }
          var Se = Ie >= 97 && Ie <= 122 ? Ie - 97 : Ie >= 48 && Ie <= 57 ? 26 : Ie <= 127 ? 30 : 31;
          ke |= 1 << Se;
        }
        return { lowerCodes: ve, bitflags: ke, containsSpace: Ae, _lower: ye };
      }, _ = (ie) => {
        for (var oe = ie.length, ye = [], ve = 0, ke = !1, Ae = !1, be = 0; be < oe; ++be) {
          var Ie = ie.charCodeAt(be), Se = Ie >= 65 && Ie <= 90, ze = Se || Ie >= 97 && Ie <= 122 || Ie >= 48 && Ie <= 57, Ne = Se && !ke || !Ae || !ze;
          ke = Se, Ae = ze, Ne && (ye[ve++] = be);
        }
        return ye;
      }, T = (ie) => {
        ie = M(ie);
        for (var oe = ie.length, ye = _(ie), ve = [], ke = ye[0], Ae = 0, be = 0; be < oe; ++be)
          ke > be ? ve[be] = ke : (ke = ye[++Ae], ve[be] = ke === void 0 ? oe : ke);
        return ve;
      }, O = /* @__PURE__ */ new Map(), I = /* @__PURE__ */ new Map(), q = [], F = [], W = [], K = [], Z = [], J = [], re = [], V = (ie, oe) => {
        var ye = ie[oe];
        if (ye !== void 0) return ye;
        if (typeof oe == "function") return oe(ie);
        var ve = oe;
        Array.isArray(oe) || (ve = oe.split("."));
        for (var ke = ve.length, Ae = -1; ie && ++Ae < ke; ) ie = ie[ve[Ae]];
        return ie;
      }, ne = (ie) => typeof ie == "object" && typeof ie._bitflags == "number", Q = 1 / 0, z = -Q, X = [];
      X.total = 0;
      var ue = null, Be = s(""), te = (ie) => {
        var oe = [], ye = 0, ve = {}, ke = (Ae) => {
          for (var be = 0, Ie = oe[be], Se = 1; Se < ye; ) {
            var ze = Se + 1;
            be = Se, ze < ye && oe[ze]._score < oe[Se]._score && (be = ze), oe[be - 1 >> 1] = oe[be], Se = 1 + (be << 1);
          }
          for (var Ne = be - 1 >> 1; be > 0 && Ie._score < oe[Ne]._score; Ne = (be = Ne) - 1 >> 1) oe[be] = oe[Ne];
          oe[be] = Ie;
        };
        return ve.add = ((Ae) => {
          var be = ye;
          oe[ye++] = Ae;
          for (var Ie = be - 1 >> 1; be > 0 && Ae._score < oe[Ie]._score; Ie = (be = Ie) - 1 >> 1) oe[be] = oe[Ie];
          oe[be] = Ae;
        }), ve.poll = ((Ae) => {
          if (ye !== 0) {
            var be = oe[0];
            return oe[0] = oe[--ye], ke(), be;
          }
        }), ve.peek = ((Ae) => {
          if (ye !== 0) return oe[0];
        }), ve.replaceTop = ((Ae) => {
          oe[0] = Ae, ke();
        }), ve;
      }, G = te();
      return { single: n, go: a, prepare: s, cleanup: u };
    });
  })(fuzzysort$2)), fuzzysort$2.exports;
}
var fuzzysortExports = requireFuzzysort();
const fuzzysort = /* @__PURE__ */ getDefaultExportFromCjs(fuzzysortExports);
class AbstractEvent {
  constructor(t) {
    this._canceled = !1, this.data = t;
  }
  get type() {
    return this.constructor.type;
  }
  get cancelable() {
    return this.constructor.cancelable;
  }
  cancel() {
    this._canceled = !0;
  }
  canceled() {
    return this._canceled;
  }
  clone(t) {
    return new this.constructor({
      ...this.data,
      ...t
    });
  }
}
AbstractEvent.type = "event";
AbstractEvent.cancelable = !1;
class AbstractPlugin {
  constructor(t) {
    this.draggable = t;
  }
  attach() {
    throw new Error("Not Implemented");
  }
  detach() {
    throw new Error("Not Implemented");
  }
}
const defaultDelay = {
  mouse: 0,
  drag: 0,
  touch: 100
};
class Sensor {
  constructor(t = [], n = {}) {
    this.containers = [...t], this.options = {
      ...n
    }, this.dragging = !1, this.currentContainer = null, this.originalSource = null, this.startEvent = null, this.delay = calcDelay(n.delay);
  }
  attach() {
    return this;
  }
  detach() {
    return this;
  }
  addContainer(...t) {
    this.containers = [...this.containers, ...t];
  }
  removeContainer(...t) {
    this.containers = this.containers.filter((n) => !t.includes(n));
  }
  trigger(t, n) {
    const a = document.createEvent("Event");
    return a.detail = n, a.initEvent(n.type, !0, !0), t.dispatchEvent(a), this.lastEvent = n, n;
  }
}
function calcDelay(e) {
  const t = {};
  if (e === void 0)
    return {
      ...defaultDelay
    };
  if (typeof e == "number") {
    for (const n in defaultDelay)
      Object.prototype.hasOwnProperty.call(defaultDelay, n) && (t[n] = e);
    return t;
  }
  for (const n in defaultDelay)
    Object.prototype.hasOwnProperty.call(defaultDelay, n) && (e[n] === void 0 ? t[n] = defaultDelay[n] : t[n] = e[n]);
  return t;
}
function closest(e, t) {
  if (e == null)
    return null;
  function n(o) {
    return o == null || t == null ? !1 : isSelector(t) ? Element.prototype.matches.call(o, t) : isNodeList(t) ? [...t].includes(o) : isElement(t) ? t === o : isFunction$2(t) ? t(o) : !1;
  }
  let a = e;
  do {
    if (a = a.correspondingUseElement || a.correspondingElement || a, n(a))
      return a;
    a = a?.parentNode || null;
  } while (a != null && a !== document.body && a !== document);
  return null;
}
function isSelector(e) {
  return typeof e == "string";
}
function isNodeList(e) {
  return e instanceof NodeList || e instanceof Array;
}
function isElement(e) {
  return e instanceof Node;
}
function isFunction$2(e) {
  return typeof e == "function";
}
function distance$1(e, t, n, a) {
  return Math.sqrt((n - e) ** 2 + (a - t) ** 2);
}
class SensorEvent extends AbstractEvent {
  get originalEvent() {
    return this.data.originalEvent;
  }
  get clientX() {
    return this.data.clientX;
  }
  get clientY() {
    return this.data.clientY;
  }
  get target() {
    return this.data.target;
  }
  get container() {
    return this.data.container;
  }
  get originalSource() {
    return this.data.originalSource;
  }
  get pressure() {
    return this.data.pressure;
  }
}
class DragStartSensorEvent extends SensorEvent {
}
DragStartSensorEvent.type = "drag:start";
class DragMoveSensorEvent extends SensorEvent {
}
DragMoveSensorEvent.type = "drag:move";
class DragStopSensorEvent extends SensorEvent {
}
DragStopSensorEvent.type = "drag:stop";
class DragPressureSensorEvent extends SensorEvent {
}
DragPressureSensorEvent.type = "drag:pressure";
const onContextMenuWhileDragging = Symbol("onContextMenuWhileDragging"), onMouseDown = Symbol("onMouseDown"), onMouseMove = Symbol("onMouseMove"), onMouseUp = Symbol("onMouseUp"), startDrag$1 = Symbol("startDrag"), onDistanceChange$1 = Symbol("onDistanceChange");
class MouseSensor extends Sensor {
  constructor(t = [], n = {}) {
    super(t, n), this.mouseDownTimeout = null, this.pageX = null, this.pageY = null, this[onContextMenuWhileDragging] = this[onContextMenuWhileDragging].bind(this), this[onMouseDown] = this[onMouseDown].bind(this), this[onMouseMove] = this[onMouseMove].bind(this), this[onMouseUp] = this[onMouseUp].bind(this), this[startDrag$1] = this[startDrag$1].bind(this), this[onDistanceChange$1] = this[onDistanceChange$1].bind(this);
  }
  attach() {
    document.addEventListener("mousedown", this[onMouseDown], !0);
  }
  detach() {
    document.removeEventListener("mousedown", this[onMouseDown], !0);
  }
  [onMouseDown](t) {
    if (t.button !== 0 || t.ctrlKey || t.metaKey)
      return;
    const n = closest(t.target, this.containers);
    if (!n || this.options.handle && t.target && !closest(t.target, this.options.handle))
      return;
    const a = closest(t.target, this.options.draggable);
    if (!a)
      return;
    const {
      delay: o
    } = this, {
      pageX: s,
      pageY: u
    } = t;
    Object.assign(this, {
      pageX: s,
      pageY: u
    }), this.onMouseDownAt = Date.now(), this.startEvent = t, this.currentContainer = n, this.originalSource = a, document.addEventListener("mouseup", this[onMouseUp]), document.addEventListener("dragstart", preventNativeDragStart), document.addEventListener("mousemove", this[onDistanceChange$1]), this.mouseDownTimeout = window.setTimeout(() => {
      this[onDistanceChange$1]({
        pageX: this.pageX,
        pageY: this.pageY
      });
    }, o.mouse);
  }
  [startDrag$1]() {
    const t = this.startEvent, n = this.currentContainer, a = this.originalSource, o = new DragStartSensorEvent({
      clientX: t.clientX,
      clientY: t.clientY,
      target: t.target,
      container: n,
      originalSource: a,
      originalEvent: t
    });
    this.trigger(this.currentContainer, o), this.dragging = !o.canceled(), this.dragging && (document.addEventListener("contextmenu", this[onContextMenuWhileDragging], !0), document.addEventListener("mousemove", this[onMouseMove]));
  }
  [onDistanceChange$1](t) {
    const {
      pageX: n,
      pageY: a
    } = t, {
      distance: o
    } = this.options, {
      startEvent: s,
      delay: u
    } = this;
    if (Object.assign(this, {
      pageX: n,
      pageY: a
    }), !this.currentContainer)
      return;
    const d = Date.now() - this.onMouseDownAt, f = distance$1(s.pageX, s.pageY, n, a) || 0;
    clearTimeout(this.mouseDownTimeout), d < u.mouse ? document.removeEventListener("mousemove", this[onDistanceChange$1]) : f >= o && (document.removeEventListener("mousemove", this[onDistanceChange$1]), this[startDrag$1]());
  }
  [onMouseMove](t) {
    if (!this.dragging)
      return;
    const n = document.elementFromPoint(t.clientX, t.clientY), a = new DragMoveSensorEvent({
      clientX: t.clientX,
      clientY: t.clientY,
      target: n,
      container: this.currentContainer,
      originalEvent: t
    });
    this.trigger(this.currentContainer, a);
  }
  [onMouseUp](t) {
    if (clearTimeout(this.mouseDownTimeout), t.button !== 0 || (document.removeEventListener("mouseup", this[onMouseUp]), document.removeEventListener("dragstart", preventNativeDragStart), document.removeEventListener("mousemove", this[onDistanceChange$1]), !this.dragging))
      return;
    const n = document.elementFromPoint(t.clientX, t.clientY), a = new DragStopSensorEvent({
      clientX: t.clientX,
      clientY: t.clientY,
      target: n,
      container: this.currentContainer,
      originalEvent: t
    });
    this.trigger(this.currentContainer, a), document.removeEventListener("contextmenu", this[onContextMenuWhileDragging], !0), document.removeEventListener("mousemove", this[onMouseMove]), this.currentContainer = null, this.dragging = !1, this.startEvent = null;
  }
  [onContextMenuWhileDragging](t) {
    t.preventDefault();
  }
}
function preventNativeDragStart(e) {
  e.preventDefault();
}
function touchCoords(e) {
  const {
    touches: t,
    changedTouches: n
  } = e;
  return t && t[0] || n && n[0];
}
const onTouchStart = Symbol("onTouchStart"), onTouchEnd = Symbol("onTouchEnd"), onTouchMove = Symbol("onTouchMove"), startDrag = Symbol("startDrag"), onDistanceChange = Symbol("onDistanceChange");
let preventScrolling = !1;
window.addEventListener("touchmove", (e) => {
  preventScrolling && e.preventDefault();
}, {
  passive: !1
});
class TouchSensor extends Sensor {
  constructor(t = [], n = {}) {
    super(t, n), this.currentScrollableParent = null, this.tapTimeout = null, this.touchMoved = !1, this.pageX = null, this.pageY = null, this[onTouchStart] = this[onTouchStart].bind(this), this[onTouchEnd] = this[onTouchEnd].bind(this), this[onTouchMove] = this[onTouchMove].bind(this), this[startDrag] = this[startDrag].bind(this), this[onDistanceChange] = this[onDistanceChange].bind(this);
  }
  attach() {
    document.addEventListener("touchstart", this[onTouchStart]);
  }
  detach() {
    document.removeEventListener("touchstart", this[onTouchStart]);
  }
  [onTouchStart](t) {
    const n = closest(t.target, this.containers);
    if (!n || this.options.handle && t.target && !closest(t.target, this.options.handle))
      return;
    const a = closest(t.target, this.options.draggable);
    if (!a)
      return;
    const {
      distance: o = 0
    } = this.options, {
      delay: s
    } = this, {
      pageX: u,
      pageY: d
    } = touchCoords(t);
    Object.assign(this, {
      pageX: u,
      pageY: d
    }), this.onTouchStartAt = Date.now(), this.startEvent = t, this.currentContainer = n, this.originalSource = a, document.addEventListener("touchend", this[onTouchEnd]), document.addEventListener("touchcancel", this[onTouchEnd]), document.addEventListener("touchmove", this[onDistanceChange]), n.addEventListener("contextmenu", onContextMenu), o && (preventScrolling = !0), this.tapTimeout = window.setTimeout(() => {
      this[onDistanceChange]({
        touches: [{
          pageX: this.pageX,
          pageY: this.pageY
        }]
      });
    }, s.touch);
  }
  [startDrag]() {
    const t = this.startEvent, n = this.currentContainer, a = touchCoords(t), o = this.originalSource, s = new DragStartSensorEvent({
      clientX: a.pageX,
      clientY: a.pageY,
      target: t.target,
      container: n,
      originalSource: o,
      originalEvent: t
    });
    this.trigger(this.currentContainer, s), this.dragging = !s.canceled(), this.dragging && document.addEventListener("touchmove", this[onTouchMove]), preventScrolling = this.dragging;
  }
  [onDistanceChange](t) {
    const {
      distance: n
    } = this.options, {
      startEvent: a,
      delay: o
    } = this, s = touchCoords(a), u = touchCoords(t), d = Date.now() - this.onTouchStartAt, f = distance$1(s.pageX, s.pageY, u.pageX, u.pageY);
    Object.assign(this, u), clearTimeout(this.tapTimeout), d < o.touch ? document.removeEventListener("touchmove", this[onDistanceChange]) : f >= n && (document.removeEventListener("touchmove", this[onDistanceChange]), this[startDrag]());
  }
  [onTouchMove](t) {
    if (!this.dragging)
      return;
    const {
      pageX: n,
      pageY: a
    } = touchCoords(t), o = document.elementFromPoint(n - window.scrollX, a - window.scrollY), s = new DragMoveSensorEvent({
      clientX: n,
      clientY: a,
      target: o,
      container: this.currentContainer,
      originalEvent: t
    });
    this.trigger(this.currentContainer, s);
  }
  [onTouchEnd](t) {
    if (clearTimeout(this.tapTimeout), preventScrolling = !1, document.removeEventListener("touchend", this[onTouchEnd]), document.removeEventListener("touchcancel", this[onTouchEnd]), document.removeEventListener("touchmove", this[onDistanceChange]), this.currentContainer && this.currentContainer.removeEventListener("contextmenu", onContextMenu), !this.dragging)
      return;
    document.removeEventListener("touchmove", this[onTouchMove]);
    const {
      pageX: n,
      pageY: a
    } = touchCoords(t), o = document.elementFromPoint(n - window.scrollX, a - window.scrollY);
    t.preventDefault();
    const s = new DragStopSensorEvent({
      clientX: n,
      clientY: a,
      target: o,
      container: this.currentContainer,
      originalEvent: t
    });
    this.trigger(this.currentContainer, s), this.currentContainer = null, this.dragging = !1, this.startEvent = null;
  }
}
function onContextMenu(e) {
  e.preventDefault(), e.stopPropagation();
}
class CollidableEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get dragEvent() {
    return this.data.dragEvent;
  }
}
CollidableEvent.type = "collidable";
class CollidableInEvent extends CollidableEvent {
  get collidingElement() {
    return this.data.collidingElement;
  }
}
CollidableInEvent.type = "collidable:in";
class CollidableOutEvent extends CollidableEvent {
  get collidingElement() {
    return this.data.collidingElement;
  }
}
CollidableOutEvent.type = "collidable:out";
function createAddInitializerMethod(e, t) {
  return function(n) {
    assertNotFinished(t, "addInitializer"), assertCallable(n, "An initializer"), e.push(n);
  };
}
function assertInstanceIfPrivate(e, t) {
  if (!e(t)) throw new TypeError("Attempted to access private element on non-instance");
}
function memberDec(e, t, n, a, o, s, u, d, f, g, v) {
  var b;
  switch (s) {
    case 1:
      b = "accessor";
      break;
    case 2:
      b = "method";
      break;
    case 3:
      b = "getter";
      break;
    case 4:
      b = "setter";
      break;
    default:
      b = "field";
  }
  var w, C, k = {
    kind: b,
    name: d ? "#" + n : n,
    static: u,
    private: d,
    metadata: v
  }, E = {
    v: !1
  };
  if (s !== 0 && (k.addInitializer = createAddInitializerMethod(o, E)), d || s !== 0 && s !== 2)
    if (s === 2) w = function(M) {
      return assertInstanceIfPrivate(g, M), a.value;
    };
    else {
      var A = s === 0 || s === 1;
      (A || s === 3) && (w = d ? function(M) {
        return assertInstanceIfPrivate(g, M), a.get.call(M);
      } : function(M) {
        return a.get.call(M);
      }), (A || s === 4) && (C = d ? function(M, B) {
        assertInstanceIfPrivate(g, M), a.set.call(M, B);
      } : function(M, B) {
        a.set.call(M, B);
      });
    }
  else w = function(M) {
    return M[n];
  }, s === 0 && (C = function(M, B) {
    M[n] = B;
  });
  var P = d ? g.bind() : function(M) {
    return n in M;
  };
  k.access = w && C ? {
    get: w,
    set: C,
    has: P
  } : w ? {
    get: w,
    has: P
  } : {
    set: C,
    has: P
  };
  try {
    return e.call(t, f, k);
  } finally {
    E.v = !0;
  }
}
function assertNotFinished(e, t) {
  if (e.v) throw new Error("attempted to call " + t + " after decoration was finished");
}
function assertCallable(e, t) {
  if (typeof e != "function") throw new TypeError(t + " must be a function");
}
function assertValidReturnValue(e, t) {
  var n = typeof t;
  if (e === 1) {
    if (n !== "object" || t === null) throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
    t.get !== void 0 && assertCallable(t.get, "accessor.get"), t.set !== void 0 && assertCallable(t.set, "accessor.set"), t.init !== void 0 && assertCallable(t.init, "accessor.init");
  } else if (n !== "function") {
    var a;
    throw a = e === 0 ? "field" : e === 5 ? "class" : "method", new TypeError(a + " decorators must return a function or void 0");
  }
}
function curryThis1(e) {
  return function() {
    return e(this);
  };
}
function curryThis2(e) {
  return function(t) {
    e(this, t);
  };
}
function applyMemberDec(e, t, n, a, o, s, u, d, f, g, v) {
  var b, w, C, k, E, A, P = n[0];
  a || Array.isArray(P) || (P = [P]), d ? b = s === 0 || s === 1 ? {
    get: curryThis1(n[3]),
    set: curryThis2(n[4])
  } : s === 3 ? {
    get: n[3]
  } : s === 4 ? {
    set: n[3]
  } : {
    value: n[3]
  } : s !== 0 && (b = Object.getOwnPropertyDescriptor(t, o)), s === 1 ? C = {
    get: b.get,
    set: b.set
  } : s === 2 ? C = b.value : s === 3 ? C = b.get : s === 4 && (C = b.set);
  for (var M = a ? 2 : 1, B = P.length - 1; B >= 0; B -= M) {
    var _;
    (k = memberDec(P[B], a ? P[B - 1] : void 0, o, b, f, s, u, d, C, g, v)) !== void 0 && (assertValidReturnValue(s, k), s === 0 ? _ = k : s === 1 ? (_ = k.init, E = k.get || C.get, A = k.set || C.set, C = {
      get: E,
      set: A
    }) : C = k, _ !== void 0 && (w === void 0 ? w = _ : typeof w == "function" ? w = [w, _] : w.push(_)));
  }
  if (s === 0 || s === 1) {
    if (w === void 0) w = function(I, q) {
      return q;
    };
    else if (typeof w != "function") {
      var T = w;
      w = function(I, q) {
        for (var F = q, W = T.length - 1; W >= 0; W--) F = T[W].call(I, F);
        return F;
      };
    } else {
      var O = w;
      w = function(I, q) {
        return O.call(I, q);
      };
    }
    e.push(w);
  }
  s !== 0 && (s === 1 ? (b.get = C.get, b.set = C.set) : s === 2 ? b.value = C : s === 3 ? b.get = C : s === 4 && (b.set = C), d ? s === 1 ? (e.push(function(I, q) {
    return C.get.call(I, q);
  }), e.push(function(I, q) {
    return C.set.call(I, q);
  })) : s === 2 ? e.push(C) : e.push(function(I, q) {
    return C.call(I, q);
  }) : Object.defineProperty(t, o, b));
}
function applyMemberDecs(e, t, n, a) {
  for (var o, s, u, d = [], f = /* @__PURE__ */ new Map(), g = /* @__PURE__ */ new Map(), v = 0; v < t.length; v++) {
    var b = t[v];
    if (Array.isArray(b)) {
      var w, C, k = b[1], E = b[2], A = b.length > 3, P = 16 & k, M = !!(8 & k), B = n;
      if (k &= 7, M ? (w = e, k !== 0 && (C = s = s || []), A && !u && (u = function(O) {
        return _checkInRHS(O) === e;
      }), B = u) : (w = e.prototype, k !== 0 && (C = o = o || [])), k !== 0 && !A) {
        var _ = M ? g : f, T = _.get(E) || 0;
        if (T === !0 || T === 3 && k !== 4 || T === 4 && k !== 3) throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + E);
        _.set(E, !(!T && k > 2) || k);
      }
      applyMemberDec(d, w, b, P, E, k, M, A, C, B, a);
    }
  }
  return pushInitializers(d, o), pushInitializers(d, s), d;
}
function pushInitializers(e, t) {
  t && e.push(function(n) {
    for (var a = 0; a < t.length; a++) t[a].call(n);
    return n;
  });
}
function applyClassDecs(e, t, n, a) {
  if (t.length) {
    for (var o = [], s = e, u = e.name, d = 1, f = t.length - 1; f >= 0; f -= d) {
      var g = {
        v: !1
      };
      try {
        var v = t[f].call(n ? t[f - 1] : void 0, s, {
          kind: "class",
          name: u,
          addInitializer: createAddInitializerMethod(o, g),
          metadata: a
        });
      } finally {
        g.v = !0;
      }
      v !== void 0 && (assertValidReturnValue(5, v), s = v);
    }
    return [defineMetadata(s, a), function() {
      for (var b = 0; b < o.length; b++) o[b].call(s);
    }];
  }
}
function defineMetadata(e, t) {
  return Object.defineProperty(e, Symbol.metadata || Symbol.for("Symbol.metadata"), {
    configurable: !0,
    enumerable: !0,
    value: t
  });
}
function _applyDecs2305(e, t, n, a, o, s) {
  if (arguments.length >= 6) var u = s[Symbol.metadata || Symbol.for("Symbol.metadata")];
  var d = Object.create(u === void 0 ? null : u), f = applyMemberDecs(e, t, o, d);
  return n.length || defineMetadata(e, d), {
    e: f,
    get c() {
      return applyClassDecs(e, n, a, d);
    }
  };
}
function _checkInRHS(e) {
  if (Object(e) !== e) throw TypeError("right-hand side of 'in' should be an object, got " + (e !== null ? typeof e : "null"));
  return e;
}
function AutoBind(e, {
  name: t,
  addInitializer: n
}) {
  n(function() {
    this[t] = e.bind(this);
  });
}
function requestNextAnimationFrame(e) {
  return requestAnimationFrame(() => {
    requestAnimationFrame(e);
  });
}
class DragEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get source() {
    return this.data.source;
  }
  get originalSource() {
    return this.data.originalSource;
  }
  get mirror() {
    return this.data.mirror;
  }
  get sourceContainer() {
    return this.data.sourceContainer;
  }
  get sensorEvent() {
    return this.data.sensorEvent;
  }
  get originalEvent() {
    return this.sensorEvent ? this.sensorEvent.originalEvent : null;
  }
}
DragEvent.type = "drag";
class DragStartEvent extends DragEvent {
}
DragStartEvent.type = "drag:start";
DragStartEvent.cancelable = !0;
class DragMoveEvent extends DragEvent {
}
DragMoveEvent.type = "drag:move";
class DragOverEvent extends DragEvent {
  get overContainer() {
    return this.data.overContainer;
  }
  get over() {
    return this.data.over;
  }
}
DragOverEvent.type = "drag:over";
DragOverEvent.cancelable = !0;
function isDragOverEvent(e) {
  return e.type === DragOverEvent.type;
}
class DragOutEvent extends DragEvent {
  get overContainer() {
    return this.data.overContainer;
  }
  get over() {
    return this.data.over;
  }
}
DragOutEvent.type = "drag:out";
class DragOverContainerEvent extends DragEvent {
  get overContainer() {
    return this.data.overContainer;
  }
}
DragOverContainerEvent.type = "drag:over:container";
class DragOutContainerEvent extends DragEvent {
  get overContainer() {
    return this.data.overContainer;
  }
}
DragOutContainerEvent.type = "drag:out:container";
class DragPressureEvent extends DragEvent {
  get pressure() {
    return this.data.pressure;
  }
}
DragPressureEvent.type = "drag:pressure";
class DragStopEvent extends DragEvent {
}
DragStopEvent.type = "drag:stop";
DragStopEvent.cancelable = !0;
class DragStoppedEvent extends DragEvent {
}
DragStoppedEvent.type = "drag:stopped";
var _initProto$1, _class$1;
class ResizeMirror extends AbstractPlugin {
  constructor(t) {
    _initProto$1(super(t)), this.lastWidth = 0, this.lastHeight = 0, this.mirror = null;
  }
  attach() {
    this.draggable.on("mirror:created", this.onMirrorCreated).on("drag:over", this.onDragOver).on("drag:over:container", this.onDragOver);
  }
  detach() {
    this.draggable.off("mirror:created", this.onMirrorCreated).off("mirror:destroy", this.onMirrorDestroy).off("drag:over", this.onDragOver).off("drag:over:container", this.onDragOver);
  }
  getOptions() {
    return this.draggable.options.resizeMirror || {};
  }
  onMirrorCreated({
    mirror: t
  }) {
    this.mirror = t;
  }
  onMirrorDestroy() {
    this.mirror = null;
  }
  onDragOver(t) {
    this.resize(t);
  }
  resize(t) {
    requestAnimationFrame(() => {
      let n = null;
      const {
        overContainer: a
      } = t;
      if (this.mirror == null || this.mirror.parentNode == null)
        return;
      this.mirror.parentNode !== a && a.appendChild(this.mirror), isDragOverEvent(t) && (n = t.over);
      const o = n || this.draggable.getDraggableElementsForContainer(a)[0];
      o && requestNextAnimationFrame(() => {
        const s = o.getBoundingClientRect();
        this.mirror == null || this.lastHeight === s.height && this.lastWidth === s.width || (this.mirror.style.width = `${s.width}px`, this.mirror.style.height = `${s.height}px`, this.lastWidth = s.width, this.lastHeight = s.height);
      });
    });
  }
}
_class$1 = ResizeMirror;
[_initProto$1] = _applyDecs2305(_class$1, [[AutoBind, 2, "onMirrorCreated"], [AutoBind, 2, "onMirrorDestroy"], [AutoBind, 2, "onDragOver"]], [], 0, void 0, AbstractPlugin).e;
class SnapEvent extends AbstractEvent {
  get dragEvent() {
    return this.data.dragEvent;
  }
  get snappable() {
    return this.data.snappable;
  }
}
SnapEvent.type = "snap";
class SnapInEvent extends SnapEvent {
}
SnapInEvent.type = "snap:in";
SnapInEvent.cancelable = !0;
class SnapOutEvent extends SnapEvent {
}
SnapOutEvent.type = "snap:out";
SnapOutEvent.cancelable = !0;
var _initProto, _class;
const defaultOptions$5 = {
  duration: 150,
  easingFunction: "ease-in-out",
  horizontal: !1
};
class SwapAnimation extends AbstractPlugin {
  constructor(t) {
    _initProto(super(t)), this.options = {
      ...defaultOptions$5,
      ...this.getOptions()
    }, this.lastAnimationFrame = null;
  }
  attach() {
    this.draggable.on("sortable:sorted", this.onSortableSorted);
  }
  detach() {
    this.draggable.off("sortable:sorted", this.onSortableSorted);
  }
  getOptions() {
    return this.draggable.options.swapAnimation || {};
  }
  onSortableSorted({
    oldIndex: t,
    newIndex: n,
    dragEvent: a
  }) {
    const {
      source: o,
      over: s
    } = a;
    this.lastAnimationFrame && cancelAnimationFrame(this.lastAnimationFrame), this.lastAnimationFrame = requestAnimationFrame(() => {
      t >= n ? animate$1(o, s, this.options) : animate$1(s, o, this.options);
    });
  }
}
_class = SwapAnimation;
[_initProto] = _applyDecs2305(_class, [[AutoBind, 2, "onSortableSorted"]], [], 0, void 0, AbstractPlugin).e;
function animate$1(e, t, {
  duration: n,
  easingFunction: a,
  horizontal: o
}) {
  for (const s of [e, t])
    s.style.pointerEvents = "none";
  if (o) {
    const s = e.offsetWidth;
    e.style.transform = `translate3d(${s}px, 0, 0)`, t.style.transform = `translate3d(-${s}px, 0, 0)`;
  } else {
    const s = e.offsetHeight;
    e.style.transform = `translate3d(0, ${s}px, 0)`, t.style.transform = `translate3d(0, -${s}px, 0)`;
  }
  requestAnimationFrame(() => {
    for (const s of [e, t])
      s.addEventListener("transitionend", resetElementOnTransitionEnd), s.style.transition = `transform ${n}ms ${a}`, s.style.transform = "";
  });
}
function resetElementOnTransitionEnd(e) {
  e.target == null || !isHTMLElement$2(e.target) || (e.target.style.transition = "", e.target.style.pointerEvents = "", e.target.removeEventListener("transitionend", resetElementOnTransitionEnd));
}
function isHTMLElement$2(e) {
  return "style" in e;
}
const onInitialize$1 = Symbol("onInitialize"), onDestroy$1 = Symbol("onDestroy"), announceEvent = Symbol("announceEvent"), announceMessage = Symbol("announceMessage"), ARIA_RELEVANT = "aria-relevant", ARIA_ATOMIC = "aria-atomic", ARIA_LIVE = "aria-live", ROLE = "role", defaultOptions$4 = {
  expire: 7e3
};
class Announcement extends AbstractPlugin {
  constructor(t) {
    super(t), this.options = {
      ...defaultOptions$4,
      ...this.getOptions()
    }, this.originalTriggerMethod = this.draggable.trigger, this[onInitialize$1] = this[onInitialize$1].bind(this), this[onDestroy$1] = this[onDestroy$1].bind(this);
  }
  attach() {
    this.draggable.on("draggable:initialize", this[onInitialize$1]);
  }
  detach() {
    this.draggable.off("draggable:destroy", this[onDestroy$1]);
  }
  getOptions() {
    return this.draggable.options.announcements || {};
  }
  [announceEvent](t) {
    const n = this.options[t.type];
    n && typeof n == "string" && this[announceMessage](n), n && typeof n == "function" && this[announceMessage](n(t));
  }
  [announceMessage](t) {
    announce(t, {
      expire: this.options.expire
    });
  }
  [onInitialize$1]() {
    this.draggable.trigger = (t) => {
      try {
        this[announceEvent](t);
      } finally {
        this.originalTriggerMethod.call(this.draggable, t);
      }
    };
  }
  [onDestroy$1]() {
    this.draggable.trigger = this.originalTriggerMethod;
  }
}
const liveRegion = createRegion();
function announce(e, {
  expire: t
}) {
  const n = document.createElement("div");
  return n.textContent = e, liveRegion.appendChild(n), setTimeout(() => {
    liveRegion.removeChild(n);
  }, t);
}
function createRegion() {
  const e = document.createElement("div");
  return e.setAttribute("id", "draggable-live-region"), e.setAttribute(ARIA_RELEVANT, "additions"), e.setAttribute(ARIA_ATOMIC, "true"), e.setAttribute(ARIA_LIVE, "assertive"), e.setAttribute(ROLE, "log"), e.style.position = "fixed", e.style.width = "1px", e.style.height = "1px", e.style.top = "-1px", e.style.overflow = "hidden", e;
}
document.addEventListener("DOMContentLoaded", () => {
  document.body.appendChild(liveRegion);
});
const onInitialize = Symbol("onInitialize"), onDestroy = Symbol("onDestroy"), defaultOptions$3 = {};
class Focusable extends AbstractPlugin {
  constructor(t) {
    super(t), this.options = {
      ...defaultOptions$3,
      ...this.getOptions()
    }, this[onInitialize] = this[onInitialize].bind(this), this[onDestroy] = this[onDestroy].bind(this);
  }
  attach() {
    this.draggable.on("draggable:initialize", this[onInitialize]).on("draggable:destroy", this[onDestroy]);
  }
  detach() {
    this.draggable.off("draggable:initialize", this[onInitialize]).off("draggable:destroy", this[onDestroy]), this[onDestroy]();
  }
  getOptions() {
    return this.draggable.options.focusable || {};
  }
  getElements() {
    return [...this.draggable.containers, ...this.draggable.getDraggableElements()];
  }
  [onInitialize]() {
    requestAnimationFrame(() => {
      this.getElements().forEach((t) => decorateElement(t));
    });
  }
  [onDestroy]() {
    requestAnimationFrame(() => {
      this.getElements().forEach((t) => stripElement(t));
    });
  }
}
const elementsWithMissingTabIndex = [];
function decorateElement(e) {
  !e.getAttribute("tabindex") && e.tabIndex === -1 && (elementsWithMissingTabIndex.push(e), e.tabIndex = 0);
}
function stripElement(e) {
  const t = elementsWithMissingTabIndex.indexOf(e);
  t !== -1 && (e.tabIndex = -1, elementsWithMissingTabIndex.splice(t, 1));
}
class MirrorEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get source() {
    return this.data.source;
  }
  get originalSource() {
    return this.data.originalSource;
  }
  get sourceContainer() {
    return this.data.sourceContainer;
  }
  get sensorEvent() {
    return this.data.sensorEvent;
  }
  get dragEvent() {
    return this.data.dragEvent;
  }
  get originalEvent() {
    return this.sensorEvent ? this.sensorEvent.originalEvent : null;
  }
}
class MirrorCreateEvent extends MirrorEvent {
}
MirrorCreateEvent.type = "mirror:create";
class MirrorCreatedEvent extends MirrorEvent {
  get mirror() {
    return this.data.mirror;
  }
}
MirrorCreatedEvent.type = "mirror:created";
class MirrorAttachedEvent extends MirrorEvent {
  get mirror() {
    return this.data.mirror;
  }
}
MirrorAttachedEvent.type = "mirror:attached";
class MirrorMoveEvent extends MirrorEvent {
  get mirror() {
    return this.data.mirror;
  }
  get passedThreshX() {
    return this.data.passedThreshX;
  }
  get passedThreshY() {
    return this.data.passedThreshY;
  }
}
MirrorMoveEvent.type = "mirror:move";
MirrorMoveEvent.cancelable = !0;
class MirrorMovedEvent extends MirrorEvent {
  get mirror() {
    return this.data.mirror;
  }
  get passedThreshX() {
    return this.data.passedThreshX;
  }
  get passedThreshY() {
    return this.data.passedThreshY;
  }
}
MirrorMovedEvent.type = "mirror:moved";
class MirrorDestroyEvent extends MirrorEvent {
  get mirror() {
    return this.data.mirror;
  }
}
MirrorDestroyEvent.type = "mirror:destroy";
MirrorDestroyEvent.cancelable = !0;
const onDragStart$3 = Symbol("onDragStart"), onDragMove$2 = Symbol("onDragMove"), onDragStop$3 = Symbol("onDragStop"), onMirrorCreated = Symbol("onMirrorCreated"), onMirrorMove = Symbol("onMirrorMove"), onScroll = Symbol("onScroll"), getAppendableContainer = Symbol("getAppendableContainer"), defaultOptions$2 = {
  constrainDimensions: !1,
  xAxis: !0,
  yAxis: !0,
  cursorOffsetX: null,
  cursorOffsetY: null,
  thresholdX: null,
  thresholdY: null
};
class Mirror extends AbstractPlugin {
  constructor(t) {
    super(t), this.options = {
      ...defaultOptions$2,
      ...this.getOptions()
    }, this.scrollOffset = {
      x: 0,
      y: 0
    }, this.initialScrollOffset = {
      x: window.scrollX,
      y: window.scrollY
    }, this[onDragStart$3] = this[onDragStart$3].bind(this), this[onDragMove$2] = this[onDragMove$2].bind(this), this[onDragStop$3] = this[onDragStop$3].bind(this), this[onMirrorCreated] = this[onMirrorCreated].bind(this), this[onMirrorMove] = this[onMirrorMove].bind(this), this[onScroll] = this[onScroll].bind(this);
  }
  attach() {
    this.draggable.on("drag:start", this[onDragStart$3]).on("drag:move", this[onDragMove$2]).on("drag:stop", this[onDragStop$3]).on("mirror:created", this[onMirrorCreated]).on("mirror:move", this[onMirrorMove]);
  }
  detach() {
    this.draggable.off("drag:start", this[onDragStart$3]).off("drag:move", this[onDragMove$2]).off("drag:stop", this[onDragStop$3]).off("mirror:created", this[onMirrorCreated]).off("mirror:move", this[onMirrorMove]);
  }
  getOptions() {
    return this.draggable.options.mirror || {};
  }
  [onDragStart$3](t) {
    if (t.canceled())
      return;
    "ontouchstart" in window && document.addEventListener("scroll", this[onScroll], !0), this.initialScrollOffset = {
      x: window.scrollX,
      y: window.scrollY
    };
    const {
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s
    } = t;
    this.lastMirrorMovedClient = {
      x: s.clientX,
      y: s.clientY
    };
    const u = new MirrorCreateEvent({
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s,
      dragEvent: t
    });
    if (this.draggable.trigger(u), isNativeDragEvent(s) || u.canceled())
      return;
    const d = this[getAppendableContainer](n) || o;
    this.mirror = n.cloneNode(!0);
    const f = new MirrorCreatedEvent({
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s,
      dragEvent: t,
      mirror: this.mirror
    }), g = new MirrorAttachedEvent({
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s,
      dragEvent: t,
      mirror: this.mirror
    });
    this.draggable.trigger(f), d.appendChild(this.mirror), this.draggable.trigger(g);
  }
  [onDragMove$2](t) {
    if (!this.mirror || t.canceled())
      return;
    const {
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s
    } = t;
    let u = !0, d = !0;
    if (this.options.thresholdX || this.options.thresholdY) {
      const {
        x: g,
        y: v
      } = this.lastMirrorMovedClient;
      if (Math.abs(g - s.clientX) < this.options.thresholdX ? u = !1 : this.lastMirrorMovedClient.x = s.clientX, Math.abs(v - s.clientY) < this.options.thresholdY ? d = !1 : this.lastMirrorMovedClient.y = s.clientY, !u && !d)
        return;
    }
    const f = new MirrorMoveEvent({
      source: n,
      originalSource: a,
      sourceContainer: o,
      sensorEvent: s,
      dragEvent: t,
      mirror: this.mirror,
      passedThreshX: u,
      passedThreshY: d
    });
    this.draggable.trigger(f);
  }
  [onDragStop$3](t) {
    if ("ontouchstart" in window && document.removeEventListener("scroll", this[onScroll], !0), this.initialScrollOffset = {
      x: 0,
      y: 0
    }, this.scrollOffset = {
      x: 0,
      y: 0
    }, !this.mirror)
      return;
    const {
      source: n,
      sourceContainer: a,
      sensorEvent: o
    } = t, s = new MirrorDestroyEvent({
      source: n,
      mirror: this.mirror,
      sourceContainer: a,
      sensorEvent: o,
      dragEvent: t
    });
    this.draggable.trigger(s), s.canceled() || this.mirror.remove();
  }
  [onScroll]() {
    this.scrollOffset = {
      x: window.scrollX - this.initialScrollOffset.x,
      y: window.scrollY - this.initialScrollOffset.y
    };
  }
  [onMirrorCreated]({
    mirror: t,
    source: n,
    sensorEvent: a
  }) {
    const o = this.draggable.getClassNamesFor("mirror"), s = ({
      mirrorOffset: d,
      initialX: f,
      initialY: g,
      ...v
    }) => (this.mirrorOffset = d, this.initialX = f, this.initialY = g, this.lastMovedX = f, this.lastMovedY = g, {
      mirrorOffset: d,
      initialX: f,
      initialY: g,
      ...v
    });
    t.style.display = "none";
    const u = {
      mirror: t,
      source: n,
      sensorEvent: a,
      mirrorClasses: o,
      scrollOffset: this.scrollOffset,
      options: this.options,
      passedThreshX: !0,
      passedThreshY: !0
    };
    return Promise.resolve(u).then(computeMirrorDimensions).then(calculateMirrorOffset).then(resetMirror).then(addMirrorClasses).then(positionMirror({
      initial: !0
    })).then(removeMirrorID).then(s);
  }
  [onMirrorMove](t) {
    if (t.canceled())
      return null;
    const n = ({
      lastMovedX: s,
      lastMovedY: u,
      ...d
    }) => (this.lastMovedX = s, this.lastMovedY = u, {
      lastMovedX: s,
      lastMovedY: u,
      ...d
    }), a = (s) => {
      const u = new MirrorMovedEvent({
        source: t.source,
        originalSource: t.originalSource,
        sourceContainer: t.sourceContainer,
        sensorEvent: t.sensorEvent,
        dragEvent: t.dragEvent,
        mirror: this.mirror,
        passedThreshX: t.passedThreshX,
        passedThreshY: t.passedThreshY
      });
      return this.draggable.trigger(u), s;
    }, o = {
      mirror: t.mirror,
      sensorEvent: t.sensorEvent,
      mirrorOffset: this.mirrorOffset,
      options: this.options,
      initialX: this.initialX,
      initialY: this.initialY,
      scrollOffset: this.scrollOffset,
      passedThreshX: t.passedThreshX,
      passedThreshY: t.passedThreshY,
      lastMovedX: this.lastMovedX,
      lastMovedY: this.lastMovedY
    };
    return Promise.resolve(o).then(positionMirror({})).then(n).then(a);
  }
  [getAppendableContainer](t) {
    const n = this.options.appendTo;
    return typeof n == "string" ? document.querySelector(n) : n instanceof HTMLElement ? n : typeof n == "function" ? n(t) : t.parentNode;
  }
}
function computeMirrorDimensions({
  source: e,
  ...t
}) {
  return withPromise((n) => {
    const a = e.getBoundingClientRect();
    n({
      source: e,
      sourceRect: a,
      ...t
    });
  });
}
function calculateMirrorOffset({
  sensorEvent: e,
  sourceRect: t,
  options: n,
  ...a
}) {
  return withPromise((o) => {
    const s = n.cursorOffsetY === null ? e.clientY - t.top : n.cursorOffsetY, u = n.cursorOffsetX === null ? e.clientX - t.left : n.cursorOffsetX;
    o({
      sensorEvent: e,
      sourceRect: t,
      mirrorOffset: {
        top: s,
        left: u
      },
      options: n,
      ...a
    });
  });
}
function resetMirror({
  mirror: e,
  source: t,
  options: n,
  ...a
}) {
  return withPromise((o) => {
    let s, u;
    if (n.constrainDimensions) {
      const d = getComputedStyle(t);
      s = d.getPropertyValue("height"), u = d.getPropertyValue("width");
    }
    e.style.display = null, e.style.position = "fixed", e.style.pointerEvents = "none", e.style.top = 0, e.style.left = 0, e.style.margin = 0, n.constrainDimensions && (e.style.height = s, e.style.width = u), o({
      mirror: e,
      source: t,
      options: n,
      ...a
    });
  });
}
function addMirrorClasses({
  mirror: e,
  mirrorClasses: t,
  ...n
}) {
  return withPromise((a) => {
    e.classList.add(...t), a({
      mirror: e,
      mirrorClasses: t,
      ...n
    });
  });
}
function removeMirrorID({
  mirror: e,
  ...t
}) {
  return withPromise((n) => {
    e.removeAttribute("id"), delete e.id, n({
      mirror: e,
      ...t
    });
  });
}
function positionMirror({
  withFrame: e = !1,
  initial: t = !1
} = {}) {
  return ({
    mirror: n,
    sensorEvent: a,
    mirrorOffset: o,
    initialY: s,
    initialX: u,
    scrollOffset: d,
    options: f,
    passedThreshX: g,
    passedThreshY: v,
    lastMovedX: b,
    lastMovedY: w,
    ...C
  }) => withPromise((k) => {
    const E = {
      mirror: n,
      sensorEvent: a,
      mirrorOffset: o,
      options: f,
      ...C
    };
    if (o) {
      const A = g ? Math.round((a.clientX - o.left - d.x) / (f.thresholdX || 1)) * (f.thresholdX || 1) : Math.round(b), P = v ? Math.round((a.clientY - o.top - d.y) / (f.thresholdY || 1)) * (f.thresholdY || 1) : Math.round(w);
      f.xAxis && f.yAxis || t ? n.style.transform = `translate3d(${A}px, ${P}px, 0)` : f.xAxis && !f.yAxis ? n.style.transform = `translate3d(${A}px, ${s}px, 0)` : f.yAxis && !f.xAxis && (n.style.transform = `translate3d(${u}px, ${P}px, 0)`), t && (E.initialX = A, E.initialY = P), E.lastMovedX = A, E.lastMovedY = P;
    }
    k(E);
  }, {});
}
function withPromise(e, {
  raf: t = !1
} = {}) {
  return new Promise((n, a) => {
    t ? requestAnimationFrame(() => {
      e(n, a);
    }) : e(n, a);
  });
}
function isNativeDragEvent(e) {
  return /^drag/.test(e.originalEvent.type);
}
const onDragStart$2 = Symbol("onDragStart"), onDragMove$1 = Symbol("onDragMove"), onDragStop$2 = Symbol("onDragStop"), scroll = Symbol("scroll"), defaultOptions$1 = {
  speed: 6,
  sensitivity: 50,
  scrollableElements: []
};
class Scrollable extends AbstractPlugin {
  constructor(t) {
    super(t), this.options = {
      ...defaultOptions$1,
      ...this.getOptions()
    }, this.currentMousePosition = null, this.scrollAnimationFrame = null, this.scrollableElement = null, this.findScrollableElementFrame = null, this[onDragStart$2] = this[onDragStart$2].bind(this), this[onDragMove$1] = this[onDragMove$1].bind(this), this[onDragStop$2] = this[onDragStop$2].bind(this), this[scroll] = this[scroll].bind(this);
  }
  attach() {
    this.draggable.on("drag:start", this[onDragStart$2]).on("drag:move", this[onDragMove$1]).on("drag:stop", this[onDragStop$2]);
  }
  detach() {
    this.draggable.off("drag:start", this[onDragStart$2]).off("drag:move", this[onDragMove$1]).off("drag:stop", this[onDragStop$2]);
  }
  getOptions() {
    return this.draggable.options.scrollable || {};
  }
  getScrollableElement(t) {
    return this.hasDefinedScrollableElements() ? closest(t, this.options.scrollableElements) || document.documentElement : closestScrollableElement(t);
  }
  hasDefinedScrollableElements() {
    return this.options.scrollableElements.length !== 0;
  }
  [onDragStart$2](t) {
    this.findScrollableElementFrame = requestAnimationFrame(() => {
      this.scrollableElement = this.getScrollableElement(t.source);
    });
  }
  [onDragMove$1](t) {
    if (this.findScrollableElementFrame = requestAnimationFrame(() => {
      this.scrollableElement = this.getScrollableElement(t.sensorEvent.target);
    }), !this.scrollableElement)
      return;
    const n = t.sensorEvent, a = {
      x: 0,
      y: 0
    };
    "ontouchstart" in window && (a.y = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, a.x = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0), this.currentMousePosition = {
      clientX: n.clientX - a.x,
      clientY: n.clientY - a.y
    }, this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
  }
  [onDragStop$2]() {
    cancelAnimationFrame(this.scrollAnimationFrame), cancelAnimationFrame(this.findScrollableElementFrame), this.scrollableElement = null, this.scrollAnimationFrame = null, this.findScrollableElementFrame = null, this.currentMousePosition = null;
  }
  [scroll]() {
    if (!this.scrollableElement || !this.currentMousePosition)
      return;
    cancelAnimationFrame(this.scrollAnimationFrame);
    const {
      speed: t,
      sensitivity: n
    } = this.options, a = this.scrollableElement.getBoundingClientRect(), o = a.bottom > window.innerHeight, u = a.top < 0 || o, d = getDocumentScrollingElement(), f = this.scrollableElement, g = this.currentMousePosition.clientX, v = this.currentMousePosition.clientY;
    if (f !== document.body && f !== document.documentElement && !u) {
      const {
        offsetHeight: b,
        offsetWidth: w
      } = f;
      a.top + b - v < n ? f.scrollTop += t : v - a.top < n && (f.scrollTop -= t), a.left + w - g < n ? f.scrollLeft += t : g - a.left < n && (f.scrollLeft -= t);
    } else {
      const {
        innerHeight: b,
        innerWidth: w
      } = window;
      v < n ? d.scrollTop -= t : b - v < n && (d.scrollTop += t), g < n ? d.scrollLeft -= t : w - g < n && (d.scrollLeft += t);
    }
    this.scrollAnimationFrame = requestAnimationFrame(this[scroll]);
  }
}
function hasOverflow(e) {
  const t = /(auto|scroll)/, n = getComputedStyle(e, null), a = n.getPropertyValue("overflow") + n.getPropertyValue("overflow-y") + n.getPropertyValue("overflow-x");
  return t.test(a);
}
function isStaticallyPositioned(e) {
  return getComputedStyle(e).getPropertyValue("position") === "static";
}
function closestScrollableElement(e) {
  if (!e)
    return getDocumentScrollingElement();
  const t = getComputedStyle(e).getPropertyValue("position"), n = t === "absolute", a = closest(e, (o) => n && isStaticallyPositioned(o) ? !1 : hasOverflow(o));
  return t === "fixed" || !a ? getDocumentScrollingElement() : a;
}
function getDocumentScrollingElement() {
  return document.scrollingElement || document.documentElement;
}
class Emitter {
  constructor() {
    this.callbacks = {};
  }
  on(t, ...n) {
    return this.callbacks[t] || (this.callbacks[t] = []), this.callbacks[t].push(...n), this;
  }
  off(t, n) {
    if (!this.callbacks[t])
      return null;
    const a = this.callbacks[t].slice(0);
    for (let o = 0; o < a.length; o++)
      n === a[o] && this.callbacks[t].splice(o, 1);
    return this;
  }
  trigger(t) {
    if (!this.callbacks[t.type])
      return null;
    const n = [...this.callbacks[t.type]], a = [];
    for (let o = n.length - 1; o >= 0; o--) {
      const s = n[o];
      try {
        s(t);
      } catch (u) {
        a.push(u);
      }
    }
    return a.length && console.error(`Draggable caught errors while triggering '${t.type}'`, a), this;
  }
}
class DraggableEvent extends AbstractEvent {
  get draggable() {
    return this.data.draggable;
  }
}
DraggableEvent.type = "draggable";
class DraggableInitializedEvent extends DraggableEvent {
}
DraggableInitializedEvent.type = "draggable:initialize";
class DraggableDestroyEvent extends DraggableEvent {
}
DraggableDestroyEvent.type = "draggable:destroy";
const onDragStart$1 = Symbol("onDragStart"), onDragMove = Symbol("onDragMove"), onDragStop$1 = Symbol("onDragStop"), onDragPressure = Symbol("onDragPressure"), dragStop = Symbol("dragStop"), defaultAnnouncements$1 = {
  "drag:start": (e) => `Picked up ${e.source.textContent.trim() || e.source.id || "draggable element"}`,
  "drag:stop": (e) => `Released ${e.source.textContent.trim() || e.source.id || "draggable element"}`
}, defaultClasses = {
  "container:dragging": "draggable-container--is-dragging",
  "source:dragging": "draggable-source--is-dragging",
  "source:placed": "draggable-source--placed",
  "container:placed": "draggable-container--placed",
  "body:dragging": "draggable--is-dragging",
  "draggable:over": "draggable--over",
  "container:over": "draggable-container--over",
  "source:original": "draggable--original",
  mirror: "draggable-mirror"
}, defaultOptions = {
  draggable: ".draggable-source",
  handle: null,
  delay: {},
  distance: 0,
  placedTimeout: 800,
  plugins: [],
  sensors: [],
  exclude: {
    plugins: [],
    sensors: []
  }
};
class Draggable {
  constructor(t = [document.body], n = {}) {
    if (t instanceof NodeList || t instanceof Array)
      this.containers = [...t];
    else if (t instanceof HTMLElement)
      this.containers = [t];
    else
      throw new Error("Draggable containers are expected to be of type `NodeList`, `HTMLElement[]` or `HTMLElement`");
    this.options = {
      ...defaultOptions,
      ...n,
      classes: {
        ...defaultClasses,
        ...n.classes || {}
      },
      announcements: {
        ...defaultAnnouncements$1,
        ...n.announcements || {}
      },
      exclude: {
        plugins: n.exclude && n.exclude.plugins || [],
        sensors: n.exclude && n.exclude.sensors || []
      }
    }, this.emitter = new Emitter(), this.dragging = !1, this.plugins = [], this.sensors = [], this[onDragStart$1] = this[onDragStart$1].bind(this), this[onDragMove] = this[onDragMove].bind(this), this[onDragStop$1] = this[onDragStop$1].bind(this), this[onDragPressure] = this[onDragPressure].bind(this), this[dragStop] = this[dragStop].bind(this), document.addEventListener("drag:start", this[onDragStart$1], !0), document.addEventListener("drag:move", this[onDragMove], !0), document.addEventListener("drag:stop", this[onDragStop$1], !0), document.addEventListener("drag:pressure", this[onDragPressure], !0);
    const a = Object.values(Draggable.Plugins).filter((u) => !this.options.exclude.plugins.includes(u)), o = Object.values(Draggable.Sensors).filter((u) => !this.options.exclude.sensors.includes(u));
    this.addPlugin(...a, ...this.options.plugins), this.addSensor(...o, ...this.options.sensors);
    const s = new DraggableInitializedEvent({
      draggable: this
    });
    this.on("mirror:created", ({
      mirror: u
    }) => this.mirror = u), this.on("mirror:destroy", () => this.mirror = null), this.trigger(s);
  }
  destroy() {
    document.removeEventListener("drag:start", this[onDragStart$1], !0), document.removeEventListener("drag:move", this[onDragMove], !0), document.removeEventListener("drag:stop", this[onDragStop$1], !0), document.removeEventListener("drag:pressure", this[onDragPressure], !0);
    const t = new DraggableDestroyEvent({
      draggable: this
    });
    this.trigger(t), this.removePlugin(...this.plugins.map((n) => n.constructor)), this.removeSensor(...this.sensors.map((n) => n.constructor));
  }
  addPlugin(...t) {
    const n = t.map((a) => new a(this));
    return n.forEach((a) => a.attach()), this.plugins = [...this.plugins, ...n], this;
  }
  removePlugin(...t) {
    return this.plugins.filter((a) => t.includes(a.constructor)).forEach((a) => a.detach()), this.plugins = this.plugins.filter((a) => !t.includes(a.constructor)), this;
  }
  addSensor(...t) {
    const n = t.map((a) => new a(this.containers, this.options));
    return n.forEach((a) => a.attach()), this.sensors = [...this.sensors, ...n], this;
  }
  removeSensor(...t) {
    return this.sensors.filter((a) => t.includes(a.constructor)).forEach((a) => a.detach()), this.sensors = this.sensors.filter((a) => !t.includes(a.constructor)), this;
  }
  addContainer(...t) {
    return this.containers = [...this.containers, ...t], this.sensors.forEach((n) => n.addContainer(...t)), this;
  }
  removeContainer(...t) {
    return this.containers = this.containers.filter((n) => !t.includes(n)), this.sensors.forEach((n) => n.removeContainer(...t)), this;
  }
  on(t, ...n) {
    return this.emitter.on(t, ...n), this;
  }
  off(t, n) {
    return this.emitter.off(t, n), this;
  }
  trigger(t) {
    return this.emitter.trigger(t), this;
  }
  getClassNameFor(t) {
    return this.getClassNamesFor(t)[0];
  }
  getClassNamesFor(t) {
    const n = this.options.classes[t];
    return n instanceof Array ? n : typeof n == "string" || n instanceof String ? [n] : [];
  }
  isDragging() {
    return !!this.dragging;
  }
  getDraggableElements() {
    return this.containers.reduce((t, n) => [...t, ...this.getDraggableElementsForContainer(n)], []);
  }
  getDraggableElementsForContainer(t) {
    return [...t.querySelectorAll(this.options.draggable)].filter((a) => a !== this.originalSource && a !== this.mirror);
  }
  cancel() {
    this[dragStop]();
  }
  [onDragStart$1](t) {
    const n = getSensorEvent(t), {
      target: a,
      container: o,
      originalSource: s
    } = n;
    if (!this.containers.includes(o))
      return;
    if (this.options.handle && a && !closest(a, this.options.handle)) {
      n.cancel();
      return;
    }
    this.originalSource = s, this.sourceContainer = o, this.lastPlacedSource && this.lastPlacedContainer && (clearTimeout(this.placedTimeoutID), this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed")), this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed"))), this.source = this.originalSource.cloneNode(!0), this.originalSource.parentNode.insertBefore(this.source, this.originalSource), this.originalSource.style.display = "none";
    const u = new DragStartEvent({
      source: this.source,
      originalSource: this.originalSource,
      sourceContainer: o,
      sensorEvent: n
    });
    if (this.trigger(u), this.dragging = !u.canceled(), u.canceled()) {
      this.source.remove(), this.originalSource.style.display = null;
      return;
    }
    this.originalSource.classList.add(...this.getClassNamesFor("source:original")), this.source.classList.add(...this.getClassNamesFor("source:dragging")), this.sourceContainer.classList.add(...this.getClassNamesFor("container:dragging")), document.body.classList.add(...this.getClassNamesFor("body:dragging")), applyUserSelect(document.body, "none"), requestAnimationFrame(() => {
      const f = getSensorEvent(t).clone({
        target: this.source
      });
      this[onDragMove]({
        ...t,
        detail: f
      });
    });
  }
  [onDragMove](t) {
    if (!this.dragging)
      return;
    const n = getSensorEvent(t), {
      container: a
    } = n;
    let o = n.target;
    const s = new DragMoveEvent({
      source: this.source,
      originalSource: this.originalSource,
      sourceContainer: a,
      sensorEvent: n
    });
    this.trigger(s), s.canceled() && n.cancel(), o = closest(o, this.options.draggable);
    const u = closest(n.target, this.containers), d = n.overContainer || u, f = this.currentOverContainer && d !== this.currentOverContainer, g = this.currentOver && o !== this.currentOver, v = d && this.currentOverContainer !== d, b = u && o && this.currentOver !== o;
    if (g) {
      const w = new DragOutEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: a,
        sensorEvent: n,
        over: this.currentOver,
        overContainer: this.currentOverContainer
      });
      this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over")), this.currentOver = null, this.trigger(w);
    }
    if (f) {
      const w = new DragOutContainerEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: a,
        sensorEvent: n,
        overContainer: this.currentOverContainer
      });
      this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over")), this.currentOverContainer = null, this.trigger(w);
    }
    if (v) {
      d.classList.add(...this.getClassNamesFor("container:over"));
      const w = new DragOverContainerEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: a,
        sensorEvent: n,
        overContainer: d
      });
      this.currentOverContainer = d, this.trigger(w);
    }
    if (b) {
      o.classList.add(...this.getClassNamesFor("draggable:over"));
      const w = new DragOverEvent({
        source: this.source,
        originalSource: this.originalSource,
        sourceContainer: a,
        sensorEvent: n,
        overContainer: d,
        over: o
      });
      this.currentOver = o, this.trigger(w);
    }
  }
  [dragStop](t) {
    if (!this.dragging)
      return;
    this.dragging = !1;
    const n = new DragStopEvent({
      source: this.source,
      originalSource: this.originalSource,
      sensorEvent: t ? t.sensorEvent : null,
      sourceContainer: this.sourceContainer
    });
    this.trigger(n), n.canceled() || this.source.parentNode.insertBefore(this.originalSource, this.source), this.source.remove(), this.originalSource.style.display = "", this.source.classList.remove(...this.getClassNamesFor("source:dragging")), this.originalSource.classList.remove(...this.getClassNamesFor("source:original")), this.originalSource.classList.add(...this.getClassNamesFor("source:placed")), this.sourceContainer.classList.add(...this.getClassNamesFor("container:placed")), this.sourceContainer.classList.remove(...this.getClassNamesFor("container:dragging")), document.body.classList.remove(...this.getClassNamesFor("body:dragging")), applyUserSelect(document.body, ""), this.currentOver && this.currentOver.classList.remove(...this.getClassNamesFor("draggable:over")), this.currentOverContainer && this.currentOverContainer.classList.remove(...this.getClassNamesFor("container:over")), this.lastPlacedSource = this.originalSource, this.lastPlacedContainer = this.sourceContainer, this.placedTimeoutID = setTimeout(() => {
      this.lastPlacedSource && this.lastPlacedSource.classList.remove(...this.getClassNamesFor("source:placed")), this.lastPlacedContainer && this.lastPlacedContainer.classList.remove(...this.getClassNamesFor("container:placed")), this.lastPlacedSource = null, this.lastPlacedContainer = null;
    }, this.options.placedTimeout);
    const a = new DragStoppedEvent({
      source: this.source,
      originalSource: this.originalSource,
      sensorEvent: t ? t.sensorEvent : null,
      sourceContainer: this.sourceContainer
    });
    this.trigger(a), this.source = null, this.originalSource = null, this.currentOverContainer = null, this.currentOver = null, this.sourceContainer = null;
  }
  [onDragStop$1](t) {
    this[dragStop](t);
  }
  [onDragPressure](t) {
    if (!this.dragging)
      return;
    const n = getSensorEvent(t), a = this.source || closest(n.originalEvent.target, this.options.draggable), o = new DragPressureEvent({
      sensorEvent: n,
      source: a,
      pressure: n.pressure
    });
    this.trigger(o);
  }
}
Draggable.Plugins = {
  Announcement,
  Focusable,
  Mirror,
  Scrollable
};
Draggable.Sensors = {
  MouseSensor,
  TouchSensor
};
function getSensorEvent(e) {
  return e.detail;
}
function applyUserSelect(e, t) {
  e.style.webkitUserSelect = t, e.style.mozUserSelect = t, e.style.msUserSelect = t, e.style.oUserSelect = t, e.style.userSelect = t;
}
class DroppableEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get dragEvent() {
    return this.data.dragEvent;
  }
}
DroppableEvent.type = "droppable";
class DroppableStartEvent extends DroppableEvent {
  get dropzone() {
    return this.data.dropzone;
  }
}
DroppableStartEvent.type = "droppable:start";
DroppableStartEvent.cancelable = !0;
class DroppableDroppedEvent extends DroppableEvent {
  get dropzone() {
    return this.data.dropzone;
  }
}
DroppableDroppedEvent.type = "droppable:dropped";
DroppableDroppedEvent.cancelable = !0;
class DroppableReturnedEvent extends DroppableEvent {
  get dropzone() {
    return this.data.dropzone;
  }
}
DroppableReturnedEvent.type = "droppable:returned";
DroppableReturnedEvent.cancelable = !0;
class DroppableStopEvent extends DroppableEvent {
  get dropzone() {
    return this.data.dropzone;
  }
}
DroppableStopEvent.type = "droppable:stop";
DroppableStopEvent.cancelable = !0;
class SwappableEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get dragEvent() {
    return this.data.dragEvent;
  }
}
SwappableEvent.type = "swappable";
class SwappableStartEvent extends SwappableEvent {
}
SwappableStartEvent.type = "swappable:start";
SwappableStartEvent.cancelable = !0;
class SwappableSwapEvent extends SwappableEvent {
  get over() {
    return this.data.over;
  }
  get overContainer() {
    return this.data.overContainer;
  }
}
SwappableSwapEvent.type = "swappable:swap";
SwappableSwapEvent.cancelable = !0;
class SwappableSwappedEvent extends SwappableEvent {
  get swappedElement() {
    return this.data.swappedElement;
  }
}
SwappableSwappedEvent.type = "swappable:swapped";
class SwappableStopEvent extends SwappableEvent {
}
SwappableStopEvent.type = "swappable:stop";
class SortableEvent extends AbstractEvent {
  constructor(t) {
    super(t), this.data = t;
  }
  get dragEvent() {
    return this.data.dragEvent;
  }
}
SortableEvent.type = "sortable";
class SortableStartEvent extends SortableEvent {
  get startIndex() {
    return this.data.startIndex;
  }
  get startContainer() {
    return this.data.startContainer;
  }
}
SortableStartEvent.type = "sortable:start";
SortableStartEvent.cancelable = !0;
class SortableSortEvent extends SortableEvent {
  get currentIndex() {
    return this.data.currentIndex;
  }
  get over() {
    return this.data.over;
  }
  get overContainer() {
    return this.data.dragEvent.overContainer;
  }
}
SortableSortEvent.type = "sortable:sort";
SortableSortEvent.cancelable = !0;
class SortableSortedEvent extends SortableEvent {
  get oldIndex() {
    return this.data.oldIndex;
  }
  get newIndex() {
    return this.data.newIndex;
  }
  get oldContainer() {
    return this.data.oldContainer;
  }
  get newContainer() {
    return this.data.newContainer;
  }
}
SortableSortedEvent.type = "sortable:sorted";
class SortableStopEvent extends SortableEvent {
  get oldIndex() {
    return this.data.oldIndex;
  }
  get newIndex() {
    return this.data.newIndex;
  }
  get oldContainer() {
    return this.data.oldContainer;
  }
  get newContainer() {
    return this.data.newContainer;
  }
}
SortableStopEvent.type = "sortable:stop";
const onDragStart = Symbol("onDragStart"), onDragOverContainer = Symbol("onDragOverContainer"), onDragOver = Symbol("onDragOver"), onDragStop = Symbol("onDragStop");
function onSortableSortedDefaultAnnouncement({
  dragEvent: e
}) {
  const t = e.source.textContent.trim() || e.source.id || "sortable element";
  if (e.over) {
    const n = e.over.textContent.trim() || e.over.id || "sortable element";
    return e.source.compareDocumentPosition(e.over) & Node.DOCUMENT_POSITION_FOLLOWING ? `Placed ${t} after ${n}` : `Placed ${t} before ${n}`;
  } else
    return `Placed ${t} into a different container`;
}
const defaultAnnouncements = {
  "sortable:sorted": onSortableSortedDefaultAnnouncement
};
class Sortable extends Draggable {
  constructor(t = [], n = {}) {
    super(t, {
      ...n,
      announcements: {
        ...defaultAnnouncements,
        ...n.announcements || {}
      }
    }), this.startIndex = null, this.startContainer = null, this[onDragStart] = this[onDragStart].bind(this), this[onDragOverContainer] = this[onDragOverContainer].bind(this), this[onDragOver] = this[onDragOver].bind(this), this[onDragStop] = this[onDragStop].bind(this), this.on("drag:start", this[onDragStart]).on("drag:over:container", this[onDragOverContainer]).on("drag:over", this[onDragOver]).on("drag:stop", this[onDragStop]);
  }
  destroy() {
    super.destroy(), this.off("drag:start", this[onDragStart]).off("drag:over:container", this[onDragOverContainer]).off("drag:over", this[onDragOver]).off("drag:stop", this[onDragStop]);
  }
  index(t) {
    return this.getSortableElementsForContainer(t.parentNode).indexOf(t);
  }
  getSortableElementsForContainer(t) {
    return [...t.querySelectorAll(this.options.draggable)].filter((a) => a !== this.originalSource && a !== this.mirror && a.parentNode === t);
  }
  [onDragStart](t) {
    this.startContainer = t.source.parentNode, this.startIndex = this.index(t.source);
    const n = new SortableStartEvent({
      dragEvent: t,
      startIndex: this.startIndex,
      startContainer: this.startContainer
    });
    this.trigger(n), n.canceled() && t.cancel();
  }
  [onDragOverContainer](t) {
    if (t.canceled())
      return;
    const {
      source: n,
      over: a,
      overContainer: o
    } = t, s = this.index(n), u = new SortableSortEvent({
      dragEvent: t,
      currentIndex: s,
      source: n,
      over: a
    });
    if (this.trigger(u), u.canceled())
      return;
    const d = this.getSortableElementsForContainer(o), f = move$1({
      source: n,
      over: a,
      overContainer: o,
      children: d
    });
    if (!f)
      return;
    const {
      oldContainer: g,
      newContainer: v
    } = f, b = this.index(t.source), w = new SortableSortedEvent({
      dragEvent: t,
      oldIndex: s,
      newIndex: b,
      oldContainer: g,
      newContainer: v
    });
    this.trigger(w);
  }
  [onDragOver](t) {
    if (t.over === t.originalSource || t.over === t.source)
      return;
    const {
      source: n,
      over: a,
      overContainer: o
    } = t, s = this.index(n), u = new SortableSortEvent({
      dragEvent: t,
      currentIndex: s,
      source: n,
      over: a
    });
    if (this.trigger(u), u.canceled())
      return;
    const d = this.getDraggableElementsForContainer(o), f = move$1({
      source: n,
      over: a,
      overContainer: o,
      children: d
    });
    if (!f)
      return;
    const {
      oldContainer: g,
      newContainer: v
    } = f, b = this.index(n), w = new SortableSortedEvent({
      dragEvent: t,
      oldIndex: s,
      newIndex: b,
      oldContainer: g,
      newContainer: v
    });
    this.trigger(w);
  }
  [onDragStop](t) {
    const n = new SortableStopEvent({
      dragEvent: t,
      oldIndex: this.startIndex,
      newIndex: this.index(t.source),
      oldContainer: this.startContainer,
      newContainer: t.source.parentNode
    });
    this.trigger(n), this.startIndex = null, this.startContainer = null;
  }
}
function index(e) {
  return Array.prototype.indexOf.call(e.parentNode.children, e);
}
function move$1({
  source: e,
  over: t,
  overContainer: n,
  children: a
}) {
  const o = !a.length, s = e.parentNode !== n, u = t && e.parentNode === t.parentNode;
  return o ? moveInsideEmptyContainer(e, n) : u ? moveWithinContainer(e, t) : s ? moveOutsideContainer(e, t, n) : null;
}
function moveInsideEmptyContainer(e, t) {
  const n = e.parentNode;
  return t.appendChild(e), {
    oldContainer: n,
    newContainer: t
  };
}
function moveWithinContainer(e, t) {
  const n = index(e), a = index(t);
  return n < a ? e.parentNode.insertBefore(e, t.nextElementSibling) : e.parentNode.insertBefore(e, t), {
    oldContainer: e.parentNode,
    newContainer: e.parentNode
  };
}
function moveOutsideContainer(e, t, n) {
  const a = e.parentNode;
  return t ? t.parentNode.insertBefore(e, t) : n.appendChild(e), {
    oldContainer: a,
    newContainer: e.parentNode
  };
}
function move(e, t, n) {
  const a = [...e.slice(0, t), ...e.slice(t + 1, e.length)];
  return [
    ...a.slice(0, n),
    e[t],
    ...a.slice(n, a.length)
  ];
}
const _sfc_main$1A = {
  emits: ["dragstart", "dragend", "update:model-value"],
  props: {
    modelValue: {
      required: !0
    },
    itemClass: {
      default: "sortable-item"
    },
    handleClass: {
      default: "sortable-handle"
    },
    mirror: {
      type: Boolean,
      default: !0
    },
    appendTo: {
      default: null
    },
    options: {
      default: () => {
      }
    },
    vertical: {
      type: Boolean
    },
    constrainDimensions: {
      type: Boolean
    },
    delay: {
      type: Number,
      default: 0
    },
    distance: {
      type: Number,
      default: 0
    },
    disabled: {
      type: Boolean,
      default: !1
    },
    animate: {
      type: Boolean,
      default: !0
    }
  },
  data() {
    return {
      sortable: null
    };
  },
  computed: {
    computedOptions() {
      let e = [];
      this.animate && e.push(SwapAnimation);
      let t = Object.assign(
        {},
        {
          draggable: `.${CSS.escape(this.itemClass)}`,
          handle: `.${CSS.escape(this.handleClass)}`,
          delay: this.delay,
          distance: this.distance,
          swapAnimation: { vertical: this.vertical, horizontal: !this.vertical },
          plugins: e,
          mirror: {
            constrainDimensions: this.constrainDimensions
          },
          exclude: {
            plugins: [Draggable.Plugins.Focusable]
          }
        },
        this.options
      );
      return this.vertical && (t.mirror.xAxis = !1), this.appendTo && (t.mirror.appendTo = this.appendTo), t;
    }
  },
  provide() {
    return {
      itemClass: this.itemClass,
      handleClass: this.handleClass
    };
  },
  render() {
    return this.$slots.default({
      items: this.modelValue
    })[0];
  },
  mounted() {
    this.disabled || this.setupSortableList();
  },
  unmounted() {
    this.destroySortableList();
  },
  methods: {
    setupSortableList() {
      this.sortable = new Sortable(this.$el, this.computedOptions), this.sortable.on("drag:start", () => this.$emit("dragstart")), this.sortable.on("drag:stop", () => this.$emit("dragend")), this.sortable.on("sortable:stop", ({ oldIndex: e, newIndex: t }) => {
        this.$emit("update:model-value", move(this.modelValue, e, t));
      }), this.mirror === !1 && this.sortable.on("mirror:create", (e) => e.cancel());
    },
    destroySortableList() {
      this.sortable.destroy();
    }
  },
  watch: {
    disabled(e) {
      e ? this.destroySortableList() : this.setupSortableList();
    }
  }
};
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var uniqid$1 = { exports: {} };
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
var hasRequiredUniqid;
function requireUniqid() {
  if (hasRequiredUniqid) return uniqid$1.exports;
  hasRequiredUniqid = 1;
  var e = typeof process < "u" && process.pid ? process.pid.toString(36) : "", t = "";
  if (typeof __webpack_require__ != "function" && typeof commonjsRequire < "u") {
    var n = "", a = require$$0;
    if (a.networkInterfaces) var o = a.networkInterfaces();
    if (o) {
      e:
        for (let d in o) {
          const f = o[d], g = f.length;
          for (var s = 0; s < g; s++)
            if (f[s] !== void 0 && f[s].mac && f[s].mac != "00:00:00:00:00:00") {
              n = f[s].mac;
              break e;
            }
        }
      t = n ? parseInt(n.replace(/\:|\D+/gi, "")).toString(36) : "";
    }
  }
  uniqid$1.exports = uniqid$1.exports.default = function(d, f) {
    return (d || "") + t + e + u().toString(36) + (f || "");
  }, uniqid$1.exports.process = function(d, f) {
    return (d || "") + e + u().toString(36) + (f || "");
  }, uniqid$1.exports.time = function(d, f) {
    return (d || "") + u().toString(36) + (f || "");
  };
  function u() {
    var d = Date.now(), f = u.last || d;
    return u.last = d > f ? d : f + 1;
  }
  return uniqid$1.exports;
}
var uniqidExports = requireUniqid();
const uniqid = /* @__PURE__ */ getDefaultExportFromCjs(uniqidExports), _hoisted_1$Y = { class: "flex" }, _hoisted_2$z = { class: "flex-1 min-w-0" }, _hoisted_3$h = ["textContent"], _hoisted_4$b = ["innerHTML"], _hoisted_5$6 = ["textContent"], _hoisted_6$3 = { class: "flex gap-1.5 items-center shrink-0 ms-1.5" }, _hoisted_7$1 = ["src"], _hoisted_8$1 = ["innerHTML"], _hoisted_9$1 = { key: 2 }, _hoisted_10$1 = ["textContent"], _hoisted_11 = ["textContent"], _hoisted_12 = { class: "flex flex-wrap gap-2" }, _hoisted_13 = ["innerHTML"], _hoisted_14 = { key: 1 }, _hoisted_15 = ["aria-label", "onClick"], _hoisted_16 = {
  key: 3,
  type: "button",
  class: "opacity-75"
}, _sfc_main$1z = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Combobox",
  props: {
    id: { type: String },
    clearable: { type: Boolean, default: !1 },
    closeOnSelect: { type: Boolean, default: void 0 },
    disabled: { type: Boolean, default: !1 },
    discreteFocusOutline: { type: Boolean, default: !1 },
    icon: { type: String, default: null },
    ignoreFilter: { type: Boolean, default: !1 },
    labelHtml: { type: Boolean, default: !1 },
    maxSelections: { type: Number, default: null },
    modelValue: { type: [Object, String, Number], default: null },
    multiple: { type: Boolean, default: !1 },
    optionLabel: { type: String, default: "label" },
    options: { type: Array, default: null },
    optionValue: { type: String, default: "value" },
    placeholder: { type: String, default: "Select..." },
    readOnly: { type: Boolean, default: !1 },
    searchable: { type: Boolean, default: !0 },
    size: { type: String, default: "base" },
    taggable: { type: Boolean, default: !1 },
    variant: { type: String, default: "default" }
  },
  emits: ["update:modelValue", "search", "selected", "added"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = useAttrs(), u = cva({
      base: "w-full flex items-center justify-between antialiased cursor-pointer",
      variants: {
        variant: {
          default: [
            "bg-linear-to-b from-white to-gray-50 text-gray-900 border border-gray-300 shadow-ui-sm focus-within:focus-outline",
            "dark:from-gray-850 dark:to-gray-900 dark:border-gray-700 dark:text-gray-300 dark:shadow-ui-md"
          ],
          filled: "bg-black/5 hover:bg-black/10 text-gray-900 border-none dark:bg-white/15 dark:hover:bg-white/20 dark:text-white focus-within:focus-outline dark:placeholder:text-red-500/60",
          ghost: "bg-transparent hover:bg-gray-400/10 text-gray-900 border-none dark:text-gray-300 dark:hover:bg-white/15 dark:hover:text-gray-200 focus-within:focus-outline",
          subtle: "bg-transparent hover:bg-gray-400/10 text-gray-500 hover:text-gray-700 border-none dark:text-gray-300 dark:hover:bg-white/15 dark:hover:text-gray-200 focus-within:focus-outline"
        },
        size: {
          lg: "px-6 h-12 text-base rounded-lg",
          base: "px-4 h-10 text-sm rounded-lg",
          sm: "px-3 h-8 text-[0.8125rem] rounded-lg",
          xs: "px-2 h-6 text-xs rounded-md"
        },
        "discrete-focus-outline": {
          true: "focus-outline-discrete"
        },
        readOnly: {
          true: "border-dashed"
        },
        disabled: {
          true: "opacity-50 cursor-not-allowed"
        }
      }
    })({
      variant: o.variant,
      size: o.size,
      "discrete-focus-outline": o.discreteFocusOutline,
      readOnly: o.readOnly,
      disabled: o.disabled
    }), d = cva({
      base: [
        "w-full flex items-center gap-2 relative select-none cursor-pointer text-sm",
        "py-1.5 px-2 antialiased rounded-lg",
        "data-disabled:text-gray-300 data-disabled:pointer-events-none data-highlighted:outline-hidden"
      ],
      variants: {
        size: {
          base: "",
          sm: "text-sm",
          xs: "text-xs"
        },
        selected: {
          false: "text-gray-900 dark:text-gray-300 data-highlighted:bg-gray-100 data-highlighted:text-gray-900 dark:data-highlighted:bg-gray-700 dark:data-highlighted:text-gray-300",
          true: "bg-blue-50 dark:bg-blue-600 text-blue-600! dark:text-blue-50!"
        }
      }
    }), f = computed(() => {
      let Z = o.modelValue === null ? [] : o.modelValue;
      return (typeof Z == "string" || typeof Z == "number") && (Z = [Z]), Z.map((J) => o.options.find((re) => b(re) === J) ?? { label: J, value: J });
    }), g = computed(() => o.multiple || !o.modelValue || f.value.length !== 1 ? null : f.value[0]), v = (Z) => Z?.[o.optionLabel], b = (Z) => Z?.[o.optionValue], w = (Z) => f.value.filter((J) => b(J) === b(Z)).length > 0, C = computed(() => o.maxSelections ? f.value.length >= o.maxSelections : !1), k = computed(() => o.maxSelections ? f.value.length > o.maxSelections : !1), E = computed(() => k.value ? "text-red-600" : C.value ? "text-green-600" : "text-gray"), A = ref(""), P = useTemplateRef("search");
    watch(A, (Z) => {
      a("search", Z, () => {
      });
    });
    const M = computed(() => {
      if (!o.searchable || o.ignoreFilter)
        return o.options;
      const Z = JSON.parse(JSON.stringify(o.options)), J = fuzzysort.go(A.value, Z, {
        all: !0,
        key: o.optionLabel
      }).map((re) => re.obj);
      return o.taggable && A.value && J.length === 0 && J.push({
        [o.optionLabel]: A.value,
        [o.optionValue]: A.value
      }), J;
    });
    function B() {
      A.value = "", a("update:modelValue", null);
    }
    function _(Z) {
      a("update:modelValue", o.modelValue.filter((J) => J !== Z));
    }
    const T = ref(!1), O = computed(() => o.closeOnSelect || !o.multiple);
    function I(Z) {
      o.taggable && o.options.length === 0 || (T.value = Z);
    }
    function q(Z) {
      let J = o.modelValue || [];
      A.value = "", a("update:modelValue", Z), Array.isArray(Z) || (Z = [Z]), Array.isArray(J) || (J = [J]), Z.filter((re) => !J?.includes(re)).forEach((re) => a("selected", re));
    }
    function F(Z) {
      if (!o.taggable)
        return;
      const J = Z.clipboardData.getData("text");
      q([...o.modelValue, ...J.split(",").map((re) => re.trim())]);
    }
    function W(Z) {
      if (o.taggable && o.options.length === 0) {
        if (Z.target.value === "") return;
        if (o.modelValue.includes(Z.target.value)) {
          A.value = "";
          return;
        }
        a("added", Z.target.value), q([...o.modelValue, Z.target.value]);
      }
    }
    function K(Z) {
      const J = Z && Z.target ? Z.target : null, re = (J && J.tagName ? J.tagName : "").toLowerCase(), V = J && (re === "input" || re === "textarea" || J.isContentEditable);
      if (!T.value) {
        if (V) {
          Z && typeof Z.preventDefault == "function" && Z.preventDefault(), I(!0), nextTick(() => {
            const ne = P?.value?.$el || P?.value;
            ne && typeof ne.focus == "function" && ne.focus();
          });
          return;
        }
        Z && typeof Z.preventDefault == "function" && Z.preventDefault(), I(!0), nextTick(() => {
          const ne = P?.value?.$el || P?.value;
          ne && typeof ne.focus == "function" && ne.focus();
        });
      }
    }
    return t({
      searchQuery: A,
      filteredOptions: M
    }), (Z, J) => (openBlock(), createElementBlock("div", null, [
      createElementVNode("div", _hoisted_1$Y, [
        createVNode(unref(_sfc_main$3S), mergeProps({
          disabled: e.disabled || e.multiple && C.value || e.readOnly,
          "model-value": e.modelValue,
          multiple: e.multiple,
          open: T.value,
          "reset-search-term-on-blur": !1,
          "reset-search-term-on-select": !1,
          "onUpdate:modelValue": q,
          "onUpdate:open": I,
          class: "cursor-pointer",
          "data-ui-combobox": "",
          "ignore-filter": ""
        }, unref(s)), {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$3X), {
              class: normalizeClass([Z.$attrs.class]),
              "data-ui-combobox-anchor": ""
            }, {
              default: withCtx(() => [
                createVNode(unref(_sfc_main$3I), {
                  as: "div",
                  ref: "trigger",
                  class: normalizeClass(unref(u)),
                  onKeydown: withKeys(K, ["space"]),
                  "data-ui-combobox-trigger": ""
                }, {
                  default: withCtx(() => [
                    createElementVNode("div", _hoisted_2$z, [
                      e.searchable && (T.value || !e.modelValue || e.multiple && e.placeholder) ? (openBlock(), createBlock(unref(_sfc_main$3M), {
                        key: 0,
                        ref: "search",
                        class: "w-full bg-transparent text-gray-900 dark:text-gray-300 opacity-100 focus:outline-none placeholder-gray-500 dark:placeholder-gray-400 [&::-webkit-search-cancel-button]:hidden",
                        type: "search",
                        id: e.id,
                        modelValue: A.value,
                        "onUpdate:modelValue": J[0] || (J[0] = (re) => A.value = re),
                        placeholder: e.placeholder,
                        autocomplete: "off",
                        onPaste: withModifiers(F, ["prevent"]),
                        onKeydown: [
                          withKeys(withModifiers(W, ["prevent"]), ["enter"]),
                          withKeys(K, ["space"])
                        ],
                        onBlur: W
                      }, null, 8, ["id", "modelValue", "placeholder", "onKeydown"])) : !e.searchable && (T.value || !e.modelValue) ? (openBlock(), createElementBlock("button", {
                        key: 1,
                        type: "button",
                        class: "w-full text-start truncate bg-transparent cursor-pointer",
                        onKeydown: withKeys(K, ["space"]),
                        "data-ui-combobox-placeholder": ""
                      }, [
                        createElementVNode("span", {
                          class: "text-gray-400 dark:text-gray-500",
                          textContent: toDisplayString(e.placeholder)
                        }, null, 8, _hoisted_3$h)
                      ], 32)) : (openBlock(), createElementBlock("button", {
                        key: 2,
                        type: "button",
                        class: "w-full text-start bg-transparent truncate flex items-center gap-2 cursor-pointer",
                        onKeydown: withKeys(K, ["space"]),
                        "data-ui-combobox-selected-option": ""
                      }, [
                        renderSlot(Z.$slots, "selected-option", normalizeProps(guardReactiveProps({ option: g.value })), () => [
                          e.icon ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                            key: 0,
                            name: e.icon,
                            class: "text-white-400 dark:text-white dark:opacity-50"
                          }, null, 8, ["name"])) : createCommentVNode("", !0),
                          e.labelHtml ? (openBlock(), createElementBlock("span", {
                            key: 1,
                            innerHTML: v(g.value)
                          }, null, 8, _hoisted_4$b)) : (openBlock(), createElementBlock("span", {
                            key: 2,
                            textContent: toDisplayString(v(g.value))
                          }, null, 8, _hoisted_5$6))
                        ])
                      ], 32))
                    ]),
                    createElementVNode("div", _hoisted_6$3, [
                      e.clearable && e.modelValue ? (openBlock(), createBlock(unref(Button), {
                        key: 0,
                        icon: "x",
                        variant: "ghost",
                        size: "xs",
                        round: "",
                        onClick: B,
                        "data-ui-combobox-clear-button": ""
                      })) : createCommentVNode("", !0),
                      e.options.length || e.ignoreFilter ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                        key: 1,
                        name: "ui/chevron-down",
                        class: "text-gray-400 dark:text-white/40",
                        "data-ui-combobox-chevron": ""
                      })) : createCommentVNode("", !0)
                    ])
                  ]),
                  _: 3
                }, 8, ["class"])
              ]),
              _: 3
            }, 8, ["class"]),
            createVNode(unref(_sfc_main$3J), null, {
              default: withCtx(() => [
                createVNode(unref(_sfc_main$3P), {
                  position: "popper",
                  "side-offset": 5,
                  class: normalizeClass([
                    "shadow-ui-sm z-100 rounded-lg border border-gray-200 bg-white p-2 dark:border-white/10 dark:bg-gray-800",
                    "max-h-[var(--reka-combobox-content-available-height)] w-[var(--reka-combobox-trigger-width)] min-w-fit",
                    "[&_[data-reka-combobox-viewport]]:grid [&_[data-reka-combobox-viewport]]:gap-1"
                  ]),
                  onEscapeKeyDown: J[2] || (J[2] = (re) => nextTick(() => Z.$refs.trigger.$el.focus())),
                  "data-ui-combobox-content": ""
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$3H), null, {
                      default: withCtx(() => [
                        createVNode(unref(_sfc_main$3O), {
                          class: "p-2 text-sm",
                          "data-ui-combobox-empty": ""
                        }, {
                          default: withCtx(() => [
                            renderSlot(Z.$slots, "no-options", normalizeProps(guardReactiveProps({ searchQuery: A.value })), () => [
                              createTextVNode(toDisplayString(Z.__("No options available.")), 1)
                            ])
                          ]),
                          _: 3
                        }),
                        M.value ? (openBlock(!0), createElementBlock(Fragment, { key: 0 }, renderList(M.value, (re, V) => (openBlock(), createBlock(unref(_sfc_main$3K), {
                          key: V,
                          value: b(re),
                          "text-value": v(re),
                          class: normalizeClass(unref(d)({ size: e.size, selected: w(re) })),
                          as: "button",
                          "data-ui-combobox-item": "",
                          onSelect: J[1] || (J[1] = () => {
                            T.value = !O.value, O.value && Z.$refs.trigger.$el.focus();
                          })
                        }, {
                          default: withCtx(() => [
                            renderSlot(Z.$slots, "option", mergeProps({ ref_for: !0 }, re), () => [
                              re.image ? (openBlock(), createElementBlock("img", {
                                key: 0,
                                src: re.image,
                                class: "size-5 rounded-full"
                              }, null, 8, _hoisted_7$1)) : createCommentVNode("", !0),
                              e.labelHtml ? (openBlock(), createElementBlock("span", {
                                key: 1,
                                innerHTML: v(re)
                              }, null, 8, _hoisted_8$1)) : (openBlock(), createElementBlock("span", _hoisted_9$1, toDisplayString(Z.__(v(re))), 1))
                            ])
                          ]),
                          _: 2
                        }, 1032, ["value", "text-value", "class"]))), 128)) : createCommentVNode("", !0)
                      ]),
                      _: 3
                    })
                  ]),
                  _: 3
                })
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 16, ["disabled", "model-value", "multiple", "open"]),
        e.maxSelections && e.maxSelections !== 1 / 0 && e.multiple ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(["ms-2 mt-3 text-xs", E.value]),
          "data-ui-combobox-limit-indicator": ""
        }, [
          createElementVNode("span", {
            textContent: toDisplayString(f.value.length)
          }, null, 8, _hoisted_10$1),
          J[3] || (J[3] = createTextVNode("/", -1)),
          createElementVNode("span", {
            textContent: toDisplayString(e.maxSelections)
          }, null, 8, _hoisted_11)
        ], 2)) : createCommentVNode("", !0)
      ]),
      renderSlot(Z.$slots, "selected-options", normalizeProps(guardReactiveProps({ disabled: e.disabled, readOnly: e.readOnly, getOptionLabel: v, getOptionValue: b, labelHtml: e.labelHtml, deselect: _ })), () => [
        e.multiple ? (openBlock(), createBlock(unref(_sfc_main$1A), {
          key: 0,
          "data-ui-combobox-selected-options": "",
          "item-class": "sortable-item",
          "handle-class": "sortable-item",
          distance: 5,
          mirror: !1,
          disabled: e.disabled,
          "model-value": e.modelValue,
          "onUpdate:modelValue": q
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_12, [
              (openBlock(!0), createElementBlock(Fragment, null, renderList(f.value, (re) => (openBlock(), createElementBlock("div", {
                key: b(re),
                class: "sortable-item mt-2"
              }, [
                createVNode(unref(_sfc_main), {
                  pill: "",
                  size: "lg"
                }, {
                  default: withCtx(() => [
                    e.labelHtml ? (openBlock(), createElementBlock("div", {
                      key: 0,
                      innerHTML: v(re)
                    }, null, 8, _hoisted_13)) : (openBlock(), createElementBlock("div", _hoisted_14, toDisplayString(Z.__(v(re))), 1)),
                    e.disabled ? (openBlock(), createElementBlock("button", _hoisted_16, "  ")) : (openBlock(), createElementBlock("button", {
                      key: 2,
                      type: "button",
                      class: "opacity-75 hover:opacity-100 cursor-pointer",
                      "aria-label": Z.__("Deselect option"),
                      onClick: (V) => _(re.value)
                    }, "  ", 8, _hoisted_15))
                  ]),
                  _: 2
                }, 1024)
              ]))), 128))
            ])
          ]),
          _: 1
        }, 8, ["disabled", "model-value"])) : createCommentVNode("", !0)
      ])
    ]));
  }
}), _sfc_main$1y = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Context",
  props: {
    align: { type: String, default: "start" },
    offset: { type: Number, default: 5 },
    side: { type: String, default: "bottom" }
  },
  setup(e) {
    const t = useAttrs(), n = cva({
      base: [
        "rounded-xl w-64 bg-gray-50 dark:bg-gray-800 outline-hidden overflow-hidden group z-50",
        "border border-gray-200 dark:border-black shadow-lg popoverAnimation"
      ]
    })({});
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$3z), null, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$3p), {
          "as-child": "",
          "data-ui-context-trigger": ""
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "trigger", {}, () => [
              createVNode(unref(Button), mergeProps({
                icon: "ui/dots",
                variant: "ghost",
                size: "sm"
              }, unref(t), {
                "aria-label": a.__("Open context menu")
              }), null, 16, ["aria-label"])
            ])
          ]),
          _: 3
        }),
        createVNode(unref(_sfc_main$3t), null, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$3y), {
              "data-ui-context-content": "",
              class: normalizeClass([unref(n), a.$attrs.class]),
              align: e.align,
              sideOffset: e.offset,
              side: e.side
            }, {
              default: withCtx(() => [
                renderSlot(a.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "align", "sideOffset", "side"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), _hoisted_1$X = {
  key: 0,
  class: "flex size-6 items-center justify-center rounded-lg bg-gray-100 p-1 text-gray-700 dark:bg-gray-900 dark:text-gray-500"
}, _hoisted_2$y = { class: "grow truncate text-sm text-gray-600 antialiased group-hover/footer:text-gray-950 dark:text-gray-400 dark:group-hover/footer:text-gray-200" }, _sfc_main$1x = {
  __name: "Footer",
  props: {
    href: { type: String, default: null },
    icon: { type: String, default: null },
    text: { type: String, default: null }
  },
  setup(e) {
    const n = !!useSlots().default, a = cva({
      base: "text-gray-600 antialiased py-2 px-3 text-sm rounded-b-xl group/footer",
      variant: {
        noSlot: "flex items-center gap-2"
      }
    });
    return (o, s) => (openBlock(), createElementBlock("footer", {
      class: normalizeClass(unref(a)({ noSlot: !n })),
      "data-ui-context-footer": ""
    }, [
      n ? renderSlot(o.$slots, "default", { key: 0 }) : (openBlock(), createBlock(resolveDynamicComponent(e.href ? "a" : "div"), {
        key: 1,
        href: e.href,
        class: "flex items-center gap-2"
      }, {
        default: withCtx(() => [
          e.icon ? (openBlock(), createElementBlock("div", _hoisted_1$X, [
            createVNode(unref(_sfc_main$1a), { name: e.icon }, null, 8, ["name"])
          ])) : createCommentVNode("", !0),
          createElementVNode("div", _hoisted_2$y, toDisplayString(e.text), 1)
        ]),
        _: 1
      }, 8, ["href"]))
    ], 2));
  }
}, _hoisted_1$W = {
  key: 0,
  class: "flex size-6 items-center justify-center p-1 text-gray-500"
}, _hoisted_2$x = { class: "col-start-2 ps-2" }, _sfc_main$1w = {
  __name: "Item",
  props: {
    href: { type: String, default: null },
    icon: { type: String, default: null },
    text: { type: String, default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$3x), {
      class: normalizeClass([
        "col-span-2 grid grid-cols-subgrid items-center",
        "rounded-lg px-1 py-1.5 text-sm antialiased",
        "text-gray-700 dark:text-gray-300",
        "not-data-disabled:cursor-pointer data-disabled:opacity-50",
        "hover:not-data-disabled:bg-gray-50 dark:hover:not-data-disabled:bg-gray-950 outline-hidden"
      ]),
      "data-ui-context-item": "",
      as: e.href ? "a" : "div",
      href: e.href
    }, {
      default: withCtx(() => [
        e.icon ? (openBlock(), createElementBlock("div", _hoisted_1$W, [
          createVNode(unref(_sfc_main$1a), {
            name: e.icon,
            class: "size-3.5!"
          }, null, 8, ["name"])
        ])) : createCommentVNode("", !0),
        createElementVNode("div", _hoisted_2$x, [
          n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(e.text), 1)
          ], 64))
        ])
      ]),
      _: 3
    }, 8, ["as", "href"]));
  }
}, _sfc_main$1v = {
  __name: "Label",
  props: {
    text: { type: String, default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$3v), {
      class: "col-span-2 grid items-center rounded-lg px-2 py-2 text-xs text-gray-400 dark:text-gray-500",
      "data-ui-context-label": ""
    }, {
      default: withCtx(() => [
        n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(e.text), 1)
        ], 64))
      ]),
      _: 3
    }));
  }
}, _sfc_main$1u = {}, _hoisted_1$V = {
  class: "grid grid-cols-[auto_1fr] p-1.5 bg-white border-gray-200 dark:bg-gray-900 dark:border-black rounded-b-xl shadow-ui-xs group-has-data-ui-context-footer:border-b [&_[data-ui-radio-item]]:ps-3 [&_[data-ui-radio-item]]:py-0.5 overflow-hidden z-10",
  "data-ui-context-menu": ""
};
function _sfc_render$c(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$V, [
    renderSlot(e.$slots, "default")
  ]);
}
const Menu = /* @__PURE__ */ _export_sfc(_sfc_main$1u, [["render", _sfc_render$c]]), _sfc_main$1t = {
  __name: "Separator",
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$3r), { class: "col-span-2 -mx-1.5 my-1 h-px bg-gray-200 dark:bg-black" }));
  }
}, _hoisted_1$U = { class: "mx-auto mt-4 space-y-3 lg:space-y-6 max-w-3xl" }, _hoisted_2$w = {
  key: 0,
  class: "text-center max-w-xl mx-auto py-6 lg:pt-12 xl:pt-16"
}, _hoisted_3$g = { class: "space-y-8" }, _hoisted_4$a = { class: "flex justify-center py-3" }, _sfc_main$1s = {
  __name: "CreateForm",
  props: {
    title: { type: String, required: !0 },
    subtitle: { type: String, default: null },
    icon: { type: String, default: null },
    submitText: { type: String, default: null },
    loading: { type: Boolean, default: !1 },
    route: { type: String, required: !0 },
    titleInstructions: { type: String, default: null },
    handleInstructions: { type: String, default: null },
    withoutHandle: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, n = getCurrentInstance(), { $slug: a, $axios: o, $toast: s, $keys: u } = n.appContext.config.globalProperties, d = ref(null), f = ref(null), g = a.separatedBy("_"), v = computed(() => d.value && (t.withoutHandle || f.value));
    watch(d, (w) => {
      w && !t.withoutHandle && (f.value = g.create(w));
    });
    const b = () => {
      let w = { title: d.value };
      t.withoutHandle || (w.handle = f.value), o.post(t.route, w).then((C) => {
        window.location = C.data.redirect;
      }).catch((C) => {
        s.error(C.response.data.message);
      });
    };
    return onMounted(() => {
      u.bindGlobal(["return", "mod+s"], (w) => {
        w.preventDefault(), v.value && b();
      });
    }), (w, C) => {
      const k = resolveComponent("ui-heading"), E = resolveComponent("ui-subheading"), A = resolveComponent("ui-input"), P = resolveComponent("ui-field"), M = resolveComponent("ui-card-panel"), B = resolveComponent("ui-button");
      return openBlock(), createElementBlock("div", _hoisted_1$U, [
        t.title || e.subtitle ? (openBlock(), createElementBlock("header", _hoisted_2$w, [
          t.title ? (openBlock(), createBlock(k, {
            key: 0,
            size: "2xl",
            level: 1,
            icon: t.icon,
            text: t.title,
            class: "justify-center"
          }, null, 8, ["icon", "text"])) : createCommentVNode("", !0),
          e.subtitle ? (openBlock(), createBlock(E, {
            key: 1,
            class: "mt-6",
            size: "lg",
            text: e.subtitle
          }, null, 8, ["text"])) : createCommentVNode("", !0)
        ])) : createCommentVNode("", !0),
        renderSlot(w.$slots, "default", {}, () => [
          createVNode(M, {
            heading: w.__("Details")
          }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_3$g, [
                createVNode(P, {
                  label: w.__("Title"),
                  instructions: e.titleInstructions,
                  "instructions-below": !0
                }, {
                  default: withCtx(() => [
                    createVNode(A, {
                      modelValue: d.value,
                      "onUpdate:modelValue": C[0] || (C[0] = (_) => d.value = _),
                      autofocus: ""
                    }, null, 8, ["modelValue"])
                  ]),
                  _: 1
                }, 8, ["label", "instructions"]),
                e.withoutHandle ? createCommentVNode("", !0) : (openBlock(), createBlock(P, {
                  key: 0,
                  label: w.__("Handle"),
                  instructions: e.handleInstructions,
                  "instructions-below": !0
                }, {
                  default: withCtx(() => [
                    createVNode(A, {
                      modelValue: f.value,
                      "onUpdate:modelValue": C[1] || (C[1] = (_) => f.value = _),
                      loading: unref(g).busy
                    }, null, 8, ["modelValue", "loading"])
                  ]),
                  _: 1
                }, 8, ["label", "instructions"]))
              ])
            ]),
            _: 1
          }, 8, ["heading"])
        ]),
        renderSlot(w.$slots, "footer", {}, () => [
          createElementVNode("footer", _hoisted_4$a, [
            createVNode(B, {
              variant: "primary",
              size: "lg",
              onClick: b,
              type: "submit",
              loading: e.loading,
              disabled: !v.value,
              text: e.submitText || t.title
            }, null, 8, ["loading", "disabled", "text"])
          ])
        ])
      ]);
    };
  }
}, _hoisted_1$T = {
  class: "group/input relative block w-full",
  "data-ui-input": ""
}, _hoisted_2$v = ["aria-invalid", "aria-label"], _hoisted_3$f = { class: "flex items-center flex-1" }, _hoisted_4$9 = ["disabled", "aria-label"], _sfc_main$1r = {
  __name: "DatePicker",
  props: {
    date: { type: String, default: null },
    badge: { type: String, default: null },
    required: { type: Boolean, default: !1 },
    modelValue: { type: [Object, String], default: null },
    min: { type: [String, Object], default: null },
    max: { type: [String, Object], default: null },
    granularity: { type: String, default: null },
    inline: { type: Boolean, default: !1 },
    numberOfMonths: { type: Number, default: 1 },
    clearable: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    readOnly: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = computed(() => ({
      modelValue: a.modelValue,
      min: a.min,
      max: a.max,
      inline: a.inline,
      numberOfMonths: a.numberOfMonths,
      components: {
        Root: _sfc_main$3j,
        Header: _sfc_main$33,
        Heading: _sfc_main$32,
        Prev: _sfc_main$2$,
        Next: _sfc_main$30,
        Grid: _sfc_main$38,
        GridHead: _sfc_main$36,
        GridBody: _sfc_main$37,
        GridRow: _sfc_main$35,
        HeadCell: _sfc_main$34,
        Cell: _sfc_main$3i,
        CellTrigger: _sfc_main$3h
      }
    })), s = computed(() => ({
      "update:model-value": (f) => n("update:modelValue", f)
    })), u = computed(() => a.modelValue === null && a.required), d = (f) => {
      switch (f) {
        case "day":
          return __("Day");
        case "month":
          return __("Month");
        case "year":
          return __("Year");
        case "hour":
          return __("Hour");
        case "minute":
          return __("Minute");
        case "second":
          return __("Second");
        case "dayPeriod":
          return __("AM/PM");
        default:
          return "";
      }
    };
    return (f, g) => (openBlock(), createElementBlock("div", _hoisted_1$T, [
      createVNode(unref(_sfc_main$3k), mergeProps({
        modelValue: e.modelValue,
        granularity: e.granularity,
        locale: f.$date.locale,
        disabled: e.disabled || e.readOnly,
        "onUpdate:modelValue": g[1] || (g[1] = (v) => n("update:modelValue", v))
      }, f.$attrs, {
        "prevent-deselect": "",
        "hide-time-zone": "",
        role: "group",
        "aria-label": f.__("Date picker"),
        "aria-required": e.required
      }), {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$39), { class: "w-full" }, {
            default: withCtx(({ segments: v }) => [
              createElementVNode("div", {
                class: normalizeClass([
                  "flex w-full items-center bg-white uppercase dark:bg-gray-900",
                  "border border-gray-300 dark:border-x-0 dark:border-t-0 dark:border-white/10 dark:inset-shadow-2xs dark:inset-shadow-black",
                  "text-gray-600 dark:text-gray-300",
                  "shadow-ui-sm not-prose h-10 rounded-lg px-2 disabled:shadow-none",
                  "data-invalid:border-red-500",
                  "disabled:shadow-none disabled:opacity-50",
                  e.readOnly ? "border-dashed" : ""
                ]),
                "aria-invalid": u.value,
                role: "textbox",
                "aria-label": f.__("Select date")
              }, [
                e.inline ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$2Z), {
                  key: 0,
                  class: "flex items-center justify-center rounded-lg p-2 -ms-1 text-gray-400 outline-hidden hover:bg-gray-100 focus:bg-gray-100 dark:hover:bg-gray-900 dark:focus:bg-gray-900",
                  "aria-label": f.__("Open calendar")
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$1a), {
                      name: "calendar",
                      class: "size-4"
                    })
                  ]),
                  _: 1
                }, 8, ["aria-label"])),
                createElementVNode("div", _hoisted_3$f, [
                  (openBlock(!0), createElementBlock(Fragment, null, renderList(v, (b) => (openBlock(), createElementBlock(Fragment, {
                    key: b.part
                  }, [
                    b.part === "literal" ? (openBlock(), createBlock(unref(_sfc_main$31), {
                      key: 0,
                      part: b.part,
                      class: normalizeClass({ "text-sm text-gray-600 dark:text-gray-400 antialiased": !b.contenteditable })
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(b.value), 1)
                      ]),
                      _: 2
                    }, 1032, ["part", "class"])) : (openBlock(), createBlock(unref(_sfc_main$31), {
                      key: 1,
                      part: b.part,
                      class: normalizeClass(["rounded-sm px-0.25 py-0.5 focus:bg-gray-100 focus:outline-hidden data-placeholder:text-gray-600 dark:focus:bg-gray-800 dark:data-placeholder:text-gray-400", {
                        "px-0.5!": b.part === "month" || b.part === "year" || b.part === "day"
                      }]),
                      "aria-label": d(b.part)
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(b.value), 1)
                      ]),
                      _: 2
                    }, 1032, ["part", "class", "aria-label"]))
                  ], 64))), 128))
                ]),
                e.clearable && !e.readOnly ? (openBlock(), createElementBlock("button", {
                  key: 1,
                  onClick: g[0] || (g[0] = (b) => n("update:modelValue", null)),
                  disabled: e.disabled,
                  type: "button",
                  class: "flex items-center justify-center rounded-lg p-2 -me-1 text-gray-300 outline-hidden hover:bg-gray-100 focus:bg-gray-100 active:text-gray-400 dark:hover:bg-gray-900 dark:focus:bg-gray-900",
                  "aria-label": f.__("Clear date")
                }, [
                  createVNode(unref(_sfc_main$1a), {
                    name: "x",
                    class: "size-3"
                  })
                ], 8, _hoisted_4$9)) : createCommentVNode("", !0)
              ], 10, _hoisted_2$v)
            ]),
            _: 1
          }),
          e.inline ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$3a), {
            key: 0,
            "side-offset": 4,
            class: "data-[state=open]:data-[side=top]:animate-slideDownAndFade data-[state=open]:data-[side=right]:animate-slideLeftAndFade data-[state=open]:data-[side=bottom]:animate-slideUpAndFade data-[state=open]:data-[side=left]:animate-slideRightAndFade will-change-[transform,opacity]"
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$1J), { class: "w-[20rem]" }, {
                default: withCtx(() => [
                  createVNode(unref(_sfc_main$1K), mergeProps(o.value, toHandlers(s.value)), null, 16)
                ]),
                _: 1
              })
            ]),
            _: 1
          })),
          e.inline ? (openBlock(), createBlock(unref(_sfc_main$1J), {
            key: 1,
            class: "mt-2"
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$1K), mergeProps(o.value, toHandlers(s.value)), null, 16)
            ]),
            _: 1
          })) : createCommentVNode("", !0)
        ]),
        _: 1
      }, 16, ["modelValue", "granularity", "locale", "disabled", "aria-label", "aria-required"])
    ]));
  }
}, _hoisted_1$S = {
  class: "group/input relative block w-full",
  "data-ui-input": ""
}, _sfc_main$1q = {
  __name: "DateRangePicker",
  props: {
    date: { type: String, default: null },
    badge: { type: String, default: null },
    required: { type: Boolean, default: !1 },
    modelValue: { type: [Object, String], default: null },
    min: { type: [String, Object], default: null },
    max: { type: [String, Object], default: null },
    granularity: { type: String, default: null },
    inline: { type: Boolean, default: !1 },
    clearable: { type: Boolean, default: !0 },
    disabled: { type: Boolean, default: !1 },
    readOnly: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = computed(() => ({
      modelValue: a.modelValue,
      min: a.min,
      max: a.max,
      components: {
        Root: _sfc_main$2U,
        Header: _sfc_main$2C,
        Heading: _sfc_main$2A,
        Prev: _sfc_main$2v,
        Next: _sfc_main$2x,
        Grid: _sfc_main$2M,
        GridHead: _sfc_main$2I,
        GridBody: _sfc_main$2K,
        GridRow: _sfc_main$2G,
        HeadCell: _sfc_main$2E,
        Cell: _sfc_main$2S,
        CellTrigger: _sfc_main$2Q
      }
    })), s = $fae977aafc393c5c$export$8e384432362ed0f0((/* @__PURE__ */ new Date()).toISOString()), u = computed(() => ({
      "update:model-value": (d) => n("update:modelValue", d)
    }));
    return (d, f) => (openBlock(), createElementBlock("div", _hoisted_1$S, [
      createVNode(unref(_sfc_main$2W), mergeProps({
        modelValue: e.modelValue,
        granularity: e.granularity,
        locale: d.$date.locale,
        disabled: e.disabled || e.readOnly,
        "onUpdate:modelValue": f[1] || (f[1] = (g) => n("update:modelValue", g))
      }, d.$attrs, {
        "prevent-deselect": "",
        "hide-time-zone": "",
        placeholder: unref(s)
      }), {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$2O), { class: "w-full" }, {
            default: withCtx(({ segments: g }) => [
              createElementVNode("div", {
                class: normalizeClass([
                  "flex w-full bg-white dark:bg-gray-900",
                  "border border-gray-300 dark:border-x-0 dark:border-t-0 dark:border-white/10 dark:inset-shadow-2xs dark:inset-shadow-black",
                  "leading-[1.375rem] text-gray-600 dark:text-gray-300",
                  "shadow-ui-sm not-prose h-10 rounded-lg py-2 px-3 disabled:shadow-none",
                  "data-invalid:border-red-500",
                  "disabled:shadow-none disabled:opacity-50",
                  e.readOnly ? "border-dashed" : ""
                ])
              }, [
                e.inline ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$2u), { key: 0 }, {
                  default: withCtx(() => [
                    createVNode(unref(Button), {
                      as: "div",
                      variant: "ghost",
                      size: "sm",
                      icon: "calendar",
                      class: "-my-1.25 -ms-2"
                    })
                  ]),
                  _: 1
                })),
                (openBlock(!0), createElementBlock(Fragment, null, renderList(g.start, (v) => (openBlock(), createElementBlock(Fragment, {
                  key: v.part
                }, [
                  v.part === "literal" ? (openBlock(), createBlock(unref(_sfc_main$2z), {
                    key: 0,
                    part: v.part,
                    type: "start"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(v.value), 1)
                    ]),
                    _: 2
                  }, 1032, ["part"])) : (openBlock(), createBlock(unref(_sfc_main$2z), {
                    key: 1,
                    part: v.part,
                    class: normalizeClass(["rounded-sm px-0.25 py-0.5 focus:bg-gray-50 focus:outline-hidden data-placeholder:text-gray-600 dark:focus:bg-gray-800 dark:data-placeholder:text-gray-400", {
                      "px-0.5!": v.part === "month" || v.part === "year" || v.part === "day"
                    }]),
                    type: "start"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(v.value), 1)
                    ]),
                    _: 2
                  }, 1032, ["part", "class"]))
                ], 64))), 128)),
                f[2] || (f[2] = createElementVNode("span", { class: "mx-1.5 text-gray-400 dark:text-gray-600" }, "", -1)),
                (openBlock(!0), createElementBlock(Fragment, null, renderList(g.end, (v) => (openBlock(), createElementBlock(Fragment, {
                  key: v.part
                }, [
                  v.part === "literal" ? (openBlock(), createBlock(unref(_sfc_main$2z), {
                    key: 0,
                    part: v.part,
                    type: "end"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(v.value), 1)
                    ]),
                    _: 2
                  }, 1032, ["part"])) : (openBlock(), createBlock(unref(_sfc_main$2z), {
                    key: 1,
                    part: v.part,
                    class: normalizeClass(["rounded-sm px-0.25 py-0.5 focus:bg-gray-50 focus:outline-hidden data-placeholder:text-gray-600 dark:focus:bg-gray-800 dark:data-placeholder:text-gray-400", {
                      "px-0.5!": v.part === "month" || v.part === "year" || v.part === "day"
                    }]),
                    type: "end"
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(v.value), 1)
                    ]),
                    _: 2
                  }, 1032, ["part", "class"]))
                ], 64))), 128)),
                f[3] || (f[3] = createElementVNode("div", { class: "flex-1" }, null, -1)),
                e.readOnly ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(Button), {
                  key: 1,
                  onClick: f[0] || (f[0] = (v) => n("update:modelValue", null)),
                  variant: "ghost",
                  size: "sm",
                  icon: "x",
                  class: "-my-1.25 -me-2",
                  disabled: e.disabled
                }, null, 8, ["disabled"]))
              ], 2)
            ]),
            _: 1
          }),
          e.inline ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$2P), {
            key: 0,
            "side-offset": 4,
            class: "data-[state=open]:data-[side=top]:animate-slideDownAndFade data-[state=open]:data-[side=right]:animate-slideLeftAndFade data-[state=open]:data-[side=bottom]:animate-slideUpAndFade data-[state=open]:data-[side=left]:animate-slideRightAndFade will-change-[transform,opacity]"
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$1J), { class: "w-[20rem]" }, {
                default: withCtx(() => [
                  createVNode(unref(_sfc_main$1K), mergeProps(o.value, toHandlers(u.value)), null, 16)
                ]),
                _: 1
              })
            ]),
            _: 1
          })),
          e.inline ? (openBlock(), createBlock(unref(_sfc_main$1J), {
            key: 1,
            class: "mt-2"
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$1K), mergeProps(o.value, toHandlers(u.value)), null, 16)
            ]),
            _: 1
          })) : createCommentVNode("", !0)
        ]),
        _: 1
      }, 16, ["modelValue", "granularity", "locale", "disabled", "placeholder"])
    ]));
  }
}, _hoisted_1$R = {
  class: "text-sm font-normal text-gray-500 dark:text-gray-400 st-text-trim-start [[data-ui-panel-header]_&]:text-gray-600 [&_a]:underline [&_a:hover]:text-gray-700 dark:[&_a:hover]:text-gray-300 [&_code]:px-0.5 [&_code]:rounded-sm",
  "data-ui-description": ""
}, _hoisted_2$u = ["innerHTML"], _sfc_main$1p = {
  __name: "Description",
  props: {
    required: { type: Boolean, default: !1 },
    text: { type: [String, Number, Boolean, null], default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createElementBlock("div", _hoisted_1$R, [
      n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("span", {
        key: 1,
        innerHTML: e.text
      }, null, 8, _hoisted_2$u))
    ]));
  }
}, _sfc_main$1o = {}, _hoisted_1$Q = ["aria-label"];
function _sfc_render$b(e, t) {
  const n = resolveComponent("ui-icon");
  return openBlock(), createElementBlock("button", {
    class: "h-full cursor-grab flex items-center justify-center text-gray-400 dark:text-gray-500 hover:text-gray-700 dark:hover:text-gray-400",
    "data-drag-handle": "",
    "aria-label": e.__("Drag to reorder")
  }, [
    createVNode(n, {
      name: "ui/drag-dots",
      class: "w-[7px] h-[17px]"
    })
  ], 8, _hoisted_1$Q);
}
const DragHandle = /* @__PURE__ */ _export_sfc(_sfc_main$1o, [["render", _sfc_render$b]]), _sfc_main$1n = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Dropdown",
  props: {
    align: { type: String, default: "start" },
    offset: { type: Number, default: 5 },
    side: { type: String, default: "bottom" }
  },
  setup(e) {
    const t = useAttrs(), n = cva({
      base: [
        "rounded-xl min-w-64 bg-gray-50 dark:bg-gray-800 outline-hidden overflow-hidden group z-50",
        "border border-gray-200 dark:border-black shadow-lg popoverAnimation"
      ]
    })({});
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$2s), null, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$2m), {
          "as-child": "",
          "data-ui-dropdown-trigger": ""
        }, {
          default: withCtx(() => [
            renderSlot(a.$slots, "trigger", {}, () => [
              createVNode(unref(Button), mergeProps({
                icon: "ui/dots",
                variant: "ghost",
                size: "sm"
              }, unref(t), {
                "aria-label": a.__("Open dropdown menu")
              }), null, 16, ["aria-label"])
            ])
          ]),
          _: 3
        }),
        createVNode(unref(_sfc_main$2o), null, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$2r), {
              "data-ui-dropdown-content": "",
              class: normalizeClass([unref(n), a.$attrs.class]),
              align: e.align,
              sideOffset: e.offset,
              side: e.side
            }, {
              default: withCtx(() => [
                renderSlot(a.$slots, "default")
              ]),
              _: 3
            }, 8, ["class", "align", "sideOffset", "side"])
          ]),
          _: 3
        })
      ]),
      _: 3
    }));
  }
}), _hoisted_1$P = {
  key: 0,
  class: "flex size-6 items-center justify-center p-1"
}, _hoisted_2$t = { class: "col-start-2 ps-2" }, _sfc_main$1m = {
  __name: "Item",
  props: {
    href: { type: String, default: null },
    target: { type: String, default: "_self" },
    icon: { type: String, default: null },
    text: { type: String, default: null },
    variant: { type: String, default: "default" }
  },
  setup(e) {
    const t = e, a = !!useSlots().default, o = cva({
      base: "col-span-2 grid grid-cols-subgrid items-center rounded-lg px-1 py-1.5 text-sm antialiased text-gray-900 dark:text-gray-300 not-data-disabled:cursor-pointer data-disabled:opacity-50 hover:not-data-disabled:bg-gray-100 dark:hover:not-data-disabled:bg-gray-800 outline-hidden",
      variants: {
        variant: {
          default: "text-gray-700 dark:text-gray-300",
          destructive: "text-red-600"
        }
      }
    })({ variant: t.variant }), s = cva({
      variants: {
        base: "size-3.5!",
        variant: {
          default: "text-gray-500",
          destructive: "text-red-500!"
        }
      }
    })({ variant: t.variant });
    return (u, d) => (openBlock(), createBlock(unref(_sfc_main$2q), {
      class: normalizeClass(unref(o)),
      "data-ui-dropdown-item": "",
      as: e.href ? "a" : "div",
      href: e.href,
      target: e.target
    }, {
      default: withCtx(() => [
        e.icon ? (openBlock(), createElementBlock("div", _hoisted_1$P, [
          createVNode(unref(_sfc_main$1a), {
            name: e.icon,
            class: normalizeClass(unref(s))
          }, null, 8, ["name", "class"])
        ])) : createCommentVNode("", !0),
        createElementVNode("div", _hoisted_2$t, [
          a ? renderSlot(u.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            createTextVNode(toDisplayString(e.text), 1)
          ], 64))
        ])
      ]),
      _: 3
    }, 8, ["class", "as", "href", "target"]));
  }
}, _sfc_main$1l = {
  __name: "Label",
  props: {
    text: { type: String, default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$2p), {
      class: "col-span-2 grid items-center rounded-lg px-2 py-2 text-xs text-gray-400 dark:text-gray-500",
      "data-ui-dropdown-label": ""
    }, {
      default: withCtx(() => [
        n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(e.text), 1)
        ], 64))
      ]),
      _: 3
    }));
  }
}, _sfc_main$1k = {}, _hoisted_1$O = {
  class: "grid grid-cols-[auto_1fr] p-1.5 bg-white border-gray-200 dark:bg-gray-900 dark:border-black rounded-b-xl shadow-ui-xs group-has-data-ui-dropdown-footer:border-b [&_[data-ui-radio-item]]:ps-3 [&_[data-ui-radio-item]]:py-0.5 overflow-hidden z-10",
  "data-ui-dropdown-menu": ""
};
function _sfc_render$a(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$O, [
    renderSlot(e.$slots, "default")
  ]);
}
const DropdownMenu = /* @__PURE__ */ _export_sfc(_sfc_main$1k, [["render", _sfc_render$a]]), _sfc_main$1j = {
  __name: "Separator",
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$2n), { class: "col-span-2 -mx-1.5 my-1 h-px bg-gray-200 dark:bg-black" }));
  }
}, _sfc_main$1i = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Editable",
  props: {
    modelValue: { type: String, default: null },
    startWithEditMode: { type: Boolean, default: !1 },
    submitMode: { type: String, default: "blur" },
    placeholder: { type: String, default: "Enter text..." }
  },
  emits: ["update:modelValue", "cancel", "submit", "edit"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = useAttrs(), u = useTemplateRef("root");
    t({
      edit: f
    });
    function d(g) {
      g === "cancel" && (a("update:modelValue", null), a("cancel")), g === "submit" && a("submit", o.modelValue), g === "edit" && a("edit", o.modelValue);
    }
    function f() {
      u.value.edit();
    }
    return (g, v) => (openBlock(), createBlock(unref(_sfc_main$2l), {
      ref: "root",
      placeholder: e.placeholder,
      startWithEditMode: e.startWithEditMode,
      submitMode: e.submitMode,
      modelValue: e.modelValue,
      "onUpdate:modelValue": v[0] || (v[0] = (b) => a("update:modelValue", b)),
      "onUpdate:state": d
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$2k), null, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$2i)),
            createVNode(unref(_sfc_main$2j), normalizeProps(guardReactiveProps(unref(s))), null, 16)
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["placeholder", "startWithEditMode", "submitMode", "modelValue"]));
  }
}), _hoisted_1$N = {
  class: "text-sm font-normal text-red-600 st-text-trim-start [[data-ui-panel-header]_&]:text-red-600 [&_a]:underline [&_a:hover]:text-red-700 dark:[&_a:hover]:text-red-300",
  "data-ui-error-message": ""
}, _hoisted_2$s = ["innerHTML"], _sfc_main$1h = {
  __name: "ErrorMessage",
  props: {
    text: { type: [String, Number, Boolean, null], default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createElementBlock("div", _hoisted_1$N, [
      n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("span", {
        key: 1,
        innerHTML: e.text
      }, null, 8, _hoisted_2$s))
    ]));
  }
}, _hoisted_1$M = { class: "w-full" }, _hoisted_2$r = { class: "flex-1 mb-4 md:mb-0 me-6 text-start" }, _sfc_main$1g = {
  __name: "Item",
  props: {
    href: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      required: !0
    },
    heading: {
      type: String,
      required: !0
    },
    description: {
      type: String,
      default: ""
    }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => {
      const s = resolveComponent("ui-heading"), u = resolveComponent("ui-description");
      return openBlock(), createElementBlock("li", _hoisted_1$M, [
        (openBlock(), createBlock(resolveDynamicComponent(n ? "div" : e.href ? "a" : "button"), {
          href: e.href,
          class: "w-full flex gap-2 px-3 pt-4 pb-5.5 items-start hover:bg-gray-100 dark:hover:bg-gray-800 rounded-md group"
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$1a), {
              name: e.icon,
              class: "size-6 me-4 mt-1 text-gray-400"
            }, null, 8, ["name"]),
            createElementVNode("div", _hoisted_2$r, [
              createVNode(s, {
                size: "xl",
                level: 3,
                text: e.heading,
                class: "mb-1.5 font-semibold"
              }, null, 8, ["text"]),
              e.description ? (openBlock(), createBlock(u, {
                key: 0,
                text: e.description
              }, null, 8, ["text"])) : createCommentVNode("", !0),
              renderSlot(a.$slots, "default")
            ])
          ]),
          _: 3
        }, 8, ["href"]))
      ]);
    };
  }
}, _hoisted_1$L = { class: "flex flex-wrap [:has(>&)]:p-1.5" }, _sfc_main$1f = {
  __name: "Menu",
  props: {
    heading: {
      type: String,
      required: !0
    },
    description: {
      type: String,
      default: null
    }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$1G), {
      heading: e.heading,
      class: "max-w-md m-auto"
    }, {
      default: withCtx(() => [
        createElementVNode("ul", _hoisted_1$L, [
          renderSlot(t.$slots, "default")
        ])
      ]),
      _: 3
    }, 8, ["heading"]));
  }
};
function _getDefaults() {
  return {
    async: !1,
    breaks: !1,
    extensions: null,
    gfm: !0,
    hooks: null,
    pedantic: !1,
    renderer: null,
    silent: !1,
    tokenizer: null,
    walkTokens: null
  };
}
var _defaults = _getDefaults();
function changeDefaults(e) {
  _defaults = e;
}
var noopTest = { exec: () => null };
function edit(e, t = "") {
  let n = typeof e == "string" ? e : e.source;
  const a = {
    replace: (o, s) => {
      let u = typeof s == "string" ? s : s.source;
      return u = u.replace(other.caret, "$1"), n = n.replace(o, u), a;
    },
    getRegex: () => new RegExp(n, t)
  };
  return a;
}
var other = {
  codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
  outputLinkReplace: /\\([\[\]])/g,
  indentCodeCompensation: /^(\s+)(?:```)/,
  beginningSpace: /^\s+/,
  endingHash: /#$/,
  startingSpaceChar: /^ /,
  endingSpaceChar: / $/,
  nonSpaceChar: /[^ ]/,
  newLineCharGlobal: /\n/g,
  tabCharGlobal: /\t/g,
  multipleSpaceGlobal: /\s+/g,
  blankLine: /^[ \t]*$/,
  doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
  blockquoteStart: /^ {0,3}>/,
  blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
  blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
  listReplaceTabs: /^\t+/,
  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
  listIsTask: /^\[[ xX]\] /,
  listReplaceTask: /^\[[ xX]\] +/,
  anyLine: /\n.*\n/,
  hrefBrackets: /^<(.*)>$/,
  tableDelimiter: /[:|]/,
  tableAlignChars: /^\||\| *$/g,
  tableRowBlankLine: /\n[ \t]*$/,
  tableAlignRight: /^ *-+: *$/,
  tableAlignCenter: /^ *:-+: *$/,
  tableAlignLeft: /^ *:-+ *$/,
  startATag: /^<a /i,
  endATag: /^<\/a>/i,
  startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
  endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
  startAngleBracket: /^</,
  endAngleBracket: />$/,
  pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
  unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
  escapeTest: /[&<>"']/,
  escapeReplace: /[&<>"']/g,
  escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
  escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
  unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,
  caret: /(^|[^\[])\^/g,
  percentDecode: /%25/g,
  findPipe: /\|/g,
  splitPipe: / \|/,
  slashPipe: /\\\|/g,
  carriageReturn: /\r\n|\r/g,
  spaceLine: /^ +$/gm,
  notSpaceStart: /^\S*/,
  endingNewline: /\n$/,
  listItemRegex: (e) => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),
  nextBulletRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),
  hrRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),
  fencesBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`),
  headingBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`),
  htmlBeginRegex: (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, "i")
}, newline = /^(?:[ \t]*(?:\n|$))+/, blockCode = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, fences = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, bullet = /(?:[*+-]|\d{1,9}[.)])/, lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, lheading = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), lheadingGfm = edit(lheadingCore).replace(/bull/g, bullet).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), _paragraph = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, blockText = /^[^\n]+/, _blockLabel = /(?!\s*\])(?:\\.|[^\[\]\\])+/, def = edit(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", _blockLabel).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), list = edit(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, bullet).getRegex(), _tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", _comment = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, html = edit(
  "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
  "i"
).replace("comment", _comment).replace("tag", _tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), paragraph = edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockquote = edit(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", paragraph).getRegex(), blockNormal = {
  blockquote,
  code: blockCode,
  def,
  fences,
  heading,
  hr,
  html,
  lheading,
  list,
  newline,
  paragraph,
  table: noopTest,
  text: blockText
}, gfmTable = edit(
  "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)"
).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex(), blockGfm = {
  ...blockNormal,
  lheading: lheadingGfm,
  table: gfmTable,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", gfmTable).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", _tag).getRegex()
}, blockPedantic = {
  ...blockNormal,
  html: edit(
    `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`
  ).replace("comment", _comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
  heading: /^(#{1,6})(.*)(?:\n+|$)/,
  fences: noopTest,
  // fences not supported
  lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
  paragraph: edit(_paragraph).replace("hr", hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", lheading).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
}, escape = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, inlineCode = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br = /^( {2,}|\\)\n(?!\s*$)/, inlineText = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, _punctuation = /[\p{P}\p{S}]/u, _punctuationOrSpace = /[\s\p{P}\p{S}]/u, _notPunctuationOrSpace = /[^\s\p{P}\p{S}]/u, punctuation = edit(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, _punctuationOrSpace).getRegex(), _punctuationGfmStrongEm = /(?!~)[\p{P}\p{S}]/u, _punctuationOrSpaceGfmStrongEm = /(?!~)[\s\p{P}\p{S}]/u, _notPunctuationOrSpaceGfmStrongEm = /(?:[^\s\p{P}\p{S}]|~)/u, blockSkip = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g, emStrongLDelimCore = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, emStrongLDelim = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuation).getRegex(), emStrongLDelimGfm = edit(emStrongLDelimCore, "u").replace(/punct/g, _punctuationGfmStrongEm).getRegex(), emStrongRDelimAstCore = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", emStrongRDelimAst = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex(), emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, "gu").replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm).replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm).replace(/punct/g, _punctuationGfmStrongEm).getRegex(), emStrongRDelimUnd = edit(
  "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
  "gu"
).replace(/notPunctSpace/g, _notPunctuationOrSpace).replace(/punctSpace/g, _punctuationOrSpace).replace(/punct/g, _punctuation).getRegex(), anyPunctuation = edit(/\\(punct)/, "gu").replace(/punct/g, _punctuation).getRegex(), autolink = edit(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), _inlineComment = edit(_comment).replace("(?:-->|$)", "-->").getRegex(), tag = edit(
  "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>"
).replace("comment", _inlineComment).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), _inlineLabel = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, link = edit(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", _inlineLabel).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), reflink = edit(/^!?\[(label)\]\[(ref)\]/).replace("label", _inlineLabel).replace("ref", _blockLabel).getRegex(), nolink = edit(/^!?\[(ref)\](?:\[\])?/).replace("ref", _blockLabel).getRegex(), reflinkSearch = edit("reflink|nolink(?!\\()", "g").replace("reflink", reflink).replace("nolink", nolink).getRegex(), inlineNormal = {
  _backpedal: noopTest,
  // only used for GFM url
  anyPunctuation,
  autolink,
  blockSkip,
  br,
  code: inlineCode,
  del: noopTest,
  emStrongLDelim,
  emStrongRDelimAst,
  emStrongRDelimUnd,
  escape,
  link,
  nolink,
  punctuation,
  reflink,
  reflinkSearch,
  tag,
  text: inlineText,
  url: noopTest
}, inlinePedantic = {
  ...inlineNormal,
  link: edit(/^!?\[(label)\]\((.*?)\)/).replace("label", _inlineLabel).getRegex(),
  reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", _inlineLabel).getRegex()
}, inlineGfm = {
  ...inlineNormal,
  emStrongRDelimAst: emStrongRDelimAstGfm,
  emStrongLDelim: emStrongLDelimGfm,
  url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
  _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
  del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
  text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
}, inlineBreaks = {
  ...inlineGfm,
  br: edit(br).replace("{2,}", "*").getRegex(),
  text: edit(inlineGfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
}, block = {
  normal: blockNormal,
  gfm: blockGfm,
  pedantic: blockPedantic
}, inline = {
  normal: inlineNormal,
  gfm: inlineGfm,
  breaks: inlineBreaks,
  pedantic: inlinePedantic
}, escapeReplacements = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
}, getEscapeReplacement = (e) => escapeReplacements[e];
function escape2(e, t) {
  if (t) {
    if (other.escapeTest.test(e))
      return e.replace(other.escapeReplace, getEscapeReplacement);
  } else if (other.escapeTestNoEncode.test(e))
    return e.replace(other.escapeReplaceNoEncode, getEscapeReplacement);
  return e;
}
function cleanUrl(e) {
  try {
    e = encodeURI(e).replace(other.percentDecode, "%");
  } catch {
    return null;
  }
  return e;
}
function splitCells(e, t) {
  const n = e.replace(other.findPipe, (s, u, d) => {
    let f = !1, g = u;
    for (; --g >= 0 && d[g] === "\\"; ) f = !f;
    return f ? "|" : " |";
  }), a = n.split(other.splitPipe);
  let o = 0;
  if (a[0].trim() || a.shift(), a.length > 0 && !a.at(-1)?.trim() && a.pop(), t)
    if (a.length > t)
      a.splice(t);
    else
      for (; a.length < t; ) a.push("");
  for (; o < a.length; o++)
    a[o] = a[o].trim().replace(other.slashPipe, "|");
  return a;
}
function rtrim(e, t, n) {
  const a = e.length;
  if (a === 0)
    return "";
  let o = 0;
  for (; o < a && e.charAt(a - o - 1) === t; )
    o++;
  return e.slice(0, a - o);
}
function findClosingBracket(e, t) {
  if (e.indexOf(t[1]) === -1)
    return -1;
  let n = 0;
  for (let a = 0; a < e.length; a++)
    if (e[a] === "\\")
      a++;
    else if (e[a] === t[0])
      n++;
    else if (e[a] === t[1] && (n--, n < 0))
      return a;
  return n > 0 ? -2 : -1;
}
function outputLink(e, t, n, a, o) {
  const s = t.href, u = t.title || null, d = e[1].replace(o.other.outputLinkReplace, "$1");
  a.state.inLink = !0;
  const f = {
    type: e[0].charAt(0) === "!" ? "image" : "link",
    raw: n,
    href: s,
    title: u,
    text: d,
    tokens: a.inlineTokens(d)
  };
  return a.state.inLink = !1, f;
}
function indentCodeCompensation(e, t, n) {
  const a = e.match(n.other.indentCodeCompensation);
  if (a === null)
    return t;
  const o = a[1];
  return t.split(`
`).map((s) => {
    const u = s.match(n.other.beginningSpace);
    if (u === null)
      return s;
    const [d] = u;
    return d.length >= o.length ? s.slice(o.length) : s;
  }).join(`
`);
}
var _Tokenizer = class {
  options;
  rules;
  // set by the lexer
  lexer;
  // set by the lexer
  constructor(e) {
    this.options = e || _defaults;
  }
  space(e) {
    const t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0)
      return {
        type: "space",
        raw: t[0]
      };
  }
  code(e) {
    const t = this.rules.block.code.exec(e);
    if (t) {
      const n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return {
        type: "code",
        raw: t[0],
        codeBlockStyle: "indented",
        text: this.options.pedantic ? n : rtrim(n, `
`)
      };
    }
  }
  fences(e) {
    const t = this.rules.block.fences.exec(e);
    if (t) {
      const n = t[0], a = indentCodeCompensation(n, t[3] || "", this.rules);
      return {
        type: "code",
        raw: n,
        lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2],
        text: a
      };
    }
  }
  heading(e) {
    const t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        const a = rtrim(n, "#");
        (this.options.pedantic || !a || this.rules.other.endingSpaceChar.test(a)) && (n = a.trim());
      }
      return {
        type: "heading",
        raw: t[0],
        depth: t[1].length,
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  hr(e) {
    const t = this.rules.block.hr.exec(e);
    if (t)
      return {
        type: "hr",
        raw: rtrim(t[0], `
`)
      };
  }
  blockquote(e) {
    const t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = rtrim(t[0], `
`).split(`
`), a = "", o = "";
      const s = [];
      for (; n.length > 0; ) {
        let u = !1;
        const d = [];
        let f;
        for (f = 0; f < n.length; f++)
          if (this.rules.other.blockquoteStart.test(n[f]))
            d.push(n[f]), u = !0;
          else if (!u)
            d.push(n[f]);
          else
            break;
        n = n.slice(f);
        const g = d.join(`
`), v = g.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        a = a ? `${a}
${g}` : g, o = o ? `${o}
${v}` : v;
        const b = this.lexer.state.top;
        if (this.lexer.state.top = !0, this.lexer.blockTokens(v, s, !0), this.lexer.state.top = b, n.length === 0)
          break;
        const w = s.at(-1);
        if (w?.type === "code")
          break;
        if (w?.type === "blockquote") {
          const C = w, k = C.raw + `
` + n.join(`
`), E = this.blockquote(k);
          s[s.length - 1] = E, a = a.substring(0, a.length - C.raw.length) + E.raw, o = o.substring(0, o.length - C.text.length) + E.text;
          break;
        } else if (w?.type === "list") {
          const C = w, k = C.raw + `
` + n.join(`
`), E = this.list(k);
          s[s.length - 1] = E, a = a.substring(0, a.length - w.raw.length) + E.raw, o = o.substring(0, o.length - C.raw.length) + E.raw, n = k.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return {
        type: "blockquote",
        raw: a,
        tokens: s,
        text: o
      };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim();
      const a = n.length > 1, o = {
        type: "list",
        raw: "",
        ordered: a,
        start: a ? +n.slice(0, -1) : "",
        loose: !1,
        items: []
      };
      n = a ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = a ? n : "[*+-]");
      const s = this.rules.other.listItemRegex(n);
      let u = !1;
      for (; e; ) {
        let f = !1, g = "", v = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e))
          break;
        g = t[0], e = e.substring(g.length);
        let b = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (P) => " ".repeat(3 * P.length)), w = e.split(`
`, 1)[0], C = !b.trim(), k = 0;
        if (this.options.pedantic ? (k = 2, v = b.trimStart()) : C ? k = t[1].length + 1 : (k = t[2].search(this.rules.other.nonSpaceChar), k = k > 4 ? 1 : k, v = b.slice(k), k += t[1].length), C && this.rules.other.blankLine.test(w) && (g += w + `
`, e = e.substring(w.length + 1), f = !0), !f) {
          const P = this.rules.other.nextBulletRegex(k), M = this.rules.other.hrRegex(k), B = this.rules.other.fencesBeginRegex(k), _ = this.rules.other.headingBeginRegex(k), T = this.rules.other.htmlBeginRegex(k);
          for (; e; ) {
            const O = e.split(`
`, 1)[0];
            let I;
            if (w = O, this.options.pedantic ? (w = w.replace(this.rules.other.listReplaceNesting, "  "), I = w) : I = w.replace(this.rules.other.tabCharGlobal, "    "), B.test(w) || _.test(w) || T.test(w) || P.test(w) || M.test(w))
              break;
            if (I.search(this.rules.other.nonSpaceChar) >= k || !w.trim())
              v += `
` + I.slice(k);
            else {
              if (C || b.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || B.test(b) || _.test(b) || M.test(b))
                break;
              v += `
` + w;
            }
            !C && !w.trim() && (C = !0), g += O + `
`, e = e.substring(O.length + 1), b = I.slice(k);
          }
        }
        o.loose || (u ? o.loose = !0 : this.rules.other.doubleBlankLine.test(g) && (u = !0));
        let E = null, A;
        this.options.gfm && (E = this.rules.other.listIsTask.exec(v), E && (A = E[0] !== "[ ] ", v = v.replace(this.rules.other.listReplaceTask, ""))), o.items.push({
          type: "list_item",
          raw: g,
          task: !!E,
          checked: A,
          loose: !1,
          text: v,
          tokens: []
        }), o.raw += g;
      }
      const d = o.items.at(-1);
      if (d)
        d.raw = d.raw.trimEnd(), d.text = d.text.trimEnd();
      else
        return;
      o.raw = o.raw.trimEnd();
      for (let f = 0; f < o.items.length; f++)
        if (this.lexer.state.top = !1, o.items[f].tokens = this.lexer.blockTokens(o.items[f].text, []), !o.loose) {
          const g = o.items[f].tokens.filter((b) => b.type === "space"), v = g.length > 0 && g.some((b) => this.rules.other.anyLine.test(b.raw));
          o.loose = v;
        }
      if (o.loose)
        for (let f = 0; f < o.items.length; f++)
          o.items[f].loose = !0;
      return o;
    }
  }
  html(e) {
    const t = this.rules.block.html.exec(e);
    if (t)
      return {
        type: "html",
        block: !0,
        raw: t[0],
        pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
        text: t[0]
      };
  }
  def(e) {
    const t = this.rules.block.def.exec(e);
    if (t) {
      const n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), a = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", o = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return {
        type: "def",
        tag: n,
        raw: t[0],
        href: a,
        title: o
      };
    }
  }
  table(e) {
    const t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2]))
      return;
    const n = splitCells(t[1]), a = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), o = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = {
      type: "table",
      raw: t[0],
      header: [],
      align: [],
      rows: []
    };
    if (n.length === a.length) {
      for (const u of a)
        this.rules.other.tableAlignRight.test(u) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(u) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(u) ? s.align.push("left") : s.align.push(null);
      for (let u = 0; u < n.length; u++)
        s.header.push({
          text: n[u],
          tokens: this.lexer.inline(n[u]),
          header: !0,
          align: s.align[u]
        });
      for (const u of o)
        s.rows.push(splitCells(u, s.header.length).map((d, f) => ({
          text: d,
          tokens: this.lexer.inline(d),
          header: !1,
          align: s.align[f]
        })));
      return s;
    }
  }
  lheading(e) {
    const t = this.rules.block.lheading.exec(e);
    if (t)
      return {
        type: "heading",
        raw: t[0],
        depth: t[2].charAt(0) === "=" ? 1 : 2,
        text: t[1],
        tokens: this.lexer.inline(t[1])
      };
  }
  paragraph(e) {
    const t = this.rules.block.paragraph.exec(e);
    if (t) {
      const n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return {
        type: "paragraph",
        raw: t[0],
        text: n,
        tokens: this.lexer.inline(n)
      };
    }
  }
  text(e) {
    const t = this.rules.block.text.exec(e);
    if (t)
      return {
        type: "text",
        raw: t[0],
        text: t[0],
        tokens: this.lexer.inline(t[0])
      };
  }
  escape(e) {
    const t = this.rules.inline.escape.exec(e);
    if (t)
      return {
        type: "escape",
        raw: t[0],
        text: t[1]
      };
  }
  tag(e) {
    const t = this.rules.inline.tag.exec(e);
    if (t)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = !1), {
        type: "html",
        raw: t[0],
        inLink: this.lexer.state.inLink,
        inRawBlock: this.lexer.state.inRawBlock,
        block: !1,
        text: t[0]
      };
  }
  link(e) {
    const t = this.rules.inline.link.exec(e);
    if (t) {
      const n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n))
          return;
        const s = rtrim(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0)
          return;
      } else {
        const s = findClosingBracket(t[2], "()");
        if (s === -2)
          return;
        if (s > -1) {
          const d = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, d).trim(), t[3] = "";
        }
      }
      let a = t[2], o = "";
      if (this.options.pedantic) {
        const s = this.rules.other.pedanticHrefTitle.exec(a);
        s && (a = s[1], o = s[3]);
      } else
        o = t[3] ? t[3].slice(1, -1) : "";
      return a = a.trim(), this.rules.other.startAngleBracket.test(a) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? a = a.slice(1) : a = a.slice(1, -1)), outputLink(t, {
        href: a && a.replace(this.rules.inline.anyPunctuation, "$1"),
        title: o && o.replace(this.rules.inline.anyPunctuation, "$1")
      }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      const a = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), o = t[a.toLowerCase()];
      if (!o) {
        const s = n[0].charAt(0);
        return {
          type: "text",
          raw: s,
          text: s
        };
      }
      return outputLink(n, o, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let a = this.rules.inline.emStrongLDelim.exec(e);
    if (!a || a[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(a[1] || a[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      const s = [...a[0]].length - 1;
      let u, d, f = s, g = 0;
      const v = a[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (v.lastIndex = 0, t = t.slice(-1 * e.length + s); (a = v.exec(t)) != null; ) {
        if (u = a[1] || a[2] || a[3] || a[4] || a[5] || a[6], !u) continue;
        if (d = [...u].length, a[3] || a[4]) {
          f += d;
          continue;
        } else if ((a[5] || a[6]) && s % 3 && !((s + d) % 3)) {
          g += d;
          continue;
        }
        if (f -= d, f > 0) continue;
        d = Math.min(d, d + f + g);
        const b = [...a[0]][0].length, w = e.slice(0, s + a.index + b + d);
        if (Math.min(s, d) % 2) {
          const k = w.slice(1, -1);
          return {
            type: "em",
            raw: w,
            text: k,
            tokens: this.lexer.inlineTokens(k)
          };
        }
        const C = w.slice(2, -2);
        return {
          type: "strong",
          raw: w,
          text: C,
          tokens: this.lexer.inlineTokens(C)
        };
      }
    }
  }
  codespan(e) {
    const t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " ");
      const a = this.rules.other.nonSpaceChar.test(n), o = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return a && o && (n = n.substring(1, n.length - 1)), {
        type: "codespan",
        raw: t[0],
        text: n
      };
    }
  }
  br(e) {
    const t = this.rules.inline.br.exec(e);
    if (t)
      return {
        type: "br",
        raw: t[0]
      };
  }
  del(e) {
    const t = this.rules.inline.del.exec(e);
    if (t)
      return {
        type: "del",
        raw: t[0],
        text: t[2],
        tokens: this.lexer.inlineTokens(t[2])
      };
  }
  autolink(e) {
    const t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, a;
      return t[2] === "@" ? (n = t[1], a = "mailto:" + n) : (n = t[1], a = n), {
        type: "link",
        raw: t[0],
        text: n,
        href: a,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, a;
      if (t[2] === "@")
        n = t[0], a = "mailto:" + n;
      else {
        let o;
        do
          o = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (o !== t[0]);
        n = t[0], t[1] === "www." ? a = "http://" + t[0] : a = t[0];
      }
      return {
        type: "link",
        raw: t[0],
        text: n,
        href: a,
        tokens: [
          {
            type: "text",
            raw: n,
            text: n
          }
        ]
      };
    }
  }
  inlineText(e) {
    const t = this.rules.inline.text.exec(e);
    if (t) {
      const n = this.lexer.state.inRawBlock;
      return {
        type: "text",
        raw: t[0],
        text: t[0],
        escaped: n
      };
    }
  }
}, _Lexer = class oo {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(t) {
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = t || _defaults, this.options.tokenizer = this.options.tokenizer || new _Tokenizer(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
      inLink: !1,
      inRawBlock: !1,
      top: !0
    };
    const n = {
      other,
      block: block.normal,
      inline: inline.normal
    };
    this.options.pedantic ? (n.block = block.pedantic, n.inline = inline.pedantic) : this.options.gfm && (n.block = block.gfm, this.options.breaks ? n.inline = inline.breaks : n.inline = inline.gfm), this.tokenizer.rules = n;
  }
  /**
   * Expose Rules
   */
  static get rules() {
    return {
      block,
      inline
    };
  }
  /**
   * Static Lex Method
   */
  static lex(t, n) {
    return new oo(n).lex(t);
  }
  /**
   * Static Lex Inline Method
   */
  static lexInline(t, n) {
    return new oo(n).inlineTokens(t);
  }
  /**
   * Preprocessing
   */
  lex(t) {
    t = t.replace(other.carriageReturn, `
`), this.blockTokens(t, this.tokens);
    for (let n = 0; n < this.inlineQueue.length; n++) {
      const a = this.inlineQueue[n];
      this.inlineTokens(a.src, a.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(t, n = [], a = !1) {
    for (this.options.pedantic && (t = t.replace(other.tabCharGlobal, "    ").replace(other.spaceLine, "")); t; ) {
      let o;
      if (this.options.extensions?.block?.some((u) => (o = u.call({ lexer: this }, t, n)) ? (t = t.substring(o.raw.length), n.push(o), !0) : !1))
        continue;
      if (o = this.tokenizer.space(t)) {
        t = t.substring(o.raw.length);
        const u = n.at(-1);
        o.raw.length === 1 && u !== void 0 ? u.raw += `
` : n.push(o);
        continue;
      }
      if (o = this.tokenizer.code(t)) {
        t = t.substring(o.raw.length);
        const u = n.at(-1);
        u?.type === "paragraph" || u?.type === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.at(-1).src = u.text) : n.push(o);
        continue;
      }
      if (o = this.tokenizer.fences(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.heading(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.hr(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.blockquote(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.list(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.html(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.def(t)) {
        t = t.substring(o.raw.length);
        const u = n.at(-1);
        u?.type === "paragraph" || u?.type === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.raw, this.inlineQueue.at(-1).src = u.text) : this.tokens.links[o.tag] || (this.tokens.links[o.tag] = {
          href: o.href,
          title: o.title
        });
        continue;
      }
      if (o = this.tokenizer.table(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      if (o = this.tokenizer.lheading(t)) {
        t = t.substring(o.raw.length), n.push(o);
        continue;
      }
      let s = t;
      if (this.options.extensions?.startBlock) {
        let u = 1 / 0;
        const d = t.slice(1);
        let f;
        this.options.extensions.startBlock.forEach((g) => {
          f = g.call({ lexer: this }, d), typeof f == "number" && f >= 0 && (u = Math.min(u, f));
        }), u < 1 / 0 && u >= 0 && (s = t.substring(0, u + 1));
      }
      if (this.state.top && (o = this.tokenizer.paragraph(s))) {
        const u = n.at(-1);
        a && u?.type === "paragraph" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : n.push(o), a = s.length !== t.length, t = t.substring(o.raw.length);
        continue;
      }
      if (o = this.tokenizer.text(t)) {
        t = t.substring(o.raw.length);
        const u = n.at(-1);
        u?.type === "text" ? (u.raw += `
` + o.raw, u.text += `
` + o.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = u.text) : n.push(o);
        continue;
      }
      if (t) {
        const u = "Infinite loop on byte: " + t.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else
          throw new Error(u);
      }
    }
    return this.state.top = !0, n;
  }
  inline(t, n = []) {
    return this.inlineQueue.push({ src: t, tokens: n }), n;
  }
  /**
   * Lexing/Compiling
   */
  inlineTokens(t, n = []) {
    let a = t, o = null;
    if (this.tokens.links) {
      const d = Object.keys(this.tokens.links);
      if (d.length > 0)
        for (; (o = this.tokenizer.rules.inline.reflinkSearch.exec(a)) != null; )
          d.includes(o[0].slice(o[0].lastIndexOf("[") + 1, -1)) && (a = a.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + a.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (o = this.tokenizer.rules.inline.anyPunctuation.exec(a)) != null; )
      a = a.slice(0, o.index) + "++" + a.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (o = this.tokenizer.rules.inline.blockSkip.exec(a)) != null; )
      a = a.slice(0, o.index) + "[" + "a".repeat(o[0].length - 2) + "]" + a.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let s = !1, u = "";
    for (; t; ) {
      s || (u = ""), s = !1;
      let d;
      if (this.options.extensions?.inline?.some((g) => (d = g.call({ lexer: this }, t, n)) ? (t = t.substring(d.raw.length), n.push(d), !0) : !1))
        continue;
      if (d = this.tokenizer.escape(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.tag(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.link(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.reflink(t, this.tokens.links)) {
        t = t.substring(d.raw.length);
        const g = n.at(-1);
        d.type === "text" && g?.type === "text" ? (g.raw += d.raw, g.text += d.text) : n.push(d);
        continue;
      }
      if (d = this.tokenizer.emStrong(t, a, u)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.codespan(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.br(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.del(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (d = this.tokenizer.autolink(t)) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      if (!this.state.inLink && (d = this.tokenizer.url(t))) {
        t = t.substring(d.raw.length), n.push(d);
        continue;
      }
      let f = t;
      if (this.options.extensions?.startInline) {
        let g = 1 / 0;
        const v = t.slice(1);
        let b;
        this.options.extensions.startInline.forEach((w) => {
          b = w.call({ lexer: this }, v), typeof b == "number" && b >= 0 && (g = Math.min(g, b));
        }), g < 1 / 0 && g >= 0 && (f = t.substring(0, g + 1));
      }
      if (d = this.tokenizer.inlineText(f)) {
        t = t.substring(d.raw.length), d.raw.slice(-1) !== "_" && (u = d.raw.slice(-1)), s = !0;
        const g = n.at(-1);
        g?.type === "text" ? (g.raw += d.raw, g.text += d.text) : n.push(d);
        continue;
      }
      if (t) {
        const g = "Infinite loop on byte: " + t.charCodeAt(0);
        if (this.options.silent) {
          console.error(g);
          break;
        } else
          throw new Error(g);
      }
    }
    return n;
  }
}, _Renderer = class {
  options;
  parser;
  // set by the parser
  constructor(e) {
    this.options = e || _defaults;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    const a = (t || "").match(other.notSpaceStart)?.[0], o = e.replace(other.endingNewline, "") + `
`;
    return a ? '<pre><code class="language-' + escape2(a) + '">' + (n ? o : escape2(o, !0)) + `</code></pre>
` : "<pre><code>" + (n ? o : escape2(o, !0)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    const t = e.ordered, n = e.start;
    let a = "";
    for (let u = 0; u < e.items.length; u++) {
      const d = e.items[u];
      a += this.listitem(d);
    }
    const o = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + o + s + `>
` + a + "</" + o + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      const n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + escape2(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({
        type: "text",
        raw: n + " ",
        text: n + " ",
        escaped: !0
      }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let o = 0; o < e.header.length; o++)
      n += this.tablecell(e.header[o]);
    t += this.tablerow({ text: n });
    let a = "";
    for (let o = 0; o < e.rows.length; o++) {
      const s = e.rows[o];
      n = "";
      for (let u = 0; u < s.length; u++)
        n += this.tablecell(s[u]);
      a += this.tablerow({ text: n });
    }
    return a && (a = `<tbody>${a}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + a + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    const t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  /**
   * span level renderer
   */
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${escape2(e, !0)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    const a = this.parser.parseInline(n), o = cleanUrl(e);
    if (o === null)
      return a;
    e = o;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + escape2(t) + '"'), s += ">" + a + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: a }) {
    a && (n = this.parser.parseInline(a, this.parser.textRenderer));
    const o = cleanUrl(e);
    if (o === null)
      return escape2(n);
    e = o;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${escape2(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : escape2(e.text);
  }
}, _TextRenderer = class {
  // no need for block level renderers
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
}, _Parser = class so {
  options;
  renderer;
  textRenderer;
  constructor(t) {
    this.options = t || _defaults, this.options.renderer = this.options.renderer || new _Renderer(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new _TextRenderer();
  }
  /**
   * Static Parse Method
   */
  static parse(t, n) {
    return new so(n).parse(t);
  }
  /**
   * Static Parse Inline Method
   */
  static parseInline(t, n) {
    return new so(n).parseInline(t);
  }
  /**
   * Parse Loop
   */
  parse(t, n = !0) {
    let a = "";
    for (let o = 0; o < t.length; o++) {
      const s = t[o];
      if (this.options.extensions?.renderers?.[s.type]) {
        const d = s, f = this.options.extensions.renderers[d.type].call({ parser: this }, d);
        if (f !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(d.type)) {
          a += f || "";
          continue;
        }
      }
      const u = s;
      switch (u.type) {
        case "space": {
          a += this.renderer.space(u);
          continue;
        }
        case "hr": {
          a += this.renderer.hr(u);
          continue;
        }
        case "heading": {
          a += this.renderer.heading(u);
          continue;
        }
        case "code": {
          a += this.renderer.code(u);
          continue;
        }
        case "table": {
          a += this.renderer.table(u);
          continue;
        }
        case "blockquote": {
          a += this.renderer.blockquote(u);
          continue;
        }
        case "list": {
          a += this.renderer.list(u);
          continue;
        }
        case "html": {
          a += this.renderer.html(u);
          continue;
        }
        case "paragraph": {
          a += this.renderer.paragraph(u);
          continue;
        }
        case "text": {
          let d = u, f = this.renderer.text(d);
          for (; o + 1 < t.length && t[o + 1].type === "text"; )
            d = t[++o], f += `
` + this.renderer.text(d);
          n ? a += this.renderer.paragraph({
            type: "paragraph",
            raw: f,
            text: f,
            tokens: [{ type: "text", raw: f, text: f, escaped: !0 }]
          }) : a += f;
          continue;
        }
        default: {
          const d = 'Token with "' + u.type + '" type was not found.';
          if (this.options.silent)
            return console.error(d), "";
          throw new Error(d);
        }
      }
    }
    return a;
  }
  /**
   * Parse Inline Tokens
   */
  parseInline(t, n = this.renderer) {
    let a = "";
    for (let o = 0; o < t.length; o++) {
      const s = t[o];
      if (this.options.extensions?.renderers?.[s.type]) {
        const d = this.options.extensions.renderers[s.type].call({ parser: this }, s);
        if (d !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(s.type)) {
          a += d || "";
          continue;
        }
      }
      const u = s;
      switch (u.type) {
        case "escape": {
          a += n.text(u);
          break;
        }
        case "html": {
          a += n.html(u);
          break;
        }
        case "link": {
          a += n.link(u);
          break;
        }
        case "image": {
          a += n.image(u);
          break;
        }
        case "strong": {
          a += n.strong(u);
          break;
        }
        case "em": {
          a += n.em(u);
          break;
        }
        case "codespan": {
          a += n.codespan(u);
          break;
        }
        case "br": {
          a += n.br(u);
          break;
        }
        case "del": {
          a += n.del(u);
          break;
        }
        case "text": {
          a += n.text(u);
          break;
        }
        default: {
          const d = 'Token with "' + u.type + '" type was not found.';
          if (this.options.silent)
            return console.error(d), "";
          throw new Error(d);
        }
      }
    }
    return a;
  }
}, _Hooks = class {
  options;
  block;
  constructor(e) {
    this.options = e || _defaults;
  }
  static passThroughHooks = /* @__PURE__ */ new Set([
    "preprocess",
    "postprocess",
    "processAllTokens"
  ]);
  /**
   * Process markdown before marked
   */
  preprocess(e) {
    return e;
  }
  /**
   * Process HTML after marked is finished
   */
  postprocess(e) {
    return e;
  }
  /**
   * Process all tokens before walk tokens
   */
  processAllTokens(e) {
    return e;
  }
  /**
   * Provide function to tokenize markdown
   */
  provideLexer() {
    return this.block ? _Lexer.lex : _Lexer.lexInline;
  }
  /**
   * Provide function to parse tokens
   */
  provideParser() {
    return this.block ? _Parser.parse : _Parser.parseInline;
  }
}, Marked = class {
  defaults = _getDefaults();
  options = this.setOptions;
  parse = this.parseMarkdown(!0);
  parseInline = this.parseMarkdown(!1);
  Parser = _Parser;
  Renderer = _Renderer;
  TextRenderer = _TextRenderer;
  Lexer = _Lexer;
  Tokenizer = _Tokenizer;
  Hooks = _Hooks;
  constructor(...e) {
    this.use(...e);
  }
  /**
   * Run callback for every token
   */
  walkTokens(e, t) {
    let n = [];
    for (const a of e)
      switch (n = n.concat(t.call(this, a)), a.type) {
        case "table": {
          const o = a;
          for (const s of o.header)
            n = n.concat(this.walkTokens(s.tokens, t));
          for (const s of o.rows)
            for (const u of s)
              n = n.concat(this.walkTokens(u.tokens, t));
          break;
        }
        case "list": {
          const o = a;
          n = n.concat(this.walkTokens(o.items, t));
          break;
        }
        default: {
          const o = a;
          this.defaults.extensions?.childTokens?.[o.type] ? this.defaults.extensions.childTokens[o.type].forEach((s) => {
            const u = o[s].flat(1 / 0);
            n = n.concat(this.walkTokens(u, t));
          }) : o.tokens && (n = n.concat(this.walkTokens(o.tokens, t)));
        }
      }
    return n;
  }
  use(...e) {
    const t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      const a = { ...n };
      if (a.async = this.defaults.async || a.async || !1, n.extensions && (n.extensions.forEach((o) => {
        if (!o.name)
          throw new Error("extension name required");
        if ("renderer" in o) {
          const s = t.renderers[o.name];
          s ? t.renderers[o.name] = function(...u) {
            let d = o.renderer.apply(this, u);
            return d === !1 && (d = s.apply(this, u)), d;
          } : t.renderers[o.name] = o.renderer;
        }
        if ("tokenizer" in o) {
          if (!o.level || o.level !== "block" && o.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          const s = t[o.level];
          s ? s.unshift(o.tokenizer) : t[o.level] = [o.tokenizer], o.start && (o.level === "block" ? t.startBlock ? t.startBlock.push(o.start) : t.startBlock = [o.start] : o.level === "inline" && (t.startInline ? t.startInline.push(o.start) : t.startInline = [o.start]));
        }
        "childTokens" in o && o.childTokens && (t.childTokens[o.name] = o.childTokens);
      }), a.extensions = t), n.renderer) {
        const o = this.defaults.renderer || new _Renderer(this.defaults);
        for (const s in n.renderer) {
          if (!(s in o))
            throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s))
            continue;
          const u = s, d = n.renderer[u], f = o[u];
          o[u] = (...g) => {
            let v = d.apply(o, g);
            return v === !1 && (v = f.apply(o, g)), v || "";
          };
        }
        a.renderer = o;
      }
      if (n.tokenizer) {
        const o = this.defaults.tokenizer || new _Tokenizer(this.defaults);
        for (const s in n.tokenizer) {
          if (!(s in o))
            throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s))
            continue;
          const u = s, d = n.tokenizer[u], f = o[u];
          o[u] = (...g) => {
            let v = d.apply(o, g);
            return v === !1 && (v = f.apply(o, g)), v;
          };
        }
        a.tokenizer = o;
      }
      if (n.hooks) {
        const o = this.defaults.hooks || new _Hooks();
        for (const s in n.hooks) {
          if (!(s in o))
            throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s))
            continue;
          const u = s, d = n.hooks[u], f = o[u];
          _Hooks.passThroughHooks.has(s) ? o[u] = (g) => {
            if (this.defaults.async)
              return Promise.resolve(d.call(o, g)).then((b) => f.call(o, b));
            const v = d.call(o, g);
            return f.call(o, v);
          } : o[u] = (...g) => {
            let v = d.apply(o, g);
            return v === !1 && (v = f.apply(o, g)), v;
          };
        }
        a.hooks = o;
      }
      if (n.walkTokens) {
        const o = this.defaults.walkTokens, s = n.walkTokens;
        a.walkTokens = function(u) {
          let d = [];
          return d.push(s.call(this, u)), o && (d = d.concat(o.call(this, u))), d;
        };
      }
      this.defaults = { ...this.defaults, ...a };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return _Lexer.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return _Parser.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, a) => {
      const o = { ...a }, s = { ...this.defaults, ...o }, u = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === !0 && o.async === !1)
        return u(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null)
        return u(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string")
        return u(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      s.hooks && (s.hooks.options = s, s.hooks.block = e);
      const d = s.hooks ? s.hooks.provideLexer() : e ? _Lexer.lex : _Lexer.lexInline, f = s.hooks ? s.hooks.provideParser() : e ? _Parser.parse : _Parser.parseInline;
      if (s.async)
        return Promise.resolve(s.hooks ? s.hooks.preprocess(n) : n).then((g) => d(g, s)).then((g) => s.hooks ? s.hooks.processAllTokens(g) : g).then((g) => s.walkTokens ? Promise.all(this.walkTokens(g, s.walkTokens)).then(() => g) : g).then((g) => f(g, s)).then((g) => s.hooks ? s.hooks.postprocess(g) : g).catch(u);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let g = d(n, s);
        s.hooks && (g = s.hooks.processAllTokens(g)), s.walkTokens && this.walkTokens(g, s.walkTokens);
        let v = f(g, s);
        return s.hooks && (v = s.hooks.postprocess(v)), v;
      } catch (g) {
        return u(g);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        const a = "<p>An error occurred:</p><pre>" + escape2(n.message + "", !0) + "</pre>";
        return t ? Promise.resolve(a) : a;
      }
      if (t)
        return Promise.reject(n);
      throw n;
    };
  }
}, markedInstance = new Marked();
function marked(e, t) {
  return markedInstance.parse(e, t);
}
marked.options = marked.setOptions = function(e) {
  return markedInstance.setOptions(e), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.getDefaults = _getDefaults;
marked.defaults = _defaults;
marked.use = function(...e) {
  return markedInstance.use(...e), marked.defaults = markedInstance.defaults, changeDefaults(marked.defaults), marked;
};
marked.walkTokens = function(e, t) {
  return markedInstance.walkTokens(e, t);
};
marked.parseInline = markedInstance.parseInline;
marked.Parser = _Parser;
marked.parser = _Parser.parse;
marked.Renderer = _Renderer;
marked.TextRenderer = _TextRenderer;
marked.Lexer = _Lexer;
marked.lexer = _Lexer.lex;
marked.Tokenizer = _Tokenizer;
marked.Hooks = _Hooks;
marked.parse = marked;
marked.options;
marked.setOptions;
marked.use;
marked.walkTokens;
marked.parseInline;
_Parser.parse;
_Lexer.lex;
function markdown$1(e, t = {}) {
  if (!e) return "";
  const n = new marked.Renderer();
  return t.openLinksInNewTabs && (n.link = function(a, o, s) {
    return marked.Renderer.prototype.link.call(this, a, o, s).replace("<a", "<a target='_blank' ");
  }), marked.parse(e, { renderer: n });
}
const _sfc_main$1e = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Field",
  props: {
    as: { type: String, default: "div", validator: (e) => ["div", "card"].includes(e) },
    badge: { type: String, default: "" },
    disabled: { type: Boolean, default: !1 },
    readOnly: { type: Boolean, default: !1 },
    error: { type: String },
    errors: { type: Object, default: (e) => e.error ? [e.error] : [] },
    id: { type: String },
    instructions: { type: String, default: "" },
    instructionsBelow: { type: Boolean, default: !1 },
    label: { type: String },
    required: { type: Boolean, default: !1 },
    variant: { type: String, default: "block" }
  },
  setup(e) {
    const t = e, n = computed(() => ({
      badge: t.badge,
      for: t.id,
      required: t.required,
      text: t.label
    })), a = computed(
      () => cva({
        base: [
          "min-w-0"
        ],
        variants: {
          variant: {
            block: "w-full",
            inline: [
              "flex justify-between gap-x-7 gap-y-1.5",
              "has-[[data-ui-label]~[data-ui-control]]:grid-cols-[1fr_auto]",
              "has-[[data-ui-control]~[data-ui-label]]:grid-cols-[auto_1fr]",
              "[&>[data-ui-control]~[data-ui-description]]:row-start-2 [&>[data-ui-control]~[data-ui-description]]:col-start-2",
              "[&>[data-ui-label]~[data-ui-control]]:row-start-1 [&>[data-ui-label]~[data-ui-control]]:col-start-2"
            ]
          },
          disabled: {
            true: "opacity-50"
          }
        }
      })({ ...t })
    ), o = computed(() => t.instructions ? markdown$1(__(t.instructions), { openLinksInNewTabs: !0 }) : null), s = computed(() => t.as === "card" ? _sfc_main$1J : "div");
    return (u, d) => (openBlock(), createBlock(resolveDynamicComponent(s.value), {
      class: normalizeClass([a.value, u.$attrs.class]),
      "data-ui-input-group": ""
    }, {
      default: withCtx(() => [
        u.$slots.actions ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([
            "flex items-center gap-x-1",
            t.label || u.$slots.label ? "justify-between" : "justify-end"
          ]),
          "data-ui-field-header": ""
        }, [
          renderSlot(u.$slots, "label", {}, () => [
            e.label ? (openBlock(), createBlock(unref(_sfc_main$18), mergeProps({ key: 0 }, n.value, { class: "flex-1" }), null, 16)) : createCommentVNode("", !0)
          ]),
          renderSlot(u.$slots, "actions")
        ], 2)) : createCommentVNode("", !0),
        e.label || o.value && !e.instructionsBelow || u.$slots.label && !u.$slots.actions ? (openBlock(), createElementBlock("div", {
          key: 1,
          "data-ui-field-text": "",
          class: normalizeClass(e.variant === "inline" ? "mb-0" : "mb-1.5")
        }, [
          u.$slots.actions ? createCommentVNode("", !0) : renderSlot(u.$slots, "label", { key: 0 }, () => [
            e.label ? (openBlock(), createBlock(unref(_sfc_main$18), mergeProps({ key: 0 }, n.value, { class: "flex-1" }), null, 16)) : createCommentVNode("", !0)
          ]),
          o.value && !e.instructionsBelow ? (openBlock(), createBlock(unref(_sfc_main$1p), {
            key: 1,
            text: o.value,
            class: normalizeClass(e.variant === "inline" ? "-mt-0.5" : "mb-2 -mt-0.5")
          }, null, 8, ["text", "class"])) : createCommentVNode("", !0)
        ], 2)) : createCommentVNode("", !0),
        renderSlot(u.$slots, "default"),
        o.value && e.instructionsBelow ? (openBlock(), createBlock(unref(_sfc_main$1p), {
          key: 2,
          text: o.value,
          class: "mt-2"
        }, null, 8, ["text"])) : createCommentVNode("", !0),
        e.errors ? (openBlock(!0), createElementBlock(Fragment, { key: 3 }, renderList(e.errors, (f, g) => (openBlock(), createBlock(unref(_sfc_main$1h), {
          key: g,
          text: f,
          class: "mt-2"
        }, null, 8, ["text"]))), 128)) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
});
function createContext$1(e) {
  const t = `${e}Context`;
  return [() => inject(t, null), (o) => {
    provide(t, o);
  }, t];
}
const [injectFieldsContext, provideFieldsContext] = createContext$1("PublishFields"), _sfc_main$1d = {
  __name: "FieldsProvider",
  props: {
    fields: {
      type: Array,
      required: !0
    },
    fieldPathPrefix: {
      type: String
    },
    metaPathPrefix: {
      type: String,
      default: (e) => e.pathPrefix
    }
  },
  setup(e) {
    const t = e;
    return provideFieldsContext({
      fields: toRef(() => t.fields),
      fieldPathPrefix: toRef(() => t.fieldPathPrefix),
      metaPathPrefix: toRef(() => t.metaPathPrefix)
    }), (n, a) => renderSlot(n.$slots, "default");
  }
}, _hoisted_1$K = {
  class: "flex flex-wrap items-center justify-between gap-4 py-8",
  "data-ui-header": ""
}, _hoisted_2$q = { class: "text-[25px] leading-[1.25] st-text-legibility font-medium antialiased flex items-center gap-2.5 flex-1" }, _hoisted_3$e = {
  key: 0,
  class: "size-5"
}, _hoisted_4$8 = { class: "flex items-center gap-3" }, _sfc_main$1c = {
  __name: "Header",
  props: {
    icon: { type: String, default: null },
    title: { type: String, default: null }
  },
  setup(e) {
    return (t, n) => (openBlock(), createElementBlock("header", _hoisted_1$K, [
      createElementVNode("h1", _hoisted_2$q, [
        e.icon ? (openBlock(), createElementBlock("div", _hoisted_3$e, [
          createVNode(unref(_sfc_main$1a), {
            name: e.icon,
            class: "size-5 text-gray-500"
          }, null, 8, ["name"])
        ])) : createCommentVNode("", !0),
        renderSlot(t.$slots, "title", {}, () => [
          createTextVNode(toDisplayString(e.title), 1)
        ])
      ]),
      createElementVNode("div", _hoisted_4$8, [
        renderSlot(t.$slots, "actions", {}, () => [
          renderSlot(t.$slots, "default")
        ])
      ])
    ]));
  }
}, _hoisted_1$J = { key: 1 }, _sfc_main$1b = {
  __name: "Heading",
  props: {
    href: { type: [String, null], default: null },
    icon: { type: [String, null], default: null },
    level: { type: [Number, null], default: null },
    size: { type: String, default: "base" },
    text: { type: [String, Number, Boolean, null], default: null }
  },
  setup(e) {
    const t = e, a = !!useSlots().default, o = computed(() => t.level ? `h${t.level}` : t.href ? "a" : "div"), s = cva({
      base: "font-medium [&:has(+[data-ui-subheading])]:mb-0.5 antialiased flex items-center gap-2",
      variants: {
        size: {
          base: "text-sm tracking-tight text-gray-700 dark:text-white",
          lg: "text-base text-gray-700 dark:text-white",
          xl: "text-lg text-gray-900 dark:text-white",
          "2xl": "text-2xl text-gray-900 dark:text-white"
        }
      }
    })({ ...t }), u = cva({
      base: "text-gray-500 dark:text-gray-600",
      variants: {
        size: {
          base: "size-4",
          lg: "size-5",
          xl: "size-5.5",
          "2xl": "size-6"
        }
      }
    })({ ...t });
    return (d, f) => (openBlock(), createBlock(resolveDynamicComponent(o.value), {
      class: normalizeClass(unref(s)),
      href: e.href,
      "data-ui-heading": ""
    }, {
      default: withCtx(() => [
        e.icon ? (openBlock(), createBlock(unref(_sfc_main$1a), {
          key: 0,
          name: e.icon,
          class: normalizeClass(unref(u))
        }, null, 8, ["name", "class"])) : createCommentVNode("", !0),
        a ? renderSlot(d.$slots, "default", { key: 2 }) : (openBlock(), createElementBlock("span", _hoisted_1$J, toDisplayString(e.text), 1))
      ]),
      _: 3
    }, 8, ["class", "href"]));
  }
}, _sfc_main$1a = {
  __name: "Icon",
  props: {
    name: { type: String, required: !0 }
  },
  setup(e) {
    const t = e, n = shallowRef(null), a = () => {
      if (t.name.startsWith("<svg"))
        return defineAsyncComponent(() => new Promise((u) => u({ template: t.name })));
      const o = t.name.includes("/") ? `../../../svg/ui/${t.name.split("/")[1]}.svg` : `../../../svg/icons/${t.name}.svg`, s = t.name.includes("/") ? uiIcons[o] : icons[`../../../svg/icons/${t.name}.svg`];
      return s ? defineAsyncComponent(() => s()) : (console.warn(`Icon not found: ${t.name}`), null);
    };
    return watch(
      () => t.name,
      () => {
        n.value = a();
      },
      { immediate: !0 }
    ), (o, s) => (openBlock(), createBlock(resolveDynamicComponent(n.value), mergeProps({ class: ["size-4 shrink-0"] }, o.$attrs), null, 16));
  }
}, _hoisted_1$I = {
  class: "group/input relative block w-full st-text-legibility focus-outline-discrete",
  "data-ui-input": ""
}, _hoisted_2$p = ["id", "type", "value", "placeholder", "disabled", "readonly", "tabindex"], _hoisted_3$d = {
  key: 2,
  class: "absolute inset-y-0 right-2 flex items-center"
}, _sfc_main$19 = {
  __name: "Input",
  props: {
    append: { type: String, default: null },
    badge: { type: String, default: null },
    clearable: { type: Boolean, default: !1 },
    copyable: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    readOnly: { type: Boolean, default: !1 },
    icon: { type: String, default: null },
    iconAppend: { type: String, default: null },
    iconPrepend: { type: String, default: null },
    id: { type: String, default: () => useId$1() },
    limit: { type: Number, default: null },
    loading: { type: Boolean, default: !1 },
    modelValue: { type: [String, Number], default: null },
    placeholder: { type: String, default: null },
    prepend: { type: String, default: null },
    required: { type: Boolean, default: !1 },
    size: { type: String, default: "base" },
    tabindex: { type: Number, default: null },
    type: { type: String, default: "text" },
    variant: { type: String, default: "default" },
    viewable: { type: Boolean, default: !1 },
    focus: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: n }) {
    const a = useSlots(), o = e, s = computed(() => !!o.iconPrepend || !!o.icon || !!a.prepend), u = computed(() => !!o.iconAppend || !!a.append || o.clearable || o.viewable || k.value || o.loading), d = computed(() => {
      const B = cva({
        base: [
          "w-full block bg-white dark:bg-gray-950",
          "border border-gray-300 with-contrast:border-gray-500 dark:border-white/15 dark:inset-shadow-2xs dark:inset-shadow-black",
          "text-gray-950 dark:text-gray-300 placeholder:text-gray-500 dark:placeholder:text-gray-400/75",
          "appearance-none antialiased shadow-ui-sm disabled:shadow-none disabled:opacity-50 read-only:border-dashed not-prose"
        ],
        variants: {
          size: {
            base: "text-base rounded-lg px-3 py-2 h-10 leading-[1.375rem]",
            sm: "text-sm rounded-md px-2.5 py-1.5 h-8 leading-[1.125rem]",
            xs: "text-xs rounded-xs px-2 py-1.5 h-6 leading-[1.125rem]"
          },
          variant: {
            default: "",
            light: "dark:bg-gray-800/20"
          },
          hasLimit: {
            true: "pe-9"
          }
        },
        compoundVariants: [
          { hasPrependedIcon: !0, size: "base", class: "ps-9" },
          { hasPrependedIcon: !0, size: "sm", class: "ps-8" },
          { hasPrependedIcon: !0, size: "xs", class: "ps-6" },
          { hasAppendedIcon: !0, size: "base", class: "pe-10" },
          { hasAppendedIcon: !0, size: "sm", class: "pe-8" },
          { hasAppendedIcon: !0, size: "xs", class: "pe-6" }
        ]
      })({
        ...o,
        hasPrependedIcon: s.value,
        hasAppendedIcon: u.value,
        hasLimit: !!o.limit
      });
      return twMerge(B);
    }), f = computed(() => {
      const B = cva({
        base: "absolute top-0 bottom-0 flex items-center justify-center text-xs text-gray-400",
        variants: {
          size: {
            base: "[&_svg]:size-4",
            sm: "[&_svg]:size-3.5",
            xs: "[&_svg]:size-3"
          }
        },
        compoundVariants: [
          { size: "base", hasPrependedIcon: !0, class: "ps-3 has-[button]:ps-1 start-0" },
          { size: "sm", hasPrependedIcon: !0, class: "ps-2 has-[button]:ps-1 start-0" },
          { size: "xs", hasPrependedIcon: !0, class: "ps-1.5 has-[button]:ps-0 start-0" },
          { size: "base", hasAppendedIcon: !0, class: "pe-3 has-[button]:pe-1 end-0" },
          { size: "sm", hasAppendedIcon: !0, class: "pe-2 has-[button]:pe-1 end-0" },
          { size: "xs", hasAppendedIcon: !0, class: "pe-1.5 has-[button]:pe-0 end-0" }
        ]
      })({
        ...o,
        hasPrependedIcon: s.value,
        hasAppendedIcon: u.value
      });
      return twMerge(B);
    }), g = n, v = () => {
      g("update:modelValue", "");
    }, b = ref(o.type), w = () => {
      b.value = b.value === "password" ? "text" : "password";
    }, C = computed(() => "clipboard" in navigator && typeof navigator.clipboard.writeText == "function"), k = computed(() => o.copyable && C.value), E = ref(!1), A = () => {
      !k.value || !o.modelValue || (navigator.clipboard.writeText(o.modelValue), E.value = !0, setTimeout(() => E.value = !1, 1e3));
    }, P = useTemplateRef("input"), M = () => P.value.focus();
    return onMounted(() => {
      o.focus && nextTick(() => M());
    }), t({ focus: M }), (B, _) => {
      const T = resolveComponent("ui-input-group-prepend"), O = resolveComponent("ui-input-group-append"), I = resolveComponent("ui-input-group");
      return openBlock(), createBlock(I, null, {
        default: withCtx(() => [
          e.prepend ? (openBlock(), createBlock(T, {
            key: 0,
            textContent: toDisplayString(e.prepend)
          }, null, 8, ["textContent"])) : createCommentVNode("", !0),
          createElementVNode("div", _hoisted_1$I, [
            s.value ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(f.value)
            }, [
              renderSlot(B.$slots, "prepend", {}, () => [
                createVNode(unref(_sfc_main$1a), {
                  name: e.iconPrepend || e.icon
                }, null, 8, ["name"])
              ])
            ], 2)) : createCommentVNode("", !0),
            createElementVNode("input", mergeProps({
              ref_key: "input",
              ref: P,
              class: d.value,
              id: e.id,
              type: b.value,
              value: e.modelValue,
              placeholder: e.placeholder,
              disabled: e.disabled,
              readonly: e.readOnly,
              tabindex: e.tabindex,
              "data-ui-control": "",
              "data-ui-group-target": ""
            }, B.$attrs, {
              onInput: _[0] || (_[0] = (q) => B.$emit("update:modelValue", q.target.value))
            }), null, 16, _hoisted_2$p),
            u.value ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(f.value)
            }, [
              renderSlot(B.$slots, "append", {}, () => [
                e.clearable ? (openBlock(), createBlock(unref(Button), {
                  key: 0,
                  size: "sm",
                  icon: "x",
                  variant: "ghost",
                  onClick: v
                })) : e.viewable ? (openBlock(), createBlock(unref(Button), {
                  key: 1,
                  size: "sm",
                  icon: b.value === "password" ? "eye" : "eye-closed",
                  variant: "ghost",
                  onClick: w
                }, null, 8, ["icon"])) : k.value ? (openBlock(), createBlock(unref(Button), {
                  key: 2,
                  size: "sm",
                  icon: E.value ? "clipboard-check" : "clipboard",
                  variant: "subtle",
                  onClick: A,
                  class: normalizeClass(["animate", E.value ? "animate-wiggle" : ""])
                }, null, 8, ["icon", "class"])) : e.iconAppend ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                  key: 3,
                  name: e.iconAppend
                }, null, 8, ["name"])) : createCommentVNode("", !0),
                e.loading ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                  key: 4,
                  name: "loading"
                })) : createCommentVNode("", !0)
              ])
            ], 2)) : createCommentVNode("", !0),
            e.limit ? (openBlock(), createElementBlock("div", _hoisted_3$d, [
              createVNode(unref(CharacterCounter), {
                text: e.modelValue,
                limit: e.limit
              }, null, 8, ["text", "limit"])
            ])) : createCommentVNode("", !0)
          ]),
          e.append ? (openBlock(), createBlock(O, {
            key: 1,
            textContent: toDisplayString(e.append)
          }, null, 8, ["textContent"])) : createCommentVNode("", !0)
        ]),
        _: 3
      });
    };
  }
}, _hoisted_1$H = ["for"], _hoisted_2$o = {
  key: 2,
  class: "relative -top-px ms-0.5 text-red-600"
}, _sfc_main$18 = {
  __name: "Label",
  props: {
    for: { type: String, default: null },
    badge: { type: String, default: "" },
    required: { type: Boolean, default: !1 },
    text: { type: [String, Number, Boolean, null], default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createElementBlock("label", {
      class: "flex justify-between mb-1.5 text-sm font-medium [&_button]:font-medium text-gray-900 select-none dark:text-gray-300",
      "data-ui-label": "",
      for: e.for
    }, [
      createElementVNode("div", null, [
        n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(e.text), 1)
        ], 64)),
        e.required ? (openBlock(), createElementBlock("span", _hoisted_2$o, "*")) : createCommentVNode("", !0)
      ]),
      e.badge ? (openBlock(), createBlock(unref(_sfc_main), {
        key: 0,
        text: e.badge,
        variant: "flat"
      }, null, 8, ["text"])) : createCommentVNode("", !0)
    ], 8, _hoisted_1$H));
  }
};
function bind(e, t) {
  return function() {
    return e.apply(t, arguments);
  };
}
const { toString: toString$1 } = Object.prototype, { getPrototypeOf } = Object, { iterator, toStringTag } = Symbol, kindOf = /* @__PURE__ */ ((e) => (t) => {
  const n = toString$1.call(t);
  return e[n] || (e[n] = n.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), kindOfTest = (e) => (e = e.toLowerCase(), (t) => kindOf(t) === e), typeOfTest = (e) => (t) => typeof t === e, { isArray: isArray$1 } = Array, isUndefined = typeOfTest("undefined");
function isBuffer$1(e) {
  return e !== null && !isUndefined(e) && e.constructor !== null && !isUndefined(e.constructor) && isFunction$1(e.constructor.isBuffer) && e.constructor.isBuffer(e);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(e) {
  let t;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && isArrayBuffer(e.buffer), t;
}
const isString$1 = typeOfTest("string"), isFunction$1 = typeOfTest("function"), isNumber$2 = typeOfTest("number"), isObject$2 = (e) => e !== null && typeof e == "object", isBoolean = (e) => e === !0 || e === !1, isPlainObject = (e) => {
  if (kindOf(e) !== "object")
    return !1;
  const t = getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(toStringTag in e) && !(iterator in e);
}, isDate = kindOfTest("Date"), isFile = kindOfTest("File"), isBlob = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = (e) => isObject$2(e) && isFunction$1(e.pipe), isFormData = (e) => {
  let t;
  return e && (typeof FormData == "function" && e instanceof FormData || isFunction$1(e.append) && ((t = kindOf(e)) === "formdata" || // detect form-data instance
  t === "object" && isFunction$1(e.toString) && e.toString() === "[object FormData]"));
}, isURLSearchParams = kindOfTest("URLSearchParams"), [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest), trim = (e) => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(e, t, { allOwnKeys: n = !1 } = {}) {
  if (e === null || typeof e > "u")
    return;
  let a, o;
  if (typeof e != "object" && (e = [e]), isArray$1(e))
    for (a = 0, o = e.length; a < o; a++)
      t.call(null, e[a], a, e);
  else {
    const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), u = s.length;
    let d;
    for (a = 0; a < u; a++)
      d = s[a], t.call(null, e[d], d, e);
  }
}
function findKey(e, t) {
  t = t.toLowerCase();
  const n = Object.keys(e);
  let a = n.length, o;
  for (; a-- > 0; )
    if (o = n[a], t === o.toLowerCase())
      return o;
  return null;
}
const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = (e) => !isUndefined(e) && e !== _global;
function merge() {
  const { caseless: e } = isContextDefined(this) && this || {}, t = {}, n = (a, o) => {
    const s = e && findKey(t, o) || o;
    isPlainObject(t[s]) && isPlainObject(a) ? t[s] = merge(t[s], a) : isPlainObject(a) ? t[s] = merge({}, a) : isArray$1(a) ? t[s] = a.slice() : t[s] = a;
  };
  for (let a = 0, o = arguments.length; a < o; a++)
    arguments[a] && forEach(arguments[a], n);
  return t;
}
const extend = (e, t, n, { allOwnKeys: a } = {}) => (forEach(t, (o, s) => {
  n && isFunction$1(o) ? e[s] = bind(o, n) : e[s] = o;
}, { allOwnKeys: a }), e), stripBOM = (e) => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), inherits = (e, t, n, a) => {
  e.prototype = Object.create(t.prototype, a), e.prototype.constructor = e, Object.defineProperty(e, "super", {
    value: t.prototype
  }), n && Object.assign(e.prototype, n);
}, toFlatObject = (e, t, n, a) => {
  let o, s, u;
  const d = {};
  if (t = t || {}, e == null) return t;
  do {
    for (o = Object.getOwnPropertyNames(e), s = o.length; s-- > 0; )
      u = o[s], (!a || a(u, e, t)) && !d[u] && (t[u] = e[u], d[u] = !0);
    e = n !== !1 && getPrototypeOf(e);
  } while (e && (!n || n(e, t)) && e !== Object.prototype);
  return t;
}, endsWith = (e, t, n) => {
  e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length;
  const a = e.indexOf(t, n);
  return a !== -1 && a === n;
}, toArray = (e) => {
  if (!e) return null;
  if (isArray$1(e)) return e;
  let t = e.length;
  if (!isNumber$2(t)) return null;
  const n = new Array(t);
  for (; t-- > 0; )
    n[t] = e[t];
  return n;
}, isTypedArray$1 = /* @__PURE__ */ ((e) => (t) => e && t instanceof e)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (e, t) => {
  const a = (e && e[iterator]).call(e);
  let o;
  for (; (o = a.next()) && !o.done; ) {
    const s = o.value;
    t.call(e, s[0], s[1]);
  }
}, matchAll = (e, t) => {
  let n;
  const a = [];
  for (; (n = e.exec(t)) !== null; )
    a.push(n);
  return a;
}, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase = (e) => e.toLowerCase().replace(
  /[-_\s]([a-z\d])(\w*)/g,
  function(n, a, o) {
    return a.toUpperCase() + o;
  }
), hasOwnProperty$9 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (e, t) => {
  const n = Object.getOwnPropertyDescriptors(e), a = {};
  forEach(n, (o, s) => {
    let u;
    (u = t(o, s, e)) !== !1 && (a[s] = u || o);
  }), Object.defineProperties(e, a);
}, freezeMethods = (e) => {
  reduceDescriptors(e, (t, n) => {
    if (isFunction$1(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1)
      return !1;
    const a = e[n];
    if (isFunction$1(a)) {
      if (t.enumerable = !1, "writable" in t) {
        t.writable = !1;
        return;
      }
      t.set || (t.set = () => {
        throw Error("Can not rewrite read-only method '" + n + "'");
      });
    }
  });
}, toObjectSet = (e, t) => {
  const n = {}, a = (o) => {
    o.forEach((s) => {
      n[s] = !0;
    });
  };
  return isArray$1(e) ? a(e) : a(String(e).split(t)), n;
}, noop$1 = () => {
}, toFiniteNumber = (e, t) => e != null && Number.isFinite(e = +e) ? e : t;
function isSpecCompliantForm(e) {
  return !!(e && isFunction$1(e.append) && e[toStringTag] === "FormData" && e[iterator]);
}
const toJSONObject = (e) => {
  const t = new Array(10), n = (a, o) => {
    if (isObject$2(a)) {
      if (t.indexOf(a) >= 0)
        return;
      if (!("toJSON" in a)) {
        t[o] = a;
        const s = isArray$1(a) ? [] : {};
        return forEach(a, (u, d) => {
          const f = n(u, o + 1);
          !isUndefined(f) && (s[d] = f);
        }), t[o] = void 0, s;
      }
    }
    return a;
  };
  return n(e, 0);
}, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = (e) => e && (isObject$2(e) || isFunction$1(e)) && isFunction$1(e.then) && isFunction$1(e.catch), _setImmediate = ((e, t) => e ? setImmediate : t ? ((n, a) => (_global.addEventListener("message", ({ source: o, data: s }) => {
  o === _global && s === n && a.length && a.shift()();
}, !1), (o) => {
  a.push(o), _global.postMessage(n, "*");
}))(`axios@${Math.random()}`, []) : (n) => setTimeout(n))(
  typeof setImmediate == "function",
  isFunction$1(_global.postMessage)
), asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global) : typeof process < "u" && process.nextTick || _setImmediate, isIterable = (e) => e != null && isFunction$1(e[iterator]), utils$1 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer: isBuffer$1,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber: isNumber$2,
  isBoolean,
  isObject: isObject$2,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$1,
  isStream,
  isURLSearchParams,
  isTypedArray: isTypedArray$1,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$9,
  hasOwnProp: hasOwnProperty$9,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$1,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(e, t, n, a, o) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), a && (this.request = a), o && (this.response = o, this.status = o.status ? o.status : null);
}
utils$1.inherits(AxiosError$1, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype, descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((e) => {
  descriptors[e] = { value: e };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: !0 });
AxiosError$1.from = (e, t, n, a, o, s) => {
  const u = Object.create(prototype$1);
  return utils$1.toFlatObject(e, u, function(f) {
    return f !== Error.prototype;
  }, (d) => d !== "isAxiosError"), AxiosError$1.call(u, e.message, t, n, a, o), u.cause = e, u.name = e.name, s && Object.assign(u, s), u;
};
const httpAdapter = null;
function isVisitable(e) {
  return utils$1.isPlainObject(e) || utils$1.isArray(e);
}
function removeBrackets(e) {
  return utils$1.endsWith(e, "[]") ? e.slice(0, -2) : e;
}
function renderKey(e, t, n) {
  return e ? e.concat(t).map(function(o, s) {
    return o = removeBrackets(o), !n && s ? "[" + o + "]" : o;
  }).join(n ? "." : "") : t;
}
function isFlatArray(e) {
  return utils$1.isArray(e) && !e.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function(t) {
  return /^is[A-Z]/.test(t);
});
function toFormData$1(e, t, n) {
  if (!utils$1.isObject(e))
    throw new TypeError("target must be an object");
  t = t || new FormData(), n = utils$1.toFlatObject(n, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(E, A) {
    return !utils$1.isUndefined(A[E]);
  });
  const a = n.metaTokens, o = n.visitor || v, s = n.dots, u = n.indexes, f = (n.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(t);
  if (!utils$1.isFunction(o))
    throw new TypeError("visitor must be a function");
  function g(k) {
    if (k === null) return "";
    if (utils$1.isDate(k))
      return k.toISOString();
    if (utils$1.isBoolean(k))
      return k.toString();
    if (!f && utils$1.isBlob(k))
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    return utils$1.isArrayBuffer(k) || utils$1.isTypedArray(k) ? f && typeof Blob == "function" ? new Blob([k]) : Buffer.from(k) : k;
  }
  function v(k, E, A) {
    let P = k;
    if (k && !A && typeof k == "object") {
      if (utils$1.endsWith(E, "{}"))
        E = a ? E : E.slice(0, -2), k = JSON.stringify(k);
      else if (utils$1.isArray(k) && isFlatArray(k) || (utils$1.isFileList(k) || utils$1.endsWith(E, "[]")) && (P = utils$1.toArray(k)))
        return E = removeBrackets(E), P.forEach(function(B, _) {
          !(utils$1.isUndefined(B) || B === null) && t.append(
            // eslint-disable-next-line no-nested-ternary
            u === !0 ? renderKey([E], _, s) : u === null ? E : E + "[]",
            g(B)
          );
        }), !1;
    }
    return isVisitable(k) ? !0 : (t.append(renderKey(A, E, s), g(k)), !1);
  }
  const b = [], w = Object.assign(predicates, {
    defaultVisitor: v,
    convertValue: g,
    isVisitable
  });
  function C(k, E) {
    if (!utils$1.isUndefined(k)) {
      if (b.indexOf(k) !== -1)
        throw Error("Circular reference detected in " + E.join("."));
      b.push(k), utils$1.forEach(k, function(P, M) {
        (!(utils$1.isUndefined(P) || P === null) && o.call(
          t,
          P,
          utils$1.isString(M) ? M.trim() : M,
          E,
          w
        )) === !0 && C(P, E ? E.concat(M) : [M]);
      }), b.pop();
    }
  }
  if (!utils$1.isObject(e))
    throw new TypeError("data must be an object");
  return C(e), t;
}
function encode$1(e) {
  const t = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function(a) {
    return t[a];
  });
}
function AxiosURLSearchParams(e, t) {
  this._pairs = [], e && toFormData$1(e, this, t);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function(t, n) {
  this._pairs.push([t, n]);
};
prototype.toString = function(t) {
  const n = t ? function(a) {
    return t.call(this, a, encode$1);
  } : encode$1;
  return this._pairs.map(function(o) {
    return n(o[0]) + "=" + n(o[1]);
  }, "").join("&");
};
function encode(e) {
  return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(e, t, n) {
  if (!t)
    return e;
  const a = n && n.encode || encode;
  utils$1.isFunction(n) && (n = {
    serialize: n
  });
  const o = n && n.serialize;
  let s;
  if (o ? s = o(t, n) : s = utils$1.isURLSearchParams(t) ? t.toString() : new AxiosURLSearchParams(t, n).toString(a), s) {
    const u = e.indexOf("#");
    u !== -1 && (e = e.slice(0, u)), e += (e.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return e;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(t, n, a) {
    return this.handlers.push({
      fulfilled: t,
      rejected: n,
      synchronous: a ? a.synchronous : !1,
      runWhen: a ? a.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(t) {
    this.handlers[t] && (this.handlers[t] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(t) {
    utils$1.forEach(this.handlers, function(a) {
      a !== null && t(a);
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$1 = {
  isBrowser: !0,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, hasBrowserEnv = typeof window < "u" && typeof document < "u", _navigator = typeof navigator == "object" && navigator || void 0, hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", origin = hasBrowserEnv && window.location.href || "http://localhost", utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" })), platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(e, t) {
  return toFormData$1(e, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(n, a, o, s) {
      return platform.isNode && utils$1.isBuffer(n) ? (this.append(a, n.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, t));
}
function parsePropPath(e) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, e).map((t) => t[0] === "[]" ? "" : t[1] || t[0]);
}
function arrayToObject(e) {
  const t = {}, n = Object.keys(e);
  let a;
  const o = n.length;
  let s;
  for (a = 0; a < o; a++)
    s = n[a], t[s] = e[s];
  return t;
}
function formDataToJSON(e) {
  function t(n, a, o, s) {
    let u = n[s++];
    if (u === "__proto__") return !0;
    const d = Number.isFinite(+u), f = s >= n.length;
    return u = !u && utils$1.isArray(o) ? o.length : u, f ? (utils$1.hasOwnProp(o, u) ? o[u] = [o[u], a] : o[u] = a, !d) : ((!o[u] || !utils$1.isObject(o[u])) && (o[u] = []), t(n, a, o[u], s) && utils$1.isArray(o[u]) && (o[u] = arrayToObject(o[u])), !d);
  }
  if (utils$1.isFormData(e) && utils$1.isFunction(e.entries)) {
    const n = {};
    return utils$1.forEachEntry(e, (a, o) => {
      t(parsePropPath(a), o, n, 0);
    }), n;
  }
  return null;
}
function stringifySafely(e, t, n) {
  if (utils$1.isString(e))
    try {
      return (t || JSON.parse)(e), utils$1.trim(e);
    } catch (a) {
      if (a.name !== "SyntaxError")
        throw a;
    }
  return (n || JSON.stringify)(e);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(t, n) {
    const a = n.getContentType() || "", o = a.indexOf("application/json") > -1, s = utils$1.isObject(t);
    if (s && utils$1.isHTMLForm(t) && (t = new FormData(t)), utils$1.isFormData(t))
      return o ? JSON.stringify(formDataToJSON(t)) : t;
    if (utils$1.isArrayBuffer(t) || utils$1.isBuffer(t) || utils$1.isStream(t) || utils$1.isFile(t) || utils$1.isBlob(t) || utils$1.isReadableStream(t))
      return t;
    if (utils$1.isArrayBufferView(t))
      return t.buffer;
    if (utils$1.isURLSearchParams(t))
      return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
    let d;
    if (s) {
      if (a.indexOf("application/x-www-form-urlencoded") > -1)
        return toURLEncodedForm(t, this.formSerializer).toString();
      if ((d = utils$1.isFileList(t)) || a.indexOf("multipart/form-data") > -1) {
        const f = this.env && this.env.FormData;
        return toFormData$1(
          d ? { "files[]": t } : t,
          f && new f(),
          this.formSerializer
        );
      }
    }
    return s || o ? (n.setContentType("application/json", !1), stringifySafely(t)) : t;
  }],
  transformResponse: [function(t) {
    const n = this.transitional || defaults.transitional, a = n && n.forcedJSONParsing, o = this.responseType === "json";
    if (utils$1.isResponse(t) || utils$1.isReadableStream(t))
      return t;
    if (t && utils$1.isString(t) && (a && !this.responseType || o)) {
      const u = !(n && n.silentJSONParsing) && o;
      try {
        return JSON.parse(t);
      } catch (d) {
        if (u)
          throw d.name === "SyntaxError" ? AxiosError$1.from(d, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : d;
      }
    }
    return t;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function(t) {
    return t >= 200 && t < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (e) => {
  defaults.headers[e] = {};
});
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]), parseHeaders = (e) => {
  const t = {};
  let n, a, o;
  return e && e.split(`
`).forEach(function(u) {
    o = u.indexOf(":"), n = u.substring(0, o).trim().toLowerCase(), a = u.substring(o + 1).trim(), !(!n || t[n] && ignoreDuplicateOf[n]) && (n === "set-cookie" ? t[n] ? t[n].push(a) : t[n] = [a] : t[n] = t[n] ? t[n] + ", " + a : a);
  }), t;
}, $internals = Symbol("internals");
function normalizeHeader(e) {
  return e && String(e).trim().toLowerCase();
}
function normalizeValue(e) {
  return e === !1 || e == null ? e : utils$1.isArray(e) ? e.map(normalizeValue) : String(e);
}
function parseTokens(e) {
  const t = /* @__PURE__ */ Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let a;
  for (; a = n.exec(e); )
    t[a[1]] = a[2];
  return t;
}
const isValidHeaderName = (e) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim());
function matchHeaderValue(e, t, n, a, o) {
  if (utils$1.isFunction(a))
    return a.call(this, t, n);
  if (o && (t = n), !!utils$1.isString(t)) {
    if (utils$1.isString(a))
      return t.indexOf(a) !== -1;
    if (utils$1.isRegExp(a))
      return a.test(t);
  }
}
function formatHeader(e) {
  return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, a) => n.toUpperCase() + a);
}
function buildAccessors(e, t) {
  const n = utils$1.toCamelCase(" " + t);
  ["get", "set", "has"].forEach((a) => {
    Object.defineProperty(e, a + n, {
      value: function(o, s, u) {
        return this[a].call(this, t, o, s, u);
      },
      configurable: !0
    });
  });
}
let AxiosHeaders$1 = class {
  constructor(t) {
    t && this.set(t);
  }
  set(t, n, a) {
    const o = this;
    function s(d, f, g) {
      const v = normalizeHeader(f);
      if (!v)
        throw new Error("header name must be a non-empty string");
      const b = utils$1.findKey(o, v);
      (!b || o[b] === void 0 || g === !0 || g === void 0 && o[b] !== !1) && (o[b || f] = normalizeValue(d));
    }
    const u = (d, f) => utils$1.forEach(d, (g, v) => s(g, v, f));
    if (utils$1.isPlainObject(t) || t instanceof this.constructor)
      u(t, n);
    else if (utils$1.isString(t) && (t = t.trim()) && !isValidHeaderName(t))
      u(parseHeaders(t), n);
    else if (utils$1.isObject(t) && utils$1.isIterable(t)) {
      let d = {}, f, g;
      for (const v of t) {
        if (!utils$1.isArray(v))
          throw TypeError("Object iterator must return a key-value pair");
        d[g = v[0]] = (f = d[g]) ? utils$1.isArray(f) ? [...f, v[1]] : [f, v[1]] : v[1];
      }
      u(d, n);
    } else
      t != null && s(n, t, a);
    return this;
  }
  get(t, n) {
    if (t = normalizeHeader(t), t) {
      const a = utils$1.findKey(this, t);
      if (a) {
        const o = this[a];
        if (!n)
          return o;
        if (n === !0)
          return parseTokens(o);
        if (utils$1.isFunction(n))
          return n.call(this, o, a);
        if (utils$1.isRegExp(n))
          return n.exec(o);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(t, n) {
    if (t = normalizeHeader(t), t) {
      const a = utils$1.findKey(this, t);
      return !!(a && this[a] !== void 0 && (!n || matchHeaderValue(this, this[a], a, n)));
    }
    return !1;
  }
  delete(t, n) {
    const a = this;
    let o = !1;
    function s(u) {
      if (u = normalizeHeader(u), u) {
        const d = utils$1.findKey(a, u);
        d && (!n || matchHeaderValue(a, a[d], d, n)) && (delete a[d], o = !0);
      }
    }
    return utils$1.isArray(t) ? t.forEach(s) : s(t), o;
  }
  clear(t) {
    const n = Object.keys(this);
    let a = n.length, o = !1;
    for (; a--; ) {
      const s = n[a];
      (!t || matchHeaderValue(this, this[s], s, t, !0)) && (delete this[s], o = !0);
    }
    return o;
  }
  normalize(t) {
    const n = this, a = {};
    return utils$1.forEach(this, (o, s) => {
      const u = utils$1.findKey(a, s);
      if (u) {
        n[u] = normalizeValue(o), delete n[s];
        return;
      }
      const d = t ? formatHeader(s) : String(s).trim();
      d !== s && delete n[s], n[d] = normalizeValue(o), a[d] = !0;
    }), this;
  }
  concat(...t) {
    return this.constructor.concat(this, ...t);
  }
  toJSON(t) {
    const n = /* @__PURE__ */ Object.create(null);
    return utils$1.forEach(this, (a, o) => {
      a != null && a !== !1 && (n[o] = t && utils$1.isArray(a) ? a.join(", ") : a);
    }), n;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`);
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(t) {
    return t instanceof this ? t : new this(t);
  }
  static concat(t, ...n) {
    const a = new this(t);
    return n.forEach((o) => a.set(o)), a;
  }
  static accessor(t) {
    const a = (this[$internals] = this[$internals] = {
      accessors: {}
    }).accessors, o = this.prototype;
    function s(u) {
      const d = normalizeHeader(u);
      a[d] || (buildAccessors(o, u), a[d] = !0);
    }
    return utils$1.isArray(t) ? t.forEach(s) : s(t), this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: e }, t) => {
  let n = t[0].toUpperCase() + t.slice(1);
  return {
    get: () => e,
    set(a) {
      this[n] = a;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(e, t) {
  const n = this || defaults, a = t || n, o = AxiosHeaders$1.from(a.headers);
  let s = a.data;
  return utils$1.forEach(e, function(d) {
    s = d.call(n, s, o.normalize(), t ? t.status : void 0);
  }), o.normalize(), s;
}
function isCancel$1(e) {
  return !!(e && e.__CANCEL__);
}
function CanceledError$1(e, t, n) {
  AxiosError$1.call(this, e ?? "canceled", AxiosError$1.ERR_CANCELED, t, n), this.name = "CanceledError";
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: !0
});
function settle(e, t, n) {
  const a = n.config.validateStatus;
  !n.status || !a || a(n.status) ? e(n) : t(new AxiosError$1(
    "Request failed with status code " + n.status,
    [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],
    n.config,
    n.request,
    n
  ));
}
function parseProtocol(e) {
  const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e);
  return t && t[1] || "";
}
function speedometer(e, t) {
  e = e || 10;
  const n = new Array(e), a = new Array(e);
  let o = 0, s = 0, u;
  return t = t !== void 0 ? t : 1e3, function(f) {
    const g = Date.now(), v = a[s];
    u || (u = g), n[o] = f, a[o] = g;
    let b = s, w = 0;
    for (; b !== o; )
      w += n[b++], b = b % e;
    if (o = (o + 1) % e, o === s && (s = (s + 1) % e), g - u < t)
      return;
    const C = v && g - v;
    return C ? Math.round(w * 1e3 / C) : void 0;
  };
}
function throttle(e, t) {
  let n = 0, a = 1e3 / t, o, s;
  const u = (g, v = Date.now()) => {
    n = v, o = null, s && (clearTimeout(s), s = null), e.apply(null, g);
  };
  return [(...g) => {
    const v = Date.now(), b = v - n;
    b >= a ? u(g, v) : (o = g, s || (s = setTimeout(() => {
      s = null, u(o);
    }, a - b)));
  }, () => o && u(o)];
}
const progressEventReducer = (e, t, n = 3) => {
  let a = 0;
  const o = speedometer(50, 250);
  return throttle((s) => {
    const u = s.loaded, d = s.lengthComputable ? s.total : void 0, f = u - a, g = o(f), v = u <= d;
    a = u;
    const b = {
      loaded: u,
      total: d,
      progress: d ? u / d : void 0,
      bytes: f,
      rate: g || void 0,
      estimated: g && d && v ? (d - u) / g : void 0,
      event: s,
      lengthComputable: d != null,
      [t ? "download" : "upload"]: !0
    };
    e(b);
  }, n);
}, progressEventDecorator = (e, t) => {
  const n = e != null;
  return [(a) => t[0]({
    lengthComputable: n,
    total: e,
    loaded: a
  }), t[1]];
}, asyncDecorator = (e) => (...t) => utils$1.asap(() => e(...t)), isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((e, t) => (n) => (n = new URL(n, platform.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => !0, cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(e, t, n, a, o, s) {
      const u = [e + "=" + encodeURIComponent(t)];
      utils$1.isNumber(n) && u.push("expires=" + new Date(n).toGMTString()), utils$1.isString(a) && u.push("path=" + a), utils$1.isString(o) && u.push("domain=" + o), s === !0 && u.push("secure"), document.cookie = u.join("; ");
    },
    read(e) {
      const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)"));
      return t ? decodeURIComponent(t[3]) : null;
    },
    remove(e) {
      this.write(e, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(e) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e);
}
function combineURLs(e, t) {
  return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e;
}
function buildFullPath(e, t, n) {
  let a = !isAbsoluteURL(t);
  return e && (a || n == !1) ? combineURLs(e, t) : t;
}
const headersToObject = (e) => e instanceof AxiosHeaders$1 ? { ...e } : e;
function mergeConfig$1(e, t) {
  t = t || {};
  const n = {};
  function a(g, v, b, w) {
    return utils$1.isPlainObject(g) && utils$1.isPlainObject(v) ? utils$1.merge.call({ caseless: w }, g, v) : utils$1.isPlainObject(v) ? utils$1.merge({}, v) : utils$1.isArray(v) ? v.slice() : v;
  }
  function o(g, v, b, w) {
    if (utils$1.isUndefined(v)) {
      if (!utils$1.isUndefined(g))
        return a(void 0, g, b, w);
    } else return a(g, v, b, w);
  }
  function s(g, v) {
    if (!utils$1.isUndefined(v))
      return a(void 0, v);
  }
  function u(g, v) {
    if (utils$1.isUndefined(v)) {
      if (!utils$1.isUndefined(g))
        return a(void 0, g);
    } else return a(void 0, v);
  }
  function d(g, v, b) {
    if (b in t)
      return a(g, v);
    if (b in e)
      return a(void 0, g);
  }
  const f = {
    url: s,
    method: s,
    data: s,
    baseURL: u,
    transformRequest: u,
    transformResponse: u,
    paramsSerializer: u,
    timeout: u,
    timeoutMessage: u,
    withCredentials: u,
    withXSRFToken: u,
    adapter: u,
    responseType: u,
    xsrfCookieName: u,
    xsrfHeaderName: u,
    onUploadProgress: u,
    onDownloadProgress: u,
    decompress: u,
    maxContentLength: u,
    maxBodyLength: u,
    beforeRedirect: u,
    transport: u,
    httpAgent: u,
    httpsAgent: u,
    cancelToken: u,
    socketPath: u,
    responseEncoding: u,
    validateStatus: d,
    headers: (g, v, b) => o(headersToObject(g), headersToObject(v), b, !0)
  };
  return utils$1.forEach(Object.keys(Object.assign({}, e, t)), function(v) {
    const b = f[v] || o, w = b(e[v], t[v], v);
    utils$1.isUndefined(w) && b !== d || (n[v] = w);
  }), n;
}
const resolveConfig = (e) => {
  const t = mergeConfig$1({}, e);
  let { data: n, withXSRFToken: a, xsrfHeaderName: o, xsrfCookieName: s, headers: u, auth: d } = t;
  t.headers = u = AxiosHeaders$1.from(u), t.url = buildURL(buildFullPath(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), d && u.set(
    "Authorization",
    "Basic " + btoa((d.username || "") + ":" + (d.password ? unescape(encodeURIComponent(d.password)) : ""))
  );
  let f;
  if (utils$1.isFormData(n)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
      u.setContentType(void 0);
    else if ((f = u.getContentType()) !== !1) {
      const [g, ...v] = f ? f.split(";").map((b) => b.trim()).filter(Boolean) : [];
      u.setContentType([g || "multipart/form-data", ...v].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv && (a && utils$1.isFunction(a) && (a = a(t)), a || a !== !1 && isURLSameOrigin(t.url))) {
    const g = o && s && cookies.read(s);
    g && u.set(o, g);
  }
  return t;
}, isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function(e) {
  return new Promise(function(n, a) {
    const o = resolveConfig(e);
    let s = o.data;
    const u = AxiosHeaders$1.from(o.headers).normalize();
    let { responseType: d, onUploadProgress: f, onDownloadProgress: g } = o, v, b, w, C, k;
    function E() {
      C && C(), k && k(), o.cancelToken && o.cancelToken.unsubscribe(v), o.signal && o.signal.removeEventListener("abort", v);
    }
    let A = new XMLHttpRequest();
    A.open(o.method.toUpperCase(), o.url, !0), A.timeout = o.timeout;
    function P() {
      if (!A)
        return;
      const B = AxiosHeaders$1.from(
        "getAllResponseHeaders" in A && A.getAllResponseHeaders()
      ), T = {
        data: !d || d === "text" || d === "json" ? A.responseText : A.response,
        status: A.status,
        statusText: A.statusText,
        headers: B,
        config: e,
        request: A
      };
      settle(function(I) {
        n(I), E();
      }, function(I) {
        a(I), E();
      }, T), A = null;
    }
    "onloadend" in A ? A.onloadend = P : A.onreadystatechange = function() {
      !A || A.readyState !== 4 || A.status === 0 && !(A.responseURL && A.responseURL.indexOf("file:") === 0) || setTimeout(P);
    }, A.onabort = function() {
      A && (a(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, e, A)), A = null);
    }, A.onerror = function() {
      a(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, e, A)), A = null;
    }, A.ontimeout = function() {
      let _ = o.timeout ? "timeout of " + o.timeout + "ms exceeded" : "timeout exceeded";
      const T = o.transitional || transitionalDefaults;
      o.timeoutErrorMessage && (_ = o.timeoutErrorMessage), a(new AxiosError$1(
        _,
        T.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        e,
        A
      )), A = null;
    }, s === void 0 && u.setContentType(null), "setRequestHeader" in A && utils$1.forEach(u.toJSON(), function(_, T) {
      A.setRequestHeader(T, _);
    }), utils$1.isUndefined(o.withCredentials) || (A.withCredentials = !!o.withCredentials), d && d !== "json" && (A.responseType = o.responseType), g && ([w, k] = progressEventReducer(g, !0), A.addEventListener("progress", w)), f && A.upload && ([b, C] = progressEventReducer(f), A.upload.addEventListener("progress", b), A.upload.addEventListener("loadend", C)), (o.cancelToken || o.signal) && (v = (B) => {
      A && (a(!B || B.type ? new CanceledError$1(null, e, A) : B), A.abort(), A = null);
    }, o.cancelToken && o.cancelToken.subscribe(v), o.signal && (o.signal.aborted ? v() : o.signal.addEventListener("abort", v)));
    const M = parseProtocol(o.url);
    if (M && platform.protocols.indexOf(M) === -1) {
      a(new AxiosError$1("Unsupported protocol " + M + ":", AxiosError$1.ERR_BAD_REQUEST, e));
      return;
    }
    A.send(s || null);
  });
}, composeSignals = (e, t) => {
  const { length: n } = e = e ? e.filter(Boolean) : [];
  if (t || n) {
    let a = new AbortController(), o;
    const s = function(g) {
      if (!o) {
        o = !0, d();
        const v = g instanceof Error ? g : this.reason;
        a.abort(v instanceof AxiosError$1 ? v : new CanceledError$1(v instanceof Error ? v.message : v));
      }
    };
    let u = t && setTimeout(() => {
      u = null, s(new AxiosError$1(`timeout ${t} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, t);
    const d = () => {
      e && (u && clearTimeout(u), u = null, e.forEach((g) => {
        g.unsubscribe ? g.unsubscribe(s) : g.removeEventListener("abort", s);
      }), e = null);
    };
    e.forEach((g) => g.addEventListener("abort", s));
    const { signal: f } = a;
    return f.unsubscribe = () => utils$1.asap(d), f;
  }
}, streamChunk = function* (e, t) {
  let n = e.byteLength;
  if (n < t) {
    yield e;
    return;
  }
  let a = 0, o;
  for (; a < n; )
    o = a + t, yield e.slice(a, o), a = o;
}, readBytes = async function* (e, t) {
  for await (const n of readStream(e))
    yield* streamChunk(n, t);
}, readStream = async function* (e) {
  if (e[Symbol.asyncIterator]) {
    yield* e;
    return;
  }
  const t = e.getReader();
  try {
    for (; ; ) {
      const { done: n, value: a } = await t.read();
      if (n)
        break;
      yield a;
    }
  } finally {
    await t.cancel();
  }
}, trackStream = (e, t, n, a) => {
  const o = readBytes(e, t);
  let s = 0, u, d = (f) => {
    u || (u = !0, a && a(f));
  };
  return new ReadableStream({
    async pull(f) {
      try {
        const { done: g, value: v } = await o.next();
        if (g) {
          d(), f.close();
          return;
        }
        let b = v.byteLength;
        if (n) {
          let w = s += b;
          n(w);
        }
        f.enqueue(new Uint8Array(v));
      } catch (g) {
        throw d(g), g;
      }
    },
    cancel(f) {
      return d(f), o.return();
    }
  }, {
    highWaterMark: 2
  });
}, isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function", encodeText = isFetchSupported && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((e) => (t) => e.encode(t))(new TextEncoder()) : async (e) => new Uint8Array(await new Response(e).arrayBuffer())), test$1 = (e, ...t) => {
  try {
    return !!e(...t);
  } catch {
    return !1;
  }
}, supportsRequestStream = isReadableStreamSupported && test$1(() => {
  let e = !1;
  const t = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return e = !0, "half";
    }
  }).headers.has("Content-Type");
  return e && !t;
}), DEFAULT_CHUNK_SIZE = 64 * 1024, supportsResponseStream = isReadableStreamSupported && test$1(() => utils$1.isReadableStream(new Response("").body)), resolvers = {
  stream: supportsResponseStream && ((e) => e.body)
};
isFetchSupported && ((e) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((t) => {
    !resolvers[t] && (resolvers[t] = utils$1.isFunction(e[t]) ? (n) => n[t]() : (n, a) => {
      throw new AxiosError$1(`Response type '${t}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, a);
    });
  });
})(new Response());
const getBodyLength = async (e) => {
  if (e == null)
    return 0;
  if (utils$1.isBlob(e))
    return e.size;
  if (utils$1.isSpecCompliantForm(e))
    return (await new Request(platform.origin, {
      method: "POST",
      body: e
    }).arrayBuffer()).byteLength;
  if (utils$1.isArrayBufferView(e) || utils$1.isArrayBuffer(e))
    return e.byteLength;
  if (utils$1.isURLSearchParams(e) && (e = e + ""), utils$1.isString(e))
    return (await encodeText(e)).byteLength;
}, resolveBodyLength = async (e, t) => {
  const n = utils$1.toFiniteNumber(e.getContentLength());
  return n ?? getBodyLength(t);
}, fetchAdapter = isFetchSupported && (async (e) => {
  let {
    url: t,
    method: n,
    data: a,
    signal: o,
    cancelToken: s,
    timeout: u,
    onDownloadProgress: d,
    onUploadProgress: f,
    responseType: g,
    headers: v,
    withCredentials: b = "same-origin",
    fetchOptions: w
  } = resolveConfig(e);
  g = g ? (g + "").toLowerCase() : "text";
  let C = composeSignals([o, s && s.toAbortSignal()], u), k;
  const E = C && C.unsubscribe && (() => {
    C.unsubscribe();
  });
  let A;
  try {
    if (f && supportsRequestStream && n !== "get" && n !== "head" && (A = await resolveBodyLength(v, a)) !== 0) {
      let T = new Request(t, {
        method: "POST",
        body: a,
        duplex: "half"
      }), O;
      if (utils$1.isFormData(a) && (O = T.headers.get("content-type")) && v.setContentType(O), T.body) {
        const [I, q] = progressEventDecorator(
          A,
          progressEventReducer(asyncDecorator(f))
        );
        a = trackStream(T.body, DEFAULT_CHUNK_SIZE, I, q);
      }
    }
    utils$1.isString(b) || (b = b ? "include" : "omit");
    const P = "credentials" in Request.prototype;
    k = new Request(t, {
      ...w,
      signal: C,
      method: n.toUpperCase(),
      headers: v.normalize().toJSON(),
      body: a,
      duplex: "half",
      credentials: P ? b : void 0
    });
    let M = await fetch(k, w);
    const B = supportsResponseStream && (g === "stream" || g === "response");
    if (supportsResponseStream && (d || B && E)) {
      const T = {};
      ["status", "statusText", "headers"].forEach((F) => {
        T[F] = M[F];
      });
      const O = utils$1.toFiniteNumber(M.headers.get("content-length")), [I, q] = d && progressEventDecorator(
        O,
        progressEventReducer(asyncDecorator(d), !0)
      ) || [];
      M = new Response(
        trackStream(M.body, DEFAULT_CHUNK_SIZE, I, () => {
          q && q(), E && E();
        }),
        T
      );
    }
    g = g || "text";
    let _ = await resolvers[utils$1.findKey(resolvers, g) || "text"](M, e);
    return !B && E && E(), await new Promise((T, O) => {
      settle(T, O, {
        data: _,
        headers: AxiosHeaders$1.from(M.headers),
        status: M.status,
        statusText: M.statusText,
        config: e,
        request: k
      });
    });
  } catch (P) {
    throw E && E(), P && P.name === "TypeError" && /Load failed|fetch/i.test(P.message) ? Object.assign(
      new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, e, k),
      {
        cause: P.cause || P
      }
    ) : AxiosError$1.from(P, P && P.code, e, k);
  }
}), knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (e, t) => {
  if (e) {
    try {
      Object.defineProperty(e, "name", { value: t });
    } catch {
    }
    Object.defineProperty(e, "adapterName", { value: t });
  }
});
const renderReason = (e) => `- ${e}`, isResolvedHandle = (e) => utils$1.isFunction(e) || e === null || e === !1, adapters = {
  getAdapter: (e) => {
    e = utils$1.isArray(e) ? e : [e];
    const { length: t } = e;
    let n, a;
    const o = {};
    for (let s = 0; s < t; s++) {
      n = e[s];
      let u;
      if (a = n, !isResolvedHandle(n) && (a = knownAdapters[(u = String(n)).toLowerCase()], a === void 0))
        throw new AxiosError$1(`Unknown adapter '${u}'`);
      if (a)
        break;
      o[u || "#" + s] = a;
    }
    if (!a) {
      const s = Object.entries(o).map(
        ([d, f]) => `adapter ${d} ` + (f === !1 ? "is not supported by the environment" : "is not available in the build")
      );
      let u = t ? s.length > 1 ? `since :
` + s.map(renderReason).join(`
`) : " " + renderReason(s[0]) : "as no adapter specified";
      throw new AxiosError$1(
        "There is no suitable adapter to dispatch the request " + u,
        "ERR_NOT_SUPPORT"
      );
    }
    return a;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(e) {
  if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted)
    throw new CanceledError$1(null, e);
}
function dispatchRequest(e) {
  return throwIfCancellationRequested(e), e.headers = AxiosHeaders$1.from(e.headers), e.data = transformData.call(
    e,
    e.transformRequest
  ), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(e.adapter || defaults.adapter)(e).then(function(a) {
    return throwIfCancellationRequested(e), a.data = transformData.call(
      e,
      e.transformResponse,
      a
    ), a.headers = AxiosHeaders$1.from(a.headers), a;
  }, function(a) {
    return isCancel$1(a) || (throwIfCancellationRequested(e), a && a.response && (a.response.data = transformData.call(
      e,
      e.transformResponse,
      a.response
    ), a.response.headers = AxiosHeaders$1.from(a.response.headers))), Promise.reject(a);
  });
}
const VERSION$1 = "1.10.0", validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => {
  validators$1[e] = function(a) {
    return typeof a === e || "a" + (t < 1 ? "n " : " ") + e;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function(t, n, a) {
  function o(s, u) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + s + "'" + u + (a ? ". " + a : "");
  }
  return (s, u, d) => {
    if (t === !1)
      throw new AxiosError$1(
        o(u, " has been removed" + (n ? " in " + n : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    return n && !deprecatedWarnings[u] && (deprecatedWarnings[u] = !0, console.warn(
      o(
        u,
        " has been deprecated since v" + n + " and will be removed in the near future"
      )
    )), t ? t(s, u, d) : !0;
  };
};
validators$1.spelling = function(t) {
  return (n, a) => (console.warn(`${a} is likely a misspelling of ${t}`), !0);
};
function assertOptions(e, t, n) {
  if (typeof e != "object")
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  const a = Object.keys(e);
  let o = a.length;
  for (; o-- > 0; ) {
    const s = a[o], u = t[s];
    if (u) {
      const d = e[s], f = d === void 0 || u(d, s, e);
      if (f !== !0)
        throw new AxiosError$1("option " + s + " must be " + f, AxiosError$1.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (n !== !0)
      throw new AxiosError$1("Unknown option " + s, AxiosError$1.ERR_BAD_OPTION);
  }
}
const validator = {
  assertOptions,
  validators: validators$1
}, validators = validator.validators;
let Axios$1 = class {
  constructor(t) {
    this.defaults = t || {}, this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(t, n) {
    try {
      return await this._request(t, n);
    } catch (a) {
      if (a instanceof Error) {
        let o = {};
        Error.captureStackTrace ? Error.captureStackTrace(o) : o = new Error();
        const s = o.stack ? o.stack.replace(/^.+\n/, "") : "";
        try {
          a.stack ? s && !String(a.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (a.stack += `
` + s) : a.stack = s;
        } catch {
        }
      }
      throw a;
    }
  }
  _request(t, n) {
    typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = mergeConfig$1(this.defaults, n);
    const { transitional: a, paramsSerializer: o, headers: s } = n;
    a !== void 0 && validator.assertOptions(a, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, !1), o != null && (utils$1.isFunction(o) ? n.paramsSerializer = {
      serialize: o
    } : validator.assertOptions(o, {
      encode: validators.function,
      serialize: validators.function
    }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), validator.assertOptions(n, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase();
    let u = s && utils$1.merge(
      s.common,
      s[n.method]
    );
    s && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (k) => {
        delete s[k];
      }
    ), n.headers = AxiosHeaders$1.concat(u, s);
    const d = [];
    let f = !0;
    this.interceptors.request.forEach(function(E) {
      typeof E.runWhen == "function" && E.runWhen(n) === !1 || (f = f && E.synchronous, d.unshift(E.fulfilled, E.rejected));
    });
    const g = [];
    this.interceptors.response.forEach(function(E) {
      g.push(E.fulfilled, E.rejected);
    });
    let v, b = 0, w;
    if (!f) {
      const k = [dispatchRequest.bind(this), void 0];
      for (k.unshift.apply(k, d), k.push.apply(k, g), w = k.length, v = Promise.resolve(n); b < w; )
        v = v.then(k[b++], k[b++]);
      return v;
    }
    w = d.length;
    let C = n;
    for (b = 0; b < w; ) {
      const k = d[b++], E = d[b++];
      try {
        C = k(C);
      } catch (A) {
        E.call(this, A);
        break;
      }
    }
    try {
      v = dispatchRequest.call(this, C);
    } catch (k) {
      return Promise.reject(k);
    }
    for (b = 0, w = g.length; b < w; )
      v = v.then(g[b++], g[b++]);
    return v;
  }
  getUri(t) {
    t = mergeConfig$1(this.defaults, t);
    const n = buildFullPath(t.baseURL, t.url, t.allowAbsoluteUrls);
    return buildURL(n, t.params, t.paramsSerializer);
  }
};
utils$1.forEach(["delete", "get", "head", "options"], function(t) {
  Axios$1.prototype[t] = function(n, a) {
    return this.request(mergeConfig$1(a || {}, {
      method: t,
      url: n,
      data: (a || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function(t) {
  function n(a) {
    return function(s, u, d) {
      return this.request(mergeConfig$1(d || {}, {
        method: t,
        headers: a ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: u
      }));
    };
  }
  Axios$1.prototype[t] = n(), Axios$1.prototype[t + "Form"] = n(!0);
});
let CancelToken$1 = class js {
  constructor(t) {
    if (typeof t != "function")
      throw new TypeError("executor must be a function.");
    let n;
    this.promise = new Promise(function(s) {
      n = s;
    });
    const a = this;
    this.promise.then((o) => {
      if (!a._listeners) return;
      let s = a._listeners.length;
      for (; s-- > 0; )
        a._listeners[s](o);
      a._listeners = null;
    }), this.promise.then = (o) => {
      let s;
      const u = new Promise((d) => {
        a.subscribe(d), s = d;
      }).then(o);
      return u.cancel = function() {
        a.unsubscribe(s);
      }, u;
    }, t(function(s, u, d) {
      a.reason || (a.reason = new CanceledError$1(s, u, d), n(a.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(t) {
    if (this.reason) {
      t(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(t) : this._listeners = [t];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(t) {
    if (!this._listeners)
      return;
    const n = this._listeners.indexOf(t);
    n !== -1 && this._listeners.splice(n, 1);
  }
  toAbortSignal() {
    const t = new AbortController(), n = (a) => {
      t.abort(a);
    };
    return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let t;
    return {
      token: new js(function(o) {
        t = o;
      }),
      cancel: t
    };
  }
};
function spread$1(e) {
  return function(n) {
    return e.apply(null, n);
  };
}
function isAxiosError$1(e) {
  return utils$1.isObject(e) && e.isAxiosError === !0;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([e, t]) => {
  HttpStatusCode$1[t] = e;
});
function createInstance(e) {
  const t = new Axios$1(e), n = bind(Axios$1.prototype.request, t);
  return utils$1.extend(n, Axios$1.prototype, t, { allOwnKeys: !0 }), utils$1.extend(n, t, null, { allOwnKeys: !0 }), n.create = function(o) {
    return createInstance(mergeConfig$1(e, o));
  }, n;
}
const axios = createInstance(defaults);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function(t) {
  return Promise.all(t);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (e) => formDataToJSON(utils$1.isHTMLForm(e) ? new FormData(e) : e);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken,
  VERSION,
  all,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios, checkStringStartsWith = (e) => (t) => typeof t == "string" && t.startsWith(e), isCSSVariableName = /* @__PURE__ */ checkStringStartsWith("--"), startsAsVariableToken = /* @__PURE__ */ checkStringStartsWith("var(--"), isCSSVariableToken = (e) => startsAsVariableToken(e) ? singleCssVariableRegex.test(e.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, scaleCorrectors = {};
function addScaleCorrector(e) {
  for (const t in e)
    scaleCorrectors[t] = e[t], isCSSVariableName(t) && (scaleCorrectors[t].isCSSVariable = !0);
}
function createContext(e, t) {
  const n = typeof e == "string" && !t ? `${e}Context` : t, a = Symbol(n);
  return [(u) => {
    const d = inject(a, u);
    if (d === void 0)
      throw new Error(
        `Injection \`${a.toString()}\` not found. Component must be used within ${Array.isArray(e) ? `one of the following components: ${e.join(
          ", "
        )}` : `\`${e}\``}`
      );
    return d;
  }, (u) => (provide(a, u), u)];
}
const [injectMotion, provideMotion] = createContext("Motion"), [injectLayoutGroup, provideLayoutGroup] = createContext("LayoutGroup");
function isAnimationControls$1(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
class Feature {
  constructor(t) {
    this.state = t;
  }
  beforeMount() {
  }
  mount() {
  }
  unmount() {
  }
  update() {
  }
  beforeUpdate() {
  }
  beforeUnmount() {
  }
}
var warning$1 = function() {
}, invariant$1 = function() {
};
process.env.NODE_ENV !== "production" && (warning$1 = function(e, t) {
  !e && typeof console < "u" && console.warn(t);
}, invariant$1 = function(e, t) {
  if (!e)
    throw new Error(t);
});
function resolveVariant$1(e, t, n) {
  if (Array.isArray(e))
    return e.reduce((a, o) => {
      const s = resolveVariant$1(o, t, n);
      return s ? { ...a, ...s } : a;
    }, {});
  if (typeof e == "object")
    return e;
  if (e && t) {
    const a = t[e];
    return typeof a == "function" ? a(n) : a;
  }
}
function hasChanged(e, t) {
  return typeof e != typeof t ? !0 : Array.isArray(e) && Array.isArray(t) ? !shallowCompare(e, t) : e !== t;
}
function shallowCompare(e, t) {
  const n = t.length;
  if (n !== e.length)
    return !1;
  for (let a = 0; a < n; a++)
    if (t[a] !== e[a])
      return !1;
  return !0;
}
function isCssVar(e) {
  return e?.startsWith("--");
}
const noopReturn = (e) => e;
function isNumber$1(e) {
  return typeof e == "number";
}
const svgElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "linearGradient",
  "radialGradient",
  "textPath"
], svgElementSet = new Set(svgElements);
function isSVGElement$1(e) {
  return svgElementSet.has(e);
}
class FeatureManager {
  constructor(t) {
    this.features = [];
    const { features: n = [], lazyMotionContext: a } = t.options, o = n.concat(a.features.value);
    this.features = o.map((u) => new u(t));
    const s = this.features;
    watch(a.features, (u) => {
      u.forEach((d) => {
        if (!o.includes(d)) {
          o.push(d);
          const f = new d(t);
          s.push(f), t.isMounted() && (f.beforeMount(), f.mount());
        }
      });
    }, {
      flush: "pre"
    });
  }
  mount() {
    this.features.forEach((t) => t.mount());
  }
  beforeMount() {
    this.features.forEach((t) => {
      var n;
      return (n = t.beforeMount) == null ? void 0 : n.call(t);
    });
  }
  unmount() {
    this.features.forEach((t) => t.unmount());
  }
  update() {
    this.features.forEach((t) => {
      var n;
      return (n = t.update) == null ? void 0 : n.call(t);
    });
  }
  beforeUpdate() {
    this.features.forEach((t) => t.beforeUpdate());
  }
  beforeUnmount() {
    this.features.forEach((t) => t.beforeUnmount());
  }
}
const doneCallbacks = /* @__PURE__ */ new WeakMap(), [injectAnimatePresence, provideAnimatePresence] = createContext("AnimatePresenceContext");
function isVariantLabels(e) {
  return typeof e == "string" || e === !1 || Array.isArray(e);
}
const noop = /* @__NO_SIDE_EFFECTS__ */ (e) => e, stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function createRenderStep(e, t) {
  let n = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), o = !1, s = !1;
  const u = /* @__PURE__ */ new WeakSet();
  let d = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function f(v) {
    u.has(v) && (g.schedule(v), e()), v(d);
  }
  const g = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (v, b = !1, w = !1) => {
      const k = w && o ? n : a;
      return b && u.add(v), k.has(v) || k.add(v), v;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (v) => {
      a.delete(v), u.delete(v);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (v) => {
      if (d = v, o) {
        s = !0;
        return;
      }
      o = !0, [n, a] = [a, n], n.forEach(f), n.clear(), o = !1, s && (s = !1, g.process(v));
    }
  };
  return g;
}
const MotionGlobalConfig = {}, maxElapsed = 40;
function createRenderBatcher(e, t) {
  let n = !1, a = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => n = !0, u = stepsOrder.reduce((B, _) => (B[_] = createRenderStep(s), B), {}), { setup: d, read: f, resolveKeyframes: g, preUpdate: v, update: b, preRender: w, render: C, postRender: k } = u, E = () => {
    const B = MotionGlobalConfig.useManualTiming ? o.timestamp : performance.now();
    n = !1, MotionGlobalConfig.useManualTiming || (o.delta = a ? 1e3 / 60 : Math.max(Math.min(B - o.timestamp, maxElapsed), 1)), o.timestamp = B, o.isProcessing = !0, d.process(o), f.process(o), g.process(o), v.process(o), b.process(o), w.process(o), C.process(o), k.process(o), o.isProcessing = !1, n && t && (a = !1, e(E));
  }, A = () => {
    n = !0, a = !0, o.isProcessing || e(E);
  };
  return { schedule: stepsOrder.reduce((B, _) => {
    const T = u[_];
    return B[_] = (O, I = !1, q = !1) => (n || A(), T.schedule(O, I, q)), B;
  }, {}), cancel: (B) => {
    for (let _ = 0; _ < stepsOrder.length; _++)
      u[stepsOrder[_]].cancel(B);
  }, state: o, steps: u };
}
const { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = /* @__PURE__ */ createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0), mountedStates = /* @__PURE__ */ new WeakMap();
let id$1 = 0;
const mountedLayoutIds = /* @__PURE__ */ new Set();
class MotionState {
  constructor(t, n) {
    var a;
    this.element = null, this.isSafeToRemove = !1, this.isVShow = !1, this.children = /* @__PURE__ */ new Set(), this.activeStates = {
      initial: !0,
      animate: !0
    }, this.currentProcess = null, this._context = null, this.animateUpdates = noop, this.id = `motion-state-${id$1++}`, this.options = t, this.parent = n, (a = n?.children) == null || a.add(this), this.depth = n?.depth + 1 || 0;
    const s = (t.initial === void 0 && t.variants ? this.context.initial : t.initial) === !1 ? ["initial", "animate"] : ["initial"];
    this.initTarget(s), this.featureManager = new FeatureManager(this), this.type = isSVGElement$1(this.options.as) ? "svg" : "html";
  }
  // Get animation context, falling back to parent context for inheritance
  get context() {
    if (!this._context) {
      const t = {
        get: (n, a) => {
          var o;
          return isVariantLabels(this.options[a]) ? this.options[a] : (o = this.parent) == null ? void 0 : o.context[a];
        }
      };
      this._context = new Proxy({}, t);
    }
    return this._context;
  }
  // Initialize animation target values
  initTarget(t) {
    var n;
    const a = this.options.custom ?? ((n = this.options.animatePresenceContext) == null ? void 0 : n.custom);
    this.baseTarget = t.reduce((o, s) => ({
      ...o,
      ...resolveVariant$1(this.options[s] || this.context[s], this.options.variants, a)
    }), {}), this.target = {};
  }
  // Update visual element with new options
  updateOptions(t) {
    var n;
    this.options = t, (n = this.visualElement) == null || n.update({
      ...this.options,
      whileTap: this.options.whilePress
    }, {
      isPresent: !doneCallbacks.has(this.element)
    });
  }
  // Called before mounting, executes in parent-to-child order
  beforeMount() {
    this.featureManager.beforeMount();
  }
  // Mount motion state to DOM element, handles parent-child relationships
  mount(t, n, a = !1) {
    var o;
    invariant$1(
      !!t,
      "Animation state must be mounted with valid Element"
    ), this.element = t, this.updateOptions(n), this.featureManager.mount(), !a && this.options.animate && ((o = this.startAnimation) == null || o.call(this)), this.options.layoutId && (mountedLayoutIds.add(this.options.layoutId), frame.render(() => {
      mountedLayoutIds.clear();
    }));
  }
  clearAnimation() {
    var t, n;
    this.currentProcess && cancelFrame(this.currentProcess), this.currentProcess = null, (n = (t = this.visualElement) == null ? void 0 : t.variantChildren) == null || n.forEach((a) => {
      a.state.clearAnimation();
    });
  }
  // update trigger animation
  startAnimation() {
    this.clearAnimation(), this.currentProcess = frame.render(() => {
      this.currentProcess = null, this.animateUpdates();
    });
  }
  // Called before unmounting, executes in child-to-parent order
  beforeUnmount() {
    this.featureManager.beforeUnmount();
  }
  // Unmount motion state and optionally unmount children
  // Handles unmounting in the correct order based on component tree
  unmount(t = !1) {
    const n = this.options.layoutId && !mountedLayoutIds.has(this.options.layoutId);
    (() => {
      const o = () => {
        var s, u, d;
        t && Array.from(this.children).reverse().forEach(this.unmountChild), (u = (s = this.parent) == null ? void 0 : s.children) == null || u.delete(this), mountedStates.delete(this.element), this.featureManager.unmount(), (d = this.visualElement) == null || d.unmount(), this.clearAnimation();
      };
      n ? Promise.resolve().then(o) : o();
    })();
  }
  unmountChild(t) {
    t.unmount(!0);
  }
  // Called before updating, executes in parent-to-child order
  beforeUpdate() {
    this.featureManager.beforeUpdate();
  }
  // Update motion state with new options
  update(t) {
    this.updateOptions(t), this.featureManager.update(), this.startAnimation();
  }
  // Set animation state active status and propagate to children
  setActive(t, n, a = !0) {
    var o;
    !this.element || this.activeStates[t] === n || (this.activeStates[t] = n, (o = this.visualElement.variantChildren) == null || o.forEach((s) => {
      s.state.setActive(t, n, !1);
    }), a && this.animateUpdates({
      isFallback: !n && t !== "exit" && this.visualElement.isControllingVariants,
      isExit: t === "exit" && this.activeStates.exit
    }));
  }
  isMounted() {
    return !!this.element;
  }
  // Called before layout updates to prepare for changes
  willUpdate(t) {
    var n;
    (this.options.layout || this.options.layoutId) && ((n = this.visualElement.projection) == null || n.willUpdate());
  }
}
const visualElementStore = /* @__PURE__ */ new WeakMap();
function motionEvent(e, t, n) {
  return new CustomEvent(e, { detail: { target: t, isExit: n } });
}
const rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: (e) => `${e}deg`
}, baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: (e) => `${e}px`
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: noopReturn
  },
  skew: rotation
}, order = ["translate", "scale", "rotate", "skew"], axes = ["", "X", "Y", "Z"], transformDefinitions = /* @__PURE__ */ new Map(), transforms = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
order.forEach((e) => {
  axes.forEach((t) => {
    transforms.push(e + t), transformDefinitions.set(
      e + t,
      baseTransformProperties[e]
    );
  });
});
const transformLookup = new Set(transforms), isTransform = (e) => transformLookup.has(e), transformAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ"
};
function compareTransformOrder([e], [t]) {
  return transforms.indexOf(e) - transforms.indexOf(t);
}
function transformListToString(e, [t, n]) {
  return `${e} ${t}(${n})`;
}
function buildTransformTemplate(e) {
  return e.sort(compareTransformOrder).reduce(transformListToString, "").trim();
}
const transformResetValue = {
  translate: [0, 0],
  rotate: 0,
  scale: 1,
  skew: 0,
  x: 0,
  y: 0,
  z: 0
}, createUnitType = /* @__NO_SIDE_EFFECTS__ */ (e) => ({
  test: (t) => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1,
  parse: parseFloat,
  transform: (t) => `${t}${e}`
}), degrees = /* @__PURE__ */ createUnitType("deg"), percent = /* @__PURE__ */ createUnitType("%"), px = /* @__PURE__ */ createUnitType("px"), vh = /* @__PURE__ */ createUnitType("vh"), vw = /* @__PURE__ */ createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (e) => percent.parse(e) / 100,
  transform: (e) => percent.transform(e * 100)
}, isMotionValue = (e) => !!(e && e.getVelocity), style = {
  get: (e, t) => {
    let n = isCssVar(t) ? e.style.getPropertyValue(t) : getComputedStyle(e)[t];
    if (!n && n !== "0") {
      const a = transformDefinitions.get(t);
      a && (n = a.initialValue);
    }
    return n;
  },
  set: (e, t, n) => {
    isCssVar(t) ? e.style.setProperty(t, n) : e.style[t] = n;
  }
};
function createStyles(e) {
  var t;
  const n = {}, a = [];
  for (let o in e) {
    let s = e[o];
    s = isMotionValue(s) ? s.get() : s, isTransform(o) && o in transformAlias && (o = transformAlias[o]);
    let u = Array.isArray(s) ? s[0] : s;
    const d = transformDefinitions.get(o);
    d ? (u = isNumber$1(s) ? (t = d.toDefaultUnit) == null ? void 0 : t.call(d, s) : s, a.push([o, u])) : n[o] = u;
  }
  return a.length && (n.transform = buildTransformTemplate(a)), Object.keys(n).length === 0 ? null : n;
}
const SVG_STYLE_TO_ATTRIBUTES = {
  fill: !0,
  stroke: !0,
  opacity: !0,
  "stroke-width": !0,
  "fill-opacity": !0,
  "stroke-opacity": !0,
  "stroke-linecap": !0,
  "stroke-linejoin": !0,
  "stroke-dasharray": !0,
  "stroke-dashoffset": !0,
  cx: !0,
  cy: !0,
  r: !0,
  d: !0,
  x1: !0,
  y1: !0,
  x2: !0,
  y2: !0,
  points: !0,
  "path-length": !0,
  viewBox: !0,
  width: !0,
  height: !0,
  "preserve-aspect-ratio": !0,
  "clip-path": !0,
  filter: !0,
  mask: !0,
  "stop-color": !0,
  "stop-opacity": !0,
  "gradient-transform": !0,
  "gradient-units": !0,
  "spread-method": !0,
  "marker-end": !0,
  "marker-mid": !0,
  "marker-start": !0,
  "text-anchor": !0,
  "dominant-baseline": !0,
  "font-family": !0,
  "font-size": !0,
  "font-weight": !0,
  "letter-spacing": !0,
  "vector-effect": !0
};
function camelToKebab(e) {
  return e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function buildSVGPath$1(e, t, n = 1, a = 0) {
  e.pathLength = 1, delete e["path-length"], e["stroke-dashoffset"] = px.transform(-a);
  const o = px.transform(t), s = px.transform(n);
  e["stroke-dasharray"] = `${o} ${s}`;
}
function convertSvgStyleToAttributes(e) {
  const t = {}, n = {};
  for (const a in e) {
    const o = camelToKebab(a);
    if (o in SVG_STYLE_TO_ATTRIBUTES) {
      const s = e[a];
      t[o] = isMotionValue(s) ? s.get() : s;
    } else
      n[a] = e[a];
  }
  return t["path-length"] !== void 0 && buildSVGPath$1(t, t["path-length"], t["path-spacing"], t["path-offset"]), {
    attrs: t,
    style: n
  };
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const isDef = (e) => typeof e < "u";
function convertBoundingBoxToBox$1({ top: e, left: t, right: n, bottom: a }) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: a }
  };
}
function transformBoxPoints$1(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), a = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: a.y,
    right: a.x
  };
}
function measureViewportBox$1(e, t) {
  return convertBoundingBoxToBox$1(transformBoxPoints$1(e.getBoundingClientRect(), t));
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const e in featureProps)
  featureDefinitions[e] = {
    isEnabled: (t) => featureProps[e].some((n) => !!t[n])
  };
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis$1 = () => ({ min: 0, max: 0 }), createBox$1 = () => ({
  x: createAxis$1(),
  y: createAxis$1()
}), isBrowser = typeof window < "u", prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), t = () => prefersReducedMotion.current = e.matches;
      e.addEventListener("change", t), t();
    } else
      prefersReducedMotion.current = !1;
}
function isAnimationControls(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function isVariantLabel(e) {
  return typeof e == "string" || Array.isArray(e);
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(e) {
  return isAnimationControls(e.animate) || variantProps.some((t) => isVariantLabel(e[t]));
}
function isVariantNode(e) {
  return !!(isControllingVariants(e) || e.variants);
}
let now;
function clearTime() {
  now = void 0;
}
const time = {
  now: () => (now === void 0 && time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (e) => {
    now = e, queueMicrotask(clearTime);
  }
}, warned = /* @__PURE__ */ new Set();
function warnOnce(e, t, n) {
  e || warned.has(t) || (console.warn(t), warned.add(t));
}
function addUniqueItem(e, t) {
  e.indexOf(t) === -1 && e.push(t);
}
function removeItem(e, t) {
  const n = e.indexOf(t);
  n > -1 && e.splice(n, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(t) {
    return addUniqueItem(this.subscriptions, t), () => removeItem(this.subscriptions, t);
  }
  notify(t, n, a) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](t, n, a);
      else
        for (let s = 0; s < o; s++) {
          const u = this.subscriptions[s];
          u && u(t, n, a);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function velocityPerSecond(e, t) {
  return t ? e * (1e3 / t) : 0;
}
const MAX_VELOCITY_DELTA = 30, isFloat = (e) => !isNaN(parseFloat(e));
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(t, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (a, o = !0) => {
      var s, u;
      const d = time.now();
      if (this.updatedAt !== d && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(a), this.current !== this.prev && ((s = this.events.change) == null || s.notify(this.current), this.dependents))
        for (const f of this.dependents)
          f.dirty();
      o && ((u = this.events.renderRequest) == null || u.notify(this.current));
    }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner;
  }
  setCurrent(t) {
    this.current = t, this.updatedAt = time.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = isFloat(this.current));
  }
  setPrevFrameValue(t = this.current) {
    this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(t) {
    return process.env.NODE_ENV !== "production" && warnOnce(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", t);
  }
  on(t, n) {
    this.events[t] || (this.events[t] = new SubscriptionManager());
    const a = this.events[t].add(n);
    return t === "change" ? () => {
      a(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : a;
  }
  clearListeners() {
    for (const t in this.events)
      this.events[t].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(t, n) {
    this.passiveEffect = t, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(t, n = !0) {
    !n || !this.passiveEffect ? this.updateAndNotify(t, n) : this.passiveEffect(t, this.updateAndNotify);
  }
  setWithVelocity(t, n, a) {
    this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - a;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(t, n = !0) {
    this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var t;
    (t = this.events.change) == null || t.notify(this.current);
  }
  addDependent(t) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(t);
  }
  removeDependent(t) {
    this.dependents && this.dependents.delete(t);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const t = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(t) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var t, n;
    (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(e, t) {
  return new MotionValue(e, t);
}
function updateMotionValuesFromProps(e, t, n) {
  for (const a in t) {
    const o = t[a], s = n[a];
    if (isMotionValue(o))
      e.addValue(a, o);
    else if (isMotionValue(s))
      e.addValue(a, motionValue(o, { owner: e }));
    else if (s !== o)
      if (e.hasValue(a)) {
        const u = e.getValue(a);
        u.liveStyle === !0 ? u.jump(o) : u.hasAnimated || u.set(o);
      } else {
        const u = e.getStaticValue(a);
        e.addValue(a, motionValue(u !== void 0 ? u : o, { owner: e }));
      }
  }
  for (const a in n)
    t[a] === void 0 && e.removeValue(a);
  return t;
}
function getValueState(e) {
  const t = [{}, {}];
  return e?.values.forEach((n, a) => {
    t[0][a] = n.get(), t[1][a] = n.getVelocity();
  }), t;
}
function resolveVariantFromProps(e, t, n, a) {
  if (typeof t == "function") {
    const [o, s] = getValueState(a);
    t = t(n !== void 0 ? n : e.custom, o, s);
  }
  if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") {
    const [o, s] = getValueState(a);
    t = t(n !== void 0 ? n : e.custom, o, s);
  }
  return t;
}
function fillWildcards(e) {
  for (let t = 1; t < e.length; t++)
    e[t] ?? (e[t] = e[t - 1]);
}
const radToDeg = (e) => e * 180 / Math.PI, rotate = (e) => {
  const t = radToDeg(Math.atan2(e[1], e[0]));
  return rebaseAngle(t);
}, matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (e) => (Math.abs(e[0]) + Math.abs(e[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (e) => radToDeg(Math.atan(e[1])),
  skewY: (e) => radToDeg(Math.atan(e[2])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[2])) / 2
}, rebaseAngle = (e) => (e = e % 360, e < 0 && (e += 360), e), rotateZ = rotate, scaleX = (e) => Math.sqrt(e[0] * e[0] + e[1] * e[1]), scaleY = (e) => Math.sqrt(e[4] * e[4] + e[5] * e[5]), matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (e) => (scaleX(e) + scaleY(e)) / 2,
  rotateX: (e) => rebaseAngle(radToDeg(Math.atan2(e[6], e[5]))),
  rotateY: (e) => rebaseAngle(radToDeg(Math.atan2(-e[2], e[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (e) => radToDeg(Math.atan(e[4])),
  skewY: (e) => radToDeg(Math.atan(e[1])),
  skew: (e) => (Math.abs(e[1]) + Math.abs(e[4])) / 2
};
function defaultTransformValue(e) {
  return e.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(e, t) {
  if (!e || e === "none")
    return defaultTransformValue(t);
  const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let a, o;
  if (n)
    a = matrix3dParsers, o = n;
  else {
    const d = e.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    a = matrix2dParsers, o = d;
  }
  if (!o)
    return defaultTransformValue(t);
  const s = a[t], u = o[1].split(",").map(convertTransformToNumber);
  return typeof s == "function" ? s(u) : u[s];
}
const readTransformValue = (e, t) => {
  const { transform: n = "none" } = getComputedStyle(e);
  return parseValueFromTransform(n, t);
};
function convertTransformToNumber(e) {
  return parseFloat(e.trim());
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder), clamp = (e, t, n) => n > t ? t : n < e ? e : n, number = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, alpha = {
  ...number,
  transform: (e) => clamp(0, 1, e)
}, scale = {
  ...number,
  default: 1
}, isNumOrPxType = (e) => e === number || e === px, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((e) => !transformKeys.has(e));
function removeNonTranslationalTransform(e) {
  const t = [];
  return nonTranslationalTransformKeys.forEach((n) => {
    const a = e.getValue(n);
    a !== void 0 && (t.push([n, a.get()]), a.set(n.startsWith("scale") ? 1 : 0));
  }), t;
}
const positionalValues = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n),
  top: (e, { top: t }) => parseFloat(t),
  left: (e, { left: t }) => parseFloat(t),
  bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
  right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
  // Transform
  x: (e, { transform: t }) => parseValueFromTransform(t, "x"),
  y: (e, { transform: t }) => parseValueFromTransform(t, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = /* @__PURE__ */ new Set();
let isScheduled = !1, anyNeedsMeasurement = !1, isForced = !1;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const e = Array.from(toResolve).filter((a) => a.needsMeasurement), t = new Set(e.map((a) => a.element)), n = /* @__PURE__ */ new Map();
    t.forEach((a) => {
      const o = removeNonTranslationalTransform(a);
      o.length && (n.set(a, o), a.render());
    }), e.forEach((a) => a.measureInitialState()), t.forEach((a) => {
      a.render();
      const o = n.get(a);
      o && o.forEach(([s, u]) => {
        var d;
        (d = a.getValue(s)) == null || d.set(u);
      });
    }), e.forEach((a) => a.measureEndState()), e.forEach((a) => {
      a.suspendedScrollY !== void 0 && window.scrollTo(0, a.suspendedScrollY);
    });
  }
  anyNeedsMeasurement = !1, isScheduled = !1, toResolve.forEach((e) => e.complete(isForced)), toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (anyNeedsMeasurement = !0);
  });
}
function flushKeyframeResolvers() {
  isForced = !0, readAllKeyframes(), measureAllKeyframes(), isForced = !1;
}
class KeyframeResolver {
  constructor(t, n, a, o, s, u = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = a, this.motionValue = o, this.element = s, this.isAsync = u;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (toResolve.add(this), isScheduled || (isScheduled = !0, frame.read(readAllKeyframes), frame.resolveKeyframes(measureAllKeyframes))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, name: n, element: a, motionValue: o } = this;
    if (t[0] === null) {
      const s = o?.get(), u = t[t.length - 1];
      if (s !== void 0)
        t[0] = s;
      else if (a && n) {
        const d = a.readValue(n, u);
        d != null && (t[0] = d);
      }
      t[0] === void 0 && (t[0] = u), o && s === void 0 && o.set(t[0]);
    }
    fillWildcards(t);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(t = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), toResolve.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (toResolve.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const isNumericalString = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), isZeroValueString = (e) => /^0[^.\s]+$/u.test(e), sanitize = (e) => Math.round(e * 1e5) / 1e5, floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(e) {
  return e == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, isColorString = (e, t) => (n) => !!(typeof n == "string" && singleColorRegex.test(n) && n.startsWith(e) || t && !isNullish(n) && Object.prototype.hasOwnProperty.call(n, t)), splitColor = (e, t, n) => (a) => {
  if (typeof a != "string")
    return a;
  const [o, s, u, d] = a.match(floatRegex);
  return {
    [e]: parseFloat(o),
    [t]: parseFloat(s),
    [n]: parseFloat(u),
    alpha: d !== void 0 ? parseFloat(d) : 1
  };
}, clampRgbUnit = (e) => clamp(0, 255, e), rgbUnit = {
  ...number,
  transform: (e) => Math.round(clampRgbUnit(e))
}, rgba = {
  test: /* @__PURE__ */ isColorString("rgb", "red"),
  parse: /* @__PURE__ */ splitColor("red", "green", "blue"),
  transform: ({ red: e, green: t, blue: n, alpha: a = 1 }) => "rgba(" + rgbUnit.transform(e) + ", " + rgbUnit.transform(t) + ", " + rgbUnit.transform(n) + ", " + sanitize(alpha.transform(a)) + ")"
};
function parseHex(e) {
  let t = "", n = "", a = "", o = "";
  return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), a = e.substring(5, 7), o = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), a = e.substring(3, 4), o = e.substring(4, 5), t += t, n += n, a += a, o += o), {
    red: parseInt(t, 16),
    green: parseInt(n, 16),
    blue: parseInt(a, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const hex = {
  test: /* @__PURE__ */ isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
}, hsla = {
  test: /* @__PURE__ */ isColorString("hsl", "hue"),
  parse: /* @__PURE__ */ splitColor("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: t, lightness: n, alpha: a = 1 }) => "hsla(" + Math.round(e) + ", " + percent.transform(sanitize(t)) + ", " + percent.transform(sanitize(n)) + ", " + sanitize(alpha.transform(a)) + ")"
}, color = {
  test: (e) => rgba.test(e) || hex.test(e) || hsla.test(e),
  parse: (e) => rgba.test(e) ? rgba.parse(e) : hsla.test(e) ? hsla.parse(e) : hex.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? rgba.transform(e) : hsla.transform(e),
  getAnimatableNone: (e) => {
    const t = color.parse(e);
    return t.alpha = 0, color.transform(t);
  }
}, colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(e) {
  var t, n;
  return isNaN(e) && typeof e == "string" && (((t = e.match(floatRegex)) == null ? void 0 : t.length) || 0) + (((n = e.match(colorRegex)) == null ? void 0 : n.length) || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(e) {
  const t = e.toString(), n = [], a = {
    color: [],
    number: [],
    var: []
  }, o = [];
  let s = 0;
  const d = t.replace(complexRegex, (f) => (color.test(f) ? (a.color.push(s), o.push(COLOR_TOKEN), n.push(color.parse(f))) : f.startsWith(VAR_FUNCTION_TOKEN) ? (a.var.push(s), o.push(VAR_TOKEN), n.push(f)) : (a.number.push(s), o.push(NUMBER_TOKEN), n.push(parseFloat(f))), ++s, SPLIT_TOKEN)).split(SPLIT_TOKEN);
  return { values: n, split: d, indexes: a, types: o };
}
function parseComplexValue(e) {
  return analyseComplexValue(e).values;
}
function createTransformer(e) {
  const { split: t, types: n } = analyseComplexValue(e), a = t.length;
  return (o) => {
    let s = "";
    for (let u = 0; u < a; u++)
      if (s += t[u], o[u] !== void 0) {
        const d = n[u];
        d === NUMBER_TOKEN ? s += sanitize(o[u]) : d === COLOR_TOKEN ? s += color.transform(o[u]) : s += o[u];
      }
    return s;
  };
}
const convertNumbersToZero = (e) => typeof e == "number" ? 0 : color.test(e) ? color.getAnimatableNone(e) : e;
function getAnimatableNone$1(e) {
  const t = parseComplexValue(e);
  return createTransformer(e)(t.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
}, auto = {
  test: (e) => e === "auto",
  parse: (e) => e
}, testValueType = (e) => (t) => t.test(e), dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = (e) => dimensionValueTypes.find(testValueType(e)), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (e) => valueTypes.find(testValueType(e)), maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(e) {
  const [t, n] = e.slice(0, -1).split("(");
  if (t === "drop-shadow")
    return e;
  const [a] = n.match(floatRegex) || [];
  if (!a)
    return e;
  const o = n.replace(a, "");
  let s = maxDefaults.has(t) ? 1 : 0;
  return a !== n && (s *= 100), t + "(" + s + o + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu, filter = {
  ...complex,
  getAnimatableNone: (e) => {
    const t = e.match(functionRegex);
    return t ? t.map(applyDefaultFilter).join(" ") : e;
  }
}, int = {
  ...number,
  transform: Math.round
}, transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
}, numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (e) => defaultValueTypes[e];
function getAnimatableNone(e, t) {
  let n = getDefaultValueType(e);
  return n !== filter && (n = complex), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0;
}
const propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(t, n, a) {
    return {};
  }
  constructor({ parent: t, props: n, presenceContext: a, reducedMotionConfig: o, blockInitialAnimation: s, visualState: u }, d = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = KeyframeResolver, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const w = time.now();
      this.renderScheduledAt < w && (this.renderScheduledAt = w, frame.render(this.render, !1, !0));
    };
    const { latestValues: f, renderState: g } = u;
    this.latestValues = f, this.baseTarget = { ...f }, this.initialValues = n.initial ? { ...f } : {}, this.renderState = g, this.parent = t, this.props = n, this.presenceContext = a, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = o, this.options = d, this.blockInitialAnimation = !!s, this.isControllingVariants = isControllingVariants(n), this.isVariantNode = isVariantNode(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(t && t.current);
    const { willChange: v, ...b } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const w in b) {
      const C = b[w];
      f[w] !== void 0 && isMotionValue(C) && C.set(f[w], !1);
    }
  }
  mount(t) {
    this.current = t, visualElementStore.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, a) => this.bindToMotionValue(a, n)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, process.env.NODE_ENV !== "production" && warnOnce(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((t) => t()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const t in this.events)
      this.events[t].clear();
    for (const t in this.features) {
      const n = this.features[t];
      n && (n.unmount(), n.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(t, n) {
    this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)();
    const a = transformProps.has(t);
    a && this.onBindTransform && this.onBindTransform();
    const o = n.on("change", (d) => {
      this.latestValues[t] = d, this.props.onUpdate && frame.preRender(this.notifyUpdate), a && this.projection && (this.projection.isTransformDirty = !0);
    }), s = n.on("renderRequest", this.scheduleRender);
    let u;
    window.MotionCheckAppearSync && (u = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => {
      o(), s(), u && u(), n.owner && n.stop();
    });
  }
  sortNodePosition(t) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current);
  }
  updateFeatures() {
    let t = "animation";
    for (t in featureDefinitions) {
      const n = featureDefinitions[t];
      if (!n)
        continue;
      const { isEnabled: a, Feature: o } = n;
      if (!this.features[t] && o && a(this.props) && (this.features[t] = new o(this)), this.features[t]) {
        const s = this.features[t];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox$1();
  }
  getStaticValue(t) {
    return this.latestValues[t];
  }
  setStaticValue(t, n) {
    this.latestValues[t] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(t, n) {
    (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let a = 0; a < propEventHandlers.length; a++) {
      const o = propEventHandlers[a];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const s = "on" + o, u = t[s];
      u && (this.propEventSubscriptions[o] = this.on(o, u));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(t) {
    return this.props.variants ? this.props.variants[t] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(t) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(t, n) {
    const a = this.values.get(t);
    n !== a && (a && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(t) {
    this.values.delete(t);
    const n = this.valueSubscriptions.get(t);
    n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(t) {
    return this.values.has(t);
  }
  getValue(t, n) {
    if (this.props.values && this.props.values[t])
      return this.props.values[t];
    let a = this.values.get(t);
    return a === void 0 && n !== void 0 && (a = motionValue(n === null ? void 0 : n, { owner: this }), this.addValue(t, a)), a;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(t, n) {
    let a = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options);
    return a != null && (typeof a == "string" && (isNumericalString(a) || isZeroValueString(a)) ? a = parseFloat(a) : !findValueType(a) && complex.test(n) && (a = getAnimatableNone(t, n)), this.setBaseTarget(t, isMotionValue(a) ? a.get() : a)), isMotionValue(a) ? a.get() : a;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(t, n) {
    this.baseTarget[t] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(t) {
    var n;
    const { initial: a } = this.props;
    let o;
    if (typeof a == "string" || typeof a == "object") {
      const u = resolveVariantFromProps(this.props, a, (n = this.presenceContext) == null ? void 0 : n.custom);
      u && (o = u[t]);
    }
    if (a && o !== void 0)
      return o;
    const s = this.getBaseTargetFromProps(this.props, t);
    return s !== void 0 && !isMotionValue(s) ? s : this.initialValues[t] !== void 0 && o === void 0 ? void 0 : this.baseTarget[t];
  }
  on(t, n) {
    return this.events[t] || (this.events[t] = new SubscriptionManager()), this.events[t].add(n);
  }
  notify(t, ...n) {
    this.events[t] && this.events[t].notify(...n);
  }
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);
let warning = () => {
}, invariant = () => {
};
process.env.NODE_ENV !== "production" && (warning = (e, t) => {
  !e && typeof console < "u" && console.warn(t);
}, invariant = (e, t) => {
  if (!e)
    throw new Error(t);
});
const splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(e) {
  const t = splitCSSVariableRegex.exec(e);
  if (!t)
    return [,];
  const [, n, a, o] = t;
  return [`--${n ?? a}`, o];
}
const maxDepth = 4;
function getVariableValue(e, t, n = 1) {
  invariant(n <= maxDepth, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`);
  const [a, o] = parseCSSVariable(e);
  if (!a)
    return;
  const s = window.getComputedStyle(t).getPropertyValue(a);
  if (s) {
    const u = s.trim();
    return isNumericalString(u) ? parseFloat(u) : u;
  }
  return isCSSVariableToken(o) ? getVariableValue(o, t, n + 1) : o;
}
function isNone(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || isZeroValueString(e) : !0;
}
const invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(e, t, n) {
  let a = 0, o;
  for (; a < e.length && !o; ) {
    const s = e[a];
    typeof s == "string" && !invalidTemplates.has(s) && analyseComplexValue(s).values.length && (o = e[a]), a++;
  }
  if (o && n)
    for (const s of t)
      e[s] = getAnimatableNone(n, o);
}
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(t, n, a, o, s) {
    super(t, n, a, o, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: t, element: n, name: a } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let f = 0; f < t.length; f++) {
      let g = t[f];
      if (typeof g == "string" && (g = g.trim(), isCSSVariableToken(g))) {
        const v = getVariableValue(g, n.current);
        v !== void 0 && (t[f] = v), f === t.length - 1 && (this.finalKeyframe = g);
      }
    }
    if (this.resolveNoneKeyframes(), !positionalKeys.has(a) || t.length !== 2)
      return;
    const [o, s] = t, u = findDimensionValueType(o), d = findDimensionValueType(s);
    if (u !== d)
      if (isNumOrPxType(u) && isNumOrPxType(d))
        for (let f = 0; f < t.length; f++) {
          const g = t[f];
          typeof g == "string" && (t[f] = parseFloat(g));
        }
      else positionalValues[a] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: t, name: n } = this, a = [];
    for (let o = 0; o < t.length; o++)
      (t[o] === null || isNone(t[o])) && a.push(o);
    a.length && makeNoneKeyframesAnimatable(t, a, n);
  }
  measureInitialState() {
    const { element: t, unresolvedKeyframes: n, name: a } = this;
    if (!t || !t.current)
      return;
    a === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = positionalValues[a](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin;
    const o = n[n.length - 1];
    o !== void 0 && t.getValue(a, o).jump(o, !1);
  }
  measureEndState() {
    var t;
    const { element: n, name: a, unresolvedKeyframes: o } = this;
    if (!n || !n.current)
      return;
    const s = n.getValue(a);
    s && s.jump(this.measuredOrigin, !1);
    const u = o.length - 1, d = o[u];
    o[u] = positionalValues[a](n.measureViewportBox(), window.getComputedStyle(n.current)), d !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = d), (t = this.removedTransforms) != null && t.length && this.removedTransforms.forEach(([f, g]) => {
      n.getValue(f).set(g);
    }), this.resolveNoneKeyframes();
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(t, n) {
    return t.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(t, n) {
    return t.style ? t.style[n] : void 0;
  }
  removeValueFromRenderState(t, { vars: n, style: a }) {
    delete n[t], delete a[t];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: t } = this.props;
    isMotionValue(t) && (this.childSubscription = t.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
const getValueAsType = (e, t) => t && typeof e == "number" ? t.transform(e) : e, translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(e, t, n) {
  let a = "", o = !0;
  for (let s = 0; s < numTransforms; s++) {
    const u = transformPropOrder[s], d = e[u];
    if (d === void 0)
      continue;
    let f = !0;
    if (typeof d == "number" ? f = d === (u.startsWith("scale") ? 1 : 0) : f = parseFloat(d) === 0, !f || n) {
      const g = getValueAsType(d, numberValueTypes[u]);
      if (!f) {
        o = !1;
        const v = translateAlias[u] || u;
        a += `${v}(${g}) `;
      }
      n && (t[u] = g);
    }
  }
  return a = a.trim(), n ? a = n(t, o ? "" : a) : o && (a = "none"), a;
}
function buildHTMLStyles(e, t, n) {
  const { style: a, vars: o, transformOrigin: s } = e;
  let u = !1, d = !1;
  for (const f in t) {
    const g = t[f];
    if (transformProps.has(f)) {
      u = !0;
      continue;
    } else if (isCSSVariableName(f)) {
      o[f] = g;
      continue;
    } else {
      const v = getValueAsType(g, numberValueTypes[f]);
      f.startsWith("origin") ? (d = !0, s[f] = v) : a[f] = v;
    }
  }
  if (t.transform || (u || n ? a.transform = buildTransform(t, e.transform, n) : a.transform && (a.transform = "none")), d) {
    const { originX: f = "50%", originY: g = "50%", originZ: v = 0 } = s;
    a.transformOrigin = `${f} ${g} ${v}`;
  }
}
function renderHTML(e, { style: t, vars: n }, a, o) {
  const s = e.style;
  let u;
  for (u in t)
    s[u] = t[u];
  o?.applyProjectionStyles(s, a);
  for (u in n)
    s.setProperty(u, n[u]);
}
function isForcedMotionValue(e, { layout: t, layoutId: n }) {
  return transformProps.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!scaleCorrectors[e] || e === "opacity");
}
function scrapeMotionValuesFromProps$1(e, t, n) {
  var a;
  const { style: o } = e, s = {};
  for (const u in o)
    (isMotionValue(o[u]) || t.style && isMotionValue(t.style[u]) || isForcedMotionValue(u, e) || ((a = n?.getValue(u)) == null ? void 0 : a.liveStyle) !== void 0) && (s[u] = o[u]);
  return s;
}
function getComputedStyle$1(e) {
  return window.getComputedStyle(e);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = renderHTML;
  }
  readValueFromInstance(t, n) {
    var a;
    if (transformProps.has(n))
      return (a = this.projection) != null && a.isProjecting ? defaultTransformValue(n) : readTransformValue(t, n);
    {
      const o = getComputedStyle$1(t), s = (isCSSVariableName(n) ? o.getPropertyValue(n) : o[n]) || 0;
      return typeof s == "string" ? s.trim() : s;
    }
  }
  measureInstanceViewportBox(t, { transformPagePoint: n }) {
    return measureViewportBox$1(t, n);
  }
  build(t, n, a) {
    buildHTMLStyles(t, n, a.transformTemplate);
  }
  scrapeMotionValuesFromProps(t, n, a) {
    return scrapeMotionValuesFromProps$1(t, n, a);
  }
}
const camelToDash = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(e, t, n = 1, a = 0, o = !0) {
  e.pathLength = 1;
  const s = o ? dashKeys : camelKeys;
  e[s.offset] = px.transform(-a);
  const u = px.transform(t), d = px.transform(n);
  e[s.array] = `${u} ${d}`;
}
function buildSVGAttrs(e, {
  attrX: t,
  attrY: n,
  attrScale: a,
  pathLength: o,
  pathSpacing: s = 1,
  pathOffset: u = 0,
  // This is object creation, which we try to avoid per-frame.
  ...d
}, f, g, v) {
  if (buildHTMLStyles(e, d, g), f) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: b, style: w } = e;
  b.transform && (w.transform = b.transform, delete b.transform), (w.transform || b.transformOrigin) && (w.transformOrigin = b.transformOrigin ?? "50% 50%", delete b.transformOrigin), w.transform && (w.transformBox = v?.transformBox ?? "fill-box", delete b.transformBox), t !== void 0 && (b.x = t), n !== void 0 && (b.y = n), a !== void 0 && (b.scale = a), o !== void 0 && buildSVGPath(b, o, s, u, !1);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), isSVGTag = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function renderSVG(e, t, n, a) {
  renderHTML(e, t, void 0, a);
  for (const o in t.attrs)
    e.setAttribute(camelCaseAttributes.has(o) ? o : camelToDash(o), t.attrs[o]);
}
function scrapeMotionValuesFromProps(e, t, n) {
  const a = scrapeMotionValuesFromProps$1(e, t, n);
  for (const o in e)
    if (isMotionValue(e[o]) || isMotionValue(t[o])) {
      const s = transformPropOrder.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      a[s] = e[o];
    }
  return a;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = createBox$1;
  }
  getBaseTargetFromProps(t, n) {
    return t[n];
  }
  readValueFromInstance(t, n) {
    if (transformProps.has(n)) {
      const a = getDefaultValueType(n);
      return a && a.default || 0;
    }
    return n = camelCaseAttributes.has(n) ? n : camelToDash(n), t.getAttribute(n);
  }
  scrapeMotionValuesFromProps(t, n, a) {
    return scrapeMotionValuesFromProps(t, n, a);
  }
  build(t, n, a) {
    buildSVGAttrs(t, n, this.isSVGTag, a.transformTemplate, a.style);
  }
  renderInstance(t, n, a, o) {
    renderSVG(t, n, a, o);
  }
  mount(t) {
    this.isSVGTag = isSVGTag(t.tagName), super.mount(t);
  }
}
function createVisualElement(e, t) {
  return isSVGElement$1(e) ? new SVGVisualElement(t) : new HTMLVisualElement(t);
}
function isDOMKeyframes(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function resolveElements(e, t, n) {
  if (e instanceof EventTarget)
    return [e];
  if (typeof e == "string") {
    let a = document;
    const o = n?.[e] ?? a.querySelectorAll(e);
    return o ? Array.from(o) : [];
  }
  return Array.from(e);
}
function resolveSubjects(e, t, n, a) {
  return typeof e == "string" && isDOMKeyframes(t) ? resolveElements(e, n, a) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e];
}
function calculateRepeatDuration(e, t, n) {
  return e * (t + 1);
}
function calcNextTime(e, t, n, a) {
  return typeof t == "number" ? t : t.startsWith("-") || t.startsWith("+") ? Math.max(0, e + parseFloat(t)) : t === "<" ? n : t.startsWith("<") ? Math.max(0, n + parseFloat(t.slice(1))) : a.get(t) ?? e;
}
const mixNumber$1 = (e, t, n) => e + (t - e) * n, wrap = (e, t, n) => {
  const a = t - e;
  return ((n - e) % a + a) % a + e;
}, isEasingArray = (e) => Array.isArray(e) && typeof e[0] != "number";
function getEasingForSegment(e, t) {
  return isEasingArray(e) ? e[wrap(0, e.length, t)] : e;
}
function eraseKeyframes(e, t, n) {
  for (let a = 0; a < e.length; a++) {
    const o = e[a];
    o.at > t && o.at < n && (removeItem(e, o), a--);
  }
}
function addKeyframes(e, t, n, a, o, s) {
  eraseKeyframes(e, o, s);
  for (let u = 0; u < t.length; u++)
    e.push({
      value: t[u],
      at: mixNumber$1(o, s, a[u]),
      easing: getEasingForSegment(n, u)
    });
}
function normalizeTimes(e, t) {
  for (let n = 0; n < e.length; n++)
    e[n] = e[n] / (t + 1);
}
function compareByTime(e, t) {
  return e.at === t.at ? e.value === null ? 1 : t.value === null ? -1 : 0 : e.at - t.at;
}
const progress = /* @__NO_SIDE_EFFECTS__ */ (e, t, n) => {
  const a = t - e;
  return a === 0 ? 1 : (n - e) / a;
};
function fillOffset(e, t) {
  const n = e[e.length - 1];
  for (let a = 1; a <= t; a++) {
    const o = /* @__PURE__ */ progress(0, t, a);
    e.push(mixNumber$1(n, 1, o));
  }
}
function defaultOffset(e) {
  const t = [0];
  return fillOffset(t, e.length - 1), t;
}
const maxGeneratorDuration = 2e4;
function calcGeneratorDuration(e) {
  let t = 0;
  const n = 50;
  let a = e.next(t);
  for (; !a.done && t < maxGeneratorDuration; )
    t += n, a = e.next(t);
  return t >= maxGeneratorDuration ? 1 / 0 : t;
}
const secondsToMilliseconds = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, millisecondsToSeconds = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3;
function createGeneratorEasing(e, t = 100, n) {
  const a = n({ ...e, keyframes: [0, t] }), o = Math.min(calcGeneratorDuration(a), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (s) => a.next(o * s).value / t,
    duration: /* @__PURE__ */ millisecondsToSeconds(o)
  };
}
function isGenerator(e) {
  return typeof e == "function" && "applyToOptions" in e;
}
const defaultSegmentEasing = "easeInOut", MAX_REPEAT = 20;
function createAnimationsFromSequence(e, { defaultTransition: t = {}, ...n } = {}, a, o) {
  const s = t.duration || 0.3, u = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), f = {}, g = /* @__PURE__ */ new Map();
  let v = 0, b = 0, w = 0;
  for (let C = 0; C < e.length; C++) {
    const k = e[C];
    if (typeof k == "string") {
      g.set(k, b);
      continue;
    } else if (!Array.isArray(k)) {
      g.set(k.name, calcNextTime(b, k.at, v, g));
      continue;
    }
    let [E, A, P = {}] = k;
    P.at !== void 0 && (b = calcNextTime(b, P.at, v, g));
    let M = 0;
    const B = (_, T, O, I = 0, q = 0) => {
      const F = keyframesAsList(_), { delay: W = 0, times: K = defaultOffset(F), type: Z = "keyframes", repeat: J, repeatType: re, repeatDelay: V = 0, ...ne } = T;
      let { ease: Q = t.ease || "easeOut", duration: z } = T;
      const X = typeof W == "function" ? W(I, q) : W, ue = F.length, Be = isGenerator(Z) ? Z : o?.[Z || "keyframes"];
      if (ue <= 2 && Be) {
        let oe = 100;
        if (ue === 2 && isNumberKeyframesArray(F)) {
          const ke = F[1] - F[0];
          oe = Math.abs(ke);
        }
        const ye = { ...ne };
        z !== void 0 && (ye.duration = /* @__PURE__ */ secondsToMilliseconds(z));
        const ve = createGeneratorEasing(ye, oe, Be);
        Q = ve.ease, z = ve.duration;
      }
      z ?? (z = s);
      const te = b + X;
      K.length === 1 && K[0] === 0 && (K[1] = 1);
      const G = K.length - F.length;
      if (G > 0 && fillOffset(K, G), F.length === 1 && F.unshift(null), J) {
        invariant(J < MAX_REPEAT, "Repeat count too high, must be less than 20"), z = calculateRepeatDuration(z, J);
        const oe = [...F], ye = [...K];
        Q = Array.isArray(Q) ? [...Q] : [Q];
        const ve = [...Q];
        for (let ke = 0; ke < J; ke++) {
          F.push(...oe);
          for (let Ae = 0; Ae < oe.length; Ae++)
            K.push(ye[Ae] + (ke + 1)), Q.push(Ae === 0 ? "linear" : getEasingForSegment(ve, Ae - 1));
        }
        normalizeTimes(K, J);
      }
      const ie = te + z;
      addKeyframes(O, F, Q, K, te, ie), M = Math.max(X + z, M), w = Math.max(ie, w);
    };
    if (isMotionValue(E)) {
      const _ = getSubjectSequence(E, d);
      B(A, P, getValueSequence("default", _));
    } else {
      const _ = resolveSubjects(E, A, a, f), T = _.length;
      for (let O = 0; O < T; O++) {
        A = A, P = P;
        const I = _[O], q = getSubjectSequence(I, d);
        for (const F in A)
          B(A[F], getValueTransition$1(P, F), getValueSequence(F, q), O, T);
      }
    }
    v = b, b += M;
  }
  return d.forEach((C, k) => {
    for (const E in C) {
      const A = C[E];
      A.sort(compareByTime);
      const P = [], M = [], B = [];
      for (let T = 0; T < A.length; T++) {
        const { at: O, value: I, easing: q } = A[T];
        P.push(I), M.push(/* @__PURE__ */ progress(0, w, O)), B.push(q || "easeOut");
      }
      M[0] !== 0 && (M.unshift(0), P.unshift(P[0]), B.unshift(defaultSegmentEasing)), M[M.length - 1] !== 1 && (M.push(1), P.push(null)), u.has(k) || u.set(k, {
        keyframes: {},
        transition: {}
      });
      const _ = u.get(k);
      _.keyframes[E] = P, _.transition[E] = {
        ...t,
        duration: w,
        ease: B,
        times: M,
        ...n
      };
    }
  }), u;
}
function getSubjectSequence(e, t) {
  return !t.has(e) && t.set(e, {}), t.get(e);
}
function getValueSequence(e, t) {
  return t[e] || (t[e] = []), t[e];
}
function keyframesAsList(e) {
  return Array.isArray(e) ? e : [e];
}
function getValueTransition$1(e, t) {
  return e && e[t] ? {
    ...e,
    ...e[t]
  } : { ...e };
}
const isNumber = (e) => typeof e == "number", isNumberKeyframesArray = (e) => e.every(isNumber), isKeyframesTarget = (e) => Array.isArray(e);
function resolveVariant(e, t, n) {
  const a = e.getProps();
  return resolveVariantFromProps(a, t, a.custom, e);
}
function setMotionValue(e, t, n) {
  e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, motionValue(n));
}
function resolveFinalValueInKeyframes(e) {
  return isKeyframesTarget(e) ? e[e.length - 1] || 0 : e;
}
function setTarget(e, t) {
  const n = resolveVariant(e, t);
  let { transitionEnd: a = {}, transition: o = {}, ...s } = n || {};
  s = { ...s, ...a };
  for (const u in s) {
    const d = resolveFinalValueInKeyframes(s[u]);
    setMotionValue(e, u, d);
  }
}
function isWillChangeMotionValue$1(e) {
  return !!(isMotionValue(e) && e.add);
}
function addValueToWillChange$1(e, t) {
  const n = e.getValue("willChange");
  if (isWillChangeMotionValue$1(n))
    return n.add(t);
  if (!n && MotionGlobalConfig.WillChange) {
    const a = new MotionGlobalConfig.WillChange("auto");
    e.addValue("willChange", a), a.add(t);
  }
}
const optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(e) {
  return e.props[optimizedAppearDataAttribute];
}
const isNotNull$1 = (e) => e !== null;
function getFinalKeyframe$1(e, { repeat: t, repeatType: n = "loop" }, a) {
  const o = e.filter(isNotNull$1), s = t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1;
  return o[s];
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (e, { keyframes: t }) => t.length > 2 ? keyframesTransition : transformProps.has(e) ? e.startsWith("scale") ? criticallyDampedSpring(t[1]) : underDampedSpring : ease;
function isTransitionDefined({ when: e, delay: t, delayChildren: n, staggerChildren: a, staggerDirection: o, repeat: s, repeatType: u, repeatDelay: d, from: f, elapsed: g, ...v }) {
  return !!Object.keys(v).length;
}
function getValueTransition(e, t) {
  return e?.[t] ?? e?.default ?? e;
}
function hueToRgb(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function hslaToRgba({ hue: e, saturation: t, lightness: n, alpha: a }) {
  e /= 360, t /= 100, n /= 100;
  let o = 0, s = 0, u = 0;
  if (!t)
    o = s = u = n;
  else {
    const d = n < 0.5 ? n * (1 + t) : n + t - n * t, f = 2 * n - d;
    o = hueToRgb(f, d, e + 1 / 3), s = hueToRgb(f, d, e), u = hueToRgb(f, d, e - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(s * 255),
    blue: Math.round(u * 255),
    alpha: a
  };
}
function mixImmediate(e, t) {
  return (n) => n > 0 ? t : e;
}
const mixLinearColor = (e, t, n) => {
  const a = e * e, o = n * (t * t - a) + a;
  return o < 0 ? 0 : Math.sqrt(o);
}, colorTypes = [hex, rgba, hsla], getColorType = (e) => colorTypes.find((t) => t.test(e));
function asRGBA(e) {
  const t = getColorType(e);
  if (warning(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`), !t)
    return !1;
  let n = t.parse(e);
  return t === hsla && (n = hslaToRgba(n)), n;
}
const mixColor = (e, t) => {
  const n = asRGBA(e), a = asRGBA(t);
  if (!n || !a)
    return mixImmediate(e, t);
  const o = { ...n };
  return (s) => (o.red = mixLinearColor(n.red, a.red, s), o.green = mixLinearColor(n.green, a.green, s), o.blue = mixLinearColor(n.blue, a.blue, s), o.alpha = mixNumber$1(n.alpha, a.alpha, s), rgba.transform(o));
}, invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(e, t) {
  return invisibleValues.has(e) ? (n) => n <= 0 ? e : t : (n) => n >= 1 ? t : e;
}
const combineFunctions = (e, t) => (n) => t(e(n)), pipe = (...e) => e.reduce(combineFunctions);
function mixNumber(e, t) {
  return (n) => mixNumber$1(e, t, n);
}
function getMixer(e) {
  return typeof e == "number" ? mixNumber : typeof e == "string" ? isCSSVariableToken(e) ? mixImmediate : color.test(e) ? mixColor : mixComplex : Array.isArray(e) ? mixArray : typeof e == "object" ? color.test(e) ? mixColor : mixObject : mixImmediate;
}
function mixArray(e, t) {
  const n = [...e], a = n.length, o = e.map((s, u) => getMixer(s)(s, t[u]));
  return (s) => {
    for (let u = 0; u < a; u++)
      n[u] = o[u](s);
    return n;
  };
}
function mixObject(e, t) {
  const n = { ...e, ...t }, a = {};
  for (const o in n)
    e[o] !== void 0 && t[o] !== void 0 && (a[o] = getMixer(e[o])(e[o], t[o]));
  return (o) => {
    for (const s in a)
      n[s] = a[s](o);
    return n;
  };
}
function matchOrder(e, t) {
  const n = [], a = { color: 0, var: 0, number: 0 };
  for (let o = 0; o < t.values.length; o++) {
    const s = t.types[o], u = e.indexes[s][a[s]], d = e.values[u] ?? 0;
    n[o] = d, a[s]++;
  }
  return n;
}
const mixComplex = (e, t) => {
  const n = complex.createTransformer(t), a = analyseComplexValue(e), o = analyseComplexValue(t);
  return a.indexes.var.length === o.indexes.var.length && a.indexes.color.length === o.indexes.color.length && a.indexes.number.length >= o.indexes.number.length ? invisibleValues.has(e) && !o.values.length || invisibleValues.has(t) && !a.values.length ? mixVisibility(e, t) : pipe(mixArray(matchOrder(a, o), o.values), n) : (warning(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), mixImmediate(e, t));
};
function mix(e, t, n) {
  return typeof e == "number" && typeof t == "number" && typeof n == "number" ? mixNumber$1(e, t, n) : getMixer(e)(e, t);
}
const frameloopDriver = (e) => {
  const t = ({ timestamp: n }) => e(n);
  return {
    start: (n = !0) => frame.update(t, n),
    stop: () => cancelFrame(t),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
}, generateLinearEasing = (e, t, n = 10) => {
  let a = "";
  const o = Math.max(Math.round(t / n), 2);
  for (let s = 0; s < o; s++)
    a += Math.round(e(s / (o - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${a.substring(0, a.length - 2)})`;
}, velocitySampleDuration = 5;
function calcGeneratorVelocity(e, t, n) {
  const a = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(n - e(a), t - a);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, safeMin = 1e-3;
function findSpring({ duration: e = springDefaults.duration, bounce: t = springDefaults.bounce, velocity: n = springDefaults.velocity, mass: a = springDefaults.mass }) {
  let o, s;
  warning(e <= /* @__PURE__ */ secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
  let u = 1 - t;
  u = clamp(springDefaults.minDamping, springDefaults.maxDamping, u), e = clamp(springDefaults.minDuration, springDefaults.maxDuration, /* @__PURE__ */ millisecondsToSeconds(e)), u < 1 ? (o = (g) => {
    const v = g * u, b = v * e, w = v - n, C = calcAngularFreq(g, u), k = Math.exp(-b);
    return safeMin - w / C * k;
  }, s = (g) => {
    const b = g * u * e, w = b * n + n, C = Math.pow(u, 2) * Math.pow(g, 2) * e, k = Math.exp(-b), E = calcAngularFreq(Math.pow(g, 2), u);
    return (-o(g) + safeMin > 0 ? -1 : 1) * ((w - C) * k) / E;
  }) : (o = (g) => {
    const v = Math.exp(-g * e), b = (g - n) * e + 1;
    return -safeMin + v * b;
  }, s = (g) => {
    const v = Math.exp(-g * e), b = (n - g) * (e * e);
    return v * b;
  });
  const d = 5 / e, f = approximateRoot(o, s, d);
  if (e = /* @__PURE__ */ secondsToMilliseconds(e), isNaN(f))
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration: e
    };
  {
    const g = Math.pow(f, 2) * a;
    return {
      stiffness: g,
      damping: u * 2 * Math.sqrt(a * g),
      duration: e
    };
  }
}
const rootIterations = 12;
function approximateRoot(e, t, n) {
  let a = n;
  for (let o = 1; o < rootIterations; o++)
    a = a - e(a) / t(a);
  return a;
}
function calcAngularFreq(e, t) {
  return e * Math.sqrt(1 - t * t);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(e, t) {
  return t.some((n) => e[n] !== void 0);
}
function getSpringOptions(e) {
  let t = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!isSpringType(e, physicsKeys) && isSpringType(e, durationKeys))
    if (e.visualDuration) {
      const n = e.visualDuration, a = 2 * Math.PI / (n * 1.2), o = a * a, s = 2 * clamp(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
      t = {
        ...t,
        mass: springDefaults.mass,
        stiffness: o,
        damping: s
      };
    } else {
      const n = findSpring(e);
      t = {
        ...t,
        ...n,
        mass: springDefaults.mass
      }, t.isResolvedFromDuration = !0;
    }
  return t;
}
function spring(e = springDefaults.visualDuration, t = springDefaults.bounce) {
  const n = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: t
  } : e;
  let { restSpeed: a, restDelta: o } = n;
  const s = n.keyframes[0], u = n.keyframes[n.keyframes.length - 1], d = { done: !1, value: s }, { stiffness: f, damping: g, mass: v, duration: b, velocity: w, isResolvedFromDuration: C } = getSpringOptions({
    ...n,
    velocity: -/* @__PURE__ */ millisecondsToSeconds(n.velocity || 0)
  }), k = w || 0, E = g / (2 * Math.sqrt(f * v)), A = u - s, P = /* @__PURE__ */ millisecondsToSeconds(Math.sqrt(f / v)), M = Math.abs(A) < 5;
  a || (a = M ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default), o || (o = M ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let B;
  if (E < 1) {
    const T = calcAngularFreq(P, E);
    B = (O) => {
      const I = Math.exp(-E * P * O);
      return u - I * ((k + E * P * A) / T * Math.sin(T * O) + A * Math.cos(T * O));
    };
  } else if (E === 1)
    B = (T) => u - Math.exp(-P * T) * (A + (k + P * A) * T);
  else {
    const T = P * Math.sqrt(E * E - 1);
    B = (O) => {
      const I = Math.exp(-E * P * O), q = Math.min(T * O, 300);
      return u - I * ((k + E * P * A) * Math.sinh(q) + T * A * Math.cosh(q)) / T;
    };
  }
  const _ = {
    calculatedDuration: C && b || null,
    next: (T) => {
      const O = B(T);
      if (C)
        d.done = T >= b;
      else {
        let I = T === 0 ? k : 0;
        E < 1 && (I = T === 0 ? /* @__PURE__ */ secondsToMilliseconds(k) : calcGeneratorVelocity(B, T, O));
        const q = Math.abs(I) <= a, F = Math.abs(u - O) <= o;
        d.done = q && F;
      }
      return d.value = d.done ? u : O, d;
    },
    toString: () => {
      const T = Math.min(calcGeneratorDuration(_), maxGeneratorDuration), O = generateLinearEasing((I) => _.next(T * I).value, T, 30);
      return T + "ms " + O;
    },
    toTransition: () => {
    }
  };
  return _;
}
spring.applyToOptions = (e) => {
  const t = createGeneratorEasing(e, 100, spring);
  return e.ease = t.ease, e.duration = /* @__PURE__ */ secondsToMilliseconds(t.duration), e.type = "keyframes", e;
};
function inertia({ keyframes: e, velocity: t = 0, power: n = 0.8, timeConstant: a = 325, bounceDamping: o = 10, bounceStiffness: s = 500, modifyTarget: u, min: d, max: f, restDelta: g = 0.5, restSpeed: v }) {
  const b = e[0], w = {
    done: !1,
    value: b
  }, C = (q) => d !== void 0 && q < d || f !== void 0 && q > f, k = (q) => d === void 0 ? f : f === void 0 || Math.abs(d - q) < Math.abs(f - q) ? d : f;
  let E = n * t;
  const A = b + E, P = u === void 0 ? A : u(A);
  P !== A && (E = P - b);
  const M = (q) => -E * Math.exp(-q / a), B = (q) => P + M(q), _ = (q) => {
    const F = M(q), W = B(q);
    w.done = Math.abs(F) <= g, w.value = w.done ? P : W;
  };
  let T, O;
  const I = (q) => {
    C(w.value) && (T = q, O = spring({
      keyframes: [w.value, k(w.value)],
      velocity: calcGeneratorVelocity(B, q, w.value),
      // TODO: This should be passing * 1000
      damping: o,
      stiffness: s,
      restDelta: g,
      restSpeed: v
    }));
  };
  return I(0), {
    calculatedDuration: null,
    next: (q) => {
      let F = !1;
      return !O && T === void 0 && (F = !0, _(q), I(q)), T !== void 0 && q >= T ? O.next(q - T) : (!F && _(q), w);
    }
  };
}
function createMixers(e, t, n) {
  const a = [], o = n || MotionGlobalConfig.mix || mix, s = e.length - 1;
  for (let u = 0; u < s; u++) {
    let d = o(e[u], e[u + 1]);
    if (t) {
      const f = Array.isArray(t) ? t[u] || noop : t;
      d = pipe(f, d);
    }
    a.push(d);
  }
  return a;
}
function interpolate(e, t, { clamp: n = !0, ease: a, mixer: o } = {}) {
  const s = e.length;
  if (invariant(s === t.length, "Both input and output ranges must be the same length"), s === 1)
    return () => t[0];
  if (s === 2 && t[0] === t[1])
    return () => t[1];
  const u = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), t = [...t].reverse());
  const d = createMixers(t, a, o), f = d.length, g = (v) => {
    if (u && v < e[0])
      return t[0];
    let b = 0;
    if (f > 1)
      for (; b < e.length - 2 && !(v < e[b + 1]); b++)
        ;
    const w = /* @__PURE__ */ progress(e[b], e[b + 1], v);
    return d[b](w);
  };
  return n ? (v) => g(clamp(e[0], e[s - 1], v)) : g;
}
function convertOffsetToTimes(e, t) {
  return e.map((n) => n * t);
}
const calcBezier = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(e, t, n, a, o) {
  let s, u, d = 0;
  do
    u = t + (n - t) / 2, s = calcBezier(u, a, o) - e, s > 0 ? n = u : t = u;
  while (Math.abs(s) > subdivisionPrecision && ++d < subdivisionMaxIterations);
  return u;
}
function cubicBezier(e, t, n, a) {
  if (e === t && n === a)
    return noop;
  const o = (s) => binarySubdivide(s, 0, 1, e, n);
  return (s) => s === 0 || s === 1 ? s : calcBezier(o(s), t, a);
}
const easeIn = /* @__PURE__ */ cubicBezier(0.42, 0, 1, 1), easeOut = /* @__PURE__ */ cubicBezier(0, 0, 0.58, 1), easeInOut = /* @__PURE__ */ cubicBezier(0.42, 0, 0.58, 1), mirrorEasing = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, reverseEasing = (e) => (t) => 1 - e(1 - t), backOut = /* @__PURE__ */ cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = /* @__PURE__ */ reverseEasing(backOut), backInOut = /* @__PURE__ */ mirrorEasing(backIn), anticipate = (e) => (e *= 2) < 1 ? 0.5 * backIn(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), circIn = (e) => 1 - Math.sin(Math.acos(e)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), isBezierDefinition = (e) => Array.isArray(e) && typeof e[0] == "number", easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, isValidEasing = (e) => typeof e == "string", easingDefinitionToFunction = (e) => {
  if (isBezierDefinition(e)) {
    invariant(e.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [t, n, a, o] = e;
    return cubicBezier(t, n, a, o);
  } else if (isValidEasing(e))
    return invariant(easingLookup[e] !== void 0, `Invalid easing type '${e}'`), easingLookup[e];
  return e;
};
function defaultEasing(e, t) {
  return e.map(() => t || easeInOut).splice(0, e.length - 1);
}
function keyframes({ duration: e = 300, keyframes: t, times: n, ease: a = "easeInOut" }) {
  const o = isEasingArray(a) ? a.map(easingDefinitionToFunction) : easingDefinitionToFunction(a), s = {
    done: !1,
    value: t[0]
  }, u = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === t.length ? n : defaultOffset(t),
    e
  ), d = interpolate(u, t, {
    ease: Array.isArray(o) ? o : defaultEasing(t, o)
  });
  return {
    calculatedDuration: e,
    next: (f) => (s.value = d(f), s.done = f >= e, s)
  };
}
const isNotNull = (e) => e !== null;
function getFinalKeyframe(e, { repeat: t, repeatType: n = "loop" }, a, o = 1) {
  const s = e.filter(isNotNull), d = o < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : s.length - 1;
  return !d || a === void 0 ? s[d] : a;
}
const transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(e) {
  typeof e.type == "string" && (e.type = transitionTypeMap[e.type]);
}
class WithPromise {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((t) => {
      this.resolve = t;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
}
const percentToProgress = (e) => e / 100;
class JSAnimation extends WithPromise {
  constructor(t) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var n, a;
      const { motionValue: o } = this.options;
      o && o.updatedAt !== time.now() && this.tick(time.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (a = (n = this.options).onStop) == null || a.call(n));
    }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: t } = this;
    replaceTransitionType(t);
    const { type: n = keyframes, repeat: a = 0, repeatDelay: o = 0, repeatType: s, velocity: u = 0 } = t;
    let { keyframes: d } = t;
    const f = n || keyframes;
    process.env.NODE_ENV !== "production" && f !== keyframes && invariant(d.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${d}`), f !== keyframes && typeof d[0] != "number" && (this.mixKeyframes = pipe(percentToProgress, mix(d[0], d[1])), d = [0, 100]);
    const g = f({ ...t, keyframes: d });
    s === "mirror" && (this.mirroredGenerator = f({
      ...t,
      keyframes: [...d].reverse(),
      velocity: -u
    })), g.calculatedDuration === null && (g.calculatedDuration = calcGeneratorDuration(g));
    const { calculatedDuration: v } = g;
    this.calculatedDuration = v, this.resolvedDuration = v + o, this.totalDuration = this.resolvedDuration * (a + 1) - o, this.generator = g;
  }
  updateTime(t) {
    const n = Math.round(t - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(t, n = !1) {
    const { generator: a, totalDuration: o, mixKeyframes: s, mirroredGenerator: u, resolvedDuration: d, calculatedDuration: f } = this;
    if (this.startTime === null)
      return a.next(0);
    const { delay: g = 0, keyframes: v, repeat: b, repeatType: w, repeatDelay: C, type: k, onUpdate: E, finalKeyframe: A } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - o / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t);
    const P = this.currentTime - g * (this.playbackSpeed >= 0 ? 1 : -1), M = this.playbackSpeed >= 0 ? P < 0 : P > o;
    this.currentTime = Math.max(P, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = o);
    let B = this.currentTime, _ = a;
    if (b) {
      const q = Math.min(this.currentTime, o) / d;
      let F = Math.floor(q), W = q % 1;
      !W && q >= 1 && (W = 1), W === 1 && F--, F = Math.min(F, b + 1), !!(F % 2) && (w === "reverse" ? (W = 1 - W, C && (W -= C / d)) : w === "mirror" && (_ = u)), B = clamp(0, 1, W) * d;
    }
    const T = M ? { done: !1, value: v[0] } : _.next(B);
    s && (T.value = s(T.value));
    let { done: O } = T;
    !M && f !== null && (O = this.playbackSpeed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
    const I = this.holdTime === null && (this.state === "finished" || this.state === "running" && O);
    return I && k !== inertia && (T.value = getFinalKeyframe(v, this.options, A, this.speed)), E && E(T.value), I && this.finish(), T;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(t, n) {
    return this.finished.then(t, n);
  }
  get duration() {
    return /* @__PURE__ */ millisecondsToSeconds(this.calculatedDuration);
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(this.currentTime);
  }
  set time(t) {
    var n;
    t = /* @__PURE__ */ secondsToMilliseconds(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(t) {
    this.updateTime(time.now());
    const n = this.playbackSpeed !== t;
    this.playbackSpeed = t, n && (this.time = /* @__PURE__ */ millisecondsToSeconds(this.currentTime));
  }
  play() {
    var t, n;
    if (this.isStopped)
      return;
    const { driver: a = frameloopDriver, startTime: o } = this.options;
    this.driver || (this.driver = a((u) => this.tick(u))), (n = (t = this.options).onPlay) == null || n.call(t);
    const s = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = o ?? s), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(time.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var t, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t);
  }
  cancel() {
    var t, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(t) {
    return this.startTime = 0, this.tick(t, !0);
  }
  attachTimeline(t) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this);
  }
}
const isCSSVar = (e) => e.startsWith("--");
function setStyle(e, t, n) {
  isCSSVar(t) ? e.style.setProperty(t, n) : e.style[t] = n;
}
// @__NO_SIDE_EFFECTS__
function memo(e) {
  let t;
  return () => (t === void 0 && (t = e()), t);
}
const supportsScrollTimeline = /* @__PURE__ */ memo(() => window.ScrollTimeline !== void 0), supportsFlags = {};
function memoSupports(e, t) {
  const n = /* @__PURE__ */ memo(e);
  return () => supportsFlags[t] ?? n();
}
const supportsLinearEasing = /* @__PURE__ */ memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), cubicBezierAsString = ([e, t, n, a]) => `cubic-bezier(${e}, ${t}, ${n}, ${a})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(e, t) {
  if (e)
    return typeof e == "function" ? supportsLinearEasing() ? generateLinearEasing(e, t) : "ease-out" : isBezierDefinition(e) ? cubicBezierAsString(e) : Array.isArray(e) ? e.map((n) => mapEasingToNativeEasing(n, t) || supportedWaapiEasing.easeOut) : supportedWaapiEasing[e];
}
function startWaapiAnimation(e, t, n, { delay: a = 0, duration: o = 300, repeat: s = 0, repeatType: u = "loop", ease: d = "easeOut", times: f } = {}, g = void 0) {
  const v = {
    [t]: n
  };
  f && (v.offset = f);
  const b = mapEasingToNativeEasing(d, o);
  Array.isArray(b) && (v.easing = b);
  const w = {
    delay: a,
    duration: o,
    easing: Array.isArray(b) ? "linear" : b,
    fill: "both",
    iterations: s + 1,
    direction: u === "reverse" ? "alternate" : "normal"
  };
  return g && (w.pseudoElement = g), e.animate(v, w);
}
function applyGeneratorOptions({ type: e, ...t }) {
  return isGenerator(e) && supportsLinearEasing() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t);
}
class NativeAnimation extends WithPromise {
  constructor(t) {
    if (super(), this.finishedTime = null, this.isStopped = !1, !t)
      return;
    const { element: n, name: a, keyframes: o, pseudoElement: s, allowFlatten: u = !1, finalKeyframe: d, onComplete: f } = t;
    this.isPseudoElement = !!s, this.allowFlatten = u, this.options = t, invariant(typeof t.type != "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
    const g = applyGeneratorOptions(t);
    this.animation = startWaapiAnimation(n, a, o, g, s), g.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !s) {
        const v = getFinalKeyframe(o, this.options, d, this.speed);
        this.updateMotionValue ? this.updateMotionValue(v) : setStyle(n, a, v), this.animation.cancel();
      }
      f?.(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var t, n;
    (n = (t = this.animation).finish) == null || n.call(t);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: t } = this;
    t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var t, n;
    this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t);
  }
  get duration() {
    var t, n;
    const a = ((n = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : n.call(t).duration) || 0;
    return /* @__PURE__ */ millisecondsToSeconds(Number(a));
  }
  get time() {
    return /* @__PURE__ */ millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(t) {
    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ secondsToMilliseconds(t);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(t) {
    t < 0 && (this.finishedTime = null), this.animation.playbackRate = t;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(t) {
    this.animation.startTime = t;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: t, observe: n }) {
    var a;
    return this.allowFlatten && ((a = this.animation.effect) == null || a.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && supportsScrollTimeline() ? (this.animation.timeline = t, noop) : n(this);
  }
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(e) {
  return e in unsupportedEasingFunctions;
}
function replaceStringEasing(e) {
  typeof e.ease == "string" && isUnsupportedEase(e.ease) && (e.ease = unsupportedEasingFunctions[e.ease]);
}
const sampleDelta = 10;
class NativeAnimationExtended extends NativeAnimation {
  constructor(t) {
    replaceStringEasing(t), replaceTransitionType(t), super(t), t.startTime && (this.startTime = t.startTime), this.options = t;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(t) {
    const { motionValue: n, onUpdate: a, onComplete: o, element: s, ...u } = this.options;
    if (!n)
      return;
    if (t !== void 0) {
      n.set(t);
      return;
    }
    const d = new JSAnimation({
      ...u,
      autoplay: !1
    }), f = /* @__PURE__ */ secondsToMilliseconds(this.finishedTime ?? this.time);
    n.setWithVelocity(d.sample(f - sampleDelta).value, d.sample(f).value, sampleDelta), d.stop();
  }
}
const isAnimatable = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(complex.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function hasKeyframesChanged(e) {
  const t = e[0];
  if (e.length === 1)
    return !0;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t)
      return !0;
}
function canAnimate(e, t, n, a) {
  const o = e[0];
  if (o === null)
    return !1;
  if (t === "display" || t === "visibility")
    return !0;
  const s = e[e.length - 1], u = isAnimatable(o, t), d = isAnimatable(s, t);
  return warning(u === d, `You are trying to animate ${t} from "${o}" to "${s}". ${o} is not an animatable value - to enable this animation set ${o} to a value animatable to ${s} via the \`style\` property.`), !u || !d ? !1 : hasKeyframesChanged(e) || (n === "spring" || isGenerator(n)) && a;
}
function isObject$1(e) {
  return typeof e == "object" && e !== null;
}
function isHTMLElement$1(e) {
  return isObject$1(e) && "offsetHeight" in e;
}
const acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), supportsWaapi = /* @__PURE__ */ memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(e) {
  var t;
  const { motionValue: n, name: a, repeatDelay: o, repeatType: s, damping: u, type: d } = e;
  if (!isHTMLElement$1((t = n?.owner) == null ? void 0 : t.current))
    return !1;
  const { onUpdate: f, transformTemplate: g } = n.owner.getProps();
  return supportsWaapi() && a && acceleratedValues.has(a) && (a !== "transform" || !g) && /**
  * If we're outputting values to onUpdate then we can't use WAAPI as there's
  * no way to read the value from WAAPI every frame.
  */
  !f && !o && s !== "mirror" && u !== 0 && d !== "inertia";
}
const MAX_RESOLVE_DELAY = 40;
class AsyncMotionValueAnimation extends WithPromise {
  constructor({ autoplay: t = !0, delay: n = 0, type: a = "keyframes", repeat: o = 0, repeatDelay: s = 0, repeatType: u = "loop", keyframes: d, name: f, motionValue: g, element: v, ...b }) {
    var w;
    super(), this.stop = () => {
      var E, A;
      this._animation && (this._animation.stop(), (E = this.stopTimeline) == null || E.call(this)), (A = this.keyframeResolver) == null || A.cancel();
    }, this.createdAt = time.now();
    const C = {
      autoplay: t,
      delay: n,
      type: a,
      repeat: o,
      repeatDelay: s,
      repeatType: u,
      name: f,
      motionValue: g,
      element: v,
      ...b
    }, k = v?.KeyframeResolver || KeyframeResolver;
    this.keyframeResolver = new k(d, (E, A, P) => this.onKeyframesResolved(E, A, C, !P), f, g, v), (w = this.keyframeResolver) == null || w.scheduleResolve();
  }
  onKeyframesResolved(t, n, a, o) {
    this.keyframeResolver = void 0;
    const { name: s, type: u, velocity: d, delay: f, isHandoff: g, onUpdate: v } = a;
    this.resolvedAt = time.now(), canAnimate(t, s, u, d) || ((MotionGlobalConfig.instantAnimations || !f) && v?.(getFinalKeyframe(t, a, n)), t[0] = t[t.length - 1], a.duration = 0, a.repeat = 0);
    const w = {
      startTime: o ? this.resolvedAt ? this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...a,
      keyframes: t
    }, C = !g && supportsBrowserAnimation(w) ? new NativeAnimationExtended({
      ...w,
      element: w.motionValue.owner.current
    }) : new JSAnimation(w);
    C.finished.then(() => this.notifyFinished()).catch(noop), this.pendingTimeline && (this.stopTimeline = C.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = C;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
  get animation() {
    var t;
    return this._animation || ((t = this.keyframeResolver) == null || t.resume(), flushKeyframeResolvers()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(t) {
    this.animation.time = t;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(t) {
    this.animation.speed = t;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(t) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var t;
    this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel();
  }
}
const animateMotionValue = (e, t, n, a = {}, o, s) => (u) => {
  const d = getValueTransition(a, e) || {}, f = d.delay || a.delay || 0;
  let { elapsed: g = 0 } = a;
  g = g - /* @__PURE__ */ secondsToMilliseconds(f);
  const v = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: t.getVelocity(),
    ...d,
    delay: -g,
    onUpdate: (w) => {
      t.set(w), d.onUpdate && d.onUpdate(w);
    },
    onComplete: () => {
      u(), d.onComplete && d.onComplete();
    },
    name: e,
    motionValue: t,
    element: s ? void 0 : o
  };
  isTransitionDefined(d) || Object.assign(v, getDefaultTransition(e, v)), v.duration && (v.duration = /* @__PURE__ */ secondsToMilliseconds(v.duration)), v.repeatDelay && (v.repeatDelay = /* @__PURE__ */ secondsToMilliseconds(v.repeatDelay)), v.from !== void 0 && (v.keyframes[0] = v.from);
  let b = !1;
  if ((v.type === !1 || v.duration === 0 && !v.repeatDelay) && (v.duration = 0, v.delay === 0 && (b = !0)), (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) && (b = !0, v.duration = 0, v.delay = 0), v.allowFlatten = !d.type && !d.ease, b && !s && t.get() !== void 0) {
    const w = getFinalKeyframe$1(v.keyframes, d);
    if (w !== void 0) {
      frame.update(() => {
        v.onUpdate(w), v.onComplete();
      });
      return;
    }
  }
  return d.isSync ? new JSAnimation(v) : new AsyncMotionValueAnimation(v);
};
function shouldBlockAnimation({ protectedKeys: e, needsAnimating: t }, n) {
  const a = e.hasOwnProperty(n) && t[n] !== !0;
  return t[n] = !1, a;
}
function animateTarget(e, t, { delay: n = 0, transitionOverride: a, type: o } = {}) {
  let { transition: s = e.getDefaultTransition(), transitionEnd: u, ...d } = t;
  a && (s = a);
  const f = [], g = o && e.animationState && e.animationState.getState()[o];
  for (const v in d) {
    const b = e.getValue(v, e.latestValues[v] ?? null), w = d[v];
    if (w === void 0 || g && shouldBlockAnimation(g, v))
      continue;
    const C = {
      delay: n,
      ...getValueTransition(s || {}, v)
    }, k = b.get();
    if (k !== void 0 && !b.isAnimating && !Array.isArray(w) && w === k && !C.velocity)
      continue;
    let E = !1;
    if (window.MotionHandoffAnimation) {
      const P = getOptimisedAppearId(e);
      if (P) {
        const M = window.MotionHandoffAnimation(P, v, frame);
        M !== null && (C.startTime = M, E = !0);
      }
    }
    addValueToWillChange$1(e, v), b.start(animateMotionValue(v, b, w, e.shouldReduceMotion && positionalKeys.has(v) ? { type: !1 } : C, e, E));
    const A = b.animation;
    A && f.push(A);
  }
  return u && Promise.all(f).then(() => {
    frame.update(() => {
      u && setTarget(e, u);
    });
  }), f;
}
function isObjectKey(e, t) {
  return e in t;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(t, n) {
    if (isObjectKey(n, t)) {
      const a = t[n];
      if (typeof a == "string" || typeof a == "number")
        return a;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(t, n) {
    delete n.output[t];
  }
  measureInstanceViewportBox() {
    return createBox$1();
  }
  build(t, n) {
    Object.assign(t.output, n);
  }
  renderInstance(t, { output: n }) {
    Object.assign(t, n);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function isSVGElement(e) {
  return isObject$1(e) && "ownerSVGElement" in e;
}
function isSVGSVGElement(e) {
  return isSVGElement(e) && e.tagName === "svg";
}
function createDOMVisualElement(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, n = isSVGElement(e) && !isSVGSVGElement(e) ? new SVGVisualElement(t) : new HTMLVisualElement(t);
  n.mount(e), visualElementStore.set(e, n);
}
function createObjectVisualElement(e) {
  const t = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, n = new ObjectVisualElement(t);
  n.mount(e), visualElementStore.set(e, n);
}
function animateSingleValue(e, t, n) {
  const a = isMotionValue(e) ? e : motionValue(e);
  return a.start(animateMotionValue("", a, t, n)), a.animation;
}
function isSingleValue(e, t) {
  return isMotionValue(e) || typeof e == "number" || typeof e == "string" && !isDOMKeyframes(t);
}
function animateSubject(e, t, n, a) {
  const o = [];
  if (isSingleValue(e, t))
    o.push(animateSingleValue(e, isDOMKeyframes(t) && t.default || t, n && (n.default || n)));
  else {
    const s = resolveSubjects(e, t, a), u = s.length;
    invariant(!!u, "No valid elements provided.");
    for (let d = 0; d < u; d++) {
      const f = s[d], g = f instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      visualElementStore.has(f) || g(f);
      const v = visualElementStore.get(f), b = { ...n };
      "delay" in b && typeof b.delay == "function" && (b.delay = b.delay(d, u)), o.push(...animateTarget(v, { ...t, transition: b }, {}));
    }
  }
  return o;
}
function animateSequence(e, t, n) {
  const a = [];
  return createAnimationsFromSequence(e, t, n, { spring }).forEach(({ keyframes: s, transition: u }, d) => {
    a.push(...animateSubject(d, s, u));
  }), a;
}
class GroupAnimation {
  constructor(t) {
    this.stop = () => this.runAll("stop"), this.animations = t.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((t) => t.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(t) {
    return this.animations[0][t];
  }
  setAll(t, n) {
    for (let a = 0; a < this.animations.length; a++)
      this.animations[a][t] = n;
  }
  attachTimeline(t) {
    const n = this.animations.map((a) => a.attachTimeline(t));
    return () => {
      n.forEach((a, o) => {
        a && a(), this.animations[o].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(t) {
    this.setAll("time", t);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(t) {
    this.setAll("speed", t);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let t = 0;
    for (let n = 0; n < this.animations.length; n++)
      t = Math.max(t, this.animations[n].duration);
    return t;
  }
  runAll(t) {
    this.animations.forEach((n) => n[t]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class GroupAnimationWithThen extends GroupAnimation {
  then(t, n) {
    return this.finished.finally(t).then(() => {
    });
  }
}
function isSequence(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function createScopedAnimate(e) {
  function t(n, a, o) {
    let s = [];
    return isSequence(n) ? s = animateSequence(n, a, e) : s = animateSubject(n, a, o, e), new GroupAnimationWithThen(s);
  }
  return t;
}
const animate = createScopedAnimate(), STATE_TYPES = ["initial", "animate", "whileInView", "whileHover", "whilePress", "whileDrag", "whileFocus", "exit"];
class AnimationFeature extends Feature {
  constructor(t) {
    var n;
    super(t), this.animateUpdates = ({
      controlActiveState: a,
      directAnimate: o,
      directTransition: s,
      controlDelay: u = 0,
      isFallback: d,
      isExit: f
    } = {}) => {
      const { reducedMotion: g } = this.state.options.motionConfig;
      this.state.visualElement.shouldReduceMotion = g === "always" || g === "user" && !!prefersReducedMotion.current;
      const v = this.state.target;
      this.state.target = { ...this.state.baseTarget };
      let b = {};
      b = this.resolveStateAnimation({
        controlActiveState: a,
        directAnimate: o,
        directTransition: s
      });
      const w = this.createAnimationFactories(v, b, u), { getChildAnimations: C } = this.setupChildAnimations(b, this.state.activeStates, d);
      return this.executeAnimations({
        factories: w,
        getChildAnimations: C,
        transition: b,
        controlActiveState: a,
        isExit: f
      });
    }, this.state.visualElement = createVisualElement(this.state.options.as, {
      presenceContext: null,
      parent: (n = this.state.parent) == null ? void 0 : n.visualElement,
      props: {
        ...this.state.options,
        whileTap: this.state.options.whilePress
      },
      visualState: {
        renderState: {
          transform: {},
          transformOrigin: {},
          style: {},
          vars: {},
          attrs: {}
        },
        latestValues: {
          ...this.state.baseTarget
        }
      },
      reducedMotionConfig: this.state.options.motionConfig.reducedMotion
    }), this.state.animateUpdates = this.animateUpdates, this.state.isMounted() && this.state.startAnimation();
  }
  updateAnimationControlsSubscription() {
    const { animate: t } = this.state.options;
    isAnimationControls$1(t) && (this.unmountControls = t.subscribe(this.state));
  }
  executeAnimations({
    factories: t,
    getChildAnimations: n,
    transition: a,
    controlActiveState: o,
    isExit: s = !1
  }) {
    const u = () => Promise.all(t.map((b) => b()).filter(Boolean)), d = { ...this.state.target }, f = this.state.element, g = (b) => {
      var w, C;
      f.dispatchEvent(motionEvent("motionstart", d)), (C = (w = this.state.options).onAnimationStart) == null || C.call(w, d), b.then(() => {
        var k, E;
        f.dispatchEvent(motionEvent("motioncomplete", d, s)), (E = (k = this.state.options).onAnimationComplete) == null || E.call(k, d);
      }).catch(noop);
    }, v = () => {
      const b = a?.when ? (a.when === "beforeChildren" ? u() : n()).then(() => a.when === "beforeChildren" ? n() : u()) : Promise.all([u(), n()]);
      return g(b), b;
    };
    return o ? v : v();
  }
  /**
   * Setup child animations
   */
  setupChildAnimations(t, n, a) {
    var o;
    const s = this.state.visualElement;
    if (!((o = s.variantChildren) != null && o.size) || !n)
      return { getChildAnimations: () => Promise.resolve() };
    const { staggerChildren: u = 0, staggerDirection: d = 1, delayChildren: f = 0 } = t || {}, g = s.variantChildren.size, v = (g - 1) * u, b = typeof f == "function", w = b ? (k) => f(k, g) : d === 1 ? (k = 0) => k * u : (k = 0) => v - k * u, C = Array.from(s.variantChildren).map((k, E) => k.state.animateUpdates({
      controlActiveState: n,
      controlDelay: (b ? 0 : f) + w(E)
    }));
    return {
      getChildAnimations: () => Promise.all(C.map((k) => k()))
    };
  }
  createAnimationFactories(t, n, a) {
    const o = [];
    return Object.keys(this.state.target).forEach((s) => {
      var u;
      if (!hasChanged(t[s], this.state.target[s]))
        return;
      (u = this.state.baseTarget)[s] ?? (u[s] = style.get(this.state.element, s));
      const d = this.state.target[s] === "none" && isDef(transformResetValue[s]) ? transformResetValue[s] : this.state.target[s];
      o.push(() => {
        var f;
        return animate(
          this.state.element,
          { [s]: d },
          {
            ...n?.[s] || n,
            delay: (((f = n?.[s]) == null ? void 0 : f.delay) || n?.delay || 0) + a
          }
        );
      });
    }), o;
  }
  resolveStateAnimation({
    controlActiveState: t,
    directAnimate: n,
    directTransition: a
  }) {
    let o = this.state.options.transition, s = {};
    const { variants: u, custom: d, transition: f, animatePresenceContext: g } = this.state.options, v = d ?? g?.custom;
    return this.state.activeStates = { ...this.state.activeStates, ...t }, STATE_TYPES.forEach((b) => {
      if (!this.state.activeStates[b] || isAnimationControls$1(this.state.options[b]))
        return;
      const w = this.state.options[b];
      let C = isDef(w) ? resolveVariant$1(w, u, v) : void 0;
      if (this.state.visualElement.isVariantNode) {
        const k = resolveVariant$1(this.state.context[b], u, v);
        C = k ? Object.assign(k || {}, C) : s;
      }
      C && (b !== "initial" && (o = C.transition || this.state.options.transition || {}), s = Object.assign(s, C));
    }), n && (s = resolveVariant$1(n, u, v), o = s.transition || a || f), Object.entries(s).forEach(([b, w]) => {
      b !== "transition" && (this.state.target[b] = w);
    }), o;
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    const { element: t } = this.state;
    mountedStates.set(t, this.state), visualElementStore.get(t) || (this.state.visualElement.mount(t), visualElementStore.set(t, this.state.visualElement)), this.state.visualElement.state = this.state, this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: t } = this.state.options, { animate: n } = this.state.visualElement.prevProps || {};
    t !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var t;
    (t = this.unmountControls) == null || t.call(this);
  }
}
const isDragging = {
  y: !1
};
function isDragActive() {
  return isDragging.y;
}
const isNodeOrChild = (e, t) => t ? e === t ? !0 : isNodeOrChild(e, t.parentElement) : !1, isPrimaryPointer$1 = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
function setupGesture(e, t) {
  const n = resolveElements(e), a = new AbortController(), o = {
    passive: !0,
    ...t,
    signal: a.signal
  };
  return [n, o, () => a.abort()];
}
const focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(e) {
  return focusableElements.has(e.tagName) || e.tabIndex !== -1;
}
const isPressing = /* @__PURE__ */ new WeakSet();
function filterEvents(e) {
  return (t) => {
    t.key === "Enter" && e(t);
  };
}
function firePointerEvent(e, t) {
  e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 }));
}
const enableKeyboardPress = (e, t) => {
  const n = e.currentTarget;
  if (!n)
    return;
  const a = filterEvents(() => {
    if (isPressing.has(n))
      return;
    firePointerEvent(n, "down");
    const o = filterEvents(() => {
      firePointerEvent(n, "up");
    }), s = () => firePointerEvent(n, "cancel");
    n.addEventListener("keyup", o, t), n.addEventListener("blur", s, t);
  });
  n.addEventListener("keydown", a, t), n.addEventListener("blur", () => n.removeEventListener("keydown", a), t);
};
function isValidPressEvent(e) {
  return isPrimaryPointer$1(e) && !0;
}
function press(e, t, n = {}) {
  const [a, o, s] = setupGesture(e, n), u = (d) => {
    const f = d.currentTarget;
    if (!isValidPressEvent(d))
      return;
    isPressing.add(f);
    const g = t(f, d), v = (C, k) => {
      window.removeEventListener("pointerup", b), window.removeEventListener("pointercancel", w), isPressing.has(f) && isPressing.delete(f), isValidPressEvent(C) && typeof g == "function" && g(C, { success: k });
    }, b = (C) => {
      v(C, f === window || f === document || n.useGlobalTarget || isNodeOrChild(f, C.target));
    }, w = (C) => {
      v(C, !1);
    };
    window.addEventListener("pointerup", b, o), window.addEventListener("pointercancel", w, o);
  };
  return a.forEach((d) => {
    (n.useGlobalTarget ? window : d).addEventListener("pointerdown", u, o), isHTMLElement$1(d) && (d.addEventListener("focus", (g) => enableKeyboardPress(g, o)), !isElementKeyboardAccessible(d) && !d.hasAttribute("tabindex") && (d.tabIndex = 0));
  }), s;
}
function extractEventInfo$1(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
function handlePressEvent(e, t, n) {
  const a = e.options;
  a.whilePress && e.setActive("whilePress", n === "Start");
  const o = `onPress${n === "End" ? "" : n}`, s = a[o];
  s && frame.postRender(() => s(t, extractEventInfo$1(t)));
}
class PressGesture extends Feature {
  isActive() {
    const { whilePress: t, onPress: n, onPressCancel: a, onPressStart: o } = this.state.options;
    return !!(t || n || a || o);
  }
  constructor(t) {
    super(t);
  }
  mount() {
    this.register();
  }
  update() {
    const { whilePress: t, onPress: n, onPressCancel: a, onPressStart: o } = this.state.options;
    t || n || a || o || this.register();
  }
  register() {
    const t = this.state.element;
    !t || !this.isActive() || (this.unmount(), this.unmount = press(
      t,
      (n, a) => (handlePressEvent(this.state, a, "Start"), (o, { success: s }) => handlePressEvent(
        this.state,
        o,
        s ? "End" : "Cancel"
      )),
      { useGlobalTarget: this.state.options.globalPressTarget }
    ));
  }
}
function isValidHover(e) {
  return !(e.pointerType === "touch" || isDragActive());
}
function hover(e, t, n = {}) {
  const [a, o, s] = setupGesture(e, n), u = (d) => {
    if (!isValidHover(d))
      return;
    const { target: f } = d, g = t(f, d);
    if (typeof g != "function" || !f)
      return;
    const v = (b) => {
      isValidHover(b) && (g(b), f.removeEventListener("pointerleave", v));
    };
    f.addEventListener("pointerleave", v, o);
  };
  return a.forEach((d) => {
    d.addEventListener("pointerenter", u, o);
  }), s;
}
function handleHoverEvent$1(e, t, n) {
  const a = e.options;
  a.whileHover && e.setActive("whileHover", n === "Start");
  const o = `onHover${n}`, s = a[o];
  s && frame.postRender(() => s(t, extractEventInfo$1(t)));
}
class HoverGesture extends Feature {
  isActive() {
    const { whileHover: t, onHoverStart: n, onHoverEnd: a } = this.state.options;
    return !!(t || n || a);
  }
  constructor(t) {
    super(t);
  }
  mount() {
    this.register();
  }
  update() {
    const { whileHover: t, onHoverStart: n, onHoverEnd: a } = this.state.visualElement.prevProps;
    t || n || a || this.register();
  }
  register() {
    const t = this.state.element;
    !t || !this.isActive() || (this.unmount(), this.unmount = hover(
      t,
      (n, a) => (handleHoverEvent$1(this.state, a, "Start"), (o) => {
        handleHoverEvent$1(this.state, o, "End");
      })
    ));
  }
}
const thresholds = {
  some: 0,
  all: 1
};
function inView(e, t, { root: n, margin: a, amount: o = "some" } = {}) {
  const s = resolveElements(e), u = /* @__PURE__ */ new WeakMap(), d = (g) => {
    g.forEach((v) => {
      const b = u.get(v.target);
      if (v.isIntersecting !== !!b)
        if (v.isIntersecting) {
          const w = t(v.target, v);
          typeof w == "function" ? u.set(v.target, w) : f.unobserve(v.target);
        } else typeof b == "function" && (b(v), u.delete(v.target));
    });
  }, f = new IntersectionObserver(d, {
    root: n,
    rootMargin: a,
    threshold: typeof o == "number" ? o : thresholds[o]
  });
  return s.forEach((g) => f.observe(g)), () => f.disconnect();
}
function handleHoverEvent(e, t, n) {
  const a = e.options;
  a.whileInView && e.setActive("whileInView", n === "Enter");
  const o = `onViewport${n}`, s = a[o];
  s && frame.postRender(() => s(t));
}
class InViewGesture extends Feature {
  isActive() {
    const { whileInView: t, onViewportEnter: n, onViewportLeave: a } = this.state.options;
    return !!(t || n || a);
  }
  constructor(t) {
    super(t);
  }
  startObserver() {
    const t = this.state.element;
    if (!t || !this.isActive())
      return;
    this.unmount();
    const { once: n, ...a } = this.state.options.inViewOptions || {};
    this.unmount = inView(
      t,
      (o, s) => {
        if (handleHoverEvent(this.state, s, "Enter"), !n)
          return (u) => {
            handleHoverEvent(this.state, s, "Leave");
          };
      },
      a
    );
  }
  mount() {
    this.startObserver();
  }
  update() {
    const { props: t, prevProps: n } = this.state.visualElement;
    ["amount", "margin", "root"].some(
      hasViewportOptionChanged(t, n)
    ) && this.startObserver();
  }
}
function hasViewportOptionChanged({ inViewOptions: e = {} }, { inViewOptions: t = {} } = {}) {
  return (n) => e[n] !== t[n];
}
function addDomEvent$1(e, t, n, a = { passive: !0 }) {
  return e.addEventListener(t, n, a), () => e.removeEventListener(t, n);
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let t = !1;
    try {
      t = this.state.element.matches(":focus-visible");
    } catch {
      t = !0;
    }
    t && (this.state.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    this.isActive && (this.state.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(
      addDomEvent$1(this.state.element, "focus", () => this.onFocus()),
      addDomEvent$1(this.state.element, "blur", () => this.onBlur())
    );
  }
}
const compareByDepth = (e, t) => e.depth - t.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(t) {
    addUniqueItem(this.children, t), this.isDirty = !0;
  }
  remove(t) {
    removeItem(this.children, t), this.isDirty = !0;
  }
  forEach(t) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(t);
  }
}
function delay(e, t) {
  const n = time.now(), a = ({ timestamp: o }) => {
    const s = o - n;
    s >= t && (cancelFrame(a), e(s - t));
  };
  return frame.setup(a, !0), () => cancelFrame(a);
}
function resolveMotionValue(e) {
  return isMotionValue(e) ? e.get() : e;
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (e) => typeof e == "string" ? parseFloat(e) : e, isPx = (e) => typeof e == "number" || px.test(e);
function mixValues(e, t, n, a, o, s) {
  o ? (e.opacity = mixNumber$1(0, n.opacity ?? 1, easeCrossfadeIn(a)), e.opacityExit = mixNumber$1(t.opacity ?? 1, 0, easeCrossfadeOut(a))) : s && (e.opacity = mixNumber$1(t.opacity ?? 1, n.opacity ?? 1, a));
  for (let u = 0; u < numBorders; u++) {
    const d = `border${borders[u]}Radius`;
    let f = getRadius(t, d), g = getRadius(n, d);
    if (f === void 0 && g === void 0)
      continue;
    f || (f = 0), g || (g = 0), f === 0 || g === 0 || isPx(f) === isPx(g) ? (e[d] = Math.max(mixNumber$1(asNumber(f), asNumber(g), a), 0), (percent.test(g) || percent.test(f)) && (e[d] += "%")) : e[d] = g;
  }
  (t.rotate || n.rotate) && (e.rotate = mixNumber$1(t.rotate || 0, n.rotate || 0, a));
}
function getRadius(e, t) {
  return e[t] !== void 0 ? e[t] : e.borderRadius;
}
const easeCrossfadeIn = /* @__PURE__ */ compress(0, 0.5, circOut), easeCrossfadeOut = /* @__PURE__ */ compress(0.5, 0.95, noop);
function compress(e, t, n) {
  return (a) => a < e ? 0 : a > t ? 1 : n(/* @__PURE__ */ progress(e, t, a));
}
function copyAxisInto(e, t) {
  e.min = t.min, e.max = t.max;
}
function copyBoxInto(e, t) {
  copyAxisInto(e.x, t.x), copyAxisInto(e.y, t.y);
}
function copyAxisDeltaInto(e, t) {
  e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin;
}
function isIdentityScale(e) {
  return e === void 0 || e === 1;
}
function hasScale({ scale: e, scaleX: t, scaleY: n }) {
  return !isIdentityScale(e) || !isIdentityScale(t) || !isIdentityScale(n);
}
function hasTransform(e) {
  return hasScale(e) || has2DTranslate(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function has2DTranslate(e) {
  return is2DTranslate(e.x) || is2DTranslate(e.y);
}
function is2DTranslate(e) {
  return e && e !== "0%";
}
function scalePoint(e, t, n) {
  const a = e - n, o = t * a;
  return n + o;
}
function applyPointDelta(e, t, n, a, o) {
  return o !== void 0 && (e = scalePoint(e, o, a)), scalePoint(e, n, a) + t;
}
function applyAxisDelta(e, t = 0, n = 1, a, o) {
  e.min = applyPointDelta(e.min, t, n, a, o), e.max = applyPointDelta(e.max, t, n, a, o);
}
function applyBoxDelta(e, { x: t, y: n }) {
  applyAxisDelta(e.x, t.translate, t.scale, t.originPoint), applyAxisDelta(e.y, n.translate, n.scale, n.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999, TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(e, t, n, a = !1) {
  const o = n.length;
  if (!o)
    return;
  t.x = t.y = 1;
  let s, u;
  for (let d = 0; d < o; d++) {
    s = n[d], u = s.projectionDelta;
    const { visualElement: f } = s.options;
    f && f.props.style && f.props.style.display === "contents" || (a && s.options.layoutScroll && s.scroll && s !== s.root && transformBox(e, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), u && (t.x *= u.x.scale, t.y *= u.y.scale, applyBoxDelta(e, u)), a && hasTransform(s.latestValues) && transformBox(e, s.latestValues));
  }
  t.x < TREE_SCALE_SNAP_MAX && t.x > TREE_SCALE_SNAP_MIN && (t.x = 1), t.y < TREE_SCALE_SNAP_MAX && t.y > TREE_SCALE_SNAP_MIN && (t.y = 1);
}
function translateAxis$1(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function transformAxis(e, t, n, a, o = 0.5) {
  const s = mixNumber$1(e.min, e.max, o);
  applyAxisDelta(e, t, n, s, a);
}
function transformBox(e, t) {
  transformAxis(e.x, t.x, t.scaleX, t.scale, t.originX), transformAxis(e.y, t.y, t.scaleY, t.scale, t.originY);
}
const SCALE_PRECISION = 1e-4, SCALE_MIN = 1 - SCALE_PRECISION, SCALE_MAX = 1 + SCALE_PRECISION, TRANSLATE_PRECISION = 0.01, TRANSLATE_MIN = 0 - TRANSLATE_PRECISION, TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength$1(e) {
  return e.max - e.min;
}
function isNear(e, t, n) {
  return Math.abs(e - t) <= n;
}
function calcAxisDelta(e, t, n, a = 0.5) {
  e.origin = a, e.originPoint = mixNumber$1(t.min, t.max, e.origin), e.scale = calcLength$1(n) / calcLength$1(t), e.translate = mixNumber$1(n.min, n.max, e.origin) - e.originPoint, (e.scale >= SCALE_MIN && e.scale <= SCALE_MAX || isNaN(e.scale)) && (e.scale = 1), (e.translate >= TRANSLATE_MIN && e.translate <= TRANSLATE_MAX || isNaN(e.translate)) && (e.translate = 0);
}
function calcBoxDelta(e, t, n, a) {
  calcAxisDelta(e.x, t.x, n.x, a ? a.originX : void 0), calcAxisDelta(e.y, t.y, n.y, a ? a.originY : void 0);
}
function calcRelativeAxis(e, t, n) {
  e.min = n.min + t.min, e.max = e.min + calcLength$1(t);
}
function calcRelativeBox(e, t, n) {
  calcRelativeAxis(e.x, t.x, n.x), calcRelativeAxis(e.y, t.y, n.y);
}
function calcRelativeAxisPosition(e, t, n) {
  e.min = t.min - n.min, e.max = e.min + calcLength$1(t);
}
function calcRelativePosition(e, t, n) {
  calcRelativeAxisPosition(e.x, t.x, n.x), calcRelativeAxisPosition(e.y, t.y, n.y);
}
function removePointDelta(e, t, n, a, o) {
  return e -= t, e = scalePoint(e, 1 / n, a), o !== void 0 && (e = scalePoint(e, 1 / o, a)), e;
}
function removeAxisDelta(e, t = 0, n = 1, a = 0.5, o, s = e, u = e) {
  if (percent.test(t) && (t = parseFloat(t), t = mixNumber$1(u.min, u.max, t / 100) - u.min), typeof t != "number")
    return;
  let d = mixNumber$1(s.min, s.max, a);
  e === s && (d -= t), e.min = removePointDelta(e.min, t, n, d, o), e.max = removePointDelta(e.max, t, n, d, o);
}
function removeAxisTransforms(e, t, [n, a, o], s, u) {
  removeAxisDelta(e, t[n], t[a], t[o], t.scale, s, u);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(e, t, n, a) {
  removeAxisTransforms(e.x, t, xKeys, n ? n.x : void 0, a ? a.x : void 0), removeAxisTransforms(e.y, t, yKeys, n ? n.y : void 0, a ? a.y : void 0);
}
function isAxisDeltaZero(e) {
  return e.translate === 0 && e.scale === 1;
}
function isDeltaZero(e) {
  return isAxisDeltaZero(e.x) && isAxisDeltaZero(e.y);
}
function axisEquals(e, t) {
  return e.min === t.min && e.max === t.max;
}
function boxEquals(e, t) {
  return axisEquals(e.x, t.x) && axisEquals(e.y, t.y);
}
function axisEqualsRounded(e, t) {
  return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max);
}
function boxEqualsRounded(e, t) {
  return axisEqualsRounded(e.x, t.x) && axisEqualsRounded(e.y, t.y);
}
function aspectRatio(e) {
  return calcLength$1(e.x) / calcLength$1(e.y);
}
function axisDeltaEquals(e, t) {
  return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(t) {
    addUniqueItem(this.members, t), t.scheduleRender();
  }
  remove(t) {
    if (removeItem(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(t) {
    const n = this.members.findIndex((o) => t === o);
    if (n === 0)
      return !1;
    let a;
    for (let o = n; o >= 0; o--) {
      const s = this.members[o];
      if (s.isPresent !== !1) {
        a = s;
        break;
      }
    }
    return a ? (this.promote(a), !0) : !1;
  }
  promote(t, n) {
    const a = this.lead;
    if (t !== a && (this.prevLead = a, this.lead = t, t.show(), a)) {
      a.instance && a.scheduleRender(), t.scheduleRender(), t.resumeFrom = a, n && (t.resumeFrom.preserveOpacity = !0), a.snapshot && (t.snapshot = a.snapshot, t.snapshot.latestValues = a.animationValues || a.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0);
      const { crossfade: o } = t.options;
      o === !1 && a.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((t) => {
      const { options: n, resumingFrom: a } = t;
      n.onExitComplete && n.onExitComplete(), a && a.options.onExitComplete && a.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((t) => {
      t.instance && t.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(e, t, n) {
  let a = "";
  const o = e.x.translate / t.x, s = e.y.translate / t.y, u = n?.z || 0;
  if ((o || s || u) && (a = `translate3d(${o}px, ${s}px, ${u}px) `), (t.x !== 1 || t.y !== 1) && (a += `scale(${1 / t.x}, ${1 / t.y}) `), n) {
    const { transformPerspective: g, rotate: v, rotateX: b, rotateY: w, skewX: C, skewY: k } = n;
    g && (a = `perspective(${g}px) ${a}`), v && (a += `rotate(${v}deg) `), b && (a += `rotateX(${b}deg) `), w && (a += `rotateY(${w}deg) `), C && (a += `skewX(${C}deg) `), k && (a += `skewY(${k}deg) `);
  }
  const d = e.x.scale * t.x, f = e.y.scale * t.y;
  return (d !== 1 || f !== 1) && (a += `scale(${d}, ${f})`), a || "none";
}
function eachAxis$1(e) {
  return [e("x"), e("y")];
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, { schedule: microtask } = /* @__PURE__ */ createRenderBatcher(queueMicrotask, !1), transformAxes = ["", "X", "Y", "Z"], animationTarget = 1e3;
let id = 0;
function resetDistortingTransform(e, t, n, a) {
  const { latestValues: o } = t;
  o[e] && (n[e] = o[e], t.setStaticValue(e, 0), a && (a[e] = 0));
}
function cancelTreeOptimisedTransformAnimations(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: t } = e.options;
  if (!t)
    return;
  const n = getOptimisedAppearId(t);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: o, layoutId: s } = e.options;
    window.MotionCancelOptimisedAnimation(n, "transform", frame, !(o || s));
  }
  const { parent: a } = e;
  a && !a.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(a);
}
function createProjectionNode({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: a, resetTransform: o }) {
  return class {
    constructor(u = {}, d = t?.()) {
      this.id = id++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = u, this.root = d ? d.root || d : this, this.path = d ? [...d.path, d] : [], this.parent = d, this.depth = d ? d.depth + 1 : 0;
      for (let f = 0; f < this.path.length; f++)
        this.path[f].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(u, d) {
      return this.eventHandlers.has(u) || this.eventHandlers.set(u, new SubscriptionManager()), this.eventHandlers.get(u).add(d);
    }
    notifyListeners(u, ...d) {
      const f = this.eventHandlers.get(u);
      f && f.notify(...d);
    }
    hasListeners(u) {
      return this.eventHandlers.has(u);
    }
    /**
     * Lifecycles
     */
    mount(u) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(u) && !isSVGSVGElement(u), this.instance = u;
      const { layoutId: d, layout: f, visualElement: g } = this.options;
      if (g && !g.current && g.mount(u), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (f || d) && (this.isLayoutDirty = !0), e) {
        let v, b = 0;
        const w = () => this.root.updateBlockedByResize = !1;
        frame.read(() => {
          b = window.innerWidth;
        }), e(u, () => {
          const C = window.innerWidth;
          C !== b && (b = C, this.root.updateBlockedByResize = !0, v && v(), v = delay(w, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation)));
        });
      }
      d && this.root.registerSharedNode(d, this), this.options.animate !== !1 && g && (d || f) && this.addEventListener("didUpdate", ({ delta: v, hasLayoutChanged: b, hasRelativeLayoutChanged: w, layout: C }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const k = this.options.transition || g.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart: E, onLayoutAnimationComplete: A } = g.getProps(), P = !this.targetLayout || !boxEqualsRounded(this.targetLayout, C), M = !b && w;
        if (this.options.layoutRoot || this.resumeFrom || M || b && (P || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const B = {
            ...getValueTransition(k, "layout"),
            onPlay: E,
            onComplete: A
          };
          (g.shouldReduceMotion || this.options.layoutRoot) && (B.delay = 0, B.type = !1), this.startAnimation(B), this.setAnimationOrigin(v, M);
        } else
          b || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = C;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const u = this.getStack();
      u && u.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetSkewAndRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: u } = this.options;
      return u && u.getProps().transformTemplate;
    }
    willUpdate(u = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cancelTreeOptimisedTransformAnimations(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let v = 0; v < this.path.length; v++) {
        const b = this.path[v];
        b.shouldResetTransform = !0, b.updateScroll("snapshot"), b.options.layoutRoot && b.willUpdate(!1);
      }
      const { layoutId: d, layout: f } = this.options;
      if (d === void 0 && !f)
        return;
      const g = this.getTransformTemplate();
      this.prevTransformTemplateValue = g ? g(this.latestValues, "") : void 0, this.updateSnapshot(), u && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(clearIsLayoutDirty);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate)) : this.nodes.forEach(clearIsLayoutDirty), this.clearAllSnapshots();
      const d = time.now();
      frameData.delta = clamp(0, 1e3 / 60, d - frameData.timestamp), frameData.timestamp = d, frameData.isProcessing = !0, frameSteps.update.process(frameData), frameSteps.preRender.process(frameData), frameSteps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !calcLength$1(this.snapshot.measuredBox.x) && !calcLength$1(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let f = 0; f < this.path.length; f++)
          this.path[f].updateScroll();
      const u = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox$1(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: d } = this.options;
      d && d.notify("LayoutMeasure", this.layout.layoutBox, u ? u.layoutBox : void 0);
    }
    updateScroll(u = "measure") {
      let d = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === u && (d = !1), d && this.instance) {
        const f = a(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: u,
          isRoot: f,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : f
        };
      }
    }
    resetTransform() {
      if (!o)
        return;
      const u = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, d = this.projectionDelta && !isDeltaZero(this.projectionDelta), f = this.getTransformTemplate(), g = f ? f(this.latestValues, "") : void 0, v = g !== this.prevTransformTemplateValue;
      u && this.instance && (d || hasTransform(this.latestValues) || v) && (o(this.instance, g), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(u = !0) {
      const d = this.measurePageBox();
      let f = this.removeElementScroll(d);
      return u && (f = this.removeTransform(f)), roundBox(f), {
        animationId: this.root.animationId,
        measuredBox: d,
        layoutBox: f,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var u;
      const { visualElement: d } = this.options;
      if (!d)
        return createBox$1();
      const f = d.measureViewportBox();
      if (!(((u = this.scroll) == null ? void 0 : u.wasRoot) || this.path.some(checkNodeWasScrollRoot))) {
        const { scroll: v } = this.root;
        v && (translateAxis$1(f.x, v.offset.x), translateAxis$1(f.y, v.offset.y));
      }
      return f;
    }
    removeElementScroll(u) {
      var d;
      const f = createBox$1();
      if (copyBoxInto(f, u), (d = this.scroll) != null && d.wasRoot)
        return f;
      for (let g = 0; g < this.path.length; g++) {
        const v = this.path[g], { scroll: b, options: w } = v;
        v !== this.root && b && w.layoutScroll && (b.wasRoot && copyBoxInto(f, u), translateAxis$1(f.x, b.offset.x), translateAxis$1(f.y, b.offset.y));
      }
      return f;
    }
    applyTransform(u, d = !1) {
      const f = createBox$1();
      copyBoxInto(f, u);
      for (let g = 0; g < this.path.length; g++) {
        const v = this.path[g];
        !d && v.options.layoutScroll && v.scroll && v !== v.root && transformBox(f, {
          x: -v.scroll.offset.x,
          y: -v.scroll.offset.y
        }), hasTransform(v.latestValues) && transformBox(f, v.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(f, this.latestValues), f;
    }
    removeTransform(u) {
      const d = createBox$1();
      copyBoxInto(d, u);
      for (let f = 0; f < this.path.length; f++) {
        const g = this.path[f];
        if (!g.instance || !hasTransform(g.latestValues))
          continue;
        hasScale(g.latestValues) && g.updateSnapshot();
        const v = createBox$1(), b = g.measurePageBox();
        copyBoxInto(v, b), removeBoxTransforms(d, g.latestValues, g.snapshot ? g.snapshot.layoutBox : void 0, v);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(d, this.latestValues), d;
    }
    setTargetDelta(u) {
      this.targetDelta = u, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(u) {
      this.options = {
        ...this.options,
        ...u,
        crossfade: u.crossfade !== void 0 ? u.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(u = !1) {
      var d;
      const f = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = f.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = f.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = f.isSharedProjectionDirty);
      const g = !!this.resumingFrom || this !== f;
      if (!(u || g && this.isSharedProjectionDirty || this.isProjectionDirty || (d = this.parent) != null && d.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: b, layoutId: w } = this.options;
      if (!(!this.layout || !(b || w))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          const C = this.getClosestProjectingParent();
          C && C.layout && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox$1(), this.relativeTargetOrigin = createBox$1(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, C.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = createBox$1(), this.targetWithTransforms = createBox$1()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const C = this.getClosestProjectingParent();
          C && !!C.resumingFrom == !!this.resumingFrom && !C.options.layoutScroll && C.target && this.animationProgress !== 1 ? (this.relativeParent = C, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox$1(), this.relativeTargetOrigin = createBox$1(), calcRelativePosition(this.relativeTargetOrigin, this.target, C.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var u;
      const d = this.getLead(), f = !!this.resumingFrom || this !== d;
      let g = !0;
      if ((this.isProjectionDirty || (u = this.parent) != null && u.isProjectionDirty) && (g = !1), f && (this.isSharedProjectionDirty || this.isTransformDirty) && (g = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (g = !1), g)
        return;
      const { layout: v, layoutId: b } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(v || b))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const w = this.treeScale.x, C = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, f), d.layout && !d.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (d.target = d.layout.layoutBox, d.targetWithTransforms = createBox$1());
      const { target: k } = d;
      if (!k) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x), copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y)), calcBoxDelta(this.projectionDelta, this.layoutCorrected, k, this.latestValues), (this.treeScale.x !== w || this.treeScale.y !== C || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", k));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(u = !0) {
      var d;
      if ((d = this.options.visualElement) == null || d.scheduleRender(), u) {
        const f = this.getStack();
        f && f.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta(), this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(u, d = !1) {
      const f = this.snapshot, g = f ? f.latestValues : {}, v = { ...this.latestValues }, b = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !d;
      const w = createBox$1(), C = f ? f.source : void 0, k = this.layout ? this.layout.source : void 0, E = C !== k, A = this.getStack(), P = !A || A.members.length <= 1, M = !!(E && !P && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let B;
      this.mixTargetDelta = (_) => {
        const T = _ / 1e3;
        mixAxisDelta(b.x, u.x, T), mixAxisDelta(b.y, u.y, T), this.setTargetDelta(b), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(w, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, w, T), B && boxEquals(this.relativeTarget, B) && (this.isProjectionDirty = !1), B || (B = createBox$1()), copyBoxInto(B, this.relativeTarget)), E && (this.animationValues = v, mixValues(v, g, this.latestValues, T, M, P)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = T;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(u) {
      var d, f, g;
      this.notifyListeners("animationStart"), (d = this.currentAnimation) == null || d.stop(), (g = (f = this.resumingFrom) == null ? void 0 : f.currentAnimation) == null || g.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = motionValue(0)), this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...u,
          velocity: 0,
          isSync: !0,
          onUpdate: (v) => {
            this.mixTargetDelta(v), u.onUpdate && u.onUpdate(v);
          },
          onStop: () => {
          },
          onComplete: () => {
            u.onComplete && u.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const u = this.getStack();
      u && u.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const u = this.getLead();
      let { targetWithTransforms: d, target: f, layout: g, latestValues: v } = u;
      if (!(!d || !f || !g)) {
        if (this !== u && this.layout && g && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, g.layoutBox)) {
          f = this.target || createBox$1();
          const b = calcLength$1(this.layout.layoutBox.x);
          f.x.min = u.target.x.min, f.x.max = f.x.min + b;
          const w = calcLength$1(this.layout.layoutBox.y);
          f.y.min = u.target.y.min, f.y.max = f.y.min + w;
        }
        copyBoxInto(d, f), transformBox(d, v), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, d, v);
      }
    }
    registerSharedNode(u, d) {
      this.sharedNodes.has(u) || this.sharedNodes.set(u, new NodeStack()), this.sharedNodes.get(u).add(d);
      const g = d.options.initialPromotionConfig;
      d.promote({
        transition: g ? g.transition : void 0,
        preserveFollowOpacity: g && g.shouldPreserveFollowOpacity ? g.shouldPreserveFollowOpacity(d) : void 0
      });
    }
    isLead() {
      const u = this.getStack();
      return u ? u.lead === this : !0;
    }
    getLead() {
      var u;
      const { layoutId: d } = this.options;
      return d ? ((u = this.getStack()) == null ? void 0 : u.lead) || this : this;
    }
    getPrevLead() {
      var u;
      const { layoutId: d } = this.options;
      return d ? (u = this.getStack()) == null ? void 0 : u.prevLead : void 0;
    }
    getStack() {
      const { layoutId: u } = this.options;
      if (u)
        return this.root.sharedNodes.get(u);
    }
    promote({ needsReset: u, transition: d, preserveFollowOpacity: f } = {}) {
      const g = this.getStack();
      g && g.promote(this, f), u && (this.projectionDelta = void 0, this.needsReset = !0), d && this.setOptions({ transition: d });
    }
    relegate() {
      const u = this.getStack();
      return u ? u.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: u } = this.options;
      if (!u)
        return;
      let d = !1;
      const { latestValues: f } = u;
      if ((f.z || f.rotate || f.rotateX || f.rotateY || f.rotateZ || f.skewX || f.skewY) && (d = !0), !d)
        return;
      const g = {};
      f.z && resetDistortingTransform("z", u, g, this.animationValues);
      for (let v = 0; v < transformAxes.length; v++)
        resetDistortingTransform(`rotate${transformAxes[v]}`, u, g, this.animationValues), resetDistortingTransform(`skew${transformAxes[v]}`, u, g, this.animationValues);
      u.render();
      for (const v in g)
        u.setStaticValue(v, g[v]), this.animationValues && (this.animationValues[v] = g[v]);
      u.scheduleRender();
    }
    applyProjectionStyles(u, d) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        u.visibility = "hidden";
        return;
      }
      const f = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, u.visibility = "", u.opacity = "", u.pointerEvents = resolveMotionValue(d?.pointerEvents) || "", u.transform = f ? f(this.latestValues, "") : "none";
        return;
      }
      const g = this.getLead();
      if (!this.projectionDelta || !this.layout || !g.target) {
        this.options.layoutId && (u.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, u.pointerEvents = resolveMotionValue(d?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (u.transform = f ? f({}, "") : "none", this.hasProjected = !1);
        return;
      }
      u.visibility = "";
      const v = g.animationValues || g.latestValues;
      this.applyTransformsToTarget();
      let b = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, v);
      f && (b = f(v, b)), u.transform = b;
      const { x: w, y: C } = this.projectionDelta;
      u.transformOrigin = `${w.origin * 100}% ${C.origin * 100}% 0`, g.animationValues ? u.opacity = g === this ? v.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : v.opacityExit : u.opacity = g === this ? v.opacity !== void 0 ? v.opacity : "" : v.opacityExit !== void 0 ? v.opacityExit : 0;
      for (const k in scaleCorrectors) {
        if (v[k] === void 0)
          continue;
        const { correct: E, applyTo: A, isCSSVariable: P } = scaleCorrectors[k], M = b === "none" ? v[k] : E(v[k], g);
        if (A) {
          const B = A.length;
          for (let _ = 0; _ < B; _++)
            u[A[_]] = M;
        } else
          P ? this.options.visualElement.renderState.vars[k] = M : u[k] = M;
      }
      this.options.layoutId && (u.pointerEvents = g === this ? resolveMotionValue(d?.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((u) => {
        var d;
        return (d = u.currentAnimation) == null ? void 0 : d.stop();
      }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(e) {
  e.updateLayout();
}
function notifyLayoutUpdate(e) {
  var t;
  const n = ((t = e.resumeFrom) == null ? void 0 : t.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && n && e.hasListeners("didUpdate")) {
    const { layoutBox: a, measuredBox: o } = e.layout, { animationType: s } = e.options, u = n.source !== e.layout.source;
    s === "size" ? eachAxis$1((b) => {
      const w = u ? n.measuredBox[b] : n.layoutBox[b], C = calcLength$1(w);
      w.min = a[b].min, w.max = w.min + C;
    }) : shouldAnimatePositionOnly(s, n.layoutBox, a) && eachAxis$1((b) => {
      const w = u ? n.measuredBox[b] : n.layoutBox[b], C = calcLength$1(a[b]);
      w.max = w.min + C, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[b].max = e.relativeTarget[b].min + C);
    });
    const d = createDelta();
    calcBoxDelta(d, a, n.layoutBox);
    const f = createDelta();
    u ? calcBoxDelta(f, e.applyTransform(o, !0), n.measuredBox) : calcBoxDelta(f, a, n.layoutBox);
    const g = !isDeltaZero(d);
    let v = !1;
    if (!e.resumeFrom) {
      const b = e.getClosestProjectingParent();
      if (b && !b.resumeFrom) {
        const { snapshot: w, layout: C } = b;
        if (w && C) {
          const k = createBox$1();
          calcRelativePosition(k, n.layoutBox, w.layoutBox);
          const E = createBox$1();
          calcRelativePosition(E, a, C.layoutBox), boxEqualsRounded(k, E) || (v = !0), b.options.layoutRoot && (e.relativeTarget = E, e.relativeTargetOrigin = k, e.relativeParent = b);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: a,
      snapshot: n,
      delta: f,
      layoutDelta: d,
      hasLayoutChanged: g,
      hasRelativeLayoutChanged: v
    });
  } else if (e.isLead()) {
    const { onExitComplete: a } = e.options;
    a && a();
  }
  e.options.transition = void 0;
}
function propagateDirtyNodes(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function cleanDirtyNodes(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function clearSnapshot(e) {
  e.clearSnapshot();
}
function clearMeasurements(e) {
  e.clearMeasurements();
}
function clearIsLayoutDirty(e) {
  e.isLayoutDirty = !1;
}
function resetTransformStyle(e) {
  const { visualElement: t } = e.options;
  t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function finishAnimation(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function resolveTargetDelta(e) {
  e.resolveTargetDelta();
}
function calcProjection(e) {
  e.calcProjection();
}
function resetSkewAndRotation(e) {
  e.resetSkewAndRotation();
}
function removeLeadSnapshots(e) {
  e.removeLeadSnapshot();
}
function mixAxisDelta(e, t, n) {
  e.translate = mixNumber$1(t.translate, 0, n), e.scale = mixNumber$1(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint;
}
function mixAxis(e, t, n, a) {
  e.min = mixNumber$1(t.min, n.min, a), e.max = mixNumber$1(t.max, n.max, a);
}
function mixBox(e, t, n, a) {
  mixAxis(e.x, t.x, n.x, a), mixAxis(e.y, t.y, n.y, a);
}
function hasOpacityCrossfade(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(e) {
  e.min = roundPoint(e.min), e.max = roundPoint(e.max);
}
function roundBox(e) {
  roundAxis(e.x), roundAxis(e.y);
}
function shouldAnimatePositionOnly(e, t, n) {
  return e === "position" || e === "preserve-aspect" && !isNear(aspectRatio(t), aspectRatio(n), 0.2);
}
function checkNodeWasScrollRoot(e) {
  var t;
  return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot);
}
function addDomEvent(e, t, n, a = { passive: !0 }) {
  return e.addEventListener(t, n, a), () => e.removeEventListener(t, n);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (e, t) => addDomEvent(e, "resize", t),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const e = new DocumentProjectionNode({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = e;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (e, t) => {
    e.style.transform = t !== void 0 ? t : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
});
function getClosestProjectingNode(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : getClosestProjectingNode(e.parent);
}
function pixelsToPercent(e, t) {
  return t.max === t.min ? 0 : e / (t.max - t.min) * 100;
}
const correctBorderRadius = {
  correct: (e, t) => {
    if (!t.target)
      return e;
    if (typeof e == "string")
      if (px.test(e))
        e = parseFloat(e);
      else
        return e;
    const n = pixelsToPercent(e, t.target.x), a = pixelsToPercent(e, t.target.y);
    return `${n}% ${a}%`;
  }
}, correctBoxShadow = {
  correct: (e, { treeScale: t, projectionDelta: n }) => {
    const a = e, o = complex.parse(e);
    if (o.length > 5)
      return a;
    const s = complex.createTransformer(e), u = typeof o[0] != "number" ? 1 : 0, d = n.x.scale * t.x, f = n.y.scale * t.y;
    o[0 + u] /= d, o[1 + u] /= f;
    const g = mixNumber$1(d, f, 0.5);
    return typeof o[2 + u] == "number" && (o[2 + u] /= g), typeof o[3 + u] == "number" && (o[3 + u] /= g), s(o);
  }
}, defaultScaleCorrector = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
function isHTMLElement(e) {
  return typeof e == "object" && e !== null && "nodeType" in e;
}
class ProjectionFeature extends Feature {
  constructor(t) {
    super(t), addScaleCorrector(defaultScaleCorrector);
  }
  initProjection() {
    const t = this.state.options;
    this.state.visualElement.projection = new HTMLProjectionNode(
      this.state.visualElement.latestValues,
      t["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(this.state.visualElement.parent)
    ), this.state.visualElement.projection.isPresent = !0, this.setOptions();
  }
  beforeMount() {
    this.initProjection();
  }
  setOptions() {
    const t = this.state.options;
    this.state.visualElement.projection.setOptions({
      layout: t.layout,
      layoutId: t.layoutId,
      alwaysMeasureLayout: !!t.drag || t.dragConstraints && isHTMLElement(t.dragConstraints),
      visualElement: this.state.visualElement,
      animationType: typeof t.layout == "string" ? t.layout : "both",
      // initialPromotionConfig
      layoutRoot: t.layoutRoot,
      layoutScroll: t.layoutScroll,
      crossfade: t.crossfade,
      onExitComplete: () => {
        var n;
        if (!((n = this.state.visualElement.projection) != null && n.isPresent)) {
          const a = doneCallbacks.get(this.state.element);
          this.state.isSafeToRemove = !0, a && a({
            detail: {
              isExit: !0
            }
          }, !0);
        }
      }
    });
  }
  update() {
    this.setOptions();
  }
  mount() {
    var t;
    (t = this.state.visualElement.projection) == null || t.mount(this.state.element);
  }
}
function isPrimaryPointer(e) {
  return e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1;
}
function extractEventInfo(e, t = "page") {
  return {
    point: {
      x: e[`${t}X`],
      y: e[`${t}Y`]
    }
  };
}
function addPointerInfo(e) {
  return (t) => isPrimaryPointer(t) && e(t, extractEventInfo(t));
}
function addPointerEvent(e, t, n, a) {
  return addDomEvent$1(e, t, addPointerInfo(n), a);
}
function createLock(e) {
  let t = null;
  return () => {
    const n = () => {
      t = null;
    };
    return t === null ? (t = e, n) : !1;
  };
}
const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical");
function getGlobalLock(e) {
  let t = !1;
  if (e === "y")
    t = globalVerticalLock();
  else if (e === "x")
    t = globalHorizontalLock();
  else {
    const n = globalHorizontalLock(), a = globalVerticalLock();
    n && a ? t = () => {
      n(), a();
    } : (n && n(), a && a());
  }
  return t;
}
function calcLength(e) {
  return e.max - e.min;
}
function applyConstraints(e, { min: t, max: n }, a) {
  return t !== void 0 && e < t ? e = a ? mixNumber$1(t, e, a.min) : Math.max(e, t) : n !== void 0 && e > n && (e = a ? mixNumber$1(n, e, a.max) : Math.min(e, n)), e;
}
const defaultElastic = 0.35;
function calcRelativeConstraints(e, { top: t, left: n, bottom: a, right: o }) {
  return {
    x: calcRelativeAxisConstraints(e.x, n, o),
    y: calcRelativeAxisConstraints(e.y, t, a)
  };
}
function calcRelativeAxisConstraints(e, t, n) {
  return {
    min: t !== void 0 ? e.min + t : void 0,
    max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0
  };
}
function resolveDragElastic(e = defaultElastic) {
  return e === !1 ? e = 0 : e === !0 && (e = defaultElastic), {
    x: resolveAxisElastic(e, "left", "right"),
    y: resolveAxisElastic(e, "top", "bottom")
  };
}
function resolveAxisElastic(e, t, n) {
  return {
    min: resolvePointElastic(e, t),
    max: resolvePointElastic(e, n)
  };
}
function resolvePointElastic(e, t) {
  return typeof e == "number" ? e : e[t] || 0;
}
function rebaseAxisConstraints(e, t) {
  const n = {};
  return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n;
}
function calcViewportConstraints(e, t) {
  return {
    x: calcViewportAxisConstraints(e.x, t.x),
    y: calcViewportAxisConstraints(e.y, t.y)
  };
}
function calcViewportAxisConstraints(e, t) {
  let n = t.min - e.min, a = t.max - e.max;
  return t.max - t.min < e.max - e.min && ([n, a] = [a, n]), { min: n, max: a };
}
function calcOrigin(e, t) {
  let n = 0.5;
  const a = calcLength(e), o = calcLength(t);
  return o > a ? n = /* @__PURE__ */ progress(t.min, t.max - a, e.min) : a > o && (n = /* @__PURE__ */ progress(e.min, e.max - o, t.min)), clamp(0, 1, n);
}
const distance = (e, t) => Math.abs(e - t);
function distance2D(e, t) {
  const n = distance(e.x, t.x), a = distance(e.y, t.y);
  return Math.sqrt(n ** 2 + a ** 2);
}
class PanSession {
  constructor(t, n, { transformPagePoint: a, contextWindow: o, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const b = getPanInfo(this.lastMoveEventInfo, this.history), w = this.startEvent !== null, C = distance2D(b.offset, { x: 0, y: 0 }) >= 3;
      if (!w && !C)
        return;
      const { point: k } = b, { timestamp: E } = frameData;
      this.history.push({ ...k, timestamp: E });
      const { onStart: A, onMove: P } = this.handlers;
      w || (A && A(this.lastMoveEvent, b), this.startEvent = this.lastMoveEvent), P && P(this.lastMoveEvent, b);
    }, this.handlePointerMove = (b, w) => {
      this.lastMoveEvent = b, this.lastMoveEventInfo = transformPoint(w, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (b, w) => {
      this.end();
      const { onEnd: C, onSessionEnd: k, resumeAnimation: E } = this.handlers;
      if (this.dragSnapToOrigin && E && E(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const A = getPanInfo(
        b.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(w, this.transformPagePoint),
        this.history
      );
      this.startEvent && C && C(b, A), k && k(b, A);
    }, !isPrimaryPointer(t))
      return;
    this.dragSnapToOrigin = s, this.handlers = n, this.transformPagePoint = a, this.contextWindow = o || window;
    const u = extractEventInfo(t), d = transformPoint(u, this.transformPagePoint), { point: f } = d, { timestamp: g } = frameData;
    this.history = [{ ...f, timestamp: g }];
    const { onSessionStart: v } = n;
    v && v(t, getPanInfo(d, this.history)), this.removeListeners = pipe(
      addPointerEvent(
        this.contextWindow,
        "pointermove",
        this.handlePointerMove
      ),
      addPointerEvent(
        this.contextWindow,
        "pointerup",
        this.handlePointerUp
      ),
      addPointerEvent(
        this.contextWindow,
        "pointercancel",
        this.handlePointerUp
      )
    );
  }
  updateHandlers(t) {
    this.handlers = t;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(e, t) {
  return t ? { point: t(e.point) } : e;
}
function subtractPoint(e, t) {
  return { x: e.x - t.x, y: e.y - t.y };
}
function getPanInfo({ point: e }, t) {
  return {
    point: e,
    delta: subtractPoint(e, lastDevicePoint(t)),
    offset: subtractPoint(e, startDevicePoint(t)),
    velocity: getVelocity(t, 0.1)
  };
}
function startDevicePoint(e) {
  return e[0];
}
function lastDevicePoint(e) {
  return e[e.length - 1];
}
function getVelocity(e, t) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let n = e.length - 1, a = null;
  const o = lastDevicePoint(e);
  for (; n >= 0 && (a = e[n], !(o.timestamp - a.timestamp > /* @__PURE__ */ secondsToMilliseconds(t))); )
    n--;
  if (!a)
    return { x: 0, y: 0 };
  const s = /* @__PURE__ */ millisecondsToSeconds(
    o.timestamp - a.timestamp
  );
  if (s === 0)
    return { x: 0, y: 0 };
  const u = {
    x: (o.x - a.x) / s,
    y: (o.y - a.y) / s
  };
  return u.x === 1 / 0 && (u.x = 0), u.y === 1 / 0 && (u.y = 0), u;
}
const createAxis = () => ({ min: 0, max: 0 });
function createBox() {
  return {
    x: createAxis(),
    y: createAxis()
  };
}
function eachAxis(e) {
  return [e("x"), e("y")];
}
function isWillChangeMotionValue(e) {
  return !!(isMotionValue(e) && e.add);
}
function addValueToWillChange(e, t) {
  const n = e.getValue("willChange");
  if (isWillChangeMotionValue(n))
    return n.add(t);
}
function convertBoundingBoxToBox({
  top: e,
  left: t,
  right: n,
  bottom: a
}) {
  return {
    x: { min: t, max: n },
    y: { min: e, max: a }
  };
}
function transformBoxPoints(e, t) {
  if (!t)
    return e;
  const n = t({ x: e.left, y: e.top }), a = t({ x: e.right, y: e.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: a.y,
    right: a.x
  };
}
function convertBoxToBoundingBox({ x: e, y: t }) {
  return { top: t.min, right: e.max, bottom: t.max, left: e.min };
}
function translateAxis(e, t) {
  e.min = e.min + t, e.max = e.max + t;
}
function measureViewportBox(e, t) {
  return convertBoundingBoxToBox(
    transformBoxPoints(e.getBoundingClientRect(), t)
  );
}
function measurePageBox(e, t, n) {
  const a = measureViewportBox(e, n), { scroll: o } = t;
  return o && (translateAxis(a.x, o.offset.x), translateAxis(a.y, o.offset.y)), a;
}
function isPresent(e) {
  return !doneCallbacks.has(e.current);
}
function getContextWindow({ current: e }) {
  return e ? e.ownerDocument.defaultView : null;
}
const elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(t) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = t;
  }
  start(t, { snapToCursor: n = !1 } = {}) {
    if (!isPresent(this.visualElement))
      return;
    const a = (g) => {
      const { dragSnapToOrigin: v } = this.getProps();
      v ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(extractEventInfo(g, "page").point);
    }, o = (g, v) => {
      const { drag: b, dragPropagation: w, onDragStart: C } = this.getProps();
      if (b && !w && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(b), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((E) => {
        let A = this.getAxisMotionValue(E).get() || 0;
        if (percent.test(A)) {
          const { projection: P } = this.visualElement;
          if (P && P.layout) {
            const M = P.layout.layoutBox[E];
            M && (A = calcLength(M) * (parseFloat(A) / 100));
          }
        }
        this.originPoint[E] = A;
      }), C && frame.postRender(() => C(g, v)), addValueToWillChange(this.visualElement, "transform"), this.visualElement.state.setActive("whileDrag", !0);
    }, s = (g, v) => {
      const {
        dragPropagation: b,
        dragDirectionLock: w,
        onDirectionLock: C,
        onDrag: k
      } = this.getProps();
      if (!b && !this.openGlobalLock)
        return;
      const { offset: E } = v;
      if (w && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(E), this.currentDirection !== null && C && C(this.currentDirection);
        return;
      }
      this.updateAxis("x", v.point, E), this.updateAxis("y", v.point, E), this.visualElement.render(), k && k(g, v);
    }, u = (g, v) => this.stop(g, v), d = () => eachAxis(
      (g) => {
        var v;
        return this.getAnimationState(g) === "paused" && ((v = this.getAxisMotionValue(g).animation) == null ? void 0 : v.play());
      }
    ), { dragSnapToOrigin: f } = this.getProps();
    this.panSession = new PanSession(
      t,
      {
        onSessionStart: a,
        onStart: o,
        onMove: s,
        onSessionEnd: u,
        resumeAnimation: d
      },
      {
        transformPagePoint: this.visualElement.getTransformPagePoint(),
        dragSnapToOrigin: f,
        contextWindow: getContextWindow(this.visualElement)
      }
    );
  }
  stop(t, n) {
    const a = this.isDragging;
    if (this.cancel(), !a)
      return;
    const { velocity: o } = n;
    this.startAnimation(o);
    const { onDragEnd: s } = this.getProps();
    s && frame.postRender(() => s(t, n));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: t, animationState: n } = this.visualElement;
    t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: a } = this.getProps();
    !a && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), this.visualElement.state.setActive("whileDrag", !1);
  }
  updateAxis(t, n, a) {
    const { drag: o } = this.getProps();
    if (!a || !shouldDrag(t, o, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(t);
    let u = this.originPoint[t] + a[t];
    this.constraints && this.constraints[t] && (u = applyConstraints(
      u,
      this.constraints[t],
      this.elastic[t]
    )), s.set(u);
  }
  resolveConstraints() {
    var t;
    const { dragConstraints: n, dragElastic: a } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (t = this.visualElement.projection) == null ? void 0 : t.layout, s = this.constraints;
    n && isHTMLElement(n) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : n && o ? this.constraints = calcRelativeConstraints(
      o.layoutBox,
      n
    ) : this.constraints = !1, this.elastic = resolveDragElastic(a), s !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && eachAxis((u) => {
      this.constraints !== !1 && this.getAxisMotionValue(u) && (this.constraints[u] = rebaseAxisConstraints(
        o.layoutBox[u],
        this.constraints[u]
      ));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps();
    if (!t || !isHTMLElement(t))
      return !1;
    const a = t;
    invariant$1(
      a !== null,
      "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop."
    );
    const { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const s = measurePageBox(
      a,
      o.root,
      this.visualElement.getTransformPagePoint()
    );
    let u = calcViewportConstraints(
      o.layout.layoutBox,
      s
    );
    if (n) {
      const d = n(
        convertBoxToBoundingBox(u)
      );
      this.hasMutatedConstraints = !!d, d && (u = convertBoundingBoxToBox(d));
    }
    return u;
  }
  startAnimation(t) {
    const {
      drag: n,
      dragMomentum: a,
      dragElastic: o,
      dragTransition: s,
      dragSnapToOrigin: u,
      onDragTransitionEnd: d
    } = this.getProps(), f = this.constraints || {}, g = eachAxis((v) => {
      if (!shouldDrag(v, n, this.currentDirection))
        return;
      let b = f && f[v] || {};
      u && (b = { min: 0, max: 0 });
      const w = o ? 200 : 1e6, C = o ? 40 : 1e7, k = {
        type: "inertia",
        velocity: a ? t[v] : 0,
        bounceStiffness: w,
        bounceDamping: C,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...b
      };
      return this.startAxisValueAnimation(v, k);
    });
    return Promise.all(g).then(d);
  }
  startAxisValueAnimation(t, n) {
    const a = this.getAxisMotionValue(t);
    return addValueToWillChange(this.visualElement, t), a.start(
      animateMotionValue(
        t,
        a,
        0,
        n,
        this.visualElement,
        !1
      )
    );
  }
  stopAnimation() {
    isPresent(this.visualElement) && eachAxis((t) => this.getAxisMotionValue(t).stop());
  }
  pauseAnimation() {
    eachAxis((t) => {
      var n;
      return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause();
    });
  }
  getAnimationState(t) {
    var n;
    return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(t) {
    const n = `_drag${t.toUpperCase()}`, a = this.visualElement.getProps();
    return a[n] || this.visualElement.getValue(
      t,
      (a.initial ? a.initial[t] : void 0) || 0
    );
  }
  snapToCursor(t) {
    eachAxis((n) => {
      const { drag: a } = this.getProps();
      if (!shouldDrag(n, a, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, s = this.getAxisMotionValue(n);
      if (o && o.layout) {
        const { min: u, max: d } = o.layout.layoutBox[n];
        s.set(t[n] - mixNumber$1(u, d, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: t, dragConstraints: n } = this.getProps(), { projection: a } = this.visualElement;
    if (!isHTMLElement(n) || !a || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    eachAxis((u) => {
      const d = this.getAxisMotionValue(u);
      if (d && this.constraints !== !1) {
        const f = d.get();
        o[u] = calcOrigin(
          { min: f, max: f },
          this.constraints[u]
        );
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", a.root && a.root.updateScroll(), a.updateLayout(), this.resolveConstraints(), eachAxis((u) => {
      if (!shouldDrag(u, t, null))
        return;
      const d = this.getAxisMotionValue(u), { min: f, max: g } = this.constraints[u];
      d.set(mixNumber$1(f, g, o[u]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const t = this.visualElement.current, n = addPointerEvent(
      t,
      "pointerdown",
      (f) => {
        const { drag: g, dragListener: v = !0 } = this.getProps();
        g && v && this.start(f);
      }
    ), a = () => {
      const { dragConstraints: f } = this.getProps();
      isHTMLElement(f) && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, s = o.addEventListener(
      "measure",
      a
    );
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), frame.read(a);
    const u = addDomEvent$1(window, "resize", () => this.scalePositionWithinConstraints()), d = o.addEventListener(
      "didUpdate",
      ({ delta: f, hasLayoutChanged: g }) => {
        this.isDragging && g && (eachAxis((v) => {
          const b = this.getAxisMotionValue(v);
          b && (this.originPoint[v] += f[v].translate, b.set(
            b.get() + f[v].translate
          ));
        }), this.visualElement.render());
      }
    );
    return () => {
      u(), n(), s(), d && d();
    };
  }
  getProps() {
    const t = this.visualElement.getProps(), {
      drag: n = !1,
      dragDirectionLock: a = !1,
      dragPropagation: o = !1,
      dragConstraints: s = !1,
      dragElastic: u = defaultElastic,
      dragMomentum: d = !0
    } = t;
    return {
      ...t,
      drag: n,
      dragDirectionLock: a,
      dragPropagation: o,
      dragConstraints: s,
      dragElastic: u,
      dragMomentum: d
    };
  }
}
function shouldDrag(e, t, n) {
  return (t === !0 || t === e) && (n === null || n === e);
}
function getCurrentDirection(e, t = 10) {
  let n = null;
  return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n;
}
class DragGesture extends Feature {
  constructor(t) {
    super(t), this.removeGroupControls = noop, this.removeListeners = noop, this.controls = new VisualElementDragControls(t.visualElement);
  }
  mount() {
    const { dragControls: t } = this.state.options;
    t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
class LayoutFeature extends Feature {
  constructor(t) {
    super(t), addScaleCorrector(defaultScaleCorrector);
  }
  beforeUpdate() {
    this.state.willUpdate("beforeUpdate");
  }
  update() {
    this.didUpdate();
  }
  didUpdate() {
    var t, n;
    (this.state.options.layout || this.state.options.layoutId || this.state.options.drag) && ((n = (t = this.state.visualElement.projection) == null ? void 0 : t.root) == null || n.didUpdate());
  }
  mount() {
    var t;
    const n = this.state.options, a = this.state.options.layoutGroup;
    if (n.layout || n.layoutId) {
      const o = this.state.visualElement.projection;
      o && (o.promote(), (t = a?.group) == null || t.add(o)), globalProjectionState.hasEverUpdated = !0;
    }
    this.didUpdate();
  }
  beforeUnmount() {
    const t = this.state.visualElement.projection;
    t && (this.state.willUpdate("beforeUnmount"), this.state.options.layoutId ? (t.isPresent = !1, t.relegate()) : this.state.options.layout && (this.state.isSafeToRemove = !0));
  }
  unmount() {
    const t = this.state.options.layoutGroup, n = this.state.visualElement.projection;
    n && (t?.group && (this.state.options.layout || this.state.options.layoutId) && t.group.remove(n), this.didUpdate());
  }
}
function asyncHandler(e) {
  return (t, n) => {
    e && frame.postRender(() => e(t, n));
  };
}
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop;
  }
  onPointerDown(t) {
    this.session = new PanSession(
      t,
      this.createPanHandlers(),
      {
        transformPagePoint: this.state.visualElement.getTransformPagePoint(),
        contextWindow: getContextWindow(this.state.visualElement)
      }
    );
  }
  createPanHandlers() {
    return {
      onSessionStart: asyncHandler((t, n) => {
        const { onPanSessionStart: a } = this.state.options;
        a && a(t, n);
      }),
      onStart: asyncHandler((t, n) => {
        const { onPanStart: a } = this.state.options;
        a && a(t, n);
      }),
      onMove: (t, n) => {
        const { onPan: a } = this.state.options;
        a && a(t, n);
      },
      onEnd: (t, n) => {
        const { onPanEnd: a } = this.state.options;
        delete this.session, a && frame.postRender(() => a(t, n));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(
      this.state.element,
      "pointerdown",
      this.onPointerDown.bind(this)
    );
  }
  update() {
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const domMax = [
  AnimationFeature,
  PressGesture,
  HoverGesture,
  InViewGesture,
  FocusGesture,
  ProjectionFeature,
  PanGesture,
  DragGesture,
  LayoutFeature
], defaultConfig = {
  reducedMotion: "never",
  transition: void 0,
  nonce: void 0
}, [injectMotionConfig, provideMotionConfig] = createContext("MotionConfig");
function useMotionConfig() {
  return injectMotionConfig(computed(() => defaultConfig));
}
function getMotionElement(e) {
  return e?.nodeType === 3 || e?.nodeType === 8 ? getMotionElement(e.nextSibling) : e;
}
const [useLazyMotionContext, lazyMotionContextProvider] = createContext("LazyMotionContext");
function useMotionState(e) {
  var t;
  const n = injectMotion(null), a = injectLayoutGroup({}), o = useMotionConfig(), s = injectAnimatePresence({}), u = useLazyMotionContext({
    features: ref([]),
    strict: !1
  });
  if (process.env.NODE_ENV !== "production" && ((t = e.features) != null && t.length) && u.strict) {
    const k = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    e.ignoreStrict ? warning$1(!1, k) : invariant$1(!1, k);
  }
  const d = useAttrs();
  function f() {
    return a.id && e.layoutId ? `${a.id}-${e.layoutId}` : e.layoutId || void 0;
  }
  function g() {
    return {
      ...e,
      lazyMotionContext: u,
      layoutId: f(),
      transition: e.transition ?? o.value.transition,
      layoutGroup: a,
      motionConfig: o.value,
      inViewOptions: e.inViewOptions ?? o.value.inViewOptions,
      animatePresenceContext: s,
      initial: s.initial === !1 ? s.initial : e.initial === !0 ? void 0 : e.initial
    };
  }
  function v() {
    return {
      ...d,
      ...g()
    };
  }
  const b = new MotionState(
    v(),
    n
  );
  provideMotion(b);
  function w() {
    var k;
    const E = b.type === "svg", A = { ...d };
    Object.keys(d).forEach((B) => {
      isMotionValue(d[B]) && (A[B] = d[B].get());
    });
    let P = {
      ...e.style,
      ...E ? {} : ((k = b.visualElement) == null ? void 0 : k.latestValues) || b.baseTarget
    };
    if (E) {
      const { attrs: B, style: _ } = convertSvgStyleToAttributes({
        ...b.isMounted() ? b.target : b.baseTarget,
        ...P
      });
      (_.transform || B.transformOrigin) && (_.transformOrigin = B.transformOrigin ?? "50% 50%", delete B.transformOrigin), _.transform && (_.transformBox = _.transformBox ?? "fill-box", delete B.transformBox), Object.assign(A, B), P = _;
    }
    e.drag && e.dragListener !== !1 && Object.assign(P, {
      userSelect: "none",
      WebkitUserSelect: "none",
      WebkitTouchCallout: "none",
      touchAction: e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`
    });
    const M = createStyles(P);
    return M && (A.style = M), A;
  }
  const C = getCurrentInstance().proxy;
  return onBeforeMount(() => {
    b.beforeMount();
  }), onMounted(() => {
    b.mount(getMotionElement(C.$el), v(), checkMotionIsHidden(C));
  }), onBeforeUnmount(() => b.beforeUnmount()), onUnmounted(() => {
    const k = getMotionElement(C.$el);
    k?.isConnected || b.unmount();
  }), onBeforeUpdate(() => {
    b.beforeUpdate();
  }), onUpdated(() => {
    b.update(v());
  }), {
    getProps: g,
    getAttrs: w,
    layoutGroup: a,
    state: b
  };
}
const MotionComponentProps = {
  ignoreStrict: { type: Boolean },
  forwardMotionProps: { type: Boolean, default: !1 },
  asChild: { type: Boolean, default: !1 },
  hover: { type: [String, Array, Object] },
  press: { type: [String, Array, Object] },
  inView: { type: [String, Array, Object] },
  focus: { type: [String, Array, Object] },
  whileDrag: { type: [String, Array, Object] },
  whileHover: { type: [String, Array, Object], default: ({ hover: e }) => (process.env.NODE_ENV === "development" && e && warning$1(!0, "hover is deprecated. Use whileHover instead."), e) },
  whilePress: { type: [String, Array, Object], default: ({ press: e }) => (process.env.NODE_ENV === "development" && e && warning$1(!0, "press is deprecated. Use whilePress instead."), e) },
  whileInView: { type: [String, Array, Object], default: ({ inView: e }) => (process.env.NODE_ENV === "development" && e && warning$1(!0, "inView is deprecated. Use whileInView instead."), e) },
  whileFocus: { type: [String, Array, Object], default: ({ focus: e }) => (process.env.NODE_ENV === "development" && e && warning$1(!0, "focus is deprecated. Use whileFocus instead."), e) },
  custom: { type: [String, Number, Object, Array] },
  initial: { type: [String, Array, Object, Boolean], default: void 0 },
  animate: { type: [String, Array, Object], default: void 0 },
  exit: { type: [String, Array, Object] },
  variants: { type: Object },
  inherit: { type: Boolean },
  style: { type: Object },
  transformTemplate: { type: Function },
  transition: { type: Object },
  layoutGroup: { type: Object },
  motionConfig: { type: Object },
  onAnimationComplete: { type: Function },
  onUpdate: { type: Function },
  layout: { type: [Boolean, String], default: !1 },
  layoutId: { type: String, default: void 0 },
  layoutScroll: { type: Boolean, default: !1 },
  layoutRoot: { type: Boolean, default: !1 },
  "data-framer-portal-id": { type: String },
  crossfade: { type: Boolean, default: !0 },
  layoutDependency: { type: [String, Number, Object, Array] },
  onBeforeLayoutMeasure: { type: Function },
  onLayoutMeasure: { type: Function },
  onLayoutAnimationStart: { type: Function },
  onLayoutAnimationComplete: { type: Function },
  globalPressTarget: { type: Boolean },
  onPressStart: { type: Function },
  onPress: { type: Function },
  onPressCancel: { type: Function },
  onHoverStart: { type: Function },
  onHoverEnd: { type: Function },
  inViewOptions: { type: Object },
  onViewportEnter: { type: Function },
  onViewportLeave: { type: Function },
  drag: { type: [Boolean, String] },
  dragSnapToOrigin: { type: Boolean },
  dragDirectionLock: { type: Boolean },
  dragPropagation: { type: Boolean },
  dragConstraints: { type: [Boolean, Object] },
  dragElastic: { type: [Boolean, Number, Object], default: 0.5 },
  dragMomentum: { type: Boolean, default: !0 },
  dragTransition: { type: Object },
  dragListener: { type: Boolean, default: !0 },
  dragControls: { type: Object },
  onDragStart: { type: Function },
  onDragEnd: { type: Function },
  onDrag: { type: Function },
  onDirectionLock: { type: Function },
  onDragTransitionEnd: { type: Function },
  onMeasureDragConstraints: { type: Function },
  onPanSessionStart: { type: Function },
  onPanStart: { type: Function },
  onPan: { type: Function },
  onPanEnd: { type: Function }
};
function checkMotionIsHidden(e) {
  var t;
  const n = ((t = getMotionElement(e.$el)) == null ? void 0 : t.style.display) === "none";
  return e.$.vnode.transition && n;
}
const componentMaxCache = /* @__PURE__ */ new Map(), componentMiniCache = /* @__PURE__ */ new Map();
function renderSlotFragments(e) {
  if (!Array.isArray(e))
    return [e];
  const t = [];
  for (const n of e)
    Array.isArray(n) ? t.push(...n) : t.push(n);
  return t;
}
const SELF_CLOSING_TAGS = ["area", "img", "input"];
function handlePrimitiveAndSlot(e, t, n) {
  var a, o;
  if (typeof e == "string" && SELF_CLOSING_TAGS.includes(e))
    return h(e, t);
  if (e === "template") {
    if (!n.default)
      return null;
    const s = renderSlotFragments(n.default()), u = s.findIndex((v) => v.type !== Comment);
    if (u === -1)
      return s;
    const d = s[u];
    (a = d.props) == null || delete a.ref;
    const f = d.props ? mergeProps(t, d.props) : t;
    t.class && ((o = d.props) != null && o.class) && delete d.props.class;
    const g = cloneVNode(d, f);
    for (const v in f)
      v.startsWith("on") && (g.props || (g.props = {}), g.props[v] = f[v]);
    return s.length === 1 ? g : (s[u] = g, s);
  }
  return null;
}
function createMotionComponent(e, t = {}) {
  var n;
  const a = typeof e == "string", o = a ? e : e.name || "", s = ((n = t.features) == null ? void 0 : n.length) > 0 ? componentMaxCache : componentMiniCache;
  if (a && s?.has(e))
    return s.get(e);
  const u = defineComponent({
    inheritAttrs: !1,
    props: {
      ...MotionComponentProps,
      features: {
        type: Object,
        default: () => t.features || []
      },
      as: { type: [String, Object], default: e || "div" }
    },
    name: o ? `motion.${o}` : "Motion",
    setup(d, { slots: f }) {
      const { getProps: g, getAttrs: v, state: b } = useMotionState(d);
      function w() {
        const C = b.element;
        if ((!(typeof d.as == "object") || d.asChild) && C) {
          const { style: E } = v();
          if (E)
            for (const [A, P] of Object.entries(E))
              C.style[A] = P;
        }
      }
      return () => {
        const C = g(), k = v(), E = d.asChild ? "template" : d.as, A = {
          ...t.forwardMotionProps || d.forwardMotionProps ? C : {},
          ...k,
          onVnodeUpdated: w
        }, P = handlePrimitiveAndSlot(E, A, f);
        return P !== null ? P : h(E, {
          ...A
        }, f);
      };
    }
  });
  return a && s?.set(e, u), u;
}
function createMotionComponentWithFeatures(e = []) {
  return new Proxy({}, {
    get(t, n) {
      return n === "create" ? (a, o) => createMotionComponent(a, {
        ...o,
        features: e
      }) : createMotionComponent(n, {
        features: e
      });
    }
  });
}
const motion = createMotionComponentWithFeatures(domMax), Motion = motion.create("div");
var freeGlobal = typeof global == "object" && global && global.Object === Object && global, freeSelf = typeof self == "object" && self && self.Object === Object && self, root = freeGlobal || freeSelf || Function("return this")(), Symbol$1 = root.Symbol, objectProto$b = Object.prototype, hasOwnProperty$8 = objectProto$b.hasOwnProperty, nativeObjectToString$1 = objectProto$b.toString, symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(e) {
  var t = hasOwnProperty$8.call(e, symToStringTag$1), n = e[symToStringTag$1];
  try {
    e[symToStringTag$1] = void 0;
    var a = !0;
  } catch {
  }
  var o = nativeObjectToString$1.call(e);
  return a && (t ? e[symToStringTag$1] = n : delete e[symToStringTag$1]), o;
}
var objectProto$a = Object.prototype, nativeObjectToString = objectProto$a.toString;
function objectToString(e) {
  return nativeObjectToString.call(e);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]", symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(e) {
  return e == null ? e === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(e) ? getRawTag(e) : objectToString(e);
}
function isObjectLike(e) {
  return e != null && typeof e == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(e) {
  return typeof e == "symbol" || isObjectLike(e) && baseGetTag(e) == symbolTag$1;
}
function arrayMap(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length, o = Array(a); ++n < a; )
    o[n] = t(e[n], n, e);
  return o;
}
var isArray = Array.isArray, symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(e) {
  if (typeof e == "string")
    return e;
  if (isArray(e))
    return arrayMap(e, baseToString) + "";
  if (isSymbol(e))
    return symbolToString ? symbolToString.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
var reWhitespace = /\s/;
function trimmedEndIndex(e) {
  for (var t = e.length; t-- && reWhitespace.test(e.charAt(t)); )
    ;
  return t;
}
var reTrimStart = /^\s+/;
function baseTrim(e) {
  return e && e.slice(0, trimmedEndIndex(e) + 1).replace(reTrimStart, "");
}
function isObject(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var NAN = NaN, reIsBadHex = /^[-+]0x[0-9a-f]+$/i, reIsBinary = /^0b[01]+$/i, reIsOctal = /^0o[0-7]+$/i, freeParseInt = parseInt;
function toNumber(e) {
  if (typeof e == "number")
    return e;
  if (isSymbol(e))
    return NAN;
  if (isObject(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = isObject(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = baseTrim(e);
  var n = reIsBinary.test(e);
  return n || reIsOctal.test(e) ? freeParseInt(e.slice(2), n ? 2 : 8) : reIsBadHex.test(e) ? NAN : +e;
}
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = toNumber(e), e === INFINITY || e === -INFINITY) {
    var t = e < 0 ? -1 : 1;
    return t * MAX_INTEGER;
  }
  return e === e ? e : 0;
}
function identity(e) {
  return e;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(e) {
  if (!isObject(e))
    return !1;
  var t = baseGetTag(e);
  return t == funcTag$1 || t == genTag || t == asyncTag || t == proxyTag;
}
var coreJsData = root["__core-js_shared__"], maskSrcKey = (function() {
  var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
})();
function isMasked(e) {
  return !!maskSrcKey && maskSrcKey in e;
}
var funcProto$1 = Function.prototype, funcToString$1 = funcProto$1.toString;
function toSource(e) {
  if (e != null) {
    try {
      return funcToString$1.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reIsHostCtor = /^\[object .+?Constructor\]$/, funcProto = Function.prototype, objectProto$9 = Object.prototype, funcToString = funcProto.toString, hasOwnProperty$7 = objectProto$9.hasOwnProperty, reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(e) {
  if (!isObject(e) || isMasked(e))
    return !1;
  var t = isFunction(e) ? reIsNative : reIsHostCtor;
  return t.test(toSource(e));
}
function getValue(e, t) {
  return e?.[t];
}
function getNative(e, t) {
  var n = getValue(e, t);
  return baseIsNative(n) ? n : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
function apply(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
var HOT_COUNT = 800, HOT_SPAN = 16, nativeNow = Date.now;
function shortOut(e) {
  var t = 0, n = 0;
  return function() {
    var a = nativeNow(), o = HOT_SPAN - (a - n);
    if (n = a, o > 0) {
      if (++t >= HOT_COUNT)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function constant(e) {
  return function() {
    return e;
  };
}
var defineProperty = (function() {
  try {
    var e = getNative(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
})(), baseSetToString = defineProperty ? function(e, t) {
  return defineProperty(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: constant(t),
    writable: !0
  });
} : identity, setToString = shortOut(baseSetToString);
function baseFindIndex(e, t, n, a) {
  for (var o = e.length, s = n + -1; ++s < o; )
    if (t(e[s], s, e))
      return s;
  return -1;
}
function baseIsNaN(e) {
  return e !== e;
}
function strictIndexOf(e, t, n) {
  for (var a = n - 1, o = e.length; ++a < o; )
    if (e[a] === t)
      return a;
  return -1;
}
function baseIndexOf(e, t, n) {
  return t === t ? strictIndexOf(e, t, n) : baseFindIndex(e, baseIsNaN, n);
}
function arrayIncludes(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && baseIndexOf(e, t, 0) > -1;
}
var MAX_SAFE_INTEGER$1 = 9007199254740991, reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(e, t) {
  var n = typeof e;
  return t = t ?? MAX_SAFE_INTEGER$1, !!t && (n == "number" || n != "symbol" && reIsUint.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
function baseAssignValue(e, t, n) {
  t == "__proto__" && defineProperty ? defineProperty(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
function eq(e, t) {
  return e === t || e !== e && t !== t;
}
var nativeMax$1 = Math.max;
function overRest(e, t, n) {
  return t = nativeMax$1(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var a = arguments, o = -1, s = nativeMax$1(a.length - t, 0), u = Array(s); ++o < s; )
      u[o] = a[t + o];
    o = -1;
    for (var d = Array(t + 1); ++o < t; )
      d[o] = a[o];
    return d[t] = n(u), apply(e, this, d);
  };
}
function baseRest(e, t) {
  return setToString(overRest(e, t, identity), e + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= MAX_SAFE_INTEGER;
}
function isArrayLike(e) {
  return e != null && isLength(e.length) && !isFunction(e);
}
function isIterateeCall(e, t, n) {
  if (!isObject(n))
    return !1;
  var a = typeof t;
  return (a == "number" ? isArrayLike(n) && isIndex(t, n.length) : a == "string" && t in n) ? eq(n[t], e) : !1;
}
var objectProto$8 = Object.prototype;
function isPrototype(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || objectProto$8;
  return e === n;
}
function baseTimes(e, t) {
  for (var n = -1, a = Array(e); ++n < e; )
    a[n] = t(n);
  return a;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(e) {
  return isObjectLike(e) && baseGetTag(e) == argsTag$2;
}
var objectProto$7 = Object.prototype, hasOwnProperty$6 = objectProto$7.hasOwnProperty, propertyIsEnumerable$1 = objectProto$7.propertyIsEnumerable, isArguments = baseIsArguments(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments : function(e) {
  return isObjectLike(e) && hasOwnProperty$6.call(e, "callee") && !propertyIsEnumerable$1.call(e, "callee");
};
function stubFalse() {
  return !1;
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module, moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1, Buffer$1 = moduleExports$1 ? root.Buffer : void 0, nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0, isBuffer = nativeIsBuffer || stubFalse, argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$2 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]", arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]", typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = !1;
function baseIsTypedArray(e) {
  return isObjectLike(e) && isLength(e.length) && !!typedArrayTags[baseGetTag(e)];
}
function baseUnary(e) {
  return function(t) {
    return e(t);
  };
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports, freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module, moduleExports = freeModule && freeModule.exports === freeExports, freeProcess = moduleExports && freeGlobal.process, nodeUtil = (function() {
  try {
    var e = freeModule && freeModule.require && freeModule.require("util").types;
    return e || freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch {
  }
})(), nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray, isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray, objectProto$6 = Object.prototype, hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys(e, t) {
  var n = isArray(e), a = !n && isArguments(e), o = !n && !a && isBuffer(e), s = !n && !a && !o && isTypedArray(e), u = n || a || o || s, d = u ? baseTimes(e.length, String) : [], f = d.length;
  for (var g in e)
    hasOwnProperty$5.call(e, g) && !(u && // Safari 9 has enumerable `arguments.length` in strict mode.
    (g == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    o && (g == "offset" || g == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    s && (g == "buffer" || g == "byteLength" || g == "byteOffset") || // Skip index properties.
    isIndex(g, f))) && d.push(g);
  return d;
}
function overArg(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var nativeKeys = overArg(Object.keys, Object), objectProto$5 = Object.prototype, hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function baseKeys(e) {
  if (!isPrototype(e))
    return nativeKeys(e);
  var t = [];
  for (var n in Object(e))
    hasOwnProperty$4.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function keys(e) {
  return isArrayLike(e) ? arrayLikeKeys(e) : baseKeys(e);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(e, t) {
  if (isArray(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || isSymbol(e) ? !0 : reIsPlainProp.test(e) || !reIsDeepProp.test(e) || t != null && e in Object(t);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0;
}
function hashDelete(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__", objectProto$4 = Object.prototype, hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashGet(e) {
  var t = this.__data__;
  if (nativeCreate) {
    var n = t[e];
    return n === HASH_UNDEFINED$2 ? void 0 : n;
  }
  return hasOwnProperty$3.call(t, e) ? t[e] : void 0;
}
var objectProto$3 = Object.prototype, hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashHas(e) {
  var t = this.__data__;
  return nativeCreate ? t[e] !== void 0 : hasOwnProperty$2.call(t, e);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = nativeCreate && t === void 0 ? HASH_UNDEFINED$1 : t, this;
}
function Hash(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [], this.size = 0;
}
function assocIndexOf(e, t) {
  for (var n = e.length; n--; )
    if (eq(e[n][0], t))
      return n;
  return -1;
}
var arrayProto = Array.prototype, splice = arrayProto.splice;
function listCacheDelete(e) {
  var t = this.__data__, n = assocIndexOf(t, e);
  if (n < 0)
    return !1;
  var a = t.length - 1;
  return n == a ? t.pop() : splice.call(t, n, 1), --this.size, !0;
}
function listCacheGet(e) {
  var t = this.__data__, n = assocIndexOf(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function listCacheHas(e) {
  return assocIndexOf(this.__data__, e) > -1;
}
function listCacheSet(e, t) {
  var n = this.__data__, a = assocIndexOf(n, e);
  return a < 0 ? (++this.size, n.push([e, t])) : n[a][1] = t, this;
}
function ListCache(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0, this.__data__ = {
    hash: new Hash(),
    map: new (Map$1 || ListCache)(),
    string: new Hash()
  };
}
function isKeyable(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function getMapData(e, t) {
  var n = e.__data__;
  return isKeyable(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function mapCacheDelete(e) {
  var t = getMapData(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function mapCacheGet(e) {
  return getMapData(this, e).get(e);
}
function mapCacheHas(e) {
  return getMapData(this, e).has(e);
}
function mapCacheSet(e, t) {
  var n = getMapData(this, e), a = n.size;
  return n.set(e, t), this.size += n.size == a ? 0 : 1, this;
}
function MapCache(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var a = e[t];
    this.set(a[0], a[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(FUNC_ERROR_TEXT);
  var n = function() {
    var a = arguments, o = t ? t.apply(this, a) : a[0], s = n.cache;
    if (s.has(o))
      return s.get(o);
    var u = e.apply(this, a);
    return n.cache = s.set(o, u) || s, u;
  };
  return n.cache = new (memoize.Cache || MapCache)(), n;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(e) {
  var t = memoize(e, function(a) {
    return n.size === MAX_MEMOIZE_SIZE && n.clear(), a;
  }), n = t.cache;
  return t;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = memoizeCapped(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(rePropName, function(n, a, o, s) {
    t.push(o ? s.replace(reEscapeChar, "$1") : a || n);
  }), t;
});
function toString(e) {
  return e == null ? "" : baseToString(e);
}
function castPath(e, t) {
  return isArray(e) ? e : isKey(e, t) ? [e] : stringToPath(toString(e));
}
function toKey(e) {
  if (typeof e == "string" || isSymbol(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -1 / 0 ? "-0" : t;
}
function baseGet(e, t) {
  t = castPath(t, e);
  for (var n = 0, a = t.length; e != null && n < a; )
    e = e[toKey(t[n++])];
  return n && n == a ? e : void 0;
}
function get(e, t, n) {
  var a = e == null ? void 0 : baseGet(e, t);
  return a === void 0 ? n : a;
}
function arrayPush(e, t) {
  for (var n = -1, a = t.length, o = e.length; ++n < a; )
    e[o + n] = t[n];
  return e;
}
var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : void 0;
function isFlattenable(e) {
  return isArray(e) || isArguments(e) || !!(spreadableSymbol && e && e[spreadableSymbol]);
}
function baseFlatten(e, t, n, a, o) {
  var s = -1, u = e.length;
  for (n || (n = isFlattenable), o || (o = []); ++s < u; ) {
    var d = e[s];
    n(d) ? arrayPush(o, d) : o[o.length] = d;
  }
  return o;
}
function flatten(e) {
  var t = e == null ? 0 : e.length;
  return t ? baseFlatten(e) : [];
}
function stackClear() {
  this.__data__ = new ListCache(), this.size = 0;
}
function stackDelete(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function stackGet(e) {
  return this.__data__.get(e);
}
function stackHas(e) {
  return this.__data__.has(e);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(e, t) {
  var n = this.__data__;
  if (n instanceof ListCache) {
    var a = n.__data__;
    if (!Map$1 || a.length < LARGE_ARRAY_SIZE - 1)
      return a.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new MapCache(a);
  }
  return n.set(e, t), this.size = n.size, this;
}
function Stack(e) {
  var t = this.__data__ = new ListCache(e);
  this.size = t.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayFilter(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length, o = 0, s = []; ++n < a; ) {
    var u = e[n];
    t(u, n, e) && (s[o++] = u);
  }
  return s;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype, propertyIsEnumerable = objectProto$2.propertyIsEnumerable, nativeGetSymbols = Object.getOwnPropertySymbols, getSymbols = nativeGetSymbols ? function(e) {
  return e == null ? [] : (e = Object(e), arrayFilter(nativeGetSymbols(e), function(t) {
    return propertyIsEnumerable.call(e, t);
  }));
} : stubArray;
function baseGetAllKeys(e, t, n) {
  var a = t(e);
  return isArray(e) ? a : arrayPush(a, n(e));
}
function getAllKeys(e) {
  return baseGetAllKeys(e, keys, getSymbols);
}
var DataView = getNative(root, "DataView"), Promise$1 = getNative(root, "Promise"), Set$1 = getNative(root, "Set"), mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]", dataViewTag$1 = "[object DataView]", dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1), getTag = baseGetTag;
(DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) && (getTag = function(e) {
  var t = baseGetTag(e), n = t == objectTag$1 ? e.constructor : void 0, a = n ? toSource(n) : "";
  if (a)
    switch (a) {
      case dataViewCtorString:
        return dataViewTag$1;
      case mapCtorString:
        return mapTag$1;
      case promiseCtorString:
        return promiseTag;
      case setCtorString:
        return setTag$1;
      case weakMapCtorString:
        return weakMapTag;
    }
  return t;
});
var Uint8Array$1 = root.Uint8Array, HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(e) {
  return this.__data__.set(e, HASH_UNDEFINED), this;
}
function setCacheHas(e) {
  return this.__data__.has(e);
}
function SetCache(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new MapCache(); ++t < n; )
    this.add(e[t]);
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(e, t) {
  for (var n = -1, a = e == null ? 0 : e.length; ++n < a; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function cacheHas(e, t) {
  return e.has(t);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(e, t, n, a, o, s) {
  var u = n & COMPARE_PARTIAL_FLAG$5, d = e.length, f = t.length;
  if (d != f && !(u && f > d))
    return !1;
  var g = s.get(e), v = s.get(t);
  if (g && v)
    return g == t && v == e;
  var b = -1, w = !0, C = n & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  for (s.set(e, t), s.set(t, e); ++b < d; ) {
    var k = e[b], E = t[b];
    if (a)
      var A = u ? a(E, k, b, t, e, s) : a(k, E, b, e, t, s);
    if (A !== void 0) {
      if (A)
        continue;
      w = !1;
      break;
    }
    if (C) {
      if (!arraySome(t, function(P, M) {
        if (!cacheHas(C, M) && (k === P || o(k, P, n, a, s)))
          return C.push(M);
      })) {
        w = !1;
        break;
      }
    } else if (!(k === E || o(k, E, n, a, s))) {
      w = !1;
      break;
    }
  }
  return s.delete(e), s.delete(t), w;
}
function mapToArray(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(a, o) {
    n[++t] = [o, a];
  }), n;
}
function setToArray(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(a) {
    n[++t] = a;
  }), n;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2, boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(e, t, n, a, o, s, u) {
  switch (n) {
    case dataViewTag:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case arrayBufferTag:
      return !(e.byteLength != t.byteLength || !s(new Uint8Array$1(e), new Uint8Array$1(t)));
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+e, +t);
    case errorTag:
      return e.name == t.name && e.message == t.message;
    case regexpTag:
    case stringTag:
      return e == t + "";
    case mapTag:
      var d = mapToArray;
    case setTag:
      var f = a & COMPARE_PARTIAL_FLAG$4;
      if (d || (d = setToArray), e.size != t.size && !f)
        return !1;
      var g = u.get(e);
      if (g)
        return g == t;
      a |= COMPARE_UNORDERED_FLAG$2, u.set(e, t);
      var v = equalArrays(d(e), d(t), a, o, s, u);
      return u.delete(e), v;
    case symbolTag:
      if (symbolValueOf)
        return symbolValueOf.call(e) == symbolValueOf.call(t);
  }
  return !1;
}
var COMPARE_PARTIAL_FLAG$3 = 1, objectProto$1 = Object.prototype, hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(e, t, n, a, o, s) {
  var u = n & COMPARE_PARTIAL_FLAG$3, d = getAllKeys(e), f = d.length, g = getAllKeys(t), v = g.length;
  if (f != v && !u)
    return !1;
  for (var b = f; b--; ) {
    var w = d[b];
    if (!(u ? w in t : hasOwnProperty$1.call(t, w)))
      return !1;
  }
  var C = s.get(e), k = s.get(t);
  if (C && k)
    return C == t && k == e;
  var E = !0;
  s.set(e, t), s.set(t, e);
  for (var A = u; ++b < f; ) {
    w = d[b];
    var P = e[w], M = t[w];
    if (a)
      var B = u ? a(M, P, w, t, e, s) : a(P, M, w, e, t, s);
    if (!(B === void 0 ? P === M || o(P, M, n, a, s) : B)) {
      E = !1;
      break;
    }
    A || (A = w == "constructor");
  }
  if (E && !A) {
    var _ = e.constructor, T = t.constructor;
    _ != T && "constructor" in e && "constructor" in t && !(typeof _ == "function" && _ instanceof _ && typeof T == "function" && T instanceof T) && (E = !1);
  }
  return s.delete(e), s.delete(t), E;
}
var COMPARE_PARTIAL_FLAG$2 = 1, argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]", objectProto = Object.prototype, hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(e, t, n, a, o, s) {
  var u = isArray(e), d = isArray(t), f = u ? arrayTag : getTag(e), g = d ? arrayTag : getTag(t);
  f = f == argsTag ? objectTag : f, g = g == argsTag ? objectTag : g;
  var v = f == objectTag, b = g == objectTag, w = f == g;
  if (w && isBuffer(e)) {
    if (!isBuffer(t))
      return !1;
    u = !0, v = !1;
  }
  if (w && !v)
    return s || (s = new Stack()), u || isTypedArray(e) ? equalArrays(e, t, n, a, o, s) : equalByTag(e, t, f, n, a, o, s);
  if (!(n & COMPARE_PARTIAL_FLAG$2)) {
    var C = v && hasOwnProperty.call(e, "__wrapped__"), k = b && hasOwnProperty.call(t, "__wrapped__");
    if (C || k) {
      var E = C ? e.value() : e, A = k ? t.value() : t;
      return s || (s = new Stack()), o(E, A, n, a, s);
    }
  }
  return w ? (s || (s = new Stack()), equalObjects(e, t, n, a, o, s)) : !1;
}
function baseIsEqual(e, t, n, a, o) {
  return e === t ? !0 : e == null || t == null || !isObjectLike(e) && !isObjectLike(t) ? e !== e && t !== t : baseIsEqualDeep(e, t, n, a, baseIsEqual, o);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(e, t, n, a) {
  var o = n.length, s = o;
  if (e == null)
    return !s;
  for (e = Object(e); o--; ) {
    var u = n[o];
    if (u[2] ? u[1] !== e[u[0]] : !(u[0] in e))
      return !1;
  }
  for (; ++o < s; ) {
    u = n[o];
    var d = u[0], f = e[d], g = u[1];
    if (u[2]) {
      if (f === void 0 && !(d in e))
        return !1;
    } else {
      var v = new Stack(), b;
      if (!(b === void 0 ? baseIsEqual(g, f, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, a, v) : b))
        return !1;
    }
  }
  return !0;
}
function isStrictComparable(e) {
  return e === e && !isObject(e);
}
function getMatchData(e) {
  for (var t = keys(e), n = t.length; n--; ) {
    var a = t[n], o = e[a];
    t[n] = [a, o, isStrictComparable(o)];
  }
  return t;
}
function matchesStrictComparable(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function baseMatches(e) {
  var t = getMatchData(e);
  return t.length == 1 && t[0][2] ? matchesStrictComparable(t[0][0], t[0][1]) : function(n) {
    return n === e || baseIsMatch(n, e, t);
  };
}
function baseHasIn(e, t) {
  return e != null && t in Object(e);
}
function hasPath(e, t, n) {
  t = castPath(t, e);
  for (var a = -1, o = t.length, s = !1; ++a < o; ) {
    var u = toKey(t[a]);
    if (!(s = e != null && n(e, u)))
      break;
    e = e[u];
  }
  return s || ++a != o ? s : (o = e == null ? 0 : e.length, !!o && isLength(o) && isIndex(u, o) && (isArray(e) || isArguments(e)));
}
function hasIn(e, t) {
  return e != null && hasPath(e, t, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(e, t) {
  return isKey(e) && isStrictComparable(t) ? matchesStrictComparable(toKey(e), t) : function(n) {
    var a = get(n, e);
    return a === void 0 && a === t ? hasIn(n, e) : baseIsEqual(t, a, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(e) {
  return function(t) {
    return t?.[e];
  };
}
function basePropertyDeep(e) {
  return function(t) {
    return baseGet(t, e);
  };
}
function property(e) {
  return isKey(e) ? baseProperty(toKey(e)) : basePropertyDeep(e);
}
function baseIteratee(e) {
  return typeof e == "function" ? e : e == null ? identity : typeof e == "object" ? isArray(e) ? baseMatchesProperty(e[0], e[1]) : baseMatches(e) : property(e);
}
function arrayAggregator(e, t, n, a) {
  for (var o = -1, s = e == null ? 0 : e.length; ++o < s; ) {
    var u = e[o];
    t(a, u, n(u), e);
  }
  return a;
}
function createBaseFor(e) {
  return function(t, n, a) {
    for (var o = -1, s = Object(t), u = a(t), d = u.length; d--; ) {
      var f = u[++o];
      if (n(s[f], f, s) === !1)
        break;
    }
    return t;
  };
}
var baseFor = createBaseFor();
function baseForOwn(e, t) {
  return e && baseFor(e, t, keys);
}
function createBaseEach(e, t) {
  return function(n, a) {
    if (n == null)
      return n;
    if (!isArrayLike(n))
      return e(n, a);
    for (var o = n.length, s = -1, u = Object(n); ++s < o && a(u[s], s, u) !== !1; )
      ;
    return n;
  };
}
var baseEach = createBaseEach(baseForOwn);
function baseAggregator(e, t, n, a) {
  return baseEach(e, function(o, s, u) {
    t(a, o, n(o), u);
  }), a;
}
function createAggregator(e, t) {
  return function(n, a) {
    var o = isArray(n) ? arrayAggregator : baseAggregator, s = {};
    return o(n, e, baseIteratee(a), s);
  };
}
function isArrayLikeObject(e) {
  return isObjectLike(e) && isArrayLike(e);
}
function baseMap(e, t) {
  var n = -1, a = isArrayLike(e) ? Array(e.length) : [];
  return baseEach(e, function(o, s, u) {
    a[++n] = t(o, s, u);
  }), a;
}
var nativeMin = Math.min;
function baseIntersection(e, t, n) {
  for (var a = arrayIncludes, o = e[0].length, s = e.length, u = s, d = Array(s), f = 1 / 0, g = []; u--; ) {
    var v = e[u];
    f = nativeMin(v.length, f), d[u] = o >= 120 && v.length >= 120 ? new SetCache(u && v) : void 0;
  }
  v = e[0];
  var b = -1, w = d[0];
  e:
    for (; ++b < o && g.length < f; ) {
      var C = v[b], k = C;
      if (C = C !== 0 ? C : 0, !(w ? cacheHas(w, k) : a(g, k))) {
        for (u = s; --u; ) {
          var E = d[u];
          if (!(E ? cacheHas(E, k) : a(e[u], k)))
            continue e;
        }
        w && w.push(k), g.push(C);
      }
    }
  return g;
}
function castArrayLikeObject(e) {
  return isArrayLikeObject(e) ? e : [];
}
var intersection = baseRest(function(e) {
  var t = arrayMap(e, castArrayLikeObject);
  return t.length && t[0] === e[0] ? baseIntersection(t) : [];
}), keyBy = createAggregator(function(e, t, n) {
  baseAssignValue(e, n, t);
});
function mapValues(e, t) {
  var n = {};
  return t = baseIteratee(t), baseForOwn(e, function(a, o, s) {
    baseAssignValue(n, o, t(a, o, s));
  }), n;
}
function baseSortBy(e, t) {
  var n = e.length;
  for (e.sort(t); n--; )
    e[n] = e[n].value;
  return e;
}
function compareAscending(e, t) {
  if (e !== t) {
    var n = e !== void 0, a = e === null, o = e === e, s = isSymbol(e), u = t !== void 0, d = t === null, f = t === t, g = isSymbol(t);
    if (!d && !g && !s && e > t || s && u && f && !d && !g || a && u && f || !n && f || !o)
      return 1;
    if (!a && !s && !g && e < t || g && n && o && !a && !s || d && n && o || !u && o || !f)
      return -1;
  }
  return 0;
}
function compareMultiple(e, t, n) {
  for (var a = -1, o = e.criteria, s = t.criteria, u = o.length, d = n.length; ++a < u; ) {
    var f = compareAscending(o[a], s[a]);
    if (f) {
      if (a >= d)
        return f;
      var g = n[a];
      return f * (g == "desc" ? -1 : 1);
    }
  }
  return e.index - t.index;
}
function baseOrderBy(e, t, n) {
  t.length ? t = arrayMap(t, function(s) {
    return isArray(s) ? function(u) {
      return baseGet(u, s.length === 1 ? s[0] : s);
    } : s;
  }) : t = [identity];
  var a = -1;
  t = arrayMap(t, baseUnary(baseIteratee));
  var o = baseMap(e, function(s, u, d) {
    var f = arrayMap(t, function(g) {
      return g(s);
    });
    return { criteria: f, index: ++a, value: s };
  });
  return baseSortBy(o, function(s, u) {
    return compareMultiple(s, u, n);
  });
}
var nativeCeil = Math.ceil, nativeMax = Math.max;
function baseRange(e, t, n, a) {
  for (var o = -1, s = nativeMax(nativeCeil((t - e) / (n || 1)), 0), u = Array(s); s--; )
    u[++o] = e, e += n;
  return u;
}
function createRange(e) {
  return function(t, n, a) {
    return a && typeof a != "number" && isIterateeCall(t, n, a) && (n = a = void 0), t = toFinite(t), n === void 0 ? (n = t, t = 0) : n = toFinite(n), a = a === void 0 ? t < n ? 1 : -1 : toFinite(a), baseRange(t, n, a);
  };
}
var range = createRange(), sortBy = baseRest(function(e, t) {
  if (e == null)
    return [];
  var n = t.length;
  return n > 1 && isIterateeCall(e, t[0], t[1]) ? t = [] : n > 2 && isIterateeCall(t[0], t[1], t[2]) && (t = [t[0]]), baseOrderBy(e, baseFlatten(t), []);
});
function useActions() {
  function e(f, g) {
    let v = t(f);
    return n(v, g);
  }
  function t(f) {
    let g = sortBy(f, "title");
    return [
      ...g.filter((v) => !v.dangerous),
      ...g.filter((v) => v.dangerous)
    ];
  }
  function n(f, g) {
    return f?.map((v) => ({
      ...v,
      run: () => a(g, v.handle)?.confirm()
    }));
  }
  function a(f, g) {
    return keyBy(f, "handle")[g];
  }
  function o({ url: f, selections: g, action: v, values: b, onSuccess: w, onError: C }) {
    return new Promise((k, E) => {
      const A = {
        action: v.handle,
        context: v.context,
        selections: g,
        values: b
      };
      axios.post(f, A, { responseType: "blob" }).then((P) => {
        P.headers["content-disposition"] ? u(P, k) : s(P, k), w && w();
      }).catch((P) => {
        d(P.response, E), C && C();
      });
    });
  }
  function s(f, g) {
    f.data.text().then((v) => {
      v = JSON.parse(v), v.redirect && (v.bypassesDirtyWarning && Statamic.$dirty.disableWarning(), window.location = v.redirect), v.callback && Statamic.$callbacks.call(v.callback[0], ...v.callback.slice(1)), g(v);
    });
  }
  function u(f, g) {
    const v = f.headers["content-disposition"].match(/^attachment.+filename\*?=(?:UTF-8'')?"?([^"]+)"?/i) || [];
    if (!v.length) return;
    const b = v.length >= 2 ? v[1] : "file.txt", w = window.URL.createObjectURL(new Blob([f.data])), C = document.createElement("a");
    C.href = w, C.setAttribute("download", b), document.body.appendChild(C), C.click(), g();
  }
  function d(f, g) {
    f.data.text().then((v) => {
      g(JSON.parse(v));
    });
  }
  return {
    prepareActions: e,
    runServerAction: o
  };
}
async function requireElevatedSession() {
  const e = await axios.get(cp_url("elevated-session"));
  if (!e.data.elevated)
    return new Promise((t, n) => {
      const a = Statamic.$components.append("elevated-session-modal", {
        props: {
          method: e.data.method
        }
      });
      a.on("closed", (o) => {
        o ? t() : n(), a.destroy();
      });
    });
}
async function requireElevatedSessionIf(e) {
  return e ? requireElevatedSession() : Promise.resolve();
}
const _hoisted_1$G = ["textContent"], _hoisted_2$n = ["textContent"], _hoisted_3$c = ["textContent"], _sfc_main$17 = {
  __name: "ConfirmableAction",
  props: {
    action: { type: Object, required: !0 },
    selections: { type: Number, required: !0 },
    errors: { type: Object },
    isDirty: { type: Boolean, default: !1 }
  },
  emits: ["confirmed"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n;
    let s = ref(!1), u = ref(!1), d = ref({ tabs: [{ fields: a.action.fields }] }), f = ref(a.action.values), g = computed(() => {
      if (a.action.confirmationText)
        return __n(a.action.confirmationText, a.selections);
    }), v = computed(() => {
      if (a.action.warningText)
        return __n(a.action.warningText, a.selections);
    }), b = computed(() => {
      if (a.isDirty)
        return __(a.action.dirtyWarningText);
    }), w = computed(() => a.isDirty && a.action.dirtyWarningText && !a.action.bypassesDirtyWarning), C = computed(() => __n(a.action.buttonText, a.selections));
    function k() {
      u.value = !1, B();
    }
    function E() {
      u.value = !1;
    }
    function A() {
      if (a.action.confirm) {
        s.value = !0;
        return;
      }
      P();
    }
    function P() {
      M();
    }
    function M() {
      requireElevatedSessionIf(a.action.requiresElevatedSession).then(() => {
        u.value = !0, o("confirmed", a.action, f.value, k, E);
      });
    }
    function B() {
      s.value = !1, f.value = clone(a.action.values);
    }
    return t({
      handle: a.action.handle,
      confirm: A
    }), (_, T) => {
      const O = resolveComponent("confirmation-modal");
      return unref(s) ? (openBlock(), createBlock(O, {
        key: 0,
        title: e.action.title,
        danger: e.action.dangerous,
        buttonText: unref(C),
        busy: unref(u),
        onConfirm: P,
        onCancel: B
      }, {
        default: withCtx(() => [
          unref(g) ? (openBlock(), createElementBlock("div", {
            key: 0,
            textContent: toDisplayString(unref(g)),
            class: normalizeClass({ "mb-4": unref(v) || unref(w) || e.action.fields.length })
          }, null, 10, _hoisted_1$G)) : createCommentVNode("", !0),
          unref(v) ? (openBlock(), createElementBlock("div", {
            key: 1,
            textContent: toDisplayString(unref(v)),
            class: normalizeClass(["text-red-600", { "mb-4": unref(w) || e.action.fields.length }])
          }, null, 10, _hoisted_2$n)) : createCommentVNode("", !0),
          unref(w) ? (openBlock(), createElementBlock("div", {
            key: 2,
            textContent: toDisplayString(unref(b)),
            class: normalizeClass(["text-red-600", { "mb-4": e.action.fields.length }])
          }, null, 10, _hoisted_3$c)) : createCommentVNode("", !0),
          e.action.fields.length ? (openBlock(), createBlock(unref(_sfc_main$G), {
            key: 3,
            name: "confirm-action",
            blueprint: unref(d),
            modelValue: unref(f),
            "onUpdate:modelValue": T[0] || (T[0] = (I) => isRef(f) ? f.value = I : f = I),
            meta: e.action.meta,
            errors: e.errors
          }, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$1d), {
                fields: e.action.fields
              }, {
                default: withCtx(() => [
                  createVNode(unref(_sfc_main$J))
                ]),
                _: 1
              }, 8, ["fields"])
            ]),
            _: 1
          }, 8, ["blueprint", "modelValue", "meta", "errors"])) : createCommentVNode("", !0)
        ]),
        _: 1
      }, 8, ["title", "danger", "buttonText", "busy"])) : createCommentVNode("", !0);
    };
  }
}, _sfc_main$16 = {
  __name: "BulkActions",
  props: {
    url: { type: String, required: !0 },
    selections: { type: Array, required: !0 },
    context: { type: Object, default: () => {
    } },
    showAlways: { type: Boolean, default: !1 }
  },
  emits: ["started", "completed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { prepareActions: o, runServerAction: s } = useActions();
    let u = ref([]);
    const d = useTemplateRef("confirmableActions");
    let f = computed(() => o(u.value, d.value)), g = computed(() => f.value.map((k) => Statamic.$commandPalette.add({
      category: Statamic.$commandPalette.category.Actions,
      text: k.title,
      icon: k.icon,
      action: k.run,
      prioritize: !0
    })));
    watch(g, function(k, E) {
      E.forEach((A) => A.remove());
    });
    let v = computed(() => n.selections.length > 0);
    watch(n.selections, b, { deep: !0 });
    function b() {
      if (!v.value) {
        u.value = [];
        return;
      }
      let k = {
        selections: toRaw(n.selections)
      };
      n.context && (k.context = n.context), axios.post(n.url + "/list", k).then((E) => u.value = E.data);
    }
    let w = ref({});
    function C(k, E, A, P) {
      w.value = {}, a("started"), s({ action: k, values: E, onSuccess: A, onError: P, url: n.url, selections: n.selections }).then((M) => a("completed", !0, M)).catch((M) => {
        w.value = M.errors, a("completed", !1, M);
      });
    }
    return (k, E) => (openBlock(), createElementBlock(Fragment, null, [
      unref(v) ? (openBlock(!0), createElementBlock(Fragment, { key: 0 }, renderList(unref(u), (A) => (openBlock(), createBlock(_sfc_main$17, {
        ref_for: !0,
        ref_key: "confirmableActions",
        ref: d,
        key: A.handle,
        action: A,
        selections: e.selections.length,
        errors: unref(w),
        onConfirmed: C
      }, null, 8, ["action", "selections", "errors"]))), 128)) : createCommentVNode("", !0),
      e.showAlways || unref(v) ? renderSlot(k.$slots, "default", {
        key: 1,
        actions: unref(f)
      }) : createCommentVNode("", !0)
    ], 64));
  }
}, _hoisted_1$F = { class: "[.nav-open_&]:translate-x-23 transition-transform duration-300 relative space-y-3 rounded-xl border border-gray-300/60 p-1 bg-gray-200/50 shadow-[0_1px_16px_-2px_rgba(63,63,71,0.2)] dark:border-none dark:bg-gray-800 dark:shadow-[0_10px_15px_rgba(0,0,0,.5)] dark:inset-shadow-2xs dark:inset-shadow-white/15" }, _sfc_main$15 = {
  __name: "BulkActions",
  setup(e) {
    const { actionUrl: t, actionContext: n, selections: a, refresh: o, clearSelections: s } = injectListingContext(), u = ref(!1), d = computed(() => a.value.length > 0);
    watch(u, (w) => Statamic.$progress.loading("action", w));
    function f() {
      u.value = !0;
    }
    function g(w = null, C = {}) {
      u.value = !1, w ? v(C) : b(C);
    }
    function v(w) {
      Statamic.$toast.success(w.message || __("Action completed")), o(), s();
    }
    function b(w) {
      Statamic.$toast.error(w.message || __("Action failed"));
    }
    return (w, C) => (openBlock(), createBlock(_sfc_main$16, {
      url: unref(t),
      selections: unref(a),
      context: unref(n),
      onStarted: f,
      onCompleted: g
    }, {
      default: withCtx(({ actions: k }) => [
        d.value ? (openBlock(), createBlock(unref(Motion), {
          key: 0,
          layout: "",
          class: "fixed inset-x-0 bottom-6 z-100 flex w-full justify-center",
          initial: { y: 100, opacity: 0 },
          animate: { y: 0, opacity: 1 },
          transition: { duration: 0.2, ease: "easeInOut" }
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_1$F, [
              createVNode(unref(ButtonGroup), null, {
                default: withCtx(() => [
                  createVNode(unref(Button), {
                    class: "text-blue-500!",
                    text: w.__n("Deselect :count item|Deselect all :count items", unref(a).length),
                    onClick: unref(s)
                  }, null, 8, ["text", "onClick"]),
                  (openBlock(!0), createElementBlock(Fragment, null, renderList(k, (E) => (openBlock(), createBlock(unref(Button), {
                    key: E.handle,
                    text: w.__(E.title),
                    onClick: E.run
                  }, null, 8, ["text", "onClick"]))), 128))
                ]),
                _: 2
              }, 1024)
            ])
          ]),
          _: 2
        }, 1024)) : createCommentVNode("", !0)
      ]),
      _: 1
    }, 8, ["url", "selections", "context"]));
  }
}, _hoisted_1$E = {
  "data-ui-column-customizer": "",
  class: "absolute right-0 mask-bg mask-bg--left"
}, _hoisted_2$m = { class: "border rounded-lg dark:border-gray-900" }, _hoisted_3$b = { class: "flex" }, _hoisted_4$7 = { class: "flex w-1/2 flex-col text-start" }, _hoisted_5$5 = { class: "flex flex-1 flex-col space-y-1 overflow-y-auto h-full px-3 py-2 select-none bg-gray-100 dark:bg-gray-900 rounded-bs-lg" }, _hoisted_6$2 = { class: "flex w-1/2 flex-col text-start border-l dark:border-gray-700" }, _hoisted_7 = { class: "overflow-y-auto bg-gray-100 dark:bg-gray-900 rounded-be-lg h-full" }, _hoisted_8 = { class: "space-y-1.5 p-3 select-none" }, _hoisted_9 = { class: "flex flex-1 items-center" }, _hoisted_10 = { class: "flex items-center justify-end space-x-3 pt-3 pb-1" }, _sfc_main$14 = {
  __name: "CustomizeColumns",
  setup(e) {
    const { preferencesPrefix: t, columns: n, visibleColumns: a, hiddenColumns: o, setColumns: s, reorderable: u } = injectListingContext(), d = ref(`${t.value}.columns`), f = ref(!1), g = ref(!1), v = computed(() => o.value.sort((E, A) => E.label.toLowerCase().localeCompare(A.label.toLowerCase()))), b = computed({
      get() {
        return a.value;
      },
      set(E) {
        s([...E, ...o.value]);
      }
    });
    function w() {
      g.value = !1;
    }
    function C() {
      f.value = !0, Statamic.$preferences.set(
        d.value,
        b.value.map((E) => E.field)
      ).then(() => {
        f.value = !1, w(), Statamic.$toast.success(__("These are now your default columns."));
      }).catch(() => {
        f.value = !1, Statamic.$toast.error(__("Unable to save column preferences."));
      });
    }
    function k() {
      s(
        n.value.map((E) => ({ ...E, visible: E.defaultVisibility })).sort((E, A) => E.defaultOrder - A.defaultOrder)
      ), f.value = !0, Statamic.$preferences.remove(d.value).then(() => {
        f.value = !1, w(), Statamic.$toast.success(__("Columns have been reset to their defaults."));
      }).catch(() => {
        f.value = !1, Statamic.$toast.error(__("Unable to save column preferences."));
      });
    }
    return (E, A) => {
      const P = resolveComponent("ui-heading"), M = resolveComponent("ui-checkbox-item"), B = resolveComponent("ui-drag-handle");
      return openBlock(), createElementBlock("div", _hoisted_1$E, [
        createVNode(unref(_sfc_main$2), {
          text: E.__("Customize Columns")
        }, {
          default: withCtx(() => [
            createVNode(unref(Button), {
              icon: "sliders-vertical",
              disabled: unref(u),
              onClick: A[0] || (A[0] = (_) => g.value = !0),
              "aria-label": E.__("Customize Columns")
            }, null, 8, ["disabled", "aria-label"])
          ]),
          _: 1
        }, 8, ["text"]),
        createVNode(unref(_sfc_main$E), {
          title: E.__("Customize Columns"),
          open: g.value,
          "onUpdate:open": A[3] || (A[3] = (_) => g.value = _)
        }, createSlots({
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$m, [
              createElementVNode("div", _hoisted_3$b, [
                createElementVNode("div", _hoisted_4$7, [
                  createVNode(P, {
                    text: E.__("Available Columns"),
                    class: "py-2 px-3 border-b dark:border-gray-900"
                  }, null, 8, ["text"]),
                  createElementVNode("div", _hoisted_5$5, [
                    (openBlock(!0), createElementBlock(Fragment, null, renderList(v.value, (_) => (openBlock(), createBlock(M, {
                      modelValue: _.visible,
                      "onUpdate:modelValue": (T) => _.visible = T,
                      label: _.label,
                      key: _.field,
                      class: "column-picker-item"
                    }, null, 8, ["modelValue", "onUpdate:modelValue", "label"]))), 128))
                  ])
                ]),
                createElementVNode("div", _hoisted_6$2, [
                  createVNode(P, {
                    text: E.__("Displayed Columns"),
                    class: "py-2 px-3 border-b dark:border-gray-900"
                  }, null, 8, ["text"]),
                  createElementVNode("div", _hoisted_7, [
                    createVNode(unref(_sfc_main$1A), {
                      modelValue: b.value,
                      "onUpdate:modelValue": A[1] || (A[1] = (_) => b.value = _),
                      distance: 5,
                      mirror: !1,
                      vertical: !0,
                      "item-class": "item",
                      "handle-class": "item",
                      "append-to": "[data-ui-modal-content]",
                      "constrain-dimensions": !0
                    }, {
                      default: withCtx(() => [
                        createElementVNode("div", _hoisted_8, [
                          (openBlock(!0), createElementBlock(Fragment, null, renderList(b.value, (_) => (openBlock(), createElementBlock("div", {
                            class: "item sortable cursor-grab py-2 px-2.5 gap-3 relative rounded-lg bg-white dark:bg-gray-700 flex items-center justify-between text-xs shadow",
                            key: _.field,
                            tabindex: "-1"
                          }, [
                            createVNode(B, { class: "item-move" }),
                            createElementVNode("div", _hoisted_9, [
                              createVNode(M, {
                                modelValue: _.visible,
                                "onUpdate:modelValue": (T) => _.visible = T,
                                label: _.label,
                                disabled: b.value.length === 1 || _.required
                              }, null, 8, ["modelValue", "onUpdate:modelValue", "label", "disabled"])
                            ])
                          ]))), 128))
                        ])
                      ]),
                      _: 1
                    }, 8, ["modelValue"])
                  ])
                ])
              ])
            ])
          ]),
          _: 2
        }, [
          d.value ? {
            name: "footer",
            fn: withCtx(() => [
              createElementVNode("div", _hoisted_10, [
                createVNode(unref(Button), {
                  text: E.__("Cancel"),
                  variant: "ghost",
                  onClick: A[2] || (A[2] = (_) => g.value = !1)
                }, null, 8, ["text"]),
                createVNode(unref(Button), {
                  text: E.__("Reset"),
                  onClick: k,
                  disabled: f.value
                }, null, 8, ["text", "disabled"]),
                createVNode(unref(Button), {
                  text: E.__("Save"),
                  variant: "primary",
                  onClick: C,
                  disabled: f.value
                }, null, 8, ["text", "disabled"])
              ])
            ]),
            key: "0"
          } : void 0
        ]), 1032, ["title", "open"])
      ]);
    };
  }
}, _hoisted_1$D = ["data-state", "value"], _sfc_main$13 = {
  __name: "PresetTrigger",
  props: {
    text: { type: String, default: null },
    name: { type: String, default: null },
    active: { type: Boolean, default: !1 }
  },
  setup(e) {
    return (t, n) => (openBlock(), createElementBlock("button", {
      "data-state": e.active ? "active" : null,
      value: e.name,
      class: "translate-y-px cursor-pointer p-2 focus-visible:rounded-lg pb-1 hover:text-gray-600 data-[state=active]:border-b data-[state=active]:border-gray-800 data-[state=active]:text-gray-900 dark:hover:text-gray-400 dark:data-[state=active]:border-gray-200 dark:data-[state=active]:text-gray-200"
    }, [
      renderSlot(t.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(e.text), 1)
      ])
    ], 8, _hoisted_1$D));
  }
}, _hoisted_1$C = { class: "relative flex shrink-0 space-x-2 border-b border-gray-200 text-sm text-gray-500 dark:border-gray-700/50 dark:text-gray-500" }, _hoisted_2$l = { key: 0 }, _sfc_main$12 = {
  __name: "Presets",
  setup(e) {
    const { preferencesPrefix: t, activeFilters: n, searchQuery: a, setFilters: o, clearFilters: s, setSearchQuery: u, clearSearchQuery: d } = injectListingContext(), f = ref(`${t.value}.filters`), g = ref(P()), v = ref(W()), b = computed(() => g.value[v.value]), w = ref(null), C = computed(() => snake_case(w.value)), k = ref(!1), E = ref(!1), A = ref(!1);
    watch([n, a], () => v.value = W(), { deep: !0 });
    function P() {
      return Statamic.$preferences.get(f.value, {});
    }
    function M() {
      g.value = P();
    }
    function B() {
      v.value = null, s(), d();
    }
    function _(V) {
      v.value = V, o(b.value.filters), u(b.value.query);
    }
    function T() {
      w.value = null, k.value = !0;
    }
    function O(V) {
      return !Statamic.$preferences.hasDefault(`${f.value}.${V}`);
    }
    function I(V) {
      return O(V);
    }
    function q() {
      w.value = b.value.display, E.value = !0;
    }
    const F = computed(() => !v.value && (Object.keys(n.value).length > 0 || (a.value ?? "") !== ""));
    function W() {
      for (const [V, ne] of Object.entries(g.value)) {
        const Q = {
          filters: ne.filters ?? {},
          query: ne.query ?? ""
        }, z = {
          filters: n.value,
          query: a.value ?? ""
        };
        if (JSON.stringify(Q) === JSON.stringify(z))
          return V;
      }
    }
    const K = computed(() => {
      let V = {
        display: w.value || b.value.display || ""
      };
      return a.value && (V.query = a.value), Object.entries(n.value).length && (V.filters = n.value), V;
    });
    function Z() {
      const V = C.value || v.value;
      Statamic.$preferences.set(`${f.value}.${V}`, K.value).then((ne) => {
        Statamic.$toast.success(__("View saved")), k.value = !1, w.value = null, M(), _(V);
      }).catch((ne) => {
        Statamic.$toast.error(__("Unable to save view")), k.value = !1, w.value = null;
      });
    }
    function J() {
      let V = Statamic.$preferences.get(`${f.value}`);
      V = Object.fromEntries(
        Object.entries(V).map(([ne, Q]) => ne === v.value ? [C.value, K.value] : [ne, Q])
      ), Statamic.$preferences.set(`${f.value}`, V).then((ne) => {
        Statamic.$toast.success(__("View renamed")), E.value = !1, M(), _(C.value);
      }).catch((ne) => {
        Statamic.$toast.error(__("Unable to rename view")), E.value = !1;
      });
    }
    function re() {
      Statamic.$preferences.remove(`${f.value}.${v.value}`).then((V) => {
        Statamic.$toast.success(__("View deleted")), A.value = !1, B(), M();
      }).catch((V) => {
        Statamic.$toast.error(__("Unable to delete view")), A.value = !1;
      });
    }
    return (V, ne) => {
      const Q = resolveComponent("ui-error-message"), z = resolveComponent("confirmation-modal");
      return openBlock(), createElementBlock(Fragment, null, [
        createElementVNode("div", _hoisted_1$C, [
          createVNode(_sfc_main$13, {
            active: !v.value,
            onClick: B,
            text: V.__("All")
          }, null, 8, ["active", "text"]),
          (openBlock(!0), createElementBlock(Fragment, null, renderList(g.value, (X, ue) => (openBlock(), createBlock(_sfc_main$13, {
            key: ue,
            active: ue === v.value,
            onClick: (Be) => _(ue)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(X.display) + " ", 1),
              ue === v.value ? (openBlock(), createBlock(unref(_sfc_main$1n), {
                key: 0,
                class: "w-48!"
              }, {
                trigger: withCtx(() => [
                  createVNode(unref(Button), {
                    class: "absolute top-1.5 -right-4",
                    variant: "ghost",
                    size: "xs",
                    icon: "ui/chevron-down"
                  })
                ]),
                default: withCtx(() => [
                  createVNode(unref(DropdownMenu), null, {
                    default: withCtx(() => [
                      createVNode(unref(_sfc_main$1m), {
                        text: V.__("Duplicate"),
                        icon: "duplicate",
                        onClick: T
                      }, null, 8, ["text"]),
                      O(ue) ? (openBlock(), createBlock(unref(_sfc_main$1m), {
                        key: 0,
                        text: V.__("Rename"),
                        icon: "rename",
                        onClick: q
                      }, null, 8, ["text"])) : createCommentVNode("", !0),
                      I(ue) ? (openBlock(), createBlock(unref(_sfc_main$1j), { key: 1 })) : createCommentVNode("", !0),
                      I(ue) ? (openBlock(), createBlock(unref(_sfc_main$1m), {
                        key: 2,
                        text: V.__("Delete"),
                        icon: "delete",
                        variant: "warning",
                        onClick: ne[0] || (ne[0] = (Be) => A.value = !0)
                      }, null, 8, ["text"])) : createCommentVNode("", !0)
                    ]),
                    _: 2
                  }, 1024)
                ]),
                _: 2
              }, 1024)) : createCommentVNode("", !0)
            ]),
            _: 2
          }, 1032, ["active", "onClick"]))), 128)),
          F.value ? (openBlock(), createBlock(unref(Button), {
            key: 0,
            onClick: T,
            variant: "ghost",
            size: "sm",
            text: V.__("New View"),
            icon: "add-bookmark",
            class: "relative top-0.5 [&_svg]:size-4"
          }, null, 8, ["text"])) : createCommentVNode("", !0)
        ]),
        k.value ? (openBlock(), createBlock(z, {
          key: 0,
          title: V.__("Create New View"),
          buttonText: V.__("Create"),
          onCancel: ne[2] || (ne[2] = (X) => k.value = !1),
          onConfirm: Z
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$19), {
              modelValue: w.value,
              "onUpdate:modelValue": ne[1] || (ne[1] = (X) => w.value = X),
              onKeydown: withKeys(Z, ["enter"])
            }, null, 8, ["modelValue"]),
            g.value && Object.keys(g.value).includes(C.value) ? (openBlock(), createBlock(Q, {
              key: 0,
              text: V.__("messages.filters_view_already_exists")
            }, null, 8, ["text"])) : createCommentVNode("", !0)
          ]),
          _: 1
        }, 8, ["title", "buttonText"])) : createCommentVNode("", !0),
        E.value ? (openBlock(), createBlock(z, {
          key: 1,
          title: V.__("Rename View"),
          buttonText: V.__("Rename"),
          onCancel: ne[4] || (ne[4] = (X) => E.value = !1),
          onConfirm: J
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$19), {
              modelValue: w.value,
              "onUpdate:modelValue": ne[3] || (ne[3] = (X) => w.value = X),
              onKeydown: withKeys(J, ["enter"])
            }, null, 8, ["modelValue"]),
            Object.keys(g.value).filter((X) => X !== v.value).includes(C.value) ? (openBlock(), createElementBlock("div", _hoisted_2$l, [
              createVNode(Q, {
                text: V.__("messages.filters_view_already_exists")
              }, null, 8, ["text"])
            ])) : createCommentVNode("", !0)
          ]),
          _: 1
        }, 8, ["title", "buttonText"])) : createCommentVNode("", !0),
        A.value ? (openBlock(), createBlock(z, {
          key: 2,
          title: V.__("Delete View"),
          bodyText: V.__("Are you sure you want to delete this view?"),
          buttonText: V.__("Delete"),
          danger: "",
          onConfirm: re,
          onCancel: ne[5] || (ne[5] = (X) => A.value = !1)
        }, null, 8, ["title", "bodyText", "buttonText"])) : createCommentVNode("", !0)
      ], 64);
    };
  }
};
function debounce(e, t, n) {
  let a;
  return function() {
    const o = this, s = arguments;
    clearTimeout(a), a = setTimeout(function() {
      a = null, e.apply(o, s);
    }, t);
  };
}
const _hoisted_1$B = {
  for: "listings-search",
  class: "sr-only"
}, placeholder = "Search...", _sfc_main$11 = {
  __name: "Search",
  setup(e, { expose: t }) {
    const { activeFilterBadgeCount: n, searchQuery: a, setSearchQuery: o, reorderable: s } = injectListingContext(), u = debounce((g) => o(g.target.value), 300), d = useTemplateRef("input");
    return t({ focus: () => d.value.focus() }), (g, v) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(["flex-1 max-w-sm", { "max-w-60!": unref(n) > 2 }])
    }, [
      createElementVNode("label", _hoisted_1$B, toDisplayString(g.__("Search entries")), 1),
      createVNode(unref(_sfc_main$19), {
        autofocus: "",
        ref_key: "input",
        ref: d,
        icon: "magnifying-glass",
        id: "listings-search",
        variant: "light",
        placeholder: g.__(placeholder),
        value: unref(a),
        disabled: unref(s),
        onInput: unref(u),
        onKeyup: v[0] || (v[0] = withKeys((b) => unref(o)(null), ["esc"]))
      }, null, 8, ["placeholder", "value", "disabled", "onInput"])
    ], 2));
  }
}, _hoisted_1$A = { class: "flex items-center justify-between mb-3" }, _hoisted_2$k = { class: "flex items-center gap-2 w-full" }, _hoisted_3$a = { class: "w-1/4 user-select-none" }, _sfc_main$10 = {
  __name: "FieldFilterRow",
  props: {
    display: { type: String, required: !0 },
    fields: { type: Array, required: !0 },
    meta: { type: Object, required: !0 },
    values: { type: Object, required: !0 }
  },
  emits: ["update:values", "removed", "enter-pressed"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = ref(null), s = async () => {
      if (await nextTick(), o.value) {
        const d = o.value.querySelector('input:not([readonly]), textarea, select, [contenteditable="true"]');
        d && d.focus();
      }
    }, u = (d) => {
      d.key === "Enter" && !d.shiftKey && (d.preventDefault(), a("enter-pressed"));
    };
    return t({
      focusFirstField: s
    }), (d, f) => {
      const g = resolveComponent("ui-input");
      return openBlock(), createElementBlock("div", _hoisted_1$A, [
        createVNode(unref(_sfc_main$G), {
          "model-value": e.values,
          "onUpdate:modelValue": f[1] || (f[1] = (v) => d.$emit("update:values", v)),
          meta: e.meta,
          "track-dirty-state": !1
        }, {
          default: withCtx(() => [
            createVNode(_sfc_main$1d, { fields: e.fields }, {
              default: withCtx(() => [
                createElementVNode("div", _hoisted_2$k, [
                  createElementVNode("div", _hoisted_3$a, [
                    createVNode(g, {
                      "read-only": "",
                      value: e.display,
                      class: "focus-within:outline-none"
                    }, null, 8, ["value"])
                  ]),
                  createElementVNode("div", {
                    ref_key: "fieldContainer",
                    ref: o,
                    class: "flex-1 flex items-center gap-2",
                    onKeydown: u
                  }, [
                    (openBlock(!0), createElementBlock(Fragment, null, renderList(e.fields, (v) => (openBlock(), createBlock(unref(_sfc_main$K), {
                      key: v.handle,
                      config: v
                    }, {
                      default: withCtx(({ fieldtypeComponent: b, fieldtypeComponentProps: w, fieldtypeComponentEvents: C }) => [
                        (openBlock(), createBlock(resolveDynamicComponent(b), mergeProps({ ref_for: !0 }, w, toHandlers(C)), null, 16))
                      ]),
                      _: 1
                    }, 8, ["config"]))), 128))
                  ], 544),
                  createVNode(unref(Button), {
                    onClick: f[0] || (f[0] = (v) => d.$emit("removed")),
                    icon: "x",
                    size: "sm",
                    variant: "ghost",
                    inset: ""
                  })
                ])
              ]),
              _: 1
            }, 8, ["fields"])
          ]),
          _: 1
        }, 8, ["model-value", "meta"])
      ]);
    };
  }
}, _hoisted_1$z = { key: 0 }, _hoisted_2$j = ["textContent"], _sfc_main$$ = {
  __name: "FieldFilter",
  props: {
    config: Object,
    values: Object
  },
  emits: ["changed", "cleared"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = ref([]), u = ref({}), d = ref(null);
    watch(
      () => o.values,
      (P) => {
        const M = [];
        Object.entries(P).forEach(([B, _]) => {
          const T = o.config.extra.find((O) => O.handle === B);
          T.values = _, M.push(T);
        }), s.value = M;
      },
      { immediate: !0 }
    );
    const f = computed(() => {
      if (!o.config) return [];
      const P = s.value.map((M) => M.handle);
      return o.config.extra.filter((M) => !P.includes(M.handle));
    }), g = computed(() => !!f.value.length), v = computed(() => {
      let P = f.value.map((M) => ({
        value: M.handle,
        label: M.display
      }));
      return sortBy(P, (M) => M.label);
    });
    async function b(P) {
      const M = f.value.find((T) => T.handle === P);
      let B = {};
      M.fields.filter((T) => T.default).forEach((T) => B[T.handle] = T.default), M.values = B, s.value.push(M), await nextTick();
      const _ = u.value[M.handle];
      _ && _.focusFirstField && _.focusFirstField();
    }
    function w(P, M) {
      a("changed", {
        ...o.values,
        [P]: M
      });
    }
    function C(P) {
      s.value = s.value.filter((B) => B.handle !== P);
      const M = { ...o.values };
      delete M[P], a("changed", M);
    }
    async function k() {
      if (await nextTick(), d.value && g.value) {
        const P = d.value.$el?.querySelector("input") || d.value.$el?.querySelector('[role="combobox"]');
        P && P.focus();
      }
    }
    const E = ref(!1);
    async function A() {
      if (E.value || (await nextTick(), !d.value)) return;
      const P = d.value.$el?.querySelector("input");
      if (P && typeof P.focus == "function") {
        P.focus(), E.value = !0;
        return;
      }
      const M = d.value.$el?.querySelector("[data-ui-combobox-anchor]");
      M && typeof M.focus == "function" && (M.focus(), E.value = !0);
    }
    return onMounted(() => {
      g.value && A();
    }), watch(f, (P) => {
      P && P.length && !E.value && A();
    }), t({
      focusAddFieldCombobox: A
    }), (P, M) => g.value ? (openBlock(), createElementBlock("div", _hoisted_1$z, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(s.value, (B) => (openBlock(), createBlock(_sfc_main$10, {
        key: B.handle,
        ref_for: !0,
        ref: (_) => {
          _ && (u.value[B.handle] = _);
        },
        display: B.display,
        fields: B.fields,
        meta: B.meta,
        values: B.values,
        "onUpdate:values": (_) => w(B.handle, _),
        onRemoved: (_) => C(B.handle),
        onEnterPressed: k
      }, null, 8, ["display", "fields", "meta", "values", "onUpdate:values", "onRemoved"]))), 128)),
      createVNode(unref(_sfc_main$1z), {
        ref_key: "fieldSelect",
        ref: d,
        placeholder: P.__("Add Field"),
        options: v.value,
        "onUpdate:modelValue": b
      }, null, 8, ["placeholder", "options"])
    ])) : (openBlock(), createElementBlock("div", {
      key: 1,
      textContent: toDisplayString(P.__("No available filters"))
    }, null, 8, _hoisted_2$j));
  }
}, _sfc_main$_ = {
  __name: "Filter",
  props: {
    filter: Object,
    values: Object
  },
  emits: ["changed"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = computed(() => a.filter.values || {}), s = ref({ ...o.value, ...a.values }), u = ref(!1);
    watch(() => a.values, (g) => {
      g || (u.value = !0, s.value = { ...o.value }, nextTick(() => u.value = !1));
    });
    const d = computed(() => (a.filter.fields.length === 1 && (a.filter.fields[0].hide_display = !0), a.filter.fields));
    function f(g) {
      let v = { ...g };
      Object.keys(g).forEach((b) => {
        (g[b] === null || g[b] === void 0) && delete v[b];
      }), !u.value && n("changed", v);
    }
    return (g, v) => (openBlock(), createBlock(unref(_sfc_main$G), {
      "model-value": s.value,
      "onUpdate:modelValue": f,
      meta: e.filter.meta,
      "track-dirty-state": !1
    }, {
      default: withCtx(() => [
        createVNode(_sfc_main$1d, { fields: d.value }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$J))
          ]),
          _: 1
        }, 8, ["fields"])
      ]),
      _: 1
    }, 8, ["model-value", "meta"]));
  }
}, _hoisted_1$y = { class: "flex flex-1 items-center gap-3 overflow-x-auto py-3 rounded-r-4xl" }, _hoisted_2$i = { class: "space-y-4" }, _sfc_main$Z = {
  __name: "Filters",
  setup(e) {
    const { filters: t, activeFilters: n, activeFilterBadges: a, activeFilterBadgeCount: o, setFilter: s, reorderable: u } = injectListingContext(), d = ref(!1), f = ref(null), g = computed(() => t.value.find((T) => T.is_fields)), v = computed(() => g.value?.handle), b = computed(() => a.value[v.value] || {}), w = computed(() => t.value.filter((T) => !T.is_fields)), C = computed(() => {
      const { [v.value]: T, ...O } = a.value;
      return O;
    });
    function k(T) {
      const O = { ...n.value[v.value] };
      delete O[T], s(v.value, O);
    }
    function E(T) {
      return n.value.hasOwnProperty(T);
    }
    const A = ref(null), P = ref(null);
    function M(T) {
      if (!T) return !1;
      const O = T.querySelector("[data-ui-combobox-anchor]");
      if (O && typeof O.focus == "function")
        return O.focus(), !0;
      const I = T.querySelector("input");
      return I && typeof I.focus == "function" ? (I.focus(), !0) : !1;
    }
    function B() {
      const T = A.value;
      T && (M(T) || (P.value && P.value.disconnect(), P.value = new MutationObserver(() => {
        M(T) && (P.value.disconnect(), P.value = null);
      }), P.value.observe(T, { childList: !0, subtree: !0 })));
    }
    watch(d, async (T) => {
      T && (await nextTick(), B());
    });
    function _() {
      P.value && (P.value.disconnect(), P.value = null), d.value = !1, nextTick(() => {
        requestAnimationFrame(() => {
          const T = f.value, O = T ? T.querySelector("button") : null;
          O && typeof O.focus == "function" && O.focus();
        });
      });
    }
    return (T, O) => {
      const I = resolveComponent("stack");
      return openBlock(), createElementBlock("div", _hoisted_1$y, [
        createElementVNode("div", {
          ref_key: "filtersButtonWrapperRef",
          ref: f,
          class: "sticky left-0 ps-[1px] rounded-r-lg bg-white dark:bg-gray-900 mask-bg mask-bg--left mask-bg--left-small"
        }, [
          createVNode(unref(Button), {
            icon: "sliders-horizontal",
            class: "[&_svg]:size-3.5",
            disabled: unref(u),
            onClick: O[0] || (O[0] = (q) => d.value = !0)
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(T.__("Filters")) + " ", 1),
              unref(o) ? (openBlock(), createBlock(unref(_sfc_main), {
                key: 0,
                text: unref(o),
                size: "sm",
                pill: "",
                class: "absolute -top-1.25 -right-2.75"
              }, null, 8, ["text"])) : createCommentVNode("", !0)
            ]),
            _: 1
          }, 8, ["disabled"])
        ], 512),
        d.value ? (openBlock(), createBlock(I, {
          key: 0,
          half: "",
          name: "filters",
          onClosed: _
        }, {
          default: withCtx(() => [
            createElementVNode("div", {
              ref_key: "stackContentRef",
              ref: A,
              class: "flex-1 p-3 bg-white dark:bg-gray-800 h-full overflow-auto rounded-l-2xl relative"
            }, [
              createVNode(unref(Button), {
                icon: "x",
                variant: "ghost",
                size: "sm",
                class: "absolute top-1.75 right-3 z-10 [&_svg]:size-4",
                onClick: _
              }),
              createVNode(unref(_sfc_main$1b), {
                size: "lg",
                text: T.__("Filters"),
                class: "mb-4 px-1.5 pr-12 [&_svg]:size-4",
                icon: "sliders-horizontal"
              }, null, 8, ["text"]),
              createElementVNode("div", _hoisted_2$i, [
                g.value ? (openBlock(), createBlock(unref(_sfc_main$A), { key: 0 }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$y), { class: "flex items-center justify-between" }, {
                      default: withCtx(() => [
                        createVNode(unref(_sfc_main$1b), {
                          text: T.__("Fields")
                        }, null, 8, ["text"]),
                        E(v.value) ? (openBlock(), createBlock(unref(Button), {
                          key: 0,
                          size: "sm",
                          text: "Clear",
                          onClick: O[1] || (O[1] = (q) => unref(s)(v.value, null))
                        })) : createCommentVNode("", !0)
                      ]),
                      _: 1
                    }),
                    createVNode(unref(_sfc_main$1J), null, {
                      default: withCtx(() => [
                        createVNode(_sfc_main$$, {
                          config: g.value,
                          values: unref(n).fields || {},
                          onChanged: O[2] || (O[2] = (q) => unref(s)(v.value, q))
                        }, null, 8, ["config", "values"])
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : createCommentVNode("", !0),
                (openBlock(!0), createElementBlock(Fragment, null, renderList(w.value, (q) => (openBlock(), createBlock(unref(_sfc_main$A), {
                  key: q.handle
                }, {
                  default: withCtx(() => [
                    createVNode(unref(_sfc_main$y), { class: "flex items-center justify-between" }, {
                      default: withCtx(() => [
                        createVNode(unref(_sfc_main$1b), {
                          text: q.title
                        }, null, 8, ["text"]),
                        E(q.handle) ? (openBlock(), createBlock(unref(Button), {
                          key: 0,
                          size: "sm",
                          text: "Clear",
                          onClick: (F) => unref(s)(q.handle, null)
                        }, null, 8, ["onClick"])) : createCommentVNode("", !0)
                      ]),
                      _: 2
                    }, 1024),
                    createVNode(unref(_sfc_main$1J), null, {
                      default: withCtx(() => [
                        createVNode(_sfc_main$_, {
                          filter: q,
                          values: unref(n)[q.handle],
                          onChanged: (F) => unref(s)(q.handle, F)
                        }, null, 8, ["filter", "values", "onChanged"])
                      ]),
                      _: 2
                    }, 1024)
                  ]),
                  _: 2
                }, 1024))), 128))
              ])
            ], 512)
          ]),
          _: 1
        })) : createCommentVNode("", !0),
        (openBlock(!0), createElementBlock(Fragment, null, renderList(b.value, (q, F, W) => (openBlock(), createBlock(unref(Button), {
          key: F,
          variant: "filled",
          "icon-append": unref(u) ? null : "x",
          text: q,
          disabled: unref(u),
          class: "last:me-12",
          onClick: (K) => k(F)
        }, null, 8, ["icon-append", "text", "disabled", "onClick"]))), 128)),
        (openBlock(!0), createElementBlock(Fragment, null, renderList(C.value, (q, F, W) => (openBlock(), createBlock(unref(Button), {
          key: F,
          variant: "filled",
          "icon-append": unref(u) ? null : "x",
          text: q,
          disabled: unref(u),
          class: "last:me-12",
          onClick: (K) => unref(s)(F, null)
        }, null, 8, ["icon-append", "text", "disabled", "onClick"]))), 128))
      ]);
    };
  }
}, _sfc_main$Y = {
  __name: "Pagination",
  setup(e) {
    const {
      meta: t,
      perPage: n,
      setPerPage: a,
      setCurrentPage: o,
      showPaginationTotals: s,
      showPaginationPageLinks: u,
      showPaginationPerPageSelector: d
    } = injectListingContext();
    return (f, g) => (openBlock(), createBlock(unref(_sfc_main$B), {
      "per-page": unref(n),
      "resource-meta": unref(t),
      "show-totals": unref(s),
      "show-page-links": unref(u),
      "show-per-page-selector": unref(d),
      onPageSelected: unref(o),
      onPerPageChanged: unref(a)
    }, null, 8, ["per-page", "resource-meta", "show-totals", "show-page-links", "show-per-page-selector", "onPageSelected", "onPerPageChanged"]));
  }
}, _hoisted_1$x = { scope: "col" }, _hoisted_2$h = ["textContent"], _sfc_main$X = {
  __name: "HeaderCell",
  props: {
    column: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = e, { sortColumn: n, setSortColumn: a } = injectListingContext(), o = computed(() => t.column.field === n.value);
    return (s, u) => (openBlock(), createElementBlock("th", _hoisted_1$x, [
      e.column.sortable ? (openBlock(), createBlock(unref(Button), {
        key: 1,
        text: s.__(e.column.label),
        "icon-append": o.value ? "up-down" : null,
        size: "sm",
        variant: "ghost",
        class: "-mt-2 -mb-1 -ml-3 text-sm! font-medium! text-gray-900! dark:text-gray-400!",
        onClick: u[0] || (u[0] = withModifiers((d) => unref(a)(e.column.field), ["prevent"]))
      }, null, 8, ["text", "icon-append"])) : (openBlock(), createElementBlock("span", {
        key: 0,
        textContent: toDisplayString(s.__(e.column.label))
      }, null, 8, _hoisted_2$h))
    ]));
  }
}, _sfc_main$W = {
  __name: "ToggleAll",
  setup(e) {
    const { items: t, selections: n, maxSelections: a, clearSelections: o, reorderable: s } = injectListingContext(), u = computed(() => n.value.length > 0), d = computed(() => u.value && n.value.length < t.value.length);
    function f() {
      u.value ? o() : g();
    }
    function g() {
      let w = t.value.map((C) => C.id);
      a.value && (w = w.slice(0, a.value)), n.value.splice(0, n.value.length, ...w);
    }
    function v() {
      return d.value ? __("Select all items") : u.value ? __("Deselect all items") : __("Select all items");
    }
    function b() {
      const w = t.value.length, C = n.value.length;
      return d.value ? __("messages.selections_select_all", { selected: C, total: w }) : u.value ? __("messages.selections_click_to_deselect_all", { total: w }) : __("messages.selections_click_to_select_all", { total: w });
    }
    return (w, C) => unref(s) ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$1E), {
      key: 0,
      "model-value": u.value,
      indeterminate: d.value,
      label: v(),
      description: b(),
      value: "all",
      size: "sm",
      solo: "",
      "onUpdate:modelValue": f
    }, null, 8, ["model-value", "indeterminate", "label", "description"]));
  }
}, _hoisted_1$w = { key: 0 }, _hoisted_2$g = {
  key: 1,
  scope: "col",
  class: "actions-column"
}, _hoisted_3$9 = {
  key: 1,
  class: "sr-only"
}, _hoisted_4$6 = ["textContent"], _sfc_main$V = {
  __name: "TableHead",
  props: {
    srOnly: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const { allowsSelections: t, reorderable: n, hasActions: a, visibleColumns: o, allowsMultipleSelections: s } = injectListingContext(), u = e, d = computed(() => u.srOnly ? !1 : t.value || o.value.length > 1);
    return (f, g) => d.value ? (openBlock(), createElementBlock("thead", _hoisted_1$w, [
      createElementVNode("tr", null, [
        unref(t) || unref(n) ? (openBlock(), createElementBlock("th", {
          key: 0,
          class: normalizeClass({ "checkbox-column": !unref(n), "handle-column": unref(n) }),
          scope: "col"
        }, [
          unref(t) && unref(s) ? (openBlock(), createBlock(_sfc_main$W, { key: 0 })) : createCommentVNode("", !0)
        ], 2)) : createCommentVNode("", !0),
        (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(o), (v) => (openBlock(), createBlock(_sfc_main$X, {
          key: v.field,
          column: v
        }, null, 8, ["column"]))), 128)),
        unref(a) ? (openBlock(), createElementBlock("th", _hoisted_2$g)) : createCommentVNode("", !0)
      ])
    ])) : (openBlock(), createElementBlock("thead", _hoisted_3$9, [
      createElementVNode("tr", null, [
        (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(o), (v) => (openBlock(), createElementBlock("th", {
          key: v.field,
          scope: "col",
          textContent: toDisplayString(f.__(v.label || v.field))
        }, null, 8, _hoisted_4$6))), 128))
      ])
    ]));
  }
}, _sfc_main$U = {
  props: {
    value: { required: !0 }
  },
  data() {
    return {
      truncateAt: 50
    };
  },
  computed: {
    text() {
      let e = this.value;
      return e === 0 ? 0 : e ? typeof e != "string" ? JSON.stringify(e) : (e = e.replace(/<\/?[^>]+(>|$)/g, ""), e.length > this.truncateAt && (e = e.substring(0, this.truncateAt) + "&hellip;"), e) : "";
    }
  },
  render() {
    return h("div", { innerHTML: this.text });
  }
}, _sfc_main$T = {
  components: { DefaultField: _sfc_main$U },
  props: {
    handle: { type: String, required: !0 },
    value: { required: !0 },
    values: { required: !0 },
    fieldtype: String
  },
  computed: {
    component() {
      const e = "DefaultField", t = `${this.fieldtype}-fieldtype-index`;
      return this.fieldtype && Statamic.$app.component(t) ? t : e;
    },
    cssClass() {
      return this.fieldtype ? `${this.fieldtype}-index-field` : "";
    }
  }
};
function _sfc_render$9(e, t, n, a, o, s) {
  return openBlock(), createElementBlock("div", null, [
    (openBlock(), createBlock(resolveDynamicComponent(s.component), {
      class: normalizeClass(s.cssClass),
      handle: n.handle,
      value: n.value,
      values: n.values
    }, null, 8, ["class", "handle", "value", "values"]))
  ]);
}
const TableField = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$9]]), _sfc_main$S = {
  __name: "ItemActions",
  props: {
    url: { type: String },
    actions: { type: Array },
    context: { type: Object, default: () => ({}) },
    item: { required: !0 },
    isDirty: { type: Boolean, default: !1 }
  },
  emits: ["started", "completed"],
  setup(e, { expose: t, emit: n }) {
    const a = e, o = n, { prepareActions: s, runServerAction: u } = useActions(), d = useTemplateRef("confirmableActions"), f = ref(a.actions), g = ref(a.actions !== void 0);
    let v = computed(() => s(f.value, d.value)), b = ref({});
    function w(k, E, A, P) {
      b.value = {}, o("started"), u({ action: k, values: E, onSuccess: A, onError: P, url: a.url, selections: [a.item] }).then((M) => o("completed", !0, M)).catch((M) => {
        b.value = M.errors, o("completed", !1, M);
      });
    }
    function C() {
      if (g.value)
        return;
      let k = {
        selections: [a.item]
      };
      a.context && (k.context = a.context), axios.post(a.url + "/list", k).then((E) => f.value = E.data), g.value = !0;
    }
    return t({
      preparedActions: v
    }), (k, E) => (openBlock(), createElementBlock(Fragment, null, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(f.value, (A) => (openBlock(), createBlock(_sfc_main$17, {
        ref_for: !0,
        ref_key: "confirmableActions",
        ref: d,
        key: A.handle,
        action: A,
        selections: 1,
        errors: unref(b),
        "is-dirty": e.isDirty,
        onConfirmed: w
      }, null, 8, ["action", "errors", "is-dirty"]))), 128)),
      renderSlot(k.$slots, "default", {
        actions: unref(v),
        loadActions: C
      })
    ], 64));
  }
}, _sfc_main$R = {
  __name: "RowActions",
  props: {
    row: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const { actionUrl: t, actionContext: n, refresh: a, reorderable: o, allowActionsWhileReordering: s } = injectListingContext(), u = ref(!1), d = computed(() => !(o.value && !s.value));
    watch(u, (C) => Statamic.$progress.loading("action", C));
    function f() {
      u.value = !0;
    }
    function g(C = null, k = {}) {
      u.value = !1, C ? v(k) : b(k);
    }
    function v(C) {
      Statamic.$toast.success(C.message || __("Action completed")), a();
    }
    function b(C) {
      Statamic.$toast.error(C.message || __("Action failed"));
    }
    function w(C) {
      t.value && C();
    }
    return (C, k) => d.value ? (openBlock(), createBlock(_sfc_main$S, {
      key: 0,
      url: unref(t),
      item: e.row.id,
      context: unref(n),
      actions: e.row.actions,
      onStarted: f,
      onCompleted: g
    }, {
      default: withCtx(({ actions: E, loadActions: A }) => [
        createVNode(unref(_sfc_main$1n), {
          onMouseover: (P) => w(A),
          placement: "left-start",
          class: "me-3"
        }, {
          default: withCtx(() => [
            createVNode(unref(DropdownMenu), null, {
              default: withCtx(() => [
                renderSlot(C.$slots, "prepended-actions", { row: e.row }),
                C.$slots["prepended-actions"] && E.length ? (openBlock(), createBlock(unref(_sfc_main$1j), { key: 0 })) : createCommentVNode("", !0),
                (openBlock(!0), createElementBlock(Fragment, null, renderList(E, (P) => (openBlock(), createBlock(unref(_sfc_main$1m), {
                  key: P.handle,
                  text: C.__(P.title),
                  icon: P.icon,
                  variant: P.dangerous ? "destructive" : "default",
                  onClick: P.run
                }, null, 8, ["text", "icon", "variant", "onClick"]))), 128))
              ]),
              _: 2
            }, 1024)
          ]),
          _: 2
        }, 1032, ["onMouseover"])
      ]),
      _: 3
    }, 8, ["url", "item", "context", "actions"])) : createCommentVNode("", !0);
  }
}, _hoisted_1$v = ["data-row", "onClick"], _hoisted_2$f = {
  key: 0,
  class: "table-drag-handle"
}, _hoisted_3$8 = {
  key: 1,
  class: "checkbox-column"
}, _hoisted_4$5 = ["width", "data-column"], _hoisted_5$4 = {
  key: 2,
  class: "actions-column"
}, _sfc_main$Q = {
  __name: "TableBody",
  setup(e) {
    const {
      items: t,
      selections: n,
      reorderable: a,
      reordered: o,
      visibleColumns: s,
      hasActions: u,
      allowsSelections: d,
      selectRange: f,
      selectionClicked: g,
      toggleSelection: v,
      hasReachedSelectionLimit: b,
      allowsMultipleSelections: w,
      isColumnVisible: C
    } = injectListingContext();
    function k(B) {
      return n.value.includes(B);
    }
    function E(B) {
      const _ = P(B);
      return k(B.id) ? __("Deselect :title", { title: _ }) : __("Select :title", { title: _ });
    }
    function A(B) {
      const _ = P(B);
      return b.value && w.value && !k(B.id) ? __("messages.selections_limit_reached", { title: _ }) : k(B.id) ? __("messages.selections_item_selected", { title: _ }) : __("messages.selections_item_unselected", { title: _ });
    }
    function P(B) {
      return B.title || B.name || B.label || B.id || __("item");
    }
    function M(B, _) {
      if (!d.value) return;
      B.target.closest('button, a, input, select, textarea, [role="button"], [role="menuitem"], [role="option"], [data-interactive]') || g(_, B);
    }
    return (B, _) => (openBlock(), createBlock(_sfc_main$1A, {
      vertical: "",
      "model-value": unref(t),
      mirror: !1,
      "item-class": "sortable-row",
      "handle-class": "table-drag-handle",
      "onUpdate:modelValue": unref(o)
    }, {
      default: withCtx(() => [
        createElementVNode("tbody", null, [
          renderSlot(B.$slots, "tbody-start"),
          (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(t), (T, O) => (openBlock(), createElementBlock("tr", {
            key: T.id,
            class: "sortable-row outline-hidden",
            "data-row": k(T.id) ? "selected" : "unselected",
            onClick: (I) => M(I, O)
          }, [
            unref(a) ? (openBlock(), createElementBlock("td", _hoisted_2$f)) : createCommentVNode("", !0),
            unref(d) && !unref(a) ? (openBlock(), createElementBlock("td", _hoisted_3$8, [
              createVNode(unref(_sfc_main$1E), {
                value: T.id,
                "model-value": k(T.id),
                disabled: unref(b) && unref(w) && !k(T.id),
                label: E(T),
                description: A(T),
                size: "sm",
                solo: "",
                "onUpdate:modelValue": (I) => unref(g)(O, I)
              }, null, 8, ["value", "model-value", "disabled", "label", "description", "onUpdate:modelValue"])
            ])) : createCommentVNode("", !0),
            (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(s), (I) => (openBlock(), createElementBlock("td", {
              key: I.field,
              width: I.width,
              "data-column": `${I.field}`
            }, [
              renderSlot(B.$slots, `cell-${I.field}`, {
                value: T[I.value || I.field],
                row: T,
                isColumnVisible: unref(C)
              }, () => [
                (openBlock(), createBlock(TableField, {
                  handle: I.field,
                  value: T[I.value || I.field],
                  values: T,
                  fieldtype: I.fieldtype,
                  key: I.field
                }, null, 8, ["handle", "value", "values", "fieldtype"]))
              ])
            ], 8, _hoisted_4$5))), 128)),
            unref(u) || B.$slots["prepended-row-actions"] ? (openBlock(), createElementBlock("td", _hoisted_5$4, [
              createVNode(_sfc_main$R, { row: T }, createSlots({ _: 2 }, [
                B.$slots["prepended-row-actions"] ? {
                  name: "prepended-actions",
                  fn: withCtx(({ row: I }) => [
                    renderSlot(B.$slots, "prepended-row-actions", { row: I })
                  ]),
                  key: "0"
                } : void 0
              ]), 1032, ["row"])
            ])) : createCommentVNode("", !0)
          ], 8, _hoisted_1$v))), 128))
        ])
      ]),
      _: 3
    }, 8, ["model-value", "onUpdate:modelValue"]));
  }
}, _hoisted_1$u = ["data-size", "data-has-selections"], _hoisted_2$e = { key: 1 }, _hoisted_3$7 = { class: "text-center text-gray-500 text-sm pt-4" }, _sfc_main$P = {
  __name: "Table",
  props: {
    unstyled: {
      type: Boolean,
      default: !1
    },
    contained: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const { visibleColumns: t, selections: n, items: a, hasActions: o, showBulkActions: s, loading: u, reorderable: d } = injectListingContext(), f = ref(!1), g = computed(() => n.value.length > 0), v = computed(() => t.value.length <= 4 ? "sm" : t.value.length <= 8 ? "md" : t.value.length >= 12 ? "lx" : "xl"), b = useSlots(), w = computed(() => Object.keys(b).filter((C) => C.startsWith("cell-")).reduce((C, k) => (C[k] = b[k], C), {}));
    return (C, k) => (openBlock(), createElementBlock(Fragment, null, [
      unref(a).length > 0 ? (openBlock(), createElementBlock("table", {
        key: 0,
        "data-size": v.value,
        class: normalizeClass({
          "select-none": f.value,
          "data-table": !e.unstyled,
          contained: e.contained,
          "opacity-50": unref(u)
        }),
        "data-table": "",
        ref: "table",
        "data-has-selections": g.value ? !0 : null,
        onKeydown: k[0] || (k[0] = withModifiers((E) => f.value = !0, ["shift"])),
        onKeyup: k[1] || (k[1] = (E) => f.value = !1)
      }, [
        createVNode(_sfc_main$V),
        createVNode(_sfc_main$Q, null, createSlots({ _: 2 }, [
          C.$slots["tbody-start"] ? {
            name: "tbody-start",
            fn: withCtx(() => [
              renderSlot(C.$slots, "tbody-start")
            ]),
            key: "0"
          } : void 0,
          C.$slots["prepended-row-actions"] ? {
            name: "prepended-row-actions",
            fn: withCtx((E) => [
              renderSlot(C.$slots, "prepended-row-actions", normalizeProps(guardReactiveProps(E)))
            ]),
            key: "1"
          } : void 0,
          renderList(w.value, (E, A) => ({
            name: A,
            fn: withCtx((P) => [
              (openBlock(), createBlock(resolveDynamicComponent(E), normalizeProps(guardReactiveProps(P)), null, 16))
            ])
          }))
        ]), 1024)
      ], 42, _hoisted_1$u)) : createCommentVNode("", !0),
      unref(a).length === 0 ? (openBlock(), createElementBlock("div", _hoisted_2$e, [
        createElementVNode("div", _hoisted_3$7, toDisplayString(C.__("No items found")), 1)
      ])) : createCommentVNode("", !0)
    ], 64));
  }
}, _hoisted_1$t = { class: "flex flex-col gap-4 justify-between mt-2" }, _hoisted_2$d = { class: "flex gap-3" }, _hoisted_3$6 = {
  key: 1,
  class: "relative flex items-center gap-3 min-h-16"
}, _hoisted_4$4 = { class: "flex flex-1 items-center gap-3 w-full" }, _hoisted_5$3 = ["textContent"], [injectListingContext, provideListingContext] = createContext$1("Listing"), _sfc_main$O = {
  __name: "Listing",
  props: {
    url: {
      type: String
    },
    items: {
      type: Array
    },
    allowPresets: {
      type: Boolean,
      default: !0
    },
    allowBulkActions: {
      type: Boolean,
      default: !0
    },
    actionUrl: {
      type: String
    },
    actionContext: {
      type: Object,
      default: () => ({})
    },
    allowActionsWhileReordering: {
      type: Boolean,
      default: !1
    },
    reorderable: {
      type: Boolean,
      default: !1
    },
    preferencesPrefix: {
      type: String
    },
    columns: {
      type: Array
    },
    allowCustomizingColumns: {
      type: Boolean,
      default: !0
    },
    sortColumn: {
      type: String,
      default: ""
    },
    sortDirection: {
      type: String,
      default: "asc"
    },
    sortable: {
      type: Boolean,
      default: !0
    },
    selections: {
      type: Array
    },
    maxSelections: {
      type: Number,
      default: 1 / 0
    },
    pushQuery: {
      type: Boolean,
      default: !1
    },
    additionalParameters: {
      type: Object,
      default: () => ({})
    },
    allowSearch: {
      type: Boolean,
      default: !0
    },
    searchQuery: {
      type: String,
      default: null
    },
    filters: {
      type: Array,
      default: () => []
    },
    filtersForReordering: {
      type: Function,
      default: null
    },
    perPage: {
      type: Number,
      default: 15
    },
    showPaginationTotals: {
      type: Boolean,
      default: !0
    },
    showPaginationPageLinks: {
      type: Boolean,
      default: !0
    },
    showPaginationPerPageSelector: {
      type: Boolean,
      default: !0
    }
  },
  emits: [
    "update:columns",
    "update:sortColumn",
    "update:sortDirection",
    "update:selections",
    "update:searchQuery",
    "requestCompleted",
    "reordered",
    "refreshing"
  ],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = useSlots(), u = uniqid(), d = ref(o.items), f = ref(), g = ref({}), v = ref([]), b = ref(null), w = ref(1), C = ref(je()), k = ref(!0), E = ref(!0);
    let A = !1, P = null;
    const M = ref(null), B = ref(Ae()), _ = ref(o.sortColumn || (B.value.length ? B.value[0].field : null)), T = ref(o.sortDirection || Qe(_.value)), O = ref(o.selections || []), I = computed(() => (o.selections || W.value) && !o.reorderable), q = computed(() => o.maxSelections > 1), F = computed(() => O.value.length === o.maxSelections), W = computed(() => !!o.actionUrl), K = computed(() => o.filters && o.filters.length > 0), Z = computed(() => o.allowPresets && o.preferencesPrefix), J = computed(() => o.allowBulkActions && W.value), re = computed({
      get() {
        let $e = d.value;
        return o.items ? (M.value && ($e = fuzzysort.go(M.value, $e, {
          all: !0,
          keys: ye.value.map((ct) => ct.field)
        }).map((ct) => ct.obj)), o.sortable && ($e = sortBy($e, (ct) => {
          let Je = ct[_.value];
          return typeof Je == "string" && (Je = Je.toLowerCase()), Je;
        })), T.value === "desc" ? $e.reverse() : $e) : $e;
      },
      set($e) {
        d.value = $e;
      }
    });
    watch(
      () => o.items,
      ($e) => d.value = $e
    );
    const V = computed(() => ({
      page: w.value,
      perPage: C.value,
      sort: _.value,
      order: T.value,
      search: M.value,
      columns: ye.value.map(($e) => $e.field).join(","),
      filters: Object.keys(g.value).length === 0 ? null : utf8btoa(JSON.stringify(g.value))
    }));
    watch(B, ($e) => a("update:columns", $e)), watch(_, ($e) => a("update:sortColumn", $e)), watch(T, ($e) => a("update:sortDirection", $e)), watch(O, ($e) => a("update:selections", $e), { deep: !0 }), watch(M, ($e) => a("update:searchQuery", $e));
    const ne = computed(() => Object.keys(s).filter(($e) => $e.startsWith("cell-")).reduce(($e, ct) => ($e[ct] = s[ct], $e), {})), Q = computed(() => {
      let $e = Object.keys(v.value).length;
      return v.value.hasOwnProperty("fields") && ($e = $e + Object.keys(v.value.fields).length - 1), $e;
    });
    function z($e) {
      $e.hasOwnProperty("page") && (w.value = parseInt($e.page)), $e.hasOwnProperty("perPage") && (C.value = parseInt($e.perPage)), $e.hasOwnProperty("sort") && (_.value = $e.sort), $e.hasOwnProperty("order") && (T.value = $e.order), $e.hasOwnProperty("search") && (M.value = $e.search), $e.hasOwnProperty("columns") && (B.value = B.value.map((ct) => ({
        ...ct,
        visible: $e.columns.split(",").includes(ct.field)
      }))), $e.hasOwnProperty("filters") && (g.value = $e.filters ? JSON.parse(utf8atob($e.filters)) : {});
    }
    const X = computed(() => ({ ...Object.fromEntries(
      Object.entries(V.value).filter(([ct, Je]) => Je != null && Je !== "")
    ), ...o.additionalParameters })), ue = computed(() => w.value > 1 && re.value.length === 0 ? (w.value = 1, !0) : !1);
    function Be() {
      o.items || (E.value = !0, P && P.abort(), P = new AbortController(), axios.get(o.url, {
        params: X.value,
        signal: P.signal
      }).then(($e) => {
        if (ze($e.data.meta.columns), v.value = { ...$e.data.meta.activeFilterBadges }, re.value = Object.values($e.data.data), f.value = $e.data.meta, ue.value) return Be();
        k.value = !1, E.value = !1, a("requestCompleted", {
          response: $e,
          items: re.value,
          parameters: X.value,
          activeFilters: g.value
        });
      }).catch(($e) => {
        axios.isCancel($e) || (k.value = !1, E.value = !1, !($e.request && !$e.response) && Statamic.$toast.error($e.response ? $e.response.data.message : __("Something went wrong"), {
          duration: null
        }));
      }));
    }
    function te() {
      a("refreshing"), Be();
    }
    function G() {
      if (!o.pushQuery || A) return;
      const $e = Object.keys(V.value), ct = new URLSearchParams(
        Object.fromEntries(
          $e.filter((Je) => X.value.hasOwnProperty(Je)).map((Je) => [Je, X.value[Je]])
        )
      );
      window.history.pushState({ parameters: X.value }, "", "?" + ct.toString());
    }
    function ie($e) {
      !o.pushQuery || !$e.state || (A = !0, z($e.state.parameters), nextTick(() => A = !1));
    }
    function oe() {
      if (!o.pushQuery || !window.location.search) return;
      const $e = new URLSearchParams(window.location.search), ct = Object.fromEntries($e.entries());
      A = !0, z(ct), nextTick(() => A = !1);
    }
    const ye = computed(() => {
      const $e = B.value.filter((ct) => ct.visible);
      return $e.length ? $e : B.value;
    }), ve = computed(() => B.value.filter(($e) => !$e.visible)), ke = computed(() => B.value.filter(($e) => $e.sortable).map(($e) => $e.field));
    function Ae() {
      return o.columns ? o.columns.map(($e) => typeof $e == "string" ? { field: $e, label: be($e), sortable: !0 } : $e) : o.items && o.items.length > 0 ? Object.keys(o.items[0] || {}).map(($e) => ({
        field: $e,
        label: be($e),
        sortable: !0
      })) : [];
    }
    function be($e) {
      return __(
        $e.replace(/_/g, " ").split(" ").map((ct) => Ie(ct)).join(" ")
      );
    }
    function Ie($e) {
      return {
        id: "ID",
        url: "URL"
      }[$e] || $e.charAt(0).toUpperCase() + $e.slice(1);
    }
    function Se($e) {
      return ye.value.find((ct) => ct.field === $e);
    }
    function ze($e) {
      JSON.stringify($e) !== JSON.stringify(B.value) && (B.value = $e);
    }
    function Ne($e) {
      o.sortable && ke.value.includes($e) && (_.value === $e ? et() : T.value = Qe($e), _.value = $e);
    }
    function tt($e) {
      return B.value.find((ct) => ct.field === $e)?.fieldtype;
    }
    function Qe($e) {
      return tt($e) === "date" ? "desc" : "asc";
    }
    function et() {
      T.value = T.value === "asc" ? "desc" : "asc";
    }
    function ce($e) {
      w.value = $e;
    }
    function pe($e) {
      C.value = $e, o.preferencesPrefix && Statamic.$preferences.set(o.preferencesPrefix + ".per_page", $e);
    }
    function je() {
      let $e = o.perPage;
      return o.preferencesPrefix && ($e = Statamic.$preferences.get(o.preferencesPrefix + ".per_page", $e)), $e;
    }
    function lt($e) {
      M.value = $e;
    }
    function Ce() {
      M.value = null;
    }
    let Oe = null;
    function Te($e, ct) {
      const Je = re.value[$e];
      ct.shiftKey && Oe !== null ? We(Math.min(Oe, $e), Math.max(Oe, $e)) : ot(Je.id), O.value.includes(Je.id) && (Oe = $e);
    }
    function ot($e) {
      const ct = O.value.indexOf($e);
      if (ct > -1) {
        O.value.splice(ct, 1);
        return;
      }
      q.value || O.value.pop(), F.value || O.value.push($e);
    }
    function We($e, ct) {
      for (let Je = $e; Je <= ct; Je++) {
        let wt = re.value[Je].id;
        !O.value.includes(wt) && !F.value && O.value.push(wt);
      }
    }
    function Ge() {
      O.value.splice(0, O.value.length);
    }
    function He($e) {
      g.value = $e || {};
    }
    function me($e, ct) {
      ct ? g.value[$e] = ct : delete g.value[$e];
    }
    function de() {
      g.value = {}, v.value = [];
    }
    function Fe() {
      if (!o.filters || o.filters.length === 0) return;
      let $e = {};
      const ct = (Je) => Array.isArray(Je) ? Je.length === 0 : Object.keys(Je).length === 0;
      o.filters.filter((Je) => !ct(Je.auto_apply)).forEach((Je) => {
        $e[Je.handle] = Je.auto_apply;
      }), He($e);
    }
    function Ze($e) {
      a("reordered", $e);
    }
    return watch(
      () => o.reorderable,
      ($e) => {
        if ($e)
          b.value = {
            filters: g.value,
            search: M.value,
            sort: _.value,
            order: T.value
          }, g.value = o.filtersForReordering ? o.filtersForReordering() : {}, M.value = null, _.value = "order", T.value = "asc", w.value = 1;
        else if (b.value) {
          const { filters: ct, search: Je, sort: wt, order: qe } = b.value;
          g.value = ct, M.value = Je, _.value = wt, T.value = qe, b.value = null;
        }
      }
    ), provideListingContext({
      loading: E,
      refresh: te,
      items: re,
      meta: f,
      columns: B,
      setColumns: ze,
      visibleColumns: ye,
      isColumnVisible: Se,
      hiddenColumns: ve,
      sortColumn: _,
      setSortColumn: Ne,
      selections: O,
      maxSelections: toRef(() => o.maxSelections),
      allowsSelections: I,
      allowsMultipleSelections: q,
      hasReachedSelectionLimit: F,
      selectionClicked: Te,
      selectRange: We,
      toggleSelection: ot,
      clearSelections: Ge,
      actionUrl: toRef(() => o.actionUrl),
      actionContext: toRef(() => o.actionContext),
      showBulkActions: J,
      hasActions: W,
      allowActionsWhileReordering: toRef(() => o.allowActionsWhileReordering),
      perPage: C,
      setPerPage: pe,
      setCurrentPage: ce,
      showPaginationTotals: toRef(() => o.showPaginationTotals),
      showPaginationPageLinks: toRef(() => o.showPaginationPageLinks),
      showPaginationPerPageSelector: toRef(() => o.showPaginationPerPageSelector),
      searchQuery: M,
      setSearchQuery: lt,
      clearSearchQuery: Ce,
      preferencesPrefix: toRef(() => o.preferencesPrefix),
      filters: toRef(() => o.filters),
      activeFilters: g,
      activeFilterBadges: v,
      activeFilterBadgeCount: Q,
      setFilter: me,
      setFilters: He,
      clearFilters: de,
      reorderable: toRef(() => o.reorderable),
      reordered: Ze
    }), t({
      refresh: te,
      setFilter: me
    }), watch(X, ($e, ct) => {
      JSON.stringify($e) !== JSON.stringify(ct) && (Be(), G());
    }), watch(E, ($e) => Statamic.$progress.loading(u, $e)), onMounted(() => {
      o.pushQuery && (window.history.replaceState({ parameters: X.value }, ""), window.addEventListener("popstate", ie));
    }), onBeforeUnmount(() => {
      o.pushQuery && window.removeEventListener("popstate", ie);
    }), Fe(), o.items ? (re.value = o.items, k.value = !1, E.value = !1) : Be(), oe(), ($e, ct) => {
      const Je = resolveComponent("ui-skeleton");
      return openBlock(), createElementBlock(Fragment, null, [
        k.value ? renderSlot($e.$slots, "initializing", { key: 0 }, () => [
          createElementVNode("div", _hoisted_1$t, [
            createVNode(Je, { class: "h-3 w-48" }),
            createElementVNode("div", _hoisted_2$d, [
              createVNode(Je, { class: "h-8 w-80" }),
              createVNode(Je, { class: "h-8 w-24" }),
              ct[0] || (ct[0] = createElementVNode("div", { class: "flex-1" }, null, -1)),
              createVNode(Je, { class: "size-8" })
            ]),
            createVNode(Je, { class: "h-48 w-full" })
          ])
        ]) : createCommentVNode("", !0),
        k.value ? createCommentVNode("", !0) : renderSlot($e.$slots, "default", {
          key: 1,
          items: re.value,
          isColumnVisible: Se,
          loading: E.value
        }, () => [
          Z.value ? (openBlock(), createBlock(_sfc_main$12, { key: 0 })) : createCommentVNode("", !0),
          e.allowSearch || K.value || e.allowCustomizingColumns ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
            createElementVNode("div", _hoisted_4$4, [
              e.allowSearch ? (openBlock(), createBlock(_sfc_main$11, { key: 0 })) : createCommentVNode("", !0),
              K.value ? (openBlock(), createBlock(_sfc_main$Z, { key: 1 })) : createCommentVNode("", !0)
            ]),
            e.allowCustomizingColumns ? (openBlock(), createBlock(_sfc_main$14, { key: 0 })) : createCommentVNode("", !0)
          ])) : createCommentVNode("", !0),
          re.value.length ? (openBlock(), createBlock(unref(_sfc_main$A), {
            key: 3,
            class: "relative overflow-x-auto overscroll-x-contain"
          }, {
            default: withCtx(() => [
              createVNode(_sfc_main$P, null, createSlots({ _: 2 }, [
                renderList(ne.value, (wt, qe) => ({
                  name: qe,
                  fn: withCtx(($t) => [
                    (openBlock(), createBlock(resolveDynamicComponent(wt), normalizeProps(guardReactiveProps($t)), null, 16))
                  ])
                })),
                $e.$slots["prepended-row-actions"] ? {
                  name: "prepended-row-actions",
                  fn: withCtx(({ row: wt }) => [
                    renderSlot($e.$slots, "prepended-row-actions", { row: wt })
                  ]),
                  key: "0"
                } : void 0
              ]), 1024),
              f.value ? (openBlock(), createBlock(unref(PanelFooter), { key: 0 }, {
                default: withCtx(() => [
                  createVNode(_sfc_main$Y)
                ]),
                _: 1
              })) : createCommentVNode("", !0)
            ]),
            _: 3
          })) : (openBlock(), createElementBlock("div", {
            key: 2,
            class: "rounded-lg border border-dashed border-gray-300 dark:border-gray-700 p-6 text-center text-gray-500",
            textContent: toDisplayString($e.__("No results"))
          }, null, 8, _hoisted_5$3))
        ]),
        J.value ? (openBlock(), createBlock(_sfc_main$15, { key: 2 })) : createCommentVNode("", !0)
      ], 64);
    };
  }
}, _sfc_main$N = {
  __name: "Resizer",
  emits: ["resize-start", "resize-end", "resized", "collapsed"],
  setup(e, { emit: t }) {
    const n = t;
    function a() {
      n("resize-start"), window.addEventListener("mousemove", s), window.addEventListener("mouseup", o);
    }
    function o() {
      n("resize-end"), window.removeEventListener("mousemove", s, !1), window.removeEventListener("mouseup", o, !1);
    }
    function s(u) {
      u.preventDefault();
      let d = u.clientX;
      if (d < 16) return n("collapsed");
      d = d < 350 ? 350 : d, n("resized", d);
    }
    return (u, d) => (openBlock(), createElementBlock("div", {
      class: "live-preview-resizer",
      onMousedown: a
    }, null, 32));
  }
};
class Component {
  constructor(t, n, a) {
    this.id = t, this.name = n, this.props = a, this.events = {};
  }
  prop(t, n) {
    this.props[t] = n;
  }
  on(t, n) {
    this.events[t] = n;
  }
  destroy() {
    Statamic.$components.destroy(this.id);
  }
}
const [injectTabContext, provideTabContext] = createContext$1("PublishTab"), _sfc_main$M = {
  __name: "TabProvider",
  props: {
    tab: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    return provideTabContext(e.tab), (n, a) => renderSlot(n.$slots, "default");
  }
}, _sfc_main$L = {
  components: {
    Button,
    Dropdown: _sfc_main$1n,
    DropdownMenu,
    DropdownItem: _sfc_main$1m
  },
  props: {
    actions: {
      type: Array
    }
  }
}, _hoisted_1$s = { class: "field-dropdown relative -top-0.5" }, _hoisted_2$c = { class: "quick-list" }, _hoisted_3$5 = { class: "quick-list-content" };
function _sfc_render$8(e, t, n, a, o, s) {
  const u = resolveComponent("ui-icon"), d = resolveComponent("Button"), f = resolveComponent("DropdownItem"), g = resolveComponent("DropdownMenu"), v = resolveComponent("Dropdown"), b = resolveDirective("tooltip");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [
    createElementVNode("div", _hoisted_2$c, [
      createElementVNode("div", _hoisted_3$5, [
        (openBlock(!0), createElementBlock(Fragment, null, renderList(n.actions.filter((w) => w.quick), (w, C) => withDirectives((openBlock(), createBlock(d, {
          key: C,
          onClick: (k) => w.run(),
          "icon-only": !0,
          size: "xs",
          variant: "ghost",
          "aria-label": w.title,
          tabindex: "-1"
        }, {
          default: withCtx(() => [
            createVNode(u, {
              name: w.icon,
              class: "size-3.5"
            }, null, 8, ["name"])
          ]),
          _: 2
        }, 1032, ["onClick", "aria-label"])), [
          [b, w.title]
        ])), 128))
      ]),
      createVNode(v, null, {
        trigger: withCtx(() => [
          createVNode(d, {
            icon: "ui/dots",
            variant: "ghost",
            size: "xs",
            "aria-label": e.__("Open dropdown menu")
          }, null, 8, ["aria-label"])
        ]),
        default: withCtx(() => [
          createVNode(g, null, {
            default: withCtx(() => [
              (openBlock(!0), createElementBlock(Fragment, null, renderList(n.actions, (w) => (openBlock(), createBlock(f, {
                key: w.handle || w.title,
                text: w.title,
                variant: w.dangerous ? "destructive" : "default",
                "aria-label": w.title,
                onClick: (C) => w.run(w)
              }, null, 8, ["text", "variant", "aria-label", "onClick"]))), 128))
            ]),
            _: 1
          })
        ]),
        _: 1
      })
    ])
  ]);
}
const FieldActions = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$8]]), KEYS = [
  "if",
  "if_any",
  "show_when",
  "show_when_any",
  "unless",
  "unless_any",
  "hide_when",
  "hide_when_any"
], OPERATORS = ["equals", "not", "contains", "contains_any", "===", "!==", ">", ">=", "<", "<=", "custom"], ALIASES = {
  is: "equals",
  "==": "equals",
  isnt: "not",
  "!=": "not",
  includes: "contains",
  includes_any: "contains_any"
};
class Converter {
  fromBlueprint(t, n = null) {
    return Object.entries(t).map(([a, o]) => this.splitRhs(a, o, n));
  }
  toBlueprint(t) {
    let n = {};
    return t.forEach((a) => {
      n[a.field] = this.combineRhs(a);
    }), n;
  }
  splitRhs(t, n, a = null) {
    return {
      field: this.getScopedFieldHandle(t, a),
      operator: this.getOperatorFromRhs(n),
      value: this.getValueFromRhs(n)
    };
  }
  getScopedFieldHandle(t, n) {
    return t.startsWith("$root.") || t.startsWith("root.") || t.startsWith("$parent.") ? t : n ? n + t : t;
  }
  getOperatorFromRhs(t) {
    let n = "==";
    return this.getOperatorsAndAliases().filter((a) => new RegExp(`^${a} [^=]`).test(this.normalizeConditionString(t))).forEach((a) => n = a), this.normalizeOperator(n);
  }
  normalizeOperator(t) {
    return ALIASES[t] ? ALIASES[t] : t;
  }
  getValueFromRhs(t) {
    let n = this.normalizeConditionString(t);
    return this.getOperatorsAndAliases().filter((a) => new RegExp(`^${a} [^=]`).test(n)).forEach((a) => n = n.replace(new RegExp(`^${a}[ ]*`), "")), n;
  }
  combineRhs(t) {
    let n = t.operator ? t.operator.trim() : "", a = t.value.trim();
    return `${n} ${a}`.trim();
  }
  getOperatorsAndAliases() {
    return OPERATORS.concat(Object.keys(ALIASES));
  }
  normalizeConditionString(t) {
    return t === null ? "null" : t === "" ? "empty" : t.toString();
  }
}
class ParentResolver {
  constructor(t) {
    this.currentFieldPath = t;
  }
  resolve(t) {
    let n = this.getParentFieldPath(this.currentFieldPath, !0), a = this.removeOneParentKeyword(t);
    for (; a.startsWith("$parent."); )
      n = this.getParentFieldPath(n), a = this.removeOneParentKeyword(a);
    return `$root.${n ? `${n}.${a}` : a}`;
  }
  getParentFieldPath(t, n) {
    const a = new RegExp("(.*?[^\\.]+)(\\.[0-9]+)*\\.[^\\.]*$");
    return (n || this.isAtSetLevel(t)) && (t = t.replace(a, "$1")), t.includes(".") ? t.replace(a, "$1$2") : "";
  }
  isAtSetLevel(t) {
    return t.match(new RegExp("(\\.[0-9]+)$"));
  }
  removeOneParentKeyword(t) {
    return t.replace(new RegExp("^\\$parent."), "");
  }
}
const translate = function(e, t) {
  let n = getLine(e);
  for (let a in t)
    n = n.split(":" + a).join(t[a]);
  return n;
}, getLine = function(e) {
  const t = Statamic.$config.get("translations");
  return t[`*.${e}`] || t[e] || t[`statamic::${e}`] || t[`statamic::messages.${e}`] || e;
};
function data_get$1(e, t, n = null) {
  var a = Array.isArray(t) ? t : t.split("."), o = a.reduce((s, u) => s && s[u], e);
  return o !== void 0 ? o : n;
}
function data_set$1(e, t, n) {
  for (var a = t.split("."); a.length - 1; ) {
    var o = a.shift(), s = a.length ? new RegExp("^[0-9]+$").test(a[0]) : !1;
    o in e || (e[o] = s ? [] : {}), e = e[o];
  }
  e[a[0]] = n;
}
function clone$1(e) {
  if (e !== void 0)
    return JSON.parse(JSON.stringify(e));
}
function __$1(e, t) {
  return translate(e, t);
}
const NUMBER_SPECIFIC_COMPARISONS = [">", ">=", "<", "<="], isEmpty = (e) => e == null ? !0 : Array.isArray(e) ? e.length === 0 : Object.keys(e).length === 0, isString = (e) => e != null && typeof e.valueOf() == "string";
class Validator {
  constructor(e, t, n, a, o, s) {
    this.field = e, this.values = t, this.currentFieldPath = a, this.revealerFields = o, this.extraPayload = s, this.rootValues = n || !1, this.passOnAny = !1, this.showOnPass = !0, this.converter = new Converter();
  }
  usingRootValues() {
    if (!this.currentFieldPath)
      throw new Error("[currentFieldPath] constructor param required for `usingRootValues()`");
    return this.rootValues = this.values, this.currentFieldPath.includes(".") ? this.scopeValuesToParent() : this;
  }
  passesConditions(e) {
    let t = e || this.getConditions();
    if (t === void 0)
      return !0;
    if (this.isCustomConditionWithoutTarget(t))
      return this.passesCustomCondition(this.prepareCondition(t));
    let n = this.passOnAny ? this.passesAnyConditions(t) : this.passesAllConditions(t);
    return this.showOnPass ? n : !n;
  }
  getConditions() {
    let e = KEYS.filter((n) => this.field[n])[0];
    if (!e)
      return;
    e.includes("any") && (this.passOnAny = !0), (e.includes("unless") || e.includes("hide_when")) && (this.showOnPass = !1);
    let t = this.field[e];
    return this.isCustomConditionWithoutTarget(t) ? t : this.converter.fromBlueprint(t, this.field.prefix);
  }
  isCustomConditionWithoutTarget(e) {
    return isString(e);
  }
  passesAllConditions(e) {
    return isEmpty(
      e.map((t) => this.prepareCondition(t)).filter((t) => !this.passesCondition(t))
    );
  }
  passesAnyConditions(e) {
    return !isEmpty(
      e.map((t) => this.prepareCondition(t)).filter((t) => this.passesCondition(t))
    );
  }
  prepareCondition(e) {
    if (isString(e) || e.operator === "custom")
      return this.prepareCustomCondition(e);
    let t = this.prepareOperator(e.operator), n = this.prepareLhs(e.field, t), a = this.prepareRhs(e.value, t);
    return { lhs: n, operator: t, rhs: a };
  }
  prepareOperator(e) {
    switch (e) {
      case null:
      case "":
      case "is":
      case "equals":
        return "==";
      case "isnt":
      case "not":
      case "\\_()_/":
        return "!=";
      case "includes":
      case "contains":
        return "includes";
      case "includes_any":
      case "contains_any":
        return "includes_any";
    }
    return e;
  }
  prepareLhs(e, t) {
    let n = this.getFieldValue(e);
    return NUMBER_SPECIFIC_COMPARISONS.includes(t) ? Number(n) : t === "includes" && !isObject(n) ? n ? n.toString() : "" : (isString(n) && isEmpty(n) && (n = null), isString(n) ? JSON.stringify(n.trim()) : n);
  }
  prepareRhs(e, t) {
    switch (e) {
      case "null":
        return null;
      case "true":
        return !0;
      case "false":
        return !1;
    }
    return NUMBER_SPECIFIC_COMPARISONS.includes(t) ? Number(e) : e === "empty" || t === "includes" || t === "includes_any" ? e : isString(e) ? JSON.stringify(e.trim()) : e;
  }
  prepareCustomCondition(e) {
    let t = this.prepareFunctionName(e.value || e), n = this.prepareParams(e.value || e), a = e.field ? this.getFieldValue(e.field) : null, o = e.field;
    return { functionName: t, params: n, target: a, targetHandle: o };
  }
  prepareFunctionName(e) {
    return e.replace(new RegExp("^custom "), "").split(":")[0];
  }
  prepareParams(e) {
    let t = e.split(":")[1];
    return t ? t.split(",").map((n) => n.trim()) : [];
  }
  getFieldValue(e) {
    return e.startsWith("$parent.") && (e = new ParentResolver(this.currentFieldPath).resolve(e)), e.startsWith("$root.") || e.startsWith("root.") ? data_get$1(this.rootValues, e.replace(new RegExp("^\\$?root\\."), "")) : data_get$1(this.values, e);
  }
  passesCondition(condition) {
    return condition.functionName ? this.passesCustomCondition(condition) : condition.operator === "includes" ? this.passesIncludesCondition(condition) : condition.operator === "includes_any" ? this.passesIncludesAnyCondition(condition) : (condition.rhs === "empty" && (condition.lhs = isEmpty(condition.lhs), condition.rhs = !0), isObject(condition.lhs) ? !1 : eval(`${condition.lhs} ${condition.operator} ${condition.rhs}`));
  }
  passesIncludesCondition(e) {
    return e.lhs.includes(e.rhs);
  }
  passesIncludesAnyCondition(e) {
    let t = e.rhs.split(",").map((n) => n.trim());
    return Array.isArray(e.lhs) ? intersection(e.lhs, t).length : new RegExp(t.join("|")).test(e.lhs);
  }
  passesCustomCondition(e) {
    let t = Statamic.$conditions.get(e.functionName);
    if (typeof t != "function")
      return console.error(`Statamic field condition [${e.functionName}] was not properly defined.`), !1;
    let n = t({
      params: e.params,
      target: e.target,
      targetHandle: e.targetHandle,
      values: this.values,
      root: this.rootValues,
      fieldPath: this.currentFieldPath,
      ...this.extraPayload
    });
    return this.showOnPass ? n : !n;
  }
  passesNonRevealerConditions(e) {
    let t = this.getConditions();
    if (this.isCustomConditionWithoutTarget(t))
      return this.passesConditions(t);
    let n = this.revealerFields || [], a = (this.getConditions() ?? []).filter(
      (o) => !n.includes(this.relativeLhsToAbsoluteFieldPath(o.field, e))
    );
    return this.passesConditions(a);
  }
  relativeLhsToAbsoluteFieldPath(e, t) {
    return e.startsWith("$parent.") && (e = new ParentResolver(this.currentFieldPath).resolve(e)), e.startsWith("$root.") || e.startsWith("root.") ? e.replace(new RegExp("^\\$?root\\."), "") : t ? t + "." + e : e;
  }
  scopeValuesToParent() {
    let e = this.currentFieldPath.replace(new RegExp(".[^.]+$"), "");
    return this.values = data_get$1(this.rootValues, e), this;
  }
}
class ShowField {
  constructor(t, n, a, o, s, u, d) {
    this.values = t, this.extraValues = { ...n, ...o }, this.rootValues = a, this.revealerValues = o, this.hiddenFields = s, this.setHiddenField = u, this.extraPayload = d || {};
  }
  showField(t, n) {
    let a = n || t.handle, o = n && n.includes(".") ? n.replace(new RegExp("." + t.handle + "$"), "") : "";
    if (t.visibility === "hidden" || this.shouldForceHiddenField(a))
      return this.setHiddenFieldState({
        dottedKey: a,
        hidden: "force",
        omitValue: !1
      }), !1;
    let s = new Validator(t, { ...this.values, ...this.extraValues }, this.rootValues, a, Object.keys(this.revealerValues), this.extraPayload), u = s.passesConditions();
    return t.always_save === !0 ? (this.setHiddenFieldState({
      dottedKey: a,
      hidden: !u,
      omitValue: !1
    }), u) : (nextTick(() => {
      this.setHiddenFieldState({
        dottedKey: a,
        hidden: !u,
        omitValue: t.type === "revealer" || !s.passesNonRevealerConditions(o)
      });
    }), u);
  }
  setHiddenFieldState({ dottedKey: t, hidden: n, omitValue: a }) {
    const o = this.hiddenFields[t];
    o && o.hidden === n && o.omitValue === a || this.setHiddenField({
      dottedKey: t,
      hidden: n,
      omitValue: a
    });
  }
  shouldForceHiddenField(t) {
    return data_get$1(this.hiddenFields[t], "hidden") === "force";
  }
}
const _hoisted_1$r = {
  key: 0,
  class: "text-xs text-red-600"
}, _hoisted_2$b = ["textContent"], namePrefix = "", _sfc_main$K = {
  __name: "Field",
  props: {
    config: {
      type: Object,
      required: !0
    }
  },
  setup(e) {
    const t = e, {
      values: n,
      extraValues: a,
      visibleValues: o,
      revealerValues: s,
      meta: u,
      syncField: d,
      desyncField: f,
      isTrackingOriginValues: g,
      originValues: v,
      asConfig: b,
      errors: w,
      readOnly: C,
      setFieldPreviewValue: k,
      localizedFields: E,
      setFieldValue: A,
      setFieldMeta: P,
      hiddenFields: M,
      setHiddenField: B,
      container: _
    } = injectContainerContext(), { fieldPathPrefix: T, metaPathPrefix: O } = injectFieldsContext(), I = t.config.handle, q = computed(() => `${t.config.component || t.config.type}-fieldtype`), F = computed(() => Statamic.$app.component(q.value) !== void 0), W = computed(() => [T.value, I].filter(Boolean).join(".")), K = computed(() => [O.value, I].filter(Boolean).join(".")), Z = computed(() => data_get(n.value, W.value)), J = computed(() => {
      const Ce = [O.value, I].filter(Boolean).join(".");
      return data_get(u.value, Ce);
    }), re = ref();
    watch(
      () => w.value,
      (Ce) => re.value = Ce[W.value] || [],
      { immediate: !0 }
    );
    const V = computed(() => `field_${W.value.replaceAll(".", "_")}`), ne = computed(() => t.config.required), Q = useTemplateRef("fieldtype"), z = computed(() => Q.value ? Q.value.fieldActions : []), X = computed(() => t.config.actions && z.value?.length > 0);
    function ue(Ce) {
      const Oe = data_get(n.value, W.value);
      Ce !== Oe && (A(W.value, Ce), pe());
    }
    function Be(Ce) {
      P(K.value, Ce);
    }
    function te(Ce) {
      k(W.value, Ce);
    }
    function G() {
    }
    function ie() {
    }
    computed(() => T.value ? data_get(n.value, T.value) : n.value);
    const oe = computed(() => T.value ? data_get(o.value, T.value) : o.value), ye = computed(() => T.value ? data_get(a.value, T.value) : a.value), ve = computed(() => new ShowField(
      oe.value,
      ye.value,
      o.value,
      s.value,
      M.value,
      B,
      { container: _ }
    ).showField(t.config, W.value)), ke = computed(() => !t.config.hide_display), Ae = computed(
      () => ke.value || // Need to see the text
      ze.value || // Need to see the avatar
      Ne.value
      // Need to see the icon
    ), be = computed(() => t.config.replicator_preview ? inject("showReplicatorFieldPreviews", !1) : !1), Ie = computed(() => t.config.localizable), Se = computed(() => C.value || g.value && Ne.value && !Ie.value ? !0 : ze.value || t.config.visibility === "read_only" || !1), ze = computed(() => !1), Ne = computed(() => Qe.value ? !1 : g.value && v.value.hasOwnProperty(W.value)), tt = computed(() => Ne.value && !E.value.includes(W.value)), Qe = computed(() => W.value.includes(".")), et = computed(() => t.config.type === "dictionary_fields" ? "div" : b.value && !Qe.value ? "card" : "div");
    function ce() {
      d(W.value);
    }
    function pe() {
      f(W.value);
    }
    const je = computed(() => ({
      id: V.value,
      config: t.config,
      value: Z.value,
      meta: J.value,
      handle: I,
      namePrefix,
      fieldPathPrefix: T.value,
      metaPathPrefix: O.value,
      readOnly: Se.value,
      showFieldPreviews: be.value
    })), lt = computed(() => ({
      "update:value": ue,
      "update:meta": Be,
      focus: G,
      blur: ie,
      replicatorPreviewUpdated: te
    }));
    return (Ce, Oe) => {
      const Te = resolveComponent("ui-button"), ot = resolveDirective("tooltip");
      return renderSlot(Ce.$slots, "default", {
        fieldtypeComponent: q.value,
        fieldtypeComponentProps: je.value,
        fieldtypeComponentEvents: lt.value
      }, () => [
        withDirectives(createVNode(unref(_sfc_main$1e), mergeProps({
          class: `${e.config.type}-fieldtype`,
          id: V.value,
          instructions: e.config.instructions,
          "instructions-below": e.config.instructions_position === "below",
          required: ne.value,
          errors: re.value,
          "read-only": Se.value,
          as: et.value,
          variant: e.config.variant
        }, Ce.$attrs), createSlots({
          default: withCtx(() => [
            F.value ? createCommentVNode("", !0) : (openBlock(), createElementBlock("div", _hoisted_1$r, [
              Oe[0] || (Oe[0] = createTextVNode(" Component ", -1)),
              createElementVNode("code", {
                textContent: toDisplayString(q.value)
              }, null, 8, _hoisted_2$b),
              Oe[1] || (Oe[1] = createTextVNode(" does not exist. ", -1))
            ])),
            (openBlock(), createBlock(resolveDynamicComponent(q.value), mergeProps({
              ref_key: "fieldtype",
              ref: Q
            }, je.value, toHandlers(lt.value)), null, 16))
          ]),
          _: 2
        }, [
          Ae.value ? {
            name: "label",
            fn: withCtx(() => [
              createVNode(unref(_sfc_main$18), {
                for: V.value,
                required: ne.value
              }, {
                default: withCtx(() => [
                  ke.value ? (openBlock(), createBlock(unref(_sfc_main$2), {
                    key: 0,
                    text: e.config.handle,
                    delay: 1e3
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(Ce.__(e.config.display)), 1)
                    ]),
                    _: 1
                  }, 8, ["text"])) : createCommentVNode("", !0),
                  !Se.value && Ne.value ? withDirectives((openBlock(), createBlock(Te, {
                    key: 1,
                    size: "xs",
                    inset: "",
                    icon: "synced",
                    variant: "ghost",
                    onClick: pe
                  }, null, 512)), [
                    [ot, Ce.__("messages.field_synced_with_origin")],
                    [vShow, tt.value]
                  ]) : createCommentVNode("", !0),
                  !Se.value && Ne.value ? withDirectives((openBlock(), createBlock(Te, {
                    key: 2,
                    size: "xs",
                    inset: "",
                    icon: "unsynced",
                    variant: "ghost",
                    onClick: ce
                  }, null, 512)), [
                    [ot, Ce.__("messages.field_desynced_from_origin")],
                    [vShow, !tt.value]
                  ]) : createCommentVNode("", !0)
                ]),
                _: 1
              }, 8, ["for", "required"])
            ]),
            key: "0"
          } : void 0,
          X.value ? {
            name: "actions",
            fn: withCtx(() => [
              createVNode(FieldActions, { actions: z.value }, null, 8, ["actions"])
            ]),
            key: "1"
          } : void 0
        ]), 1040, ["class", "id", "instructions", "instructions-below", "required", "errors", "read-only", "as", "variant"]), [
          [vShow, ve.value]
        ])
      ]);
    };
  }
}, _sfc_main$J = {
  __name: "Fields",
  setup(e) {
    const { asConfig: t } = injectContainerContext(), { fields: n, fieldPathPrefix: a } = injectFieldsContext(), o = computed(() => (a.value ?? "").includes("."));
    return (s, u) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(t) && !o.value ? "publish-fields-fluid" : "publish-fields")
    }, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(n), (d) => (openBlock(), createBlock(_sfc_main$K, {
        key: d.handle,
        config: d,
        class: normalizeClass(`form-group field-w-${d.width}`)
      }, null, 8, ["config", "class"]))), 128))
    ], 2));
  }
}, _hoisted_1$q = { class: "p-px" }, _sfc_main$I = {
  __name: "Sections",
  setup(e) {
    const { blueprint: t, container: n, visibleValues: a, extraValues: o, revealerValues: s, asConfig: u, hiddenFields: d, setHiddenField: f } = injectContainerContext(), v = injectTabContext().sections, b = computed(() => v.filter((k) => k.fields.some((E) => new ShowField(
      a.value,
      o.value,
      a.value,
      s.value,
      d.value,
      f,
      { container: n }
    ).showField(E, E.handle))));
    function w(k) {
      return k ? markdown$1(__(k), { openLinksInNewTabs: !0 }) : "";
    }
    function C(k) {
      v[k].collapsible && (v[k].collapsed = !v[k].collapsed);
    }
    return (k, E) => (openBlock(), createElementBlock("div", null, [
      (openBlock(!0), createElementBlock(Fragment, null, renderList(b.value, (A, P) => (openBlock(), createBlock(unref(_sfc_main$A), {
        key: P,
        class: normalizeClass([
          unref(u) ? "mb-12" : "mb-6",
          { "pb-0": A.collapsed }
        ])
      }, {
        default: withCtx(() => [
          A.display || A.collapsible ? (openBlock(), createBlock(unref(_sfc_main$y), {
            key: 0,
            onClick: (M) => C(P),
            class: "flex justify-between"
          }, {
            default: withCtx(() => [
              createElementVNode("div", null, [
                createVNode(unref(_sfc_main$1b), {
                  text: k.__(A.display)
                }, null, 8, ["text"]),
                A.instructions ? (openBlock(), createBlock(unref(_sfc_main$i), {
                  key: 0,
                  text: w(A.instructions)
                }, null, 8, ["text"])) : createCommentVNode("", !0)
              ]),
              A.collapsible ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                key: 0,
                name: "ui/chevron-down",
                class: normalizeClass(["size-5 text-gray-400", A.collapsed ? "rotate-270" : "rotate-0"])
              }, null, 8, ["class"])) : createCommentVNode("", !0)
            ]),
            _: 2
          }, 1032, ["onClick"])) : createCommentVNode("", !0),
          createElementVNode("div", {
            style: { "--tw-ease": "ease" },
            class: normalizeClass(["h-auto overflow-clip visible transition-[height,visibility] duration-[250ms,2s]", { "h-0! visibility-hidden": A.collapsed }])
          }, [
            createElementVNode("div", _hoisted_1$q, [
              createVNode(unref(Primitive), {
                as: unref(u) ? "div" : unref(_sfc_main$1J)
              }, {
                default: withCtx(() => [
                  createVNode(_sfc_main$1d, {
                    fields: A.fields
                  }, {
                    default: withCtx(() => [
                      renderSlot(k.$slots, "default", { section: A }, () => [
                        createVNode(_sfc_main$J)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["fields"])
                ]),
                _: 2
              }, 1032, ["as"])
            ])
          ], 2)
        ]),
        _: 2
      }, 1032, ["class"]))), 128))
    ]));
  }
}, _hoisted_1$p = {
  key: 2,
  class: "space-y-6"
}, _sfc_main$H = {
  __name: "Tabs",
  setup(e) {
    const t = useSlots(), { blueprint: n, visibleValues: a, extraValues: o, revealerValues: s, errors: u, hiddenFields: d, setHiddenField: f, container: g } = injectContainerContext(), v = ref(n.value.tabs), b = ref(null), w = computed(() => v.value.find((T) => T.handle === "sidebar")), C = computed(
      () => E.value && w.value ? v.value.filter((T) => T.handle !== "sidebar") : v.value
    ), k = computed(() => C.value.filter((T) => T.sections.some((O) => O.fields.some((I) => new ShowField(
      a.value,
      o.value,
      a.value,
      s.value,
      d.value,
      f,
      { container: g }
    ).showField(I, I.handle))))), E = computed(() => (t.sidebar || w.value) && b.value > 920), A = ref(k.value[0].handle);
    onMounted(() => P());
    function P() {
      if (window.location.hash.length === 0) return;
      const T = window.location.hash.substr(1);
      k.value.some((O) => O.handle === T) ? A.value = T : A.value = k.value[0].handle;
    }
    watch(
      () => A.value,
      (T) => window.location.hash = T
    );
    const M = computed(() => {
      let T = {};
      return Object.values(v.value).forEach((O) => {
        O.sections.forEach((I) => {
          I.fields.forEach((q) => {
            T[q.handle] = O.handle;
          });
        });
      }), T;
    }), B = computed(() => [
      ...new Set(
        Object.keys(u.value).map((T) => T.split(".")[0]).filter((T) => M.value[T]).map((T) => M.value[T])
      )
    ]);
    function _(T) {
      return B.value.includes(T.handle);
    }
    return (T, O) => (openBlock(), createBlock(_sfc_main$1C, {
      onResized: O[1] || (O[1] = (I) => b.value = I.width)
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$8), {
          modelValue: A.value,
          "onUpdate:modelValue": O[0] || (O[0] = (I) => A.value = I)
        }, {
          default: withCtx(() => [
            k.value.length > 1 ? (openBlock(), createBlock(unref(_sfc_main$9), {
              key: 0,
              class: "mb-6"
            }, {
              default: withCtx(() => [
                (openBlock(!0), createElementBlock(Fragment, null, renderList(k.value, (I) => (openBlock(), createBlock(unref(_sfc_main$7), {
                  key: I.handle,
                  name: I.handle,
                  text: T.__(I.display),
                  class: normalizeClass({ "!text-red-600": _(I) })
                }, null, 8, ["name", "text", "class"]))), 128))
              ]),
              _: 1
            })) : createCommentVNode("", !0),
            createElementVNode("div", {
              class: normalizeClass({ "grid grid-cols-[1fr_320px] gap-8": E.value })
            }, [
              k.value.length > 1 ? (openBlock(!0), createElementBlock(Fragment, { key: 0 }, renderList(C.value, (I) => (openBlock(), createBlock(unref(_sfc_main$g), {
                key: I.handle,
                name: I.handle
              }, {
                default: withCtx(() => [
                  createVNode(_sfc_main$M, { tab: I }, {
                    default: withCtx(() => [
                      renderSlot(T.$slots, "default", { tab: I }, () => [
                        createVNode(_sfc_main$I)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["tab"])
                ]),
                _: 2
              }, 1032, ["name"]))), 128)) : (openBlock(), createBlock(_sfc_main$M, {
                key: 1,
                tab: k.value[0]
              }, {
                default: withCtx(() => [
                  renderSlot(T.$slots, "default", {
                    tab: k.value[0]
                  }, () => [
                    createVNode(_sfc_main$I)
                  ])
                ]),
                _: 3
              }, 8, ["tab"])),
              E.value ? (openBlock(), createElementBlock("aside", _hoisted_1$p, [
                renderSlot(T.$slots, "actions"),
                w.value ? (openBlock(), createBlock(_sfc_main$M, {
                  key: 0,
                  tab: w.value
                }, {
                  default: withCtx(() => [
                    createVNode(_sfc_main$I)
                  ]),
                  _: 1
                }, 8, ["tab"])) : createCommentVNode("", !0)
              ])) : createCommentVNode("", !0)
            ], 2)
          ]),
          _: 3
        }, 8, ["modelValue"])
      ]),
      _: 3
    }));
  }
};
function data_delete(e, t) {
  for (var n = t.split("."); n.length - 1; ) {
    var a = n.shift(), o = n.length ? new RegExp("^[0-9]+$").test(n[0]) : !1;
    a in e || (e[a] = o ? [] : {}), e = e[a];
  }
  delete e[n[0]];
}
class Values {
  constructor(t, n) {
    this.values = clone$1(t), this.jsonFields = clone$1(n || []).filter((a, o) => n.indexOf(a) === o).sort();
  }
  get(t) {
    let n = new this.constructor(clone$1(this.values), this.jsonFields).jsonDecode().values;
    return data_get$1(n, t);
  }
  set(t, n) {
    return this.jsonDecode().setValue(t, n).jsonEncode(), this;
  }
  mergeDottedKeys(t, n) {
    let a = new this.constructor(clone$1(n.values), n.jsonFields).jsonDecode().values;
    return this.jsonDecode(), t.forEach((o) => {
      data_set$1(this.values, o, data_get$1(a, o));
    }), this.jsonEncode(), this;
  }
  except(t) {
    return this.jsonDecode().rejectValuesByKey(t).jsonEncode().all();
  }
  all() {
    return this.values;
  }
  jsonDecode() {
    return this.jsonFields.forEach((t) => {
      this.jsonDecodeValue(t);
    }), this;
  }
  jsonEncode() {
    return clone$1(this.jsonFields).reverse().forEach((t) => {
      this.jsonEncodeValue(t);
    }), this;
  }
  dottedKeyToJsPath(t) {
    return t.split(".").map((n) => new RegExp(/^\d+.*/).test(n) ? '["' + n + '"]' : n).join(".").replace(/\.\[/g, "[");
  }
  missingValue(t) {
    var n = Array.isArray(t) ? t : t.split("."), a = n.reduce((o, s) => o && o[s], clone$1(this.values));
    return a === void 0;
  }
  jsonDecodeValue(t) {
    if (this.missingValue(t)) return;
    let n = clone$1(this.values), a = data_get$1(n, t), o = JSON.parse(a);
    data_set$1(n, t, o), this.values = n;
  }
  jsonEncodeValue(t) {
    if (this.missingValue(t)) return;
    let n = clone$1(this.values), a = data_get$1(n, t), o = JSON.stringify(a);
    data_set$1(n, t, o), this.values = n;
  }
  setValue(t, n) {
    return data_set$1(this.values, t, n), this;
  }
  rejectValuesByKey(t) {
    return t.forEach((n) => {
      this.forgetValue(n);
    }), this;
  }
  forgetValue(t) {
    if (this.missingValue(t)) return;
    let n = clone$1(this.values);
    data_delete(n, t), this.values = n;
  }
}
const [injectContainerContext, provideContainerContext, containerContextKey] = createContext$1("PublishContainer"), _sfc_main$G = {
  __name: "Container",
  props: {
    name: {
      type: String,
      default: () => uniqid()
    },
    reference: {
      type: String
    },
    blueprint: {
      type: Object
    },
    modelValue: {
      type: Object,
      default: () => ({})
    },
    extraValues: {
      type: Object,
      default: () => ({})
    },
    meta: {
      type: Object,
      default: () => ({})
    },
    originValues: {
      type: Object
    },
    originMeta: {
      type: Object
    },
    errors: {
      type: Object,
      default: () => ({})
    },
    site: {
      type: String
    },
    modifiedFields: {
      type: Array
    },
    trackDirtyState: {
      type: Boolean,
      default: !0
    },
    syncFieldConfirmationText: {
      type: String,
      default: () => __("Are you sure?")
    },
    readOnly: {
      type: Boolean,
      default: !1
    },
    asConfig: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["update:modelValue", "update:visibleValues", "update:modifiedFields"],
  setup(e, { expose: t, emit: n }) {
    const a = n, o = e, s = injectContainerContext(containerContextKey), u = ref(o.modelValue), d = ref(o.extraValues), f = ref({}), g = ref([]), v = ref(o.meta), b = ref({}), w = ref(o.modifiedFields || []), C = ref([]), k = computed(() => {
      const z = Object.keys(f.value).filter(
        (X) => f.value[X].omitValue
      );
      return new Values(u.value).except(z);
    }), E = computed(() => g.value.reduce((z, X) => (z[X] = data_get$1(u.value, X), z), {})), A = (z) => {
      f.value[z.dottedKey] = {
        hidden: z.hidden,
        omitValue: z.omitValue
      };
    }, P = (z) => {
      g.value.includes(z) || g.value.push(z);
    }, M = (z) => {
      const X = g.value.indexOf(z);
      X !== -1 && g.value.splice(X, 1);
    }, B = (z, X) => {
      data_set(b.value, z + "_", X);
    };
    watch(
      () => o.modelValue,
      (z) => u.value = z
    ), watch(
      () => o.meta,
      (z) => v.value = z
    ), watch(
      u,
      (z) => {
        o.trackDirtyState && _(), a("update:modelValue", z);
      },
      { deep: !0 }
    ), watch(
      k,
      (z) => a("update:visibleValues", z),
      { deep: !0 }
    ), watch(
      w,
      (z) => a("update:modifiedFields", z),
      { deep: !0 }
    );
    function _() {
      Statamic.$dirty.add(o.name);
    }
    function T() {
      Statamic.$dirty.remove(o.name);
    }
    function O(z) {
      u.value = z;
    }
    function I(z) {
      d.value = z;
    }
    function q(z, X) {
      data_set(u.value, z, X);
    }
    function F(z, X) {
      data_set(v.value, z, X);
    }
    function W(z) {
      confirm(o.syncFieldConfirmationText) && (J(z), q(z, o.originValues[z]), F(z, o.originMeta[z]));
    }
    function K(z) {
      Z(z), _();
    }
    function Z(z) {
      w.value.includes(z) || w.value.push(z);
    }
    function J(z) {
      const X = w.value.indexOf(z);
      X !== -1 && w.value.splice(X, 1);
    }
    function re(z, { props: X }) {
      const ue = new Component(uniqid(), z, X);
      return C.value.push(ue), ue;
    }
    const V = {
      name: toRef(() => o.name),
      parentContainer: s,
      blueprint: toRef(() => o.blueprint),
      reference: toRef(() => o.reference),
      values: u,
      extraValues: d,
      visibleValues: k,
      originValues: toRef(() => o.originValues),
      hiddenFields: f,
      revealerFields: g,
      revealerValues: E,
      localizedFields: w,
      meta: v,
      site: toRef(() => o.site),
      errors: toRef(() => o.errors),
      readOnly: toRef(() => o.readOnly),
      previews: b,
      syncField: W,
      desyncField: K,
      components: C,
      asConfig: toRef(() => o.asConfig),
      isTrackingOriginValues: computed(() => !!o.originValues),
      setValues: O,
      setFieldValue: q,
      setFieldMeta: F,
      setFieldPreviewValue: B,
      setRevealerField: P,
      unsetRevealerField: M,
      setHiddenField: A
    };
    provideContainerContext({ ...V, container: V }), t({
      name: o.name,
      values: u,
      saving: ne,
      saved: Q,
      revealerFields: g,
      setFieldValue: q,
      desyncField: K,
      clearDirtyState: T,
      pushComponent: re,
      visibleValues: k,
      setValues: O,
      setExtraValues: I
    });
    function ne() {
    }
    function Q() {
      T();
    }
    return (z, X) => renderSlot(z.$slots, "default", {}, () => [
      createVNode(_sfc_main$H)
    ]);
  }
};
function wait(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
const _hoisted_1$o = { class: "live-preview fixed flex flex-col" }, _hoisted_2$a = { class: "live-preview-header" }, _hoisted_3$4 = { class: "dark:text-dark-150 text-base font-medium text-gray-700 ltr:mr-4 rtl:ml-4" }, _hoisted_4$3 = { class: "flex items-center gap-x-2" }, _hoisted_5$2 = { class: "live-preview-main" }, _hoisted_6$1 = { class: "live-preview-fields h-full flex-1 overflow-scroll" }, widthLocalStorageKey = "statamic.live-preview.editor-width", _sfc_main$F = {
  __name: "LivePreview",
  props: {
    enabled: {
      type: Boolean,
      default: !1,
      required: !0
    },
    url: {
      type: String,
      required: !1
    },
    targets: {
      type: Array,
      default: () => [],
      required: !0
    }
  },
  emits: ["opened", "closed"],
  setup(e, { emit: t }) {
    const n = e, a = t, { name: o, blueprint: s, values: u } = injectContainerContext(), d = ref(!1), f = ref(!1), g = ref(!1), v = ref(localStorage.getItem(widthLocalStorageKey) || 400), b = ref(!1), w = ref(!1), C = ref(null), k = ref(!1), E = ref(null), A = ref(!1), P = ref(!0), M = ref({}), B = ref(null), _ = ref(0), T = ref(null), O = useTemplateRef("contents");
    let I;
    const q = computed(() => `live-preview-fields-${o.value}`);
    watch(
      () => n.enabled,
      (Se, ze) => {
        ze && !Se ? nextTick(() => d.value = !1) : d.value = Se, Se && (K(), ne());
      }
    );
    const F = computed(() => {
      let Se = n.url;
      return Se += (Se.includes("?") ? "&" : "?") + `target=${_.value}`, B.value && (Se += `&token=${B.value}`), Se;
    }), W = computed(() => ({
      blueprint: s.value.handle,
      preview: u.value,
      extras: M.value
    }));
    watch(
      [W, _],
      (Se) => {
        n.enabled && K();
      },
      { deep: !0 }
    );
    const K = debounce(() => {
      I && I.abort(), I = new AbortController(), P.value = !0, axios.post(F.value, W.value, { signal: I.signal }).then((Se) => {
        B.value = Se.data.token;
        const ze = Se.data.url, Ne = n.targets[_.value], tt = { token: B.value, reference: n.reference };
        k.value ? C.value.postMessage({ event: "updated", url: ze, target: Ne, payload: tt }) : re(ze, _, tt), P.value = !1;
      }).catch((Se) => {
        if (Se.code !== "ERR_CANCELED")
          throw Se;
      });
    }, 150), Z = (Se, ze) => (Se = new URL(Se), ze = new URL(ze), Se.searchParams.delete("live-preview"), ze.searchParams.delete("live-preview"), Se.toString() !== ze.toString()), J = (Se, ze, Ne) => {
      const tt = /^https?:\/\//.test(ze) ? new URL(ze)?.origin : window.origin;
      Se.firstChild.contentWindow.postMessage(
        {
          name: "statamic.preview.updated",
          url: ze,
          ...Ne
        },
        tt
      );
    };
    function re(Se, ze, Ne) {
      const tt = document.createElement("iframe");
      tt.setAttribute("frameborder", "0"), tt.setAttribute("src", Se), tt.setAttribute("id", "live-preview-iframe"), V(tt);
      const Qe = O.value;
      let et = new URL(Se), ce = et.host + et.pathname;
      if (!Qe.firstChild) {
        Qe.appendChild(tt), T.value = ce;
        return;
      }
      let pe = ze.refresh;
      if (Z(Qe.firstChild.src, tt.src) && (pe = !0), !pe) {
        J(Qe, Se, Ne);
        return;
      }
      let lt = (Se.startsWith("/") || et.host === window.location.host) && ce === T.value, Ce = lt ? [Qe.firstChild.contentWindow.scrollX ?? 0, Qe.firstChild.contentWindow.scrollY ?? 0] : null;
      if (Qe.replaceChild(tt, Qe.firstChild), lt) {
        let Oe = tt.contentWindow;
        const Te = (ot) => {
          Oe.scrollTo(...Ce);
        };
        Oe.addEventListener("DOMContentLoaded", Te, !0), Oe.addEventListener("load", Te, !0);
      }
      T.value = ce;
    }
    function V(Se) {
      Se.setAttribute("frameborder", "0"), Se.setAttribute("class", ie.value ? "device" : "responsive"), ie.value ? Se.setAttribute("style", `width: ${oe.value}; height: ${ye.value}`) : Se.removeAttribute("style");
    }
    function ne() {
      return wait(100).then(() => (g.value = !0, wait(200))).then(() => (f.value = !0, wait(300))).then(() => {
        window.dispatchEvent(new Event("resize"));
      });
    }
    function Q() {
      return f.value = !1, g.value = !1, wait(300);
    }
    const z = computed(() => typeof BroadcastChannel == "function");
    function X() {
      k.value = !0, C.value = C.value || new BroadcastChannel("livepreview"), C.value.onmessage = (tt) => {
        switch (tt.data.event) {
          case "popout.opened":
            ue(), K();
            break;
          case "popout.closed":
            k.value = !1, K();
          case "popout.pong":
            A.value = !0;
            break;
        }
      };
      const Se = O.value.clientWidth, ze = O.value.clientHeight, Ne = screen.width - Se;
      E.value = window.open(n.url, "livepreview", `width=${Se},height=${ze},top=0,left=${Ne}`);
    }
    function ue() {
      C.value.postMessage({ event: "ping" }), setTimeout(() => {
        A.value ? ue() : (k.value = !1, K()), A.value = !1;
      }, 500);
    }
    function Be() {
      k.value && E.value.close();
    }
    const te = computed(
      () => Object.values(
        mapValues(n.targets, (Se, ze) => ({ value: ze, label: __(Se.label) }))
      )
    ), G = computed(() => {
      let Se = Object.values(
        mapValues(Statamic.$config.get("livePreview.devices"), (ze, Ne) => Ne === "Responsive" ? { value: null, label: __("Responsive") } : { value: Ne, label: __(Ne) })
      );
      return Se.filter((ze) => ze.label === __("Responsive")).length === 0 && Se.unshift({ value: null, label: __("Responsive") }), Se;
    }), ie = ref(G.value[0].value);
    watch(ie, (Se) => {
      V(document.getElementById("live-preview-iframe"));
    });
    const oe = computed(() => {
      if (console.log(ie.value), ie.value)
        return `${Statamic.$config.get("livePreview.devices")[ie.value].width}px`;
    }), ye = computed(() => {
      if (ie)
        return `${Statamic.$config.get("livePreview.devices")[ie.value].height}px`;
    }), ve = computed(() => Statamic.$config.get("livePreview.inputs", {}));
    function ke() {
      w.value = !0, v.value = 16;
    }
    function Ae(Se) {
      w.value = !1, v.value = Se, localStorage.setItem(widthLocalStorageKey, Se);
    }
    function be() {
      k.value && Be(), Q().then(() => a("closed"));
    }
    const Ie = ref(
      Statamic.$keys.bindGlobal("mod+shift+p", () => {
        n.enabled ? be() : a("opened");
      })
    );
    return onUnmounted(() => Ie.value.destroy()), Statamic.$events.$on(`live-preview.${o.value}.refresh`, () => {
      n.enabled && K();
    }), (Se, ze) => {
      const Ne = resolveComponent("v-portal"), tt = resolveComponent("portal-target"), Qe = resolveComponent("portal");
      return openBlock(), createElementBlock(Fragment, null, [
        createVNode(Ne, {
          to: q.value,
          disabled: !d.value
        }, {
          default: withCtx(() => [
            renderSlot(Se.$slots, "default")
          ]),
          _: 3
        }, 8, ["to", "disabled"]),
        e.enabled ? (openBlock(), createBlock(Qe, {
          key: 0,
          name: "live-preview",
          "target-class": "live-preview-portal"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_1$o, [
              createVNode(Transition, { name: "live-preview-header-slide" }, {
                default: withCtx(() => [
                  withDirectives(createElementVNode("div", _hoisted_2$a, [
                    createElementVNode("div", _hoisted_3$4, toDisplayString(Se.__("Live Preview")), 1),
                    createElementVNode("div", _hoisted_4$3, [
                      z.value && !k.value ? (openBlock(), createBlock(unref(Button), {
                        key: 0,
                        size: "sm",
                        icon: "maximize",
                        onClick: X
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(Se.__("Pop out")), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", !0),
                      k.value ? (openBlock(), createBlock(unref(Button), {
                        key: 1,
                        size: "sm",
                        icon: "minimize",
                        onClick: Be
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(Se.__("Pop in")), 1)
                        ]),
                        _: 1
                      })) : createCommentVNode("", !0),
                      withDirectives(createVNode(unref(_sfc_main$q), {
                        options: G.value,
                        modelValue: ie.value,
                        "onUpdate:modelValue": ze[0] || (ze[0] = (et) => ie.value = et),
                        size: "sm"
                      }, null, 8, ["options", "modelValue"]), [
                        [vShow, !k.value]
                      ]),
                      e.targets.length > 1 ? (openBlock(), createBlock(unref(_sfc_main$q), {
                        key: 2,
                        options: te.value,
                        modelValue: _.value,
                        "onUpdate:modelValue": ze[1] || (ze[1] = (et) => _.value = et),
                        size: "sm"
                      }, null, 8, ["options", "modelValue"])) : createCommentVNode("", !0),
                      (openBlock(!0), createElementBlock(Fragment, null, renderList(ve.value, (et, ce) => (openBlock(), createBlock(resolveDynamicComponent(et), {
                        key: ce,
                        value: M.value[ce],
                        loading: P.value,
                        onInput: (pe) => Se.componentUpdated(ce, pe)
                      }, null, 40, ["value", "loading", "onInput"]))), 128)),
                      renderSlot(Se.$slots, "buttons"),
                      createVNode(unref(Button), {
                        onClick: be,
                        icon: "x",
                        "icon-only": "",
                        size: "sm",
                        variant: "ghost"
                      })
                    ])
                  ], 512), [
                    [vShow, g.value]
                  ])
                ]),
                _: 3
              }),
              createElementVNode("div", _hoisted_5$2, [
                createVNode(Transition, { name: "live-preview-editor-slide" }, {
                  default: withCtx(() => [
                    withDirectives(createElementVNode("div", {
                      class: "live-preview-editor @container/live-preview",
                      style: normalizeStyle({ width: k.value ? "100%" : `${v.value}px` })
                    }, [
                      createElementVNode("div", _hoisted_6$1, [
                        createVNode(tt, { name: q.value }, null, 8, ["name"])
                      ]),
                      withDirectives(createVNode(_sfc_main$N, {
                        onResized: Ae,
                        onResizeStart: ze[2] || (ze[2] = (et) => b.value = !0),
                        onResizeEnd: ze[3] || (ze[3] = (et) => b.value = !1),
                        onCollapsed: ke
                      }, null, 512), [
                        [vShow, !k.value]
                      ])
                    ], 4), [
                      [vShow, f.value]
                    ])
                  ]),
                  _: 1
                }),
                createVNode(Transition, { name: "live-preview-contents-slide" }, {
                  default: withCtx(() => [
                    withDirectives(createElementVNode("div", {
                      ref: "contents",
                      class: normalizeClass(["live-preview-contents items-center justify-center overflow-auto", { "pointer-events-none": b.value }])
                    }, null, 2), [
                      [vShow, f.value]
                    ])
                  ]),
                  _: 1
                })
              ])
            ])
          ]),
          _: 3
        })) : createCommentVNode("", !0)
      ], 64);
    };
  }
};
function hasComponent(e) {
  const t = useSlots();
  return computed(() => {
    const n = t.default?.();
    return n ? n.some((a) => {
      const o = a.type;
      return o?.name === e || o?.__name === e;
    }) : !1;
  });
}
const _hoisted_1$n = { class: "relative space-y-3 rounded-xl border border-gray-400/60 bg-white p-4 shadow-[0_1px_16px_-2px_rgba(63,63,71,0.2)] dark:border-none dark:bg-gray-800 dark:shadow-[0_10px_15px_rgba(0,0,0,.5)] dark:inset-shadow-2xs dark:inset-shadow-white/15" }, _sfc_main$E = {
  __name: "Modal",
  props: {
    title: { type: String, default: "" },
    icon: { type: [String, null], default: null },
    open: { type: Boolean, default: !1 },
    dismissible: { type: Boolean, default: !0 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = hasComponent("ModalTitle"), s = cva({
      base: [
        "fixed outline-hidden left-1/2 top-1/6 z-50 w-full max-w-2xl -translate-x-1/2",
        "bg-white/80 dark:bg-gray-850 backdrop-blur-[2px] rounded-2xl p-2",
        "shadow-[0_8px_5px_-6px_rgba(0,0,0,0.12),_0_3px_8px_0_rgba(0,0,0,0.02),_0_30px_22px_-22px_rgba(39,39,42,0.35)]",
        "dark:shadow-[0_5px_20px_rgba(0,0,0,.5)]",
        "duration-200 will-change-[transform,opacity]",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "slide-in-from-top-2"
      ]
    })({}), u = getCurrentInstance(), d = computed(() => u?.vnode.props?.hasOwnProperty("open")), f = ref(a.open);
    watch(
      () => a.open,
      (b) => f.value = b
    );
    function g(b) {
      if (d.value) {
        n("update:open", b);
        return;
      }
      f.value = b;
    }
    function v(b) {
      a.dismissible || b.preventDefault();
    }
    return (b, w) => {
      const C = resolveComponent("ui-heading");
      return openBlock(), createBlock(unref(_sfc_main$4t), {
        open: f.value,
        "onUpdate:open": g
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$4h), {
            "data-ui-modal-trigger": "",
            "as-child": ""
          }, {
            default: withCtx(() => [
              renderSlot(b.$slots, "trigger")
            ]),
            _: 3
          }),
          createVNode(unref(_sfc_main$2t), null, {
            default: withCtx(() => [
              createVNode(unref(_sfc_main$4k), { class: "data-[state=open]:show fixed inset-0 z-30 bg-gray-800/20 backdrop-blur-[2px] dark:bg-gray-800/50" }),
              createVNode(unref(_sfc_main$4m), {
                class: normalizeClass([unref(s), b.$attrs.class]),
                "data-ui-modal-content": "",
                "aria-describedby": void 0,
                onPointerDownOutside: v,
                onEscapeKeyDown: v
              }, {
                default: withCtx(() => [
                  createElementVNode("div", _hoisted_1$n, [
                    unref(o) ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$4i), {
                      key: 0,
                      "data-ui-modal-title": "",
                      class: "flex items-center gap-2"
                    }, {
                      default: withCtx(() => [
                        e.icon ? (openBlock(), createBlock(unref(_sfc_main$1a), {
                          key: 0,
                          name: e.icon,
                          class: "size-4"
                        }, null, 8, ["name"])) : createCommentVNode("", !0),
                        createVNode(C, {
                          text: e.title,
                          size: "lg",
                          class: "font-medium"
                        }, null, 8, ["text"])
                      ]),
                      _: 1
                    })),
                    renderSlot(b.$slots, "default")
                  ]),
                  renderSlot(b.$slots, "footer")
                ]),
                _: 3
              }, 8, ["class"])
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["open"]);
    };
  }
}, _sfc_main$D = {
  __name: "Close",
  setup(e) {
    const t = useSlots(), n = computed(() => !!t.default);
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$4s), {
      "data-ui-modal-close": "",
      asChild: !n.value
    }, {
      default: withCtx(() => [
        n.value ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createBlock(unref(Button), {
          key: 1,
          variant: "ghost",
          size: "sm",
          icon: "x",
          class: "absolute top-3 right-2"
        }))
      ]),
      _: 3
    }, 8, ["asChild"]));
  }
}, _sfc_main$C = /* @__PURE__ */ Object.assign({
  name: "ModalTitle"
}, {
  __name: "Title",
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$4i), { "data-ui-modal-title": "" }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), HasInputOptions = {
  methods: {
    normalizeInputOptions(e) {
      return Array.isArray(e) ? e.map((t) => {
        if (typeof t == "object") {
          let n = "value", a = "label";
          return t.hasOwnProperty("key") && (n = "key", a = "value"), {
            value: t[n],
            label: `${__$1(t[a]) || t[n]}`
          };
        }
        return {
          value: t,
          label: `${__$1(t) || t}`
        };
      }) : Object.entries(e).map(([t, n]) => ({
        value: Array.isArray(e) ? n : t,
        label: `${__$1(n) || t}`
      }));
    }
  }
}, _hoisted_1$m = { class: "flex" }, _hoisted_2$9 = { class: "flex flex-1 items-center" }, _hoisted_3$3 = {
  key: 0,
  class: "text-sm text-gray-600 dark:text-gray-500"
}, _hoisted_4$2 = {
  key: 0,
  class: "flex items-center gap-1"
}, _hoisted_5$1 = {
  key: 1,
  class: "flex flex-1 items-center justify-end"
}, _hoisted_6 = { class: "me-3 text-sm text-gray-600" }, onEachSide = 3, _sfc_main$B = {
  __name: "Pagination",
  props: {
    showTotals: { type: Boolean, default: !0 },
    perPage: { type: Number },
    resourceMeta: { type: Object, required: !0 },
    scrollToTop: { type: Boolean, default: !0 },
    showPageLinks: { type: Boolean, default: !0 },
    showPerPageSelector: { type: Boolean, default: !0 }
  },
  emits: ["page-selected", "per-page-changed"],
  setup(e, { emit: t }) {
    const n = HasInputOptions.methods.normalizeInputOptions, a = t, o = e, s = onEachSide * 2, u = computed(() => o.resourceMeta.last_page), d = computed(() => {
      const V = f.value;
      let ne = [
        V.first,
        V.slider ? "separator" : null,
        V.slider,
        V.last ? "separator" : null,
        V.last
      ].filter((Q) => Q !== null);
      return flatten(ne);
    }), f = computed(() => v.value < onEachSide * 2 + 6 ? I() : g.value <= s ? F() : g.value > v.value - s ? W() : q()), g = computed(() => o.resourceMeta.current_page), v = computed(() => o.resourceMeta.last_page), b = computed(() => u.value > 1), w = computed(() => g.value > 1), C = computed(() => g.value < u.value), k = computed(() => {
      let V = Statamic.$config.get("paginationSize"), ne = Statamic.$config.get("paginationSizeOptions").filter((z) => z !== V), Q = n(ne);
      return Q.push({
        value: V,
        label: `${V}`
      }), sortBy(Q, "value");
    }), E = computed(() => o.resourceMeta.total > k.value[0].value), A = computed(() => o.showPerPageSelector && E.value), P = computed(() => o.resourceMeta.total), M = computed(() => o.resourceMeta.from || 0), B = computed(() => Math.min(o.resourceMeta.to, P.value));
    function _(V) {
      V !== g.value && (a("page-selected", V), o.scrollToTop && window.scrollTo(0, 0));
    }
    function T() {
      _(g.value - 1);
    }
    function O() {
      _(g.value + 1);
    }
    function I() {
      return {
        first: re(1, v.value),
        slider: null,
        last: null
      };
    }
    function q() {
      return {
        first: K(),
        slider: J(),
        last: Z()
      };
    }
    function F() {
      return {
        first: re(1, s + 2),
        slider: null,
        last: Z()
      };
    }
    function W() {
      const V = re(v.value - (s + 2), v.value);
      return {
        first: K(),
        slider: null,
        last: V
      };
    }
    function K() {
      return re(1, 2);
    }
    function Z() {
      return re(v.value - 1, v.value);
    }
    function J() {
      return re(g.value - onEachSide, g.value + onEachSide);
    }
    function re(V, ne) {
      return range(V, ne + 1);
    }
    return (V, ne) => (openBlock(), createElementBlock("div", _hoisted_1$m, [
      createElementVNode("div", _hoisted_2$9, [
        e.showTotals && P.value > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$3, toDisplayString(V.__(":start-:end of :total", { start: M.value, end: B.value, total: P.value })), 1)) : createCommentVNode("", !0)
      ]),
      b.value ? (openBlock(), createElementBlock("div", _hoisted_4$2, [
        createVNode(unref(Button), {
          size: "sm",
          variant: w.value && !e.showPageLinks ? "filled" : "ghost",
          round: "",
          icon: "ui/chevron-left",
          disabled: !w.value,
          onClick: T
        }, null, 8, ["variant", "disabled"]),
        e.showPageLinks ? (openBlock(!0), createElementBlock(Fragment, { key: 0 }, renderList(d.value, (Q, z) => (openBlock(), createBlock(unref(Button), {
          size: "sm",
          round: "",
          variant: Q == g.value ? "filled" : "ghost",
          key: z,
          onClick: (X) => _(Q),
          disabled: Q === "separator" || Q === g.value,
          text: Q === "separator" ? "..." : String(Q)
        }, null, 8, ["variant", "onClick", "disabled", "text"]))), 128)) : createCommentVNode("", !0),
        createVNode(unref(Button), {
          size: "sm",
          variant: C.value && !e.showPageLinks ? "filled" : "ghost",
          round: "",
          icon: "ui/chevron-right",
          disabled: !C.value,
          onClick: O
        }, null, 8, ["variant", "disabled"])
      ])) : createCommentVNode("", !0),
      e.perPage && A.value ? (openBlock(), createElementBlock("div", _hoisted_5$1, [
        createElementVNode("span", _hoisted_6, toDisplayString(V.__("Per Page")), 1),
        createVNode(unref(_sfc_main$q), {
          class: "w-auto!",
          size: "sm",
          options: k.value,
          "model-value": e.perPage,
          "onUpdate:modelValue": ne[0] || (ne[0] = (Q) => V.$emit("per-page-changed", Q))
        }, null, 8, ["options", "model-value"])
      ])) : createCommentVNode("", !0)
    ]));
  }
}, _hoisted_1$l = {
  class: /* @__PURE__ */ normalizeClass([
    "relative bg-gray-200/50 dark:bg-gray-950 dark:inset-shadow-2xs dark:inset-shadow-black",
    "w-full rounded-2xl mb-5 p-1.5 [&:has([data-ui-panel-header])]:pt-0 focus-none"
  ]),
  "data-ui-panel": ""
}, _sfc_main$A = {
  __name: "Panel",
  props: {
    heading: { type: String, default: null },
    subheading: { type: String, default: null }
  },
  setup(e) {
    return (t, n) => (openBlock(), createElementBlock("div", _hoisted_1$l, [
      e.heading ? (openBlock(), createBlock(unref(_sfc_main$y), { key: 0 }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$1b), { innerHTML: e.heading }, null, 8, ["innerHTML"]),
          e.subheading ? (openBlock(), createBlock(unref(_sfc_main$i), {
            key: 0,
            innerHTML: e.subheading
          }, null, 8, ["innerHTML"])) : createCommentVNode("", !0),
          renderSlot(t.$slots, "header-actions")
        ]),
        _: 3
      })) : createCommentVNode("", !0),
      renderSlot(t.$slots, "default")
    ]));
  }
}, _sfc_main$z = {}, _hoisted_1$k = {
  class: "px-4.5 pt-3 pb-1.5 antialiased",
  "data-ui-panel-footer": ""
};
function _sfc_render$7(e, t) {
  return openBlock(), createElementBlock("footer", _hoisted_1$k, [
    renderSlot(e.$slots, "default")
  ]);
}
const PanelFooter = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$7]]), _hoisted_1$j = {
  class: "px-4.5 py-3 [&:has(button)]:pr-1 [&_button]:-my-2 [&_button]:relative",
  "data-ui-panel-header": ""
}, _sfc_main$y = {
  __name: "Header",
  props: {
    title: { type: String, default: null }
  },
  setup(e) {
    const t = e;
    return (n, a) => (openBlock(), createElementBlock("header", _hoisted_1$j, [
      t.title ? (openBlock(), createBlock(unref(_sfc_main$1b), {
        key: 0,
        textContent: toDisplayString(t.title)
      }, null, 8, ["textContent"])) : renderSlot(n.$slots, "default", { key: 1 })
    ]));
  }
}, _sfc_main$x = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Popover",
  props: {
    align: { type: String, default: "center" },
    arrow: { type: Boolean, default: !1 },
    inset: { type: Boolean, default: !1 },
    offset: { type: Number, default: 5 },
    side: { type: String, default: "bottom" },
    open: { type: Boolean, default: !1 }
  },
  emits: ["update:open"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = cva({
      base: [
        "rounded-xl w-64 bg-white dark:bg-gray-800 outline-hidden overflow-hidden",
        "border border-gray-200 dark:border-white/10 dark:border-b-0 shadow-lg",
        "duration-100 will-change-[transform,opacity]",
        "data-[state=open]:animate-in data-[state=closed]:animate-out",
        "data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
        "data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95",
        "data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2",
        "data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2"
      ],
      variants: {
        inset: { true: "inset-0", false: "p-4" }
      }
    })({
      ...a
    }), s = ref(a.open);
    watch(
      () => a.open,
      (d) => s.value = d
    );
    function u(d) {
      n("update:open", d), s.value = d;
    }
    return (d, f) => (openBlock(), createBlock(unref(_sfc_main$3m), {
      open: s.value,
      "onUpdate:open": u
    }, {
      default: withCtx((g) => [
        createVNode(unref(_sfc_main$2_), {
          "data-ui-popover-trigger": "",
          "as-child": ""
        }, {
          default: withCtx(() => [
            renderSlot(d.$slots, "trigger")
          ]),
          _: 3
        }),
        createVNode(unref(_sfc_main$3f), null, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$3b), {
              "data-ui-popover-content": "",
              class: normalizeClass([unref(o), d.$attrs.class]),
              align: e.align,
              sideOffset: e.offset,
              side: e.side
            }, {
              default: withCtx(() => [
                renderSlot(d.$slots, "default", normalizeProps(guardReactiveProps(g))),
                createVNode(unref(_sfc_main$3g), { "as-child": "" }, {
                  default: withCtx(() => [
                    renderSlot(d.$slots, "close", normalizeProps(guardReactiveProps(g)))
                  ]),
                  _: 2
                }, 1024),
                e.arrow ? (openBlock(), createBlock(unref(_sfc_main$3l), {
                  key: 0,
                  class: "fill-white stroke-gray-300"
                })) : createCommentVNode("", !0)
              ]),
              _: 2
            }, 1032, ["class", "align", "sideOffset", "side"])
          ]),
          _: 2
        }, 1024)
      ]),
      _: 3
    }, 8, ["open"]));
  }
}), _sfc_main$w = {
  __name: "Components",
  setup(e) {
    const { components: t } = injectContainerContext();
    return (n, a) => (openBlock(!0), createElementBlock(Fragment, null, renderList(unref(t), (o) => (openBlock(), createBlock(resolveDynamicComponent(o.name), mergeProps({
      key: o.name
    }, { ref_for: !0 }, o.props), null, 16))), 128));
  }
};
function resetValuesFromResponse(e, t) {
  const n = t.values;
  if (!e) return n;
  let a = ["id"].concat(t.revealerFields), o = new Values(n), s = new Values(e);
  return s.mergeDottedKeys(a, o), s.all();
}
let container = null, errors = null, saving = null;
class Pipeline {
  provide(t) {
    return container = t.container, errors = t.errors, saving = t.saving, this;
  }
  async through(t) {
    return [new Start(), ...t, new Finish()].reduce(async (n, a) => {
      const o = await n;
      a = typeof a == "function" ? a(o) : a;
      try {
        return await a.handle(o);
      } catch (s) {
        throw s instanceof PipelineStopped && new Stopped().handle(o), s;
      }
    }, initialPromise);
  }
}
const initialPromise = new Promise((e) => {
  setTimeout(() => e(), 151);
});
class PipelineStopped extends Error {
  constructor(t) {
    super(), this.payload = t;
  }
}
class Step {
}
class Start extends Step {
  handle(t) {
    return errors && (errors.value = {}), saving && (saving.value = !0), container && container.value.saving(), t;
  }
}
let Request$1 = class extends Step {
  #e;
  #t;
  #n;
  constructor(t, n, a) {
    super(), this.#e = t, this.#t = n.toLowerCase(), this.#n = a;
  }
  handle(t) {
    return new Promise((n, a) => {
      const o = { ...container.value.visibleValues, ...this.#n };
      return axios[this.#t](this.#e, o).then((s) => {
        container && s.data.data?.hasOwnProperty("values") && (container.value.setValues(
          resetValuesFromResponse(s.data.data.values, container.value)
        ), container.value.setExtraValues(s.data.data.extraValues)), n(s);
      }).catch((s) => {
        if (s.response && s.response.status === 422) {
          const { errors: u, message: d } = s.response.data;
          errors && (errors.value = u), Statamic.$toast.error(d), s = new PipelineStopped();
        } else s.response && s.response.data.message ? (Statamic.$toast.error(s.response.data.message), s = new PipelineStopped()) : s.response && (Statamic.$toast.error("Something went wrong"), s = new PipelineStopped());
        a(s);
      });
    });
  }
};
class BeforeSaveHooks extends Step {
  #e;
  #t;
  constructor(t, n) {
    super(), this.#e = t, this.#t = n;
  }
  handle(t) {
    return new Promise((n, a) => Statamic.$hooks.run(`${this.#e}.saving`, this.#t).then(() => n(t)));
  }
}
class AfterSaveHooks extends Step {
  #e;
  #t;
  constructor(t, n) {
    super(), this.#e = t, this.#t = n;
  }
  handle(t) {
    return new Promise((n, a) => Statamic.$hooks.run(`${this.#e}.saved`, {
      ...this.#t,
      response: t
    }).then(() => n(t)));
  }
}
class Stopped extends Step {
  handle(t) {
    return saving && (saving.value = !1), t;
  }
}
class Finish extends Step {
  handle(t) {
    return saving && (saving.value = !1), container && container.value.saved(), t;
  }
}
const _sfc_main$v = {
  __name: "Form",
  props: {
    icon: {
      type: String
    },
    title: {
      type: String,
      default: () => uniqid()
    },
    blueprint: {
      type: Object,
      required: !0
    },
    initialValues: {
      type: Object,
      required: !0,
      default: () => ({})
    },
    initialMeta: {
      type: Object,
      required: !0,
      default: () => ({})
    },
    submitUrl: {
      type: String,
      required: !0
    },
    submitMethod: {
      type: String,
      default: "patch"
    },
    readOnly: {
      type: Boolean,
      default: !1
    },
    asConfig: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, n = Statamic.$slug.separatedBy("_").create(t.title), a = useTemplateRef("container"), o = ref(t.initialValues), s = ref(t.initialMeta), u = ref({}), d = ref(!1);
    function f() {
      new Pipeline().provide({ container: a, errors: u, saving: d }).through([
        new BeforeSaveHooks("entry"),
        new Request$1(t.submitUrl, t.submitMethod),
        new AfterSaveHooks("entry")
      ]).then((v) => {
        Statamic.$toast.success("Saved"), v.data.redirect && (window.location = v.data.redirect);
      });
    }
    let g;
    return onMounted(() => {
      g = Statamic.$keys.bindGlobal(["mod+s"], (v) => {
        v.preventDefault(), f();
      });
    }), onUnmounted(() => g.destroy()), (v, b) => (openBlock(), createElementBlock(Fragment, null, [
      createVNode(unref(_sfc_main$1c), {
        title: e.title,
        icon: e.icon
      }, {
        default: withCtx(() => [
          e.readOnly ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(Button), {
            key: 0,
            variant: "primary",
            text: "Save",
            onClick: f,
            disabled: d.value
          }, null, 8, ["disabled"]))
        ]),
        _: 1
      }, 8, ["title", "icon"]),
      createVNode(_sfc_main$G, {
        ref_key: "container",
        ref: a,
        name: unref(n),
        blueprint: e.blueprint,
        meta: s.value,
        errors: u.value,
        "read-only": e.readOnly,
        "as-config": e.asConfig,
        modelValue: o.value,
        "onUpdate:modelValue": b[0] || (b[0] = (w) => o.value = w)
      }, {
        default: withCtx(() => [
          createVNode(_sfc_main$H)
        ]),
        _: 1
      }, 8, ["name", "blueprint", "meta", "errors", "read-only", "as-config", "modelValue"])
    ], 64));
  }
}, _hoisted_1$i = { class: "flex items-center justify-between gap-x-2" }, _hoisted_2$8 = { class: "flex items-center gap-1.5" }, _sfc_main$u = {
  __name: "Localization",
  props: {
    localization: {
      type: Object,
      required: !0
    },
    localizing: {
      type: [Boolean, String],
      default: !1
    }
  },
  setup(e) {
    return (t, n) => (openBlock(), createElementBlock("div", _hoisted_1$i, [
      createElementVNode("div", {
        class: normalizeClass(["flex flex-1 items-center", { "line-through opacity-50": !e.localization.exists }])
      }, [
        createElementVNode("span", {
          class: normalizeClass(["little-dot me-2", {
            "bg-green-600": e.localization.published,
            "bg-gray-500": !e.localization.published,
            "bg-red-600": !e.localization.exists
          }])
        }, null, 2),
        createTextVNode(" " + toDisplayString(t.__(e.localization.name)) + " ", 1),
        e.localizing === e.localization.handle ? (openBlock(), createBlock(unref(_sfc_main$1a), {
          key: 0,
          name: "loading",
          class: "ms-2"
        })) : createCommentVNode("", !0)
      ], 2),
      createElementVNode("div", _hoisted_2$8, [
        e.localization.origin ? (openBlock(), createBlock(unref(_sfc_main), {
          key: 0,
          size: "sm",
          color: "orange",
          text: t.__("Origin")
        }, null, 8, ["text"])) : createCommentVNode("", !0),
        e.localization.active ? (openBlock(), createBlock(unref(_sfc_main), {
          key: 1,
          size: "sm",
          color: "blue",
          text: t.__("Active")
        }, null, 8, ["text"])) : createCommentVNode("", !0),
        e.localization.root && !e.localization.origin && !e.localization.active ? (openBlock(), createBlock(unref(_sfc_main), {
          key: 2,
          size: "sm",
          color: "purple",
          text: t.__("Root")
        }, null, 8, ["text"])) : createCommentVNode("", !0)
      ])
    ]));
  }
}, _hoisted_1$h = ["onClick"], _sfc_main$t = {
  __name: "Localizations",
  props: {
    localizations: {
      type: Array,
      required: !0
    },
    localizing: {
      type: [Boolean, String],
      default: !1
    }
  },
  emits: ["selected"],
  setup(e) {
    const t = e, n = computed(() => t.localizations.find((a) => a.active));
    return (a, o) => e.localizations.length > 1 ? (openBlock(), createBlock(unref(_sfc_main$A), {
      key: 0,
      heading: a.__("Sites")
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$1J), { class: "p-3! space-y-1" }, {
          default: withCtx(() => [
            e.localizations.length > 5 ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createVNode(unref(_sfc_main$18), {
                text: a.__("Current Localization")
              }, null, 8, ["text"]),
              createVNode(unref(_sfc_main$1z), {
                class: "flex-1",
                options: e.localizations,
                "option-value": "handle",
                "option-label": "name",
                "model-value": n.value?.handle,
                "onUpdate:modelValue": o[0] || (o[0] = (s) => a.$emit("selected", s))
              }, {
                option: withCtx((s) => [
                  createVNode(_sfc_main$u, {
                    localization: s,
                    localizing: e.localizing
                  }, null, 8, ["localization", "localizing"])
                ]),
                _: 1
              }, 8, ["options", "model-value"])
            ], 64)) : (openBlock(!0), createElementBlock(Fragment, { key: 1 }, renderList(e.localizations, (s) => (openBlock(), createElementBlock("button", {
              key: s.handle,
              class: normalizeClass(["w-full cursor-pointer px-4 py-2 text-sm rounded-lg", s.active ? "dark:bg-gray-700 bg-blue-100" : "dark:hover:bg-gray-800 hover:bg-gray-100"]),
              onClick: (u) => a.$emit("selected", s)
            }, [
              createVNode(_sfc_main$u, {
                localization: s,
                localizing: e.localizing
              }, null, 8, ["localization", "localizing"])
            ], 10, _hoisted_1$h))), 128))
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["heading"])) : createCommentVNode("", !0);
  }
}, _hoisted_1$g = {
  class: "flex items-start gap-1.5",
  "data-ui-radio-item": ""
}, _hoisted_2$7 = ["for"], _hoisted_3$2 = { class: "text-sm font-normal text-gray-600 antialiased dark:text-gray-200" }, _hoisted_4$1 = {
  key: 0,
  class: "mt-0.5 block text-xs leading-snug text-gray-500"
}, _sfc_main$s = {
  __name: "Item",
  props: {
    description: { type: String, default: null },
    disabled: { type: Boolean, default: !1 },
    label: { type: String, default: null },
    value: { type: [String, Number, Boolean], required: !0 }
  },
  setup(e) {
    const t = useId();
    return (n, a) => (openBlock(), createElementBlock("div", _hoisted_1$g, [
      createVNode(unref(_sfc_main$2f), {
        id: unref(t),
        value: e.value,
        class: "shadow-ui-xs mt-0.5 size-4 cursor-default rounded-full focus:focus-outline border border-gray-400/75 dark:border-none bg-white outline-hidden data-[state=checked]:border-ui-accent dark:bg-gray-400 dark:data-[state=checked]:border-none dark:data-[state=checked]:bg-gray-300"
      }, {
        default: withCtx(() => [
          createVNode(unref(_sfc_main$2e), { class: "relative flex h-full w-full items-center justify-center rounded-[50%] border border-ui-accent after:block after:h-[0.5rem] after:w-[0.5rem] after:rounded-[50%] after:bg-ui-accent after:content-[''] dark:border-none dark:after:bg-dark-ui-accent" })
        ]),
        _: 1
      }, 8, ["id", "value"]),
      createElementVNode("label", {
        class: "flex flex-col",
        for: unref(t)
      }, [
        createElementVNode("span", _hoisted_3$2, [
          renderSlot(n.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(e.label || e.value), 1)
          ])
        ]),
        e.description ? (openBlock(), createElementBlock("span", _hoisted_4$1, toDisplayString(e.description), 1)) : createCommentVNode("", !0)
      ], 8, _hoisted_2$7)
    ]));
  }
}, _sfc_main$r = {
  __name: "Group",
  props: {
    inline: { type: Boolean, default: !1 },
    modelValue: { type: [String, Number, Boolean], default: null },
    name: { type: String, default: () => useId$1() },
    required: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t }) {
    return t({ focus: function() {
      console.log("focusing. todo.");
    } }), (a, o) => (openBlock(), createBlock(unref(_sfc_main$2g), {
      modelValue: e.modelValue,
      "onUpdate:modelValue": o[0] || (o[0] = (s) => a.$emit("update:modelValue", s)),
      name: e.name,
      class: normalizeClass(["relative block w-full space-y-2", { "flex flex-wrap space-y-0 gap-x-4 gap-y-2": e.inline }]),
      "data-ui-input": "",
      "data-ui-radio-group": ""
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["modelValue", "name", "class"]));
  }
}, _sfc_main$q = /* @__PURE__ */ Object.assign({
  inheritAttrs: !1
}, {
  __name: "Select",
  props: {
    clearable: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    icon: { type: String, default: null },
    modelValue: { type: [Object, String, Number], default: null },
    optionLabel: { type: String, default: "label" },
    options: { type: Array, default: null },
    optionValue: { type: String, default: "value" },
    placeholder: { type: String, default: "Select..." },
    readOnly: { type: Boolean, default: !1 },
    size: { type: String, default: "base" },
    variant: { type: String, default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t, a = useAttrs(), o = useSlots(), s = !!o["selected-option"], u = !!o["no-options"], d = !!o.option;
    return (f, g) => (openBlock(), createBlock(unref(_sfc_main$1z), mergeProps(unref(a), {
      clearable: e.clearable,
      disabled: e.disabled,
      icon: e.icon,
      "model-value": e.modelValue,
      "option-label": e.optionLabel,
      "option-value": e.optionValue,
      options: e.options,
      placeholder: e.placeholder,
      "read-only": e.readOnly,
      searchable: !1,
      size: e.size,
      variant: e.variant,
      "onUpdate:modelValue": g[0] || (g[0] = (v) => n("update:modelValue", v))
    }), createSlots({ _: 2 }, [
      s ? {
        name: "selected-option",
        fn: withCtx(({ option: v }) => [
          renderSlot(f.$slots, "selected-option", normalizeProps(guardReactiveProps({ option: v })))
        ]),
        key: "0"
      } : void 0,
      u ? {
        name: "no-options",
        fn: withCtx(() => [
          renderSlot(f.$slots, "no-options")
        ]),
        key: "1"
      } : void 0,
      d ? {
        name: "option",
        fn: withCtx((v) => [
          renderSlot(f.$slots, "option", normalizeProps(guardReactiveProps(v)))
        ]),
        key: "2"
      } : void 0
    ]), 1040, ["clearable", "disabled", "icon", "model-value", "option-label", "option-value", "options", "placeholder", "read-only", "size", "variant"]));
  }
}), _hoisted_1$f = ["textContent"], _sfc_main$p = {
  __name: "Separator",
  props: {
    text: { type: String, default: null },
    variant: { type: String, default: "line" },
    vertical: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, n = cva({
      variants: {
        text: { true: "before:me-4 after:ms-4 antialiased" },
        vertical: {
          true: "inline-block h-full bg-gray-300 dark:bg-gray-600 self-center w-px",
          false: "flex w-full items-center text-center text-gray-400 dark:text-gray-500 text-sm my-4 before:flex-1 after:flex-1"
        },
        variant: {
          line: "before:bg-gray-300 after:bg-gray-300 before:h-px after:h-px dark:before:bg-gray-600 dark:after:bg-gray-600",
          dots: "dotted-line"
        }
      }
    })({
      text: !!t.text,
      variant: t.variant,
      vertical: t.vertical
    });
    return (a, o) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(n)),
      textContent: toDisplayString(e.text),
      "data-ui-separator": ""
    }, null, 10, _hoisted_1$f));
  }
}, Separator = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["__scopeId", "data-v-a3e242ab"]]), _sfc_main$o = {
  __name: "Slider",
  props: {
    description: { type: String, default: null },
    id: { type: String, default: () => useId$1() },
    label: { type: String, default: null },
    modelValue: { type: Number, default: 0 },
    min: { type: Number, default: 0 },
    max: { type: Number, default: 100 },
    step: { type: Number, default: 1 },
    size: { type: String, default: "base" },
    variant: { type: String, default: "default" }
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = e, n = cva({
      base: "relative flex w-full touch-none items-center select-none",
      variants: {
        size: {
          sm: "h-2",
          base: "h-5"
        }
      }
    })({ ...t }), a = cva({
      base: "relative grow rounded-full bg-gray-300/80 dark:bg-gray-800",
      variants: {
        size: {
          sm: "h-1",
          base: "h-2"
        }
      }
    })({ ...t }), o = cva({
      base: "absolute h-full rounded-full",
      variants: {
        variant: {
          default: "bg-gray-900"
        }
      }
    })({ ...t }), s = cva({
      base: "shadow-ui-md block rounded-full bg-white dark:bg-gray-400 focus:outline-hidden",
      variants: {
        size: {
          sm: "size-4",
          base: "size-5"
        },
        variant: {
          default: "border-2 border-gray-900 hover:bg-gray-50"
        }
      }
    })({ ...t });
    return (u, d) => (openBlock(), createBlock(unref(_sfc_main$2a), {
      "data-ui-control": "",
      class: normalizeClass(unref(n)),
      id: e.id,
      max: e.max,
      min: e.min,
      step: e.step,
      "model-value": [e.modelValue],
      "onUpdate:modelValue": d[0] || (d[0] = (f) => u.$emit("update:modelValue", f[0]))
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$26), {
          class: normalizeClass(unref(a))
        }, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$29), {
              class: normalizeClass(unref(o))
            }, null, 8, ["class"])
          ]),
          _: 1
        }, 8, ["class"]),
        createVNode(unref(_sfc_main$27), {
          class: normalizeClass(unref(s)),
          "aria-label": e.label
        }, null, 8, ["class", "aria-label"])
      ]),
      _: 1
    }, 8, ["class", "id", "max", "min", "step", "model-value"]));
  }
}, _sfc_main$n = {}, _hoisted_1$e = { class: "animate-pulse rounded-md bg-gradient-to-r from-gray-100 to-bg-50 dark:from-gray-950 dark:to-gray-900" };
function _sfc_render$6(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$e, [
    renderSlot(e.$slots, "default")
  ]);
}
const Skeleton = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$6]]), _sfc_main$m = {
  __name: "Group",
  props: {
    direction: { type: String, default: "horizontal" }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$25), { direction: e.direction }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["direction"]));
  }
}, _sfc_main$l = {
  __name: "Panel",
  props: {
    collapsible: { type: Boolean, default: !1 },
    collapsedSize: { type: Number, default: 10 },
    minSize: { type: Number, default: 20 }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$24), {
      "min-size": e.minSize,
      collapsible: e.collapsible,
      class: ""
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["min-size", "collapsible"]));
  }
}, _sfc_main$k = {
  __name: "ResizeHandle",
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$23)));
  }
}, _hoisted_1$d = { class: "flex items-center gap-2" }, _hoisted_2$6 = ["textContent"], _sfc_main$j = {
  __name: "StatusIndicator",
  props: {
    status: {
      type: String,
      required: !1,
      default: "published",
      validator: (e) => ["published", "scheduled", "expired", "draft", "hidden"].includes(e)
    },
    date: { type: String, default: null },
    showDot: { type: Boolean, default: !0 },
    showLabel: { type: Boolean, default: !1 },
    private: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, n = computed(() => t.status === "published" && t.private || t.status === "hidden" ? "bg-transparent border border-gray-600" : t.status === "published" ? "bg-green-400" : "bg-gray-300 dark:bg-gray-200"), a = computed(() => ({
      published: __("Published"),
      scheduled: __("Scheduled"),
      expired: __("Expired"),
      draft: __("Draft")
    })[t.status]);
    return (o, s) => {
      const u = resolveDirective("tooltip");
      return openBlock(), createElementBlock("span", _hoisted_1$d, [
        e.showDot ? withDirectives((openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(["size-2 rounded-full", n.value])
        }, null, 2)), [
          [u, a.value]
        ]) : createCommentVNode("", !0),
        e.showLabel ? (openBlock(), createElementBlock("span", {
          key: 1,
          class: normalizeClass(["status-index-field select-none", `status-${e.status}`]),
          textContent: toDisplayString(a.value)
        }, null, 10, _hoisted_2$6)) : createCommentVNode("", !0)
      ]);
    };
  }
}, _hoisted_1$c = ["innerHTML"], _sfc_main$i = {
  __name: "Subheading",
  props: {
    size: { type: String, default: "base" },
    text: { type: [String, Number, Boolean, null], default: null },
    icon: { type: String, default: null }
  },
  setup(e) {
    const t = e, n = cva({
      base: "text-gray-600 text-balance tracking-tight dark:text-gray-400 [&_code]:text-xs [&_code]:bg-gray-600/10 [&_code]:rounded-sm [&_code]:px-1 [&_code]:py-0.5",
      variants: {
        size: {
          sm: "text-xs",
          base: "text-sm",
          lg: "text-base",
          xl: "text-lg"
        },
        icon: {
          true: "flex items-center gap-2"
        }
      }
    })({ ...t, icon: !!t.icon });
    return (a, o) => {
      const s = resolveComponent("ui-icon");
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(n)),
        "data-ui-subheading": ""
      }, [
        e.icon ? (openBlock(), createBlock(s, {
          key: 0,
          name: e.icon,
          class: "size-2 text-gray-400 dark:text-gray-600"
        }, null, 8, ["name"])) : createCommentVNode("", !0),
        e.text ? (openBlock(), createElementBlock("span", {
          key: 2,
          innerHTML: e.text
        }, null, 8, _hoisted_1$c)) : renderSlot(a.$slots, "default", { key: 1 })
      ], 2);
    };
  }
}, _sfc_main$h = {
  __name: "Switch",
  props: {
    required: { type: Boolean, default: !1 },
    id: { type: String, default: () => useId$1() },
    modelValue: { type: Boolean, default: !1 },
    size: { type: String, default: "base" }
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = e, n = cva({
      base: [
        "relative flex rounded-full shrink-0 border-2",
        "transition-colors cursor-pointer",
        "data-[state=checked]:shadow-inner data-[state=checked]:border-switch-bg data-[state=checked]:bg-switch-bg",
        "dark:data-[state=checked]:border-dark-switch-bg dark:data-[state=checked]:bg-dark-switch-bg",
        "data-[state=unchecked]:border-transparent dark:data-[state=unchecked]:border-gray-700",
        "data-[state=unchecked]:bg-gray-200 dark:data-[state=unchecked]:bg-gray-700"
      ],
      variants: {
        size: {
          xs: "h-3.5 w-6",
          sm: "h-5 w-9",
          base: "h-6 w-11",
          lg: "h-7 w-14"
        }
      }
    })({ size: t.size }), a = cva({
      base: [
        "my-auto flex items-center justify-center rounded-full bg-white text-xs shadow-ui-xl transition-transform will-change-transform",
        "data-[state=checked]:translate-x-full"
      ],
      variants: {
        size: {
          xs: "size-2.5",
          sm: "size-4",
          base: "size-5",
          lg: "size-6"
        }
      }
    })({ size: t.size });
    return (o, s) => (openBlock(), createBlock(unref(_sfc_main$22), {
      "data-ui-control": "",
      dir: "ltr",
      id: e.id,
      "model-value": e.modelValue,
      class: normalizeClass(unref(n)),
      "onUpdate:modelValue": s[0] || (s[0] = (u) => o.$emit("update:modelValue", u)),
      "data-ui-switch": ""
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$21), {
          class: normalizeClass(unref(a))
        }, null, 8, ["class"])
      ]),
      _: 1
    }, 8, ["id", "model-value", "class"]));
  }
}, _sfc_main$g = {
  __name: "Content",
  props: {
    name: { type: String, default: null }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$1$), {
      value: e.name,
      tabindex: "-1"
    }, {
      default: withCtx(() => [
        renderSlot(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["value"]));
  }
}, _sfc_main$f = {}, _hoisted_1$b = { class: "w-full overflow-auto" }, _hoisted_2$5 = { class: "w-full divide-y divide-gray-800/10 text-sm dark:divide-white/10 [&:not(:has(*))]:border-t-0!" };
function _sfc_render$5(e, t) {
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createElementVNode("table", _hoisted_2$5, [
      renderSlot(e.$slots, "default")
    ])
  ]);
}
const Table = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$5]]), _sfc_main$e = {}, _hoisted_1$a = { class: "p-3 text-left text-sm first:pl-0 last:pr-0" };
function _sfc_render$4(e, t) {
  return openBlock(), createElementBlock("td", _hoisted_1$a, [
    renderSlot(e.$slots, "default")
  ]);
}
const Cell = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$4]]), _sfc_main$d = {}, _hoisted_1$9 = { class: "p-3 text-left text-sm font-medium text-gray-900 antialiased first:pl-0 last:pr-0 dark:text-gray-300" };
function _sfc_render$3(e, t) {
  return openBlock(), createElementBlock("th", _hoisted_1$9, [
    renderSlot(e.$slots, "default")
  ]);
}
const Column = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$3]]), _sfc_main$c = {};
function _sfc_render$2(e, t) {
  return openBlock(), createElementBlock("thead", null, [
    createElementVNode("tr", null, [
      renderSlot(e.$slots, "default")
    ])
  ]);
}
const Columns = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$2]]), _sfc_main$b = {}, _hoisted_1$8 = { class: "not-last:border-b border-gray-200 dark:border-gray-700" };
function _sfc_render$1(e, t) {
  return openBlock(), createElementBlock("tr", _hoisted_1$8, [
    renderSlot(e.$slots, "default")
  ]);
}
const Row = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$1]]), _sfc_main$a = {}, _hoisted_1$7 = { class: "[&_tr:last-child]:border-0" };
function _sfc_render(e, t) {
  return openBlock(), createElementBlock("tbody", _hoisted_1$7, [
    renderSlot(e.$slots, "default")
  ]);
}
const Rows = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render]]), _sfc_main$9 = {
  __name: "List",
  setup(e) {
    const t = hasComponent("TabsIndicator");
    return (n, a) => (openBlock(), createBlock(unref(_sfc_main$1Z), {
      class: "relative flex shrink-0 space-x-4 border-b border-gray-200 text-sm text-gray-500 dark:border-gray-700 dark:text-gray-500",
      "data-ui-tabs-list": ""
    }, {
      default: withCtx(() => [
        unref(t) ? createCommentVNode("", !0) : (openBlock(), createBlock(unref(_sfc_main$1_), {
          key: 0,
          class: "absolute bottom-0 left-0 h-px w-[var(--reka-tabs-indicator-size)] translate-x-[var(--reka-tabs-indicator-position)] translate-y-[1px] rounded-full bg-black transition duration-300 dark:bg-white",
          "data-ui-tabs-indicator": ""
        })),
        renderSlot(n.$slots, "default")
      ]),
      _: 3
    }));
  }
}, _sfc_main$8 = {
  __name: "Tabs",
  props: {
    modelValue: { type: String, default: null },
    unmountOnHide: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t;
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$20), {
      "model-value": e.modelValue,
      "onUpdate:modelValue": o[0] || (o[0] = (s) => n("update:modelValue", s)),
      "unmount-on-hide": e.unmountOnHide
    }, {
      default: withCtx(() => [
        renderSlot(a.$slots, "default")
      ]),
      _: 3
    }, 8, ["model-value", "unmount-on-hide"]));
  }
}, _hoisted_1$6 = { key: 1 }, _sfc_main$7 = {
  __name: "Trigger",
  props: {
    text: { type: String, default: null },
    name: { type: String, default: null }
  },
  setup(e) {
    const n = !!useSlots().default;
    return (a, o) => (openBlock(), createBlock(unref(_sfc_main$1Y), {
      value: e.name,
      class: "cursor-pointer p-2 pb-1 hover:text-gray-600 data-[state=active]:text-gray-900 dark:hover:text-gray-400 dark:data-[state=active]:text-gray-200"
    }, {
      default: withCtx(() => [
        n ? renderSlot(a.$slots, "default", { key: 0 }) : (openBlock(), createElementBlock("span", _hoisted_1$6, toDisplayString(e.text), 1))
      ]),
      _: 3
    }, 8, ["value"]));
  }
}, _hoisted_1$5 = {
  class: "group/input relative block w-full",
  "data-ui-input": ""
}, _hoisted_2$4 = ["rows", "id", "value", "disabled", "readonly"], _hoisted_3$1 = {
  key: 0,
  class: "absolute right-2 bottom-2"
}, _sfc_main$6 = {
  __name: "Textarea",
  props: {
    elastic: { type: Boolean, default: !1 },
    disabled: { type: Boolean, default: !1 },
    id: { type: String, default: null },
    readOnly: { type: Boolean, default: !1 },
    required: { type: Boolean, default: !1 },
    resize: { type: String, default: "vertical" },
    rows: { type: [Number, String], default: 4 },
    modelValue: { type: String, default: null },
    limit: { type: Number, default: null }
  },
  emits: ["update:modelValue"],
  setup(e) {
    const t = e, n = cva({
      base: [
        "w-full block bg-white dark:bg-gray-900 px-3 pt-2.5 pb-3 rounded-lg",
        "border border-gray-300 with-contrast:border-gray-500 dark:border-x-0 dark:border-t-0 dark:border-white/10 dark:inset-shadow-2xs dark:inset-shadow-black",
        "text-gray-900 dark:text-gray-300",
        "appearance-none antialiased shadow-ui-sm disabled:shadow-none read-only:border-dashed not-prose"
      ],
      variants: {
        resize: {
          both: "resize",
          horizontal: "resize-x",
          vertical: "resize-y",
          none: "resize-none"
        },
        elastic: {
          true: "field-sizing-content"
        }
      }
    })({ ...t });
    return (a, o) => (openBlock(), createElementBlock("div", _hoisted_1$5, [
      createElementVNode("textarea", mergeProps({
        class: unref(n),
        rows: e.rows,
        id: e.id
      }, a.$attrs, {
        value: e.modelValue,
        disabled: e.disabled,
        readonly: e.readOnly,
        "data-ui-control": "",
        onInput: o[0] || (o[0] = (s) => a.$emit("update:modelValue", s.target.value))
      }), null, 16, _hoisted_2$4),
      e.limit ? (openBlock(), createElementBlock("div", _hoisted_3$1, [
        createVNode(unref(CharacterCounter), {
          text: e.modelValue,
          limit: e.limit
        }, null, 8, ["text", "limit"])
      ])) : createCommentVNode("", !0)
    ]));
  }
}, _hoisted_1$4 = { class: "flex-1 flex items-center" }, _hoisted_2$3 = { class: "flex items-center gap-1" }, _sfc_main$5 = {
  __name: "TimePicker",
  props: {
    badge: { type: String, default: null },
    required: { type: Boolean, default: !1 },
    modelValue: { type: Object, default: null },
    granularity: { type: String, default: null },
    clearable: { type: Boolean, default: !0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = t, a = e, o = () => {
      const s = /* @__PURE__ */ new Date(), u = String(s.getHours()).padStart(2, "0"), d = String(s.getMinutes()).padStart(2, "0"), f = String(s.getSeconds()).padStart(2, "0");
      n(
        "update:modelValue",
        a.granularity === "second" ? `${u}:${d}:${f}` : `${u}:${d}`
      );
    };
    return (s, u) => {
      const d = resolveDirective("tooltip");
      return openBlock(), createBlock(unref(_sfc_main$1X), {
        "model-value": e.modelValue,
        "onUpdate:modelValue": u[1] || (u[1] = (f) => n("update:modelValue", f)),
        granularity: e.granularity,
        class: normalizeClass([
          "flex w-full bg-white dark:bg-gray-900",
          "border border-gray-300 dark:border-x-0 dark:border-t-0 dark:border-white/10 dark:inset-shadow-2xs dark:inset-shadow-black",
          "leading-5 text-gray-600 dark:text-gray-300",
          "shadow-ui-sm not-prose h-10 rounded-lg py-2 px-3 disabled:shadow-none",
          "data-invalid:border-red-500"
        ])
      }, {
        default: withCtx(({ segments: f }) => [
          createElementVNode("div", _hoisted_1$4, [
            (openBlock(!0), createElementBlock(Fragment, null, renderList(f, (g) => (openBlock(), createElementBlock(Fragment, {
              key: g.part
            }, [
              g.part === "literal" ? (openBlock(), createBlock(unref(_sfc_main$1W), {
                key: 0,
                part: g.part
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(g.value), 1)
                ]),
                _: 2
              }, 1032, ["part"])) : (openBlock(), createBlock(unref(_sfc_main$1W), {
                key: 1,
                part: g.part,
                class: "rounded-sm px-0.25 py-0.5 focus:bg-gray-100 focus:outline-hidden data-placeholder:text-gray-600 dark:focus:bg-gray-800 dark:data-placeholder:text-gray-400"
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(g.value), 1)
                ]),
                _: 2
              }, 1032, ["part"]))
            ], 64))), 128))
          ]),
          createElementVNode("div", _hoisted_2$3, [
            e.clearable ? withDirectives((openBlock(), createBlock(unref(Button), {
              key: 0,
              onClick: o,
              type: "button",
              class: "",
              size: "xs",
              icon: "time-now"
            }, null, 512)), [
              [d, s.__("Set to now")]
            ]) : createCommentVNode("", !0),
            e.clearable ? withDirectives((openBlock(), createBlock(unref(Button), {
              key: 1,
              onClick: u[0] || (u[0] = (g) => n("update:modelValue", null)),
              type: "button",
              class: "",
              icon: "x",
              size: "xs"
            }, null, 512)), [
              [d, s.__("Clear")]
            ]) : createCommentVNode("", !0)
          ])
        ]),
        _: 1
      }, 8, ["model-value", "granularity"]);
    };
  }
}, _sfc_main$4 = {
  __name: "Group",
  props: {
    required: { type: Boolean, default: !1 },
    modelValue: { type: [String, Array], default: null },
    size: { type: String, default: "base" },
    variant: { type: String, default: "default" },
    multiple: { type: Boolean, default: !1 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const n = e, a = t, o = ref(n.modelValue ?? (n.multiple ? [] : null));
    watch(
      () => n.modelValue,
      (d) => {
        o.value = d ?? (n.multiple ? [] : null);
      }
    ), watch(o, (d) => {
      a("update:modelValue", d);
    }), provide("toggleVariant", n.variant), provide("toggleSize", n.size);
    const s = cva({
      base: "flex group/button",
      variants: {
        notGhost: {
          true: [
            "[&>[data-ui-group-target]:not(:first-child):not(:last-child)]:rounded-none",
            "[&>[data-ui-group-target]:first-child:not(:last-child)]:rounded-e-none",
            "[&>[data-ui-group-target]:last-child:not(:first-child)]:rounded-s-none",
            "[&>*:not(:first-child):not(:last-child):not(:only-child)_[data-ui-group-target]]:rounded-none",
            "[&>*:first-child:not(:last-child)_[data-ui-group-target]]:rounded-e-none",
            "[&>*:last-child:not(:first-child)_[data-ui-group-target]]:rounded-s-none"
          ],
          false: "gap-1"
        }
      }
    })({
      notGhost: n.variant !== "ghost"
    });
    function u(d) {
      d && a("update:modelValue", d);
    }
    return (d, f) => (openBlock(), createBlock(unref(_sfc_main$1V), {
      type: e.multiple ? "multiple" : "single",
      class: normalizeClass(unref(s)),
      "data-ui-toggle-group": "",
      "model-value": o.value,
      "onUpdate:modelValue": u
    }, {
      default: withCtx(() => [
        renderSlot(d.$slots, "default")
      ]),
      _: 3
    }, 8, ["type", "class", "model-value"]));
  }
}, _hoisted_1$3 = { key: 1 }, _hoisted_2$2 = { key: 2 }, _sfc_main$3 = {
  __name: "Item",
  props: {
    value: { type: String, required: !0 },
    label: { type: String, default: null },
    icon: { type: String, default: null },
    disabled: { type: Boolean, default: !1 },
    ariaDescribedby: { type: String, default: null }
  },
  setup(e) {
    const t = e, n = inject("toggleVariant", "default"), a = inject("toggleSize", "base"), s = !!useSlots().default, u = computed(() => !!t.icon && !s && !t.label), d = computed(() => s ? t.label || null : t.label || (t.icon ? `Toggle ${t.value}` : null)), f = computed(() => {
      const g = cva({
        base: "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-lg font-medium antialiased cursor-pointer no-underline disabled:opacity-75 disabled:cursor-default disabled:pointer-events-none [&_svg]:text-gray-500 [&_svg]:shrink-0",
        variants: {
          variant: {
            default: [
              "bg-linear-to-b from-white to-gray-50 hover:to-gray-100 text-gray-900 border border-gray-300 shadow-ui-sm data-[state=on]:from-gray-100 data-[state=on]:to-gray-100 data-[state=on]:text-gray-900 data-[state=on]:inset-shadow-sm/10",
              "dark:from-gray-800 dark:to-gray-850 dark:hover:to-gray-800 hover:bg-gray-50 dark:hover:bg-gray-850 dark:border-b-0 dark:ring dark:ring-black dark:border-white/10 dark:text-gray-300 dark:shadow-md dark:data-[state=on]:from-gray-950 dark:data-[state=on]:to-gray-950 dark:data-[state=on]:text-white"
            ],
            primary: [
              "bg-linear-to-b from-primary/90 to-primary hover:bg-primary-hover text-white border border-primary-border shadow-ui-md inset-shadow-2xs inset-shadow-white/25 data-[state=on]:bg-primary-hover",
              "dark:from-white dark:to-gray-200 dark:hover:from-gray-200 dark:text-gray-900 dark:border-0 dark:data-[state=on]:from-gray-300 dark:data-[state=on]:to-gray-300"
            ],
            filled: "bg-gray-100 hover:bg-gray-200 dark:bg-gray-700/80 dark:hover:bg-gray-700 data-[state=on]:bg-gray-300 data-[state=on]:border-gray-500 dark:data-[state=on]:bg-gray-950",
            ghost: "bg-transparent rounded-lg hover:bg-gray-400/10 text-gray-500 hover:text-gray-700 dark:text-gray-300 dark:hover:bg-gray-700/80 dark:hover:text-gray-200 data-[state=on]:bg-gray-400/20 data-[state=on]:text-gray-700 dark:data-[state=on]:bg-gray-700/80 dark:data-[state=on]:text-white"
          },
          size: {
            base: "px-3 h-10 text-sm [&_svg]:size-3.5",
            sm: "px-2.5 h-8 text-[0.8125rem] [&_svg]:size-3",
            xs: "px-2 h-6.5 text-xs [&_svg]:size-2.5"
          },
          groupBorder: {
            default: "[[data-ui-toggle-group]_&]:border-s-0 [:is([data-ui-toggle-group]>&:first-child,_[data-ui-toggle-group]_:first-child>&)]:border-s-[1px]",
            primary: "[[data-ui-toggle-group]_&]:border-e-0 [:is([data-ui-toggle-group]>&:last-child,_[data-ui-toggle-group]_:last-child>&)]:border-e-[1px] [:is([data-ui-toggle-group]>&:not(:first-child),_[data-ui-toggle-group]_:not(:first-child)>&)]:border-s-primary-gap",
            filled: "[[data-ui-toggle-group]_&]:border-e [:is([data-ui-toggle-group]>&:last-child,_[data-ui-toggle-group]_:last-child>&)]:border-e-0 [[data-ui-toggle-group]_&]:border-gray-300/70",
            ghost: ""
          }
        },
        compoundVariants: [
          { iconOnly: !0, size: "base", class: "w-10 px-0! [&_svg]:size-4" },
          { iconOnly: !0, size: "sm", class: "w-8 px-0! [&_svg]:size-3.5" },
          { iconOnly: !0, size: "xs", class: "w-6.5 px-0! [&_svg]:size-3" }
        ]
      })({
        variant: n,
        size: a,
        groupBorder: n,
        iconOnly: u.value
      });
      return twMerge(g);
    });
    return (g, v) => (openBlock(), createBlock(unref(_sfc_main$1T), {
      value: e.value,
      "aria-label": d.value,
      "aria-describedby": e.ariaDescribedby,
      disabled: e.disabled,
      class: normalizeClass(f.value),
      "data-ui-group-target": ""
    }, {
      default: withCtx(() => [
        e.icon ? (openBlock(), createBlock(unref(_sfc_main$1a), {
          key: 0,
          name: e.icon,
          class: "text-gray-400",
          "aria-hidden": !u.value
        }, null, 8, ["name", "aria-hidden"])) : createCommentVNode("", !0),
        s ? (openBlock(), createElementBlock("span", _hoisted_1$3, [
          renderSlot(g.$slots, "default")
        ])) : e.label ? (openBlock(), createElementBlock("span", _hoisted_2$2, toDisplayString(e.label), 1)) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["value", "aria-label", "aria-describedby", "disabled", "class"]));
  }
}, _hoisted_1$2 = ["innerHTML"], _sfc_main$2 = {
  __name: "Tooltip",
  props: {
    text: { type: String, default: null },
    markdown: { type: String, default: null },
    delay: { type: Number, default: 0 }
  },
  setup(e) {
    const t = useAttrs(), n = e, a = computed(() => n.markdown ? markdown(n.markdown) : n.text), o = computed(() => ({
      "as-child": !t.as,
      ...t
    }));
    return (s, u) => a.value ? (openBlock(), createBlock(unref(_sfc_main$1R), {
      key: 0,
      ariaLabel: a.value,
      "delay-duration": e.delay
    }, {
      default: withCtx(() => [
        createVNode(unref(_sfc_main$1Q), null, {
          default: withCtx(() => [
            createVNode(unref(_sfc_main$1L), normalizeProps(guardReactiveProps(o.value)), {
              default: withCtx(() => [
                renderSlot(s.$slots, "default")
              ]),
              _: 3
            }, 16),
            createVNode(unref(_sfc_main$1M), null, {
              default: withCtx(() => [
                createVNode(unref(_sfc_main$1N), {
                  class: normalizeClass([
                    "data-[state=delayed-open]:data-[side=top]:animate-slideDownAndFade",
                    "data-[state=delayed-open]:data-[side=right]:animate-slideLeftAndFade",
                    "data-[state=delayed-open]:data-[side=left]:animate-slideRightAndFade",
                    "data-[state=delayed-open]:data-[side=bottom]:animate-slideUpAndFade",
                    "rounded-xl bg-white px-3 py-2",
                    "text-xs leading-none text-gray-600",
                    "shadow-ui-sm border border-gray-300",
                    "will-change-[transform,opacity]"
                  ]),
                  "side-offset": 5,
                  role: "tooltip",
                  "aria-label": a.value
                }, {
                  default: withCtx(() => [
                    createElementVNode("span", { innerHTML: a.value }, null, 8, _hoisted_1$2),
                    createVNode(unref(_sfc_main$1S), {
                      class: "fill-white stroke-gray-300",
                      width: 12,
                      height: 6
                    })
                  ]),
                  _: 1
                }, 8, ["aria-label"])
              ]),
              _: 1
            })
          ]),
          _: 3
        })
      ]),
      _: 3
    }, 8, ["ariaLabel", "delay-duration"])) : renderSlot(s.$slots, "default", { key: 1 });
  }
}, _hoisted_1$1 = { class: "flex h-full min-h-54 flex-col" }, _hoisted_2$1 = { class: "flex items-center min-h-[49px] justify-between border-b border-gray-200 px-4.5 py-2 dark:border-gray-700" }, _hoisted_3 = { class: "flex items-center gap-3" }, _hoisted_4 = ["textContent"], _hoisted_5 = { class: "flex items-center gap-4 -mr-2.5" }, _sfc_main$1 = {
  __name: "Widget",
  props: {
    title: String,
    icon: { type: String, default: "collections" }
  },
  setup(e) {
    return (t, n) => (openBlock(), createBlock(unref(_sfc_main$1J), {
      inset: "",
      class: "@container/widget"
    }, {
      default: withCtx(() => [
        createElementVNode("div", _hoisted_1$1, [
          createElementVNode("header", _hoisted_2$1, [
            createElementVNode("div", _hoisted_3, [
              createVNode(unref(_sfc_main$1a), {
                name: e.icon,
                class: "hidden! size-5 text-gray-500 @xs/widget:block!"
              }, null, 8, ["name"]),
              createElementVNode("span", {
                textContent: toDisplayString(e.title)
              }, null, 8, _hoisted_4)
            ]),
            createElementVNode("div", _hoisted_5, [
              renderSlot(t.$slots, "actions")
            ])
          ]),
          renderSlot(t.$slots, "default"),
          renderSlot(t.$slots, "footer")
        ])
      ]),
      _: 3
    }));
  }
}, _hoisted_1 = {
  key: 0,
  class: "font-medium border-e border-inherit pe-2"
}, _hoisted_2 = {
  key: 5,
  class: "font-medium border-s border-inherit ps-2"
}, _sfc_main = {
  __name: "Badge",
  props: {
    append: { type: [String, Number, Boolean, null], default: null },
    as: { type: String, default: "div" },
    color: { type: String, default: "default" },
    href: { type: String, default: null },
    icon: { type: String, default: null },
    iconAppend: { type: String, default: null },
    pill: { type: Boolean, default: !1 },
    prepend: { type: [String, Number, Boolean, null], default: null },
    shadow: { type: [Boolean, String], default: !0 },
    size: { type: String, default: "default" },
    text: { type: [String, Number, Boolean, null], default: null },
    variant: { type: String, default: "default" }
  },
  setup(e) {
    const t = e, a = !!useSlots().default, o = computed(() => t.href ? "a" : t.as), s = computed(() => {
      const u = cva({
        base: "relative inline-flex items-center justify-center gap-1 font-normal antialiased whitespace-nowrap no-underline not-prose [button]:cursor-pointer group [&_svg]:opacity-60 [&_svg]:group-hover:opacity-80 dark:[&_svg]:group-hover:opacity-70",
        variants: {
          size: {
            sm: "text-2xs leading-normal px-1.25 rounded-[0.1875rem] [&_svg]:size-2.5",
            default: "text-xs leading-5.5 px-2 rounded-sm [&_svg]:size-3.5 gap-2",
            lg: "font-medium text-sm leading-7 px-2.5 rounded-lg [&_svg]:size-4 gap-2"
          },
          color: {
            amber: "bg-amber-100 border-amber-400 text-amber-700 dark:bg-amber-300/6 dark:text-amber-300 [a]:hover:bg-amber-200/70 [button]:hover:bg-amber-200/70",
            black: "bg-gray-900 border-black text-white dark:bg-gray-300/6 dark:text-gray-300 [a]:hover:bg-black/90 [button]:hover:bg-black/90",
            blue: "bg-blue-100/80 border-blue-300 text-blue-700 dark:bg-blue-300/6 dark:text-blue-300 [a]:hover:bg-blue-200/60 [button]:hover:bg-blue-200/60",
            cyan: "bg-cyan-100/80 border-cyan-400 text-cyan-700 dark:bg-cyan-300/6 dark:text-cyan-300 [a]:hover:bg-cyan-200/60 [button]:hover:bg-cyan-200/60",
            default: "bg-gray-100/80 border-gray-300 dark:bg-gray-800 dark:text-gray-100 text-gray-700 [a]:hover:bg-gray-200/50 dark:[a]:hover:bg-gray-700/50 [button]:hover:bg-gray-200/50",
            emerald: "bg-emerald-100/80 border-emerald-400 text-emerald-700 dark:bg-emerald-300/6 dark:text-emerald-300 [a]:hover:bg-emerald-200/60 [button]:hover:bg-emerald-200/60",
            fuchsia: "bg-fuchsia-100/80 border-fuchsia-300 text-fuchsia-700 dark:bg-fuschia-300/6 dark:text-fuschia-300 [a]:hover:bg-fuchsia-200/60 [button]:hover:bg-fuchsia-200/60 dark:[a]:hover:bg-fuchsia-300/15",
            green: "bg-green-100/80 border-green-400 text-green-700 dark:bg-green-300/6 dark:text-green-300 [a]:hover:bg-green-200/60 [button]:hover:bg-green-200/60 dark:[a]:hover:bg-green-300/15",
            indigo: "bg-indigo-100/80 border-indigo-300 text-indigo-700 dark:bg-indigo-300/6 dark:text-indigo-300 [a]:hover:bg-indigo-200/60 [button]:hover:bg-indigo-200/60 dark:[a]:hover:bg-indigo-300/15",
            lime: "bg-lime-100 border-lime-400 text-lime-700 dark:bg-lime-300/6 dark:text-lime-300 [a]:hover:bg-lime-200/80 [button]:hover:bg-lime-200/80 dark:[a]:hover:bg-lime-300/15",
            orange: "bg-orange-100 border-orange-400 text-orange-700 dark:bg-orange-300/6 dark:text-orange-300 [a]:hover:bg-orange-200/60 [button]:hover:bg-orange-200/60 dark:[a]:hover:bg-orange-300/15",
            pink: "bg-pink-100/80 border-pink-300 text-pink-800 dark:bg-pink-300/6 dark:text-pink-300 [a]:hover:bg-pink-200/60 [button]:hover:bg-pink-200/60 dark:[a]:hover:bg-pink-300/15",
            purple: "bg-purple-100/80 border-purple-300 text-purple-800 dark:bg-purple-300/6 dark:text-purple-300 [a]:hover:bg-purple-200/60 [button]:hover:bg-purple-200/60 dark:[a]:hover:bg-purple-300/15",
            red: "bg-red-100/80 border-red-400/80 text-red-700 dark:bg-red-300/6 dark:text-red-300 [a]:hover:bg-red-200/60 [button]:hover:bg-red-200/60 dark:[a]:hover:bg-red-300/15",
            rose: "bg-rose-100/80 border-rose-300 text-rose-800 dark:bg-rose-300/6 dark:text-rose-300 [a]:hover:bg-rose-200/60 [button]:hover:bg-rose-200/60 dark:[a]:hover:bg-rose-300/15",
            sky: "bg-sky-100/80 border-sky-300 text-sky-700 dark:bg-sky-300/6 dark:text-sky-300 [a]:hover:bg-sky-200/60 [button]:hover:bg-sky-200/60 dark:[a]:hover:bg-sky-300/15",
            teal: "bg-teal-100 border-teal-400 text-teal-700 dark:bg-teal-300/6 dark:text-teal-300 [a]:hover:bg-teal-200/70 [button]:hover:bg-teal-200/70 dark:[a]:hover:bg-teal-300/15",
            violet: "bg-violet-100/80 border-violet-300 text-violet-700 dark:bg-violet-300/6 dark:text-violet-300 [a]:hover:bg-violet-200/60 [button]:hover:bg-violet-200/60 dark:[a]:hover:bg-violet-300/15",
            white: "bg-white border-gray-300 text-gray-700 dark:bg-gray-300/6 dark:text-gray-300 [a]:hover:bg-gray-200/30 [button]:hover:bg-gray-200/30 dark:[a]:hover:bg-gray-300/15",
            yellow: "bg-yellow-100 border-yellow-400 text-yellow-700 dark:bg-yellow-300/6 dark:text-yellow-300 [a]:hover:bg-yellow-200/80 [button]:hover:bg-yellow-200/80 dark:[a]:hover:bg-yellow-300/15"
          },
          variant: {
            default: "border dark:border-none shadow-ui-sm",
            flat: "border-0 shadow-none"
          },
          pill: { true: "rounded-full" },
          shadow: {
            false: "shadow-none!",
            true: "shadow-ui-sm"
          }
        }
      })({ ...t });
      return twMerge(u);
    });
    return (u, d) => (openBlock(), createBlock(resolveDynamicComponent(o.value), {
      class: normalizeClass(s.value),
      href: t.href,
      "data-ui-badge": ""
    }, {
      default: withCtx(() => [
        t.prepend ? (openBlock(), createElementBlock("span", _hoisted_1, toDisplayString(e.prepend), 1)) : createCommentVNode("", !0),
        e.icon ? (openBlock(), createBlock(unref(_sfc_main$1a), {
          key: 1,
          name: e.icon
        }, null, 8, ["name"])) : createCommentVNode("", !0),
        a ? renderSlot(u.$slots, "default", { key: 2 }) : (openBlock(), createElementBlock(Fragment, { key: 3 }, [
          createTextVNode(toDisplayString(e.text), 1)
        ], 64)),
        e.iconAppend ? (openBlock(), createBlock(unref(_sfc_main$1a), {
          key: 4,
          name: e.iconAppend
        }, null, 8, ["name"])) : createCommentVNode("", !0),
        t.append ? (openBlock(), createElementBlock("span", _hoisted_2, toDisplayString(e.append), 1)) : createCommentVNode("", !0)
      ]),
      _: 3
    }, 8, ["class", "href"]));
  }
};
export {
  _sfc_main$4x as AuthCard,
  _sfc_main as Badge,
  Button,
  ButtonGroup,
  _sfc_main$1K as Calendar,
  _sfc_main$1J as Card,
  _sfc_main$1I as CardList,
  ListItem as CardListItem,
  _sfc_main$1G as CardPanel,
  CharacterCounter,
  _sfc_main$1E as Checkbox,
  _sfc_main$1D as CheckboxGroup,
  _sfc_main$1B as CodeEditor,
  _sfc_main$1z as Combobox,
  _sfc_main$1y as Context,
  _sfc_main$1x as ContextFooter,
  _sfc_main$1w as ContextItem,
  _sfc_main$1v as ContextLabel,
  Menu as ContextMenu,
  _sfc_main$1t as ContextSeparator,
  _sfc_main$1s as CreateForm,
  _sfc_main$1r as DatePicker,
  _sfc_main$1q as DateRangePicker,
  _sfc_main$1p as Description,
  DragHandle,
  _sfc_main$1n as Dropdown,
  _sfc_main$1m as DropdownItem,
  _sfc_main$1l as DropdownLabel,
  DropdownMenu,
  _sfc_main$1j as DropdownSeparator,
  _sfc_main$1i as Editable,
  _sfc_main$1g as EmptyStateItem,
  _sfc_main$1f as EmptyStateMenu,
  _sfc_main$1h as ErrorMessage,
  _sfc_main$1e as Field,
  _sfc_main$1d as FieldsProvider,
  _sfc_main$1c as Header,
  _sfc_main$1b as Heading,
  _sfc_main$1a as Icon,
  _sfc_main$19 as Input,
  _sfc_main$18 as Label,
  _sfc_main$O as Listing,
  _sfc_main$14 as ListingCustomizeColumns,
  _sfc_main$Z as ListingFilters,
  _sfc_main$X as ListingHeaderCell,
  _sfc_main$Y as ListingPagination,
  _sfc_main$13 as ListingPresetTrigger,
  _sfc_main$12 as ListingPresets,
  _sfc_main$R as ListingRowActions,
  _sfc_main$11 as ListingSearch,
  _sfc_main$P as ListingTable,
  _sfc_main$Q as ListingTableBody,
  _sfc_main$V as ListingTableHead,
  _sfc_main$W as ListingToggleAll,
  _sfc_main$F as LivePreview,
  _sfc_main$E as Modal,
  _sfc_main$D as ModalClose,
  _sfc_main$C as ModalTitle,
  _sfc_main$B as Pagination,
  _sfc_main$A as Panel,
  PanelFooter,
  _sfc_main$y as PanelHeader,
  _sfc_main$x as Popover,
  _sfc_main$w as PublishComponents,
  _sfc_main$K as PublishField,
  _sfc_main$J as PublishFields,
  _sfc_main$v as PublishForm,
  _sfc_main$t as PublishLocalizations,
  _sfc_main$I as PublishSections,
  _sfc_main$H as PublishTabs,
  _sfc_main$s as Radio,
  _sfc_main$r as RadioGroup,
  _sfc_main$q as Select,
  Separator,
  Skeleton,
  _sfc_main$o as Slider,
  _sfc_main$m as SplitterGroup,
  _sfc_main$l as SplitterPanel,
  _sfc_main$k as SplitterResizeHandle,
  _sfc_main$j as StatusIndicator,
  _sfc_main$i as Subheading,
  _sfc_main$h as Switch,
  _sfc_main$g as TabContent,
  _sfc_main$9 as TabList,
  _sfc_main$M as TabProvider,
  _sfc_main$7 as TabTrigger,
  Table,
  Cell as TableCell,
  Column as TableColumn,
  Columns as TableColumns,
  Row as TableRow,
  Rows as TableRows,
  _sfc_main$8 as Tabs,
  _sfc_main$6 as Textarea,
  _sfc_main$5 as TimePicker,
  _sfc_main$4 as ToggleGroup,
  _sfc_main$3 as ToggleItem,
  _sfc_main$2 as Tooltip,
  _sfc_main$1 as Widget
};
